#include "ecere.hpp"

TCPPClass<Bitmap> Bitmap::_cpp_class;
TCPPClass<BitmapFormat> BitmapFormat::_cpp_class;
TCPPClass<BitmapResource> BitmapResource::_cpp_class;
TCPPClass<CubeMap> CubeMap::_cpp_class;
TCPPClass<Display> Display::_cpp_class;
TCPPClass<DisplayDriver> DisplayDriver::_cpp_class;
TCPPClass<DisplaySystem> DisplaySystem::_cpp_class;
TCPPClass<DrawList> DrawList::_cpp_class;
TCPPClass<DrawManager> DrawManager::_cpp_class;
TCPPClass<FontManager> FontManager::_cpp_class;
TCPPClass<FontManagerRenderer> FontManagerRenderer::_cpp_class;
TCPPClass<FontRenderer> FontRenderer::_cpp_class;
TCPPClass<FontResource> FontResource::_cpp_class;
TCPPClass<Resource> Resource::_cpp_class;
TCPPClass<Surface> Surface::_cpp_class;
TCPPClass<DefaultShader> DefaultShader::_cpp_class;
TCPPClass<FreeBlockMap> FreeBlockMap::_cpp_class;
TCPPClass<GLMB> GLMB::_cpp_class;
TCPPClass<GLStats> GLStats::_cpp_class;
TCPPClass<LFBDisplayDriver> LFBDisplayDriver::_cpp_class;
TCPPClass<Shader> Shader::_cpp_class;
TCPPClass<Camera> Camera::_cpp_class;
TCPPClass<MeshSkin> MeshSkin::_cpp_class;
TCPPClass<ObjectFormat> ObjectFormat::_cpp_class;
TCPPClass<CommonControl> CommonControl::_cpp_class;
TCPPClass<ControllableWindow> ControllableWindow::_cpp_class;
TCPPClass<Cursor> Cursor::_cpp_class;
TCPPClass<GuiApplication> GuiApplication::_cpp_class;
TCPPClass<Interface> Interface::_cpp_class;
TCPPClass<Skin> Skin::_cpp_class;
TCPPClass<Timer> Timer::_cpp_class;
TCPPClass<Window> Window::_cpp_class;
TCPPClass<WindowController> WindowController::_cpp_class;
TCPPClass<Button> Button::_cpp_class;
TCPPClass<CalendarControl> CalendarControl::_cpp_class;
TCPPClass<DataBox> DataBox::_cpp_class;
TCPPClass<DataField> DataField::_cpp_class;
TCPPClass<DataRow> DataRow::_cpp_class;
TCPPClass<DirectoriesBox> DirectoriesBox::_cpp_class;
TCPPClass<DropBox> DropBox::_cpp_class;
TCPPClass<EditBox> EditBox::_cpp_class;
TCPPClass<EditBoxStream> EditBoxStream::_cpp_class;
TCPPClass<EditSyntaxHL> EditSyntaxHL::_cpp_class;
TCPPClass<EditableSelectorButton> EditableSelectorButton::_cpp_class;
TCPPClass<Label> Label::_cpp_class;
TCPPClass<ListBox> ListBox::_cpp_class;
TCPPClass<Menu> Menu::_cpp_class;
TCPPClass<MenuDivider> MenuDivider::_cpp_class;
TCPPClass<MenuItem> MenuItem::_cpp_class;
TCPPClass<MenuPlacement> MenuPlacement::_cpp_class;
TCPPClass<OldArray> OldArray::_cpp_class;
TCPPClass<PaneSplitter> PaneSplitter::_cpp_class;
TCPPClass<PathBox> PathBox::_cpp_class;
TCPPClass<Picture> Picture::_cpp_class;
TCPPClass<PopupMenu> PopupMenu::_cpp_class;
TCPPClass<ProgressBar> ProgressBar::_cpp_class;
TCPPClass<SavingDataBox> SavingDataBox::_cpp_class;
TCPPClass<ScrollBar> ScrollBar::_cpp_class;
TCPPClass<SelectorBar> SelectorBar::_cpp_class;
TCPPClass<SelectorButton> SelectorButton::_cpp_class;
TCPPClass<Stacker> Stacker::_cpp_class;
TCPPClass<StatusBar> StatusBar::_cpp_class;
TCPPClass<StatusField> StatusField::_cpp_class;
TCPPClass<Tab> Tab::_cpp_class;
TCPPClass<TabControl> TabControl::_cpp_class;
TCPPClass<ToolBar> ToolBar::_cpp_class;
TCPPClass<ToolButton> ToolButton::_cpp_class;
TCPPClass<ToolSeparator> ToolSeparator::_cpp_class;
TCPPClass<ToolTip> ToolTip::_cpp_class;
TCPPClass<UndoBuffer> UndoBuffer::_cpp_class;
TCPPClass<ColorPicker> ColorPicker::_cpp_class;
TCPPClass<CreateDirectoryDialog> CreateDirectoryDialog::_cpp_class;
TCPPClass<FileDialog> FileDialog::_cpp_class;
TCPPClass<FindDialog> FindDialog::_cpp_class;
TCPPClass<GoToDialog> GoToDialog::_cpp_class;
TCPPClass<MessageBox> MessageBox::_cpp_class;
TCPPClass<ReplaceDialog> ReplaceDialog::_cpp_class;
TCPPClass<WindowList> WindowList::_cpp_class;
TCPPClass<TVisionSkin_Window> TVisionSkin_Window::_cpp_class;
TCPPClass<WindowsSkin_Button> WindowsSkin_Button::_cpp_class;
TCPPClass<WindowsSkin_Window> WindowsSkin_Window::_cpp_class;
TCPPClass<DCOMClientObject> DCOMClientObject::_cpp_class;
TCPPClass<DCOMSendControl> DCOMSendControl::_cpp_class;
TCPPClass<DCOMServerObject> DCOMServerObject::_cpp_class;
TCPPClass<DCOMServerSocket> DCOMServerSocket::_cpp_class;
TCPPClass<DCOMService> DCOMService::_cpp_class;
TCPPClass<FileServerConnection> FileServerConnection::_cpp_class;
TCPPClass<HTTPFile> HTTPFile::_cpp_class;
TCPPClass<NetworkClientFile> NetworkClientFile::_cpp_class;
TCPPClass<SSLSocket> SSLSocket::_cpp_class;
TCPPClass<Service> Service::_cpp_class;
TCPPClass<Socket> Socket::_cpp_class;
TCPPClass<Archive> Archive::_cpp_class;
TCPPClass<ArchiveDir> ArchiveDir::_cpp_class;
TCPPClass<BufferedFile> BufferedFile::_cpp_class;
TCPPClass<ConsoleFile> ConsoleFile::_cpp_class;
TCPPClass<DualPipe> DualPipe::_cpp_class;
TCPPClass<ECONGlobalSettings> ECONGlobalSettings::_cpp_class;
TCPPClass<ECONParser> ECONParser::_cpp_class;
TCPPClass<File> File::_cpp_class;
TCPPClass<FileMonitor> FileMonitor::_cpp_class;
TCPPClass<GlobalAppSettings> GlobalAppSettings::_cpp_class;
TCPPClass<GlobalSettings> GlobalSettings::_cpp_class;
TCPPClass<GlobalSettingsData> GlobalSettingsData::_cpp_class;
TCPPClass<GlobalSettingsDriver> GlobalSettingsDriver::_cpp_class;
TCPPClass<JSONGlobalSettings> JSONGlobalSettings::_cpp_class;
TCPPClass<JSONParser> JSONParser::_cpp_class;
TCPPClass<OptionsMap> OptionsMap::_cpp_class;
TCPPClass<RepButton> RepButton::_cpp_class;
TCPPClass<TempFile> TempFile::_cpp_class;
TCPPClass<Thread> Thread::_cpp_class;

int ecere_cpp_init(const Module & module)
{
   if(!Thread::_cpp_class.impl)
   {
#ifdef _DEBUG
      // printf("%s_cpp_init\n", "ecere");
#endif

   TStruct<FreeSpots>::_class = CO(FreeSpots);
   TStruct<GLArrayTexture>::_class = CO(GLArrayTexture);
   TStruct<GLDrawCommand>::_class = CO(GLDrawCommand);
   TStruct<GLMultiDraw>::_class = CO(GLMultiDraw);
   TStruct<ColorCMYK>::_class = CO(ColorCMYK);
   TStruct<ColorHSV>::_class = CO(ColorHSV);
   TStruct<ColorKey>::_class = CO(ColorKey);
   TStruct<ColorLab>::_class = CO(ColorLab);
   TStruct<ColorRGB>::_class = CO(ColorRGB);
   TStruct<ColorRGBAf>::_class = CO(ColorRGBAf);
   TStruct<DrawSlot>::_class = CO(DrawSlot);
   TStruct<FMPathDraw>::_class = CO(FMPathDraw);
   TStruct<FontInfo>::_class = CO(FontInfo);
   TStruct<Light>::_class = CO(Light);
   TStruct<RenderStateFloat>::_class = CO(RenderStateFloat);
   TStruct<PNGOptions>::_class = CO(PNGOptions);
   TStruct<GLAB>::_class = CO(GLAB);
   TStruct<GLB>::_class = CO(GLB);
   TStruct<GLCAB>::_class = CO(GLCAB);
   TStruct<GLEAB>::_class = CO(GLEAB);
   TStruct<GLFB>::_class = CO(GLFB);
   TStruct<Euler>::_class = CO(Euler);
   TStruct<FrameKey>::_class = CO(FrameKey);
   TStruct<Line>::_class = CO(Line);
   TStruct<Matrix>::_class = CO(Matrix);
   TStruct<Matrixf>::_class = CO(Matrixf);
   TStruct<MeshMorph>::_class = CO(MeshMorph);
   TStruct<MeshPart>::_class = CO(MeshPart);
   TStruct<Plane>::_class = CO(Plane);
   TStruct<PrimitiveSingle>::_class = CO(PrimitiveSingle);
   TStruct<Quaternion>::_class = CO(Quaternion);
   TStruct<SkinBone>::_class = CO(SkinBone);
   TStruct<SkinVert>::_class = CO(SkinVert);
   TStruct<Transform>::_class = CO(Transform);
   TStruct<Vector3D>::_class = CO(Vector3D);
   TStruct<Vector3Df>::_class = CO(Vector3Df);
   TStruct<Anchor>::_class = CO(Anchor);
   TStruct<AnchorValue>::_class = CO(AnchorValue);
   TStruct<Extent>::_class = CO(Extent);
   TStruct<Joystick>::_class = CO(Joystick);
   TStruct<MiddleAnchorValue>::_class = CO(MiddleAnchorValue);
   TStruct<SizeAnchor>::_class = CO(SizeAnchor);
   TStruct<TouchPointerInfo>::_class = CO(TouchPointerInfo);
   TStruct<BufferLocation>::_class = CO(BufferLocation);
   TStruct<DataFieldSort>::_class = CO(DataFieldSort);
   TStruct<FileFilter>::_class = CO(FileFilter);
   TStruct<FileName>::_class = CO(FileName);
   TStruct<FileType>::_class = CO(FileType);
   TStruct<Box>::_class = CO(Box);
   TStruct<Date>::_class = CO(Date);
   TStruct<DateTime>::_class = CO(DateTime);
   TStruct<FileListing>::_class = CO(FileListing);
   TStruct<FileStats>::_class = CO(FileStats);
   TStruct<Point>::_class = CO(Point);
   TStruct<Pointd>::_class = CO(Pointd);
   TStruct<Pointf>::_class = CO(Pointf);
   TStruct<Size>::_class = CO(Size);

   Bitmap::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Bitmap", "Bitmap",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Bitmap::constructor,
               (void(*)(void *)) Bitmap::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   BitmapFormat::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "BitmapFormat", "BitmapFormat",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) BitmapFormat::constructor,
               (void(*)(void *)) BitmapFormat::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   BitmapResource::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "BitmapResource", "BitmapResource",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) BitmapResource::constructor,
               (void(*)(void *)) BitmapResource::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   CubeMap::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "CubeMap", "CubeMap",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) CubeMap::constructor,
               (void(*)(void *)) CubeMap::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Display::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Display", "Display",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Display::constructor,
               (void(*)(void *)) Display::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DisplayDriver::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DisplayDriver", "DisplayDriver",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DisplayDriver::constructor,
               (void(*)(void *)) DisplayDriver::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DisplaySystem::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DisplaySystem", "DisplaySystem",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DisplaySystem::constructor,
               (void(*)(void *)) DisplaySystem::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DrawList::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DrawList", "DrawList",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DrawList::constructor,
               (void(*)(void *)) DrawList::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DrawManager::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DrawManager", "DrawManager",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DrawManager::constructor,
               (void(*)(void *)) DrawManager::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FontManager::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FontManager", "FontManager",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FontManager::constructor,
               (void(*)(void *)) FontManager::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FontManagerRenderer::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FontManagerRenderer", "FontManagerRenderer",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FontManagerRenderer::constructor,
               (void(*)(void *)) FontManagerRenderer::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FontRenderer::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FontRenderer", "FontRenderer",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FontRenderer::constructor,
               (void(*)(void *)) FontRenderer::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FontResource::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FontResource", "FontResource",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FontResource::constructor,
               (void(*)(void *)) FontResource::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Resource::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Resource", "Resource",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Resource::constructor,
               (void(*)(void *)) Resource::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Surface::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Surface", "Surface",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Surface::constructor,
               (void(*)(void *)) Surface::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DefaultShader::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DefaultShader", "DefaultShader",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DefaultShader::constructor,
               (void(*)(void *)) DefaultShader::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FreeBlockMap::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FreeBlockMap", "FreeBlockMap",
               sizeof(Instance *), 0,
               null,
               null,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GLMB::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GLMB", "GLMB",
               sizeof(Instance *), 0,
               null,
               null,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GLStats::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GLStats", "GLStats",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) GLStats::constructor,
               (void(*)(void *)) GLStats::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   LFBDisplayDriver::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "LFBDisplayDriver", "LFBDisplayDriver",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) LFBDisplayDriver::constructor,
               (void(*)(void *)) LFBDisplayDriver::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Shader::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Shader", "Shader",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Shader::constructor,
               (void(*)(void *)) Shader::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Camera::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Camera", "Camera",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Camera::constructor,
               (void(*)(void *)) Camera::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   MeshSkin::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "MeshSkin", "MeshSkin",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) MeshSkin::constructor,
               (void(*)(void *)) MeshSkin::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ObjectFormat::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ObjectFormat", "ObjectFormat",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ObjectFormat::constructor,
               (void(*)(void *)) ObjectFormat::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   CommonControl::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "CommonControl", "CommonControl",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) CommonControl::constructor,
               (void(*)(void *)) CommonControl::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ControllableWindow::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ControllableWindow", "ControllableWindow",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ControllableWindow::constructor,
               (void(*)(void *)) ControllableWindow::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Cursor::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Cursor", "Cursor",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Cursor::constructor,
               (void(*)(void *)) Cursor::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GuiApplication::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GuiApplication", "GuiApplication",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) GuiApplication::constructor,
               (void(*)(void *)) GuiApplication::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Interface::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Interface", "Interface",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Interface::constructor,
               (void(*)(void *)) Interface::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Skin::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Skin", "Skin",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Skin::constructor,
               (void(*)(void *)) Skin::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Timer::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Timer", "Timer",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Timer::constructor,
               (void(*)(void *)) Timer::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Window::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Window", "Window",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Window::constructor,
               (void(*)(void *)) Window::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   WindowController::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "WindowController", "WindowController",
               sizeof(Instance *), 0,
               null,
               null,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Button::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Button", "Button",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Button::constructor,
               (void(*)(void *)) Button::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   CalendarControl::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "CalendarControl", "CalendarControl",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) CalendarControl::constructor,
               (void(*)(void *)) CalendarControl::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DataBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DataBox", "DataBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DataBox::constructor,
               (void(*)(void *)) DataBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DataField::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DataField", "DataField",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DataField::constructor,
               (void(*)(void *)) DataField::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DataRow::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DataRow", "DataRow",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DataRow::constructor,
               (void(*)(void *)) DataRow::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DirectoriesBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DirectoriesBox", "DirectoriesBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DirectoriesBox::constructor,
               (void(*)(void *)) DirectoriesBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DropBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DropBox", "DropBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DropBox::constructor,
               (void(*)(void *)) DropBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   EditBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "EditBox", "EditBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) EditBox::constructor,
               (void(*)(void *)) EditBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   EditBoxStream::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "EditBoxStream", "EditBoxStream",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) EditBoxStream::constructor,
               (void(*)(void *)) EditBoxStream::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   EditSyntaxHL::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "EditSyntaxHL", "EditSyntaxHL",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) EditSyntaxHL::constructor,
               (void(*)(void *)) EditSyntaxHL::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   EditableSelectorButton::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "EditableSelectorButton", "EditableSelectorButton",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) EditableSelectorButton::constructor,
               (void(*)(void *)) EditableSelectorButton::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Label::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Label", "Label",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Label::constructor,
               (void(*)(void *)) Label::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ListBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ListBox", "ListBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ListBox::constructor,
               (void(*)(void *)) ListBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Menu::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Menu", "Menu",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Menu::constructor,
               (void(*)(void *)) Menu::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   MenuDivider::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "MenuDivider", "MenuDivider",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) MenuDivider::constructor,
               (void(*)(void *)) MenuDivider::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   MenuItem::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "MenuItem", "MenuItem",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) MenuItem::constructor,
               (void(*)(void *)) MenuItem::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   MenuPlacement::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "MenuPlacement", "MenuPlacement",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) MenuPlacement::constructor,
               (void(*)(void *)) MenuPlacement::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   OldArray::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "OldArray", "OldArray",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) OldArray::constructor,
               (void(*)(void *)) OldArray::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   PaneSplitter::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "PaneSplitter", "PaneSplitter",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) PaneSplitter::constructor,
               (void(*)(void *)) PaneSplitter::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   PathBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "PathBox", "PathBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) PathBox::constructor,
               (void(*)(void *)) PathBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Picture::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Picture", "Picture",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Picture::constructor,
               (void(*)(void *)) Picture::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   PopupMenu::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "PopupMenu", "PopupMenu",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) PopupMenu::constructor,
               (void(*)(void *)) PopupMenu::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ProgressBar::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ProgressBar", "ProgressBar",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ProgressBar::constructor,
               (void(*)(void *)) ProgressBar::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   SavingDataBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "SavingDataBox", "SavingDataBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) SavingDataBox::constructor,
               (void(*)(void *)) SavingDataBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ScrollBar::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ScrollBar", "ScrollBar",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ScrollBar::constructor,
               (void(*)(void *)) ScrollBar::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   SelectorBar::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "SelectorBar", "SelectorBar",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) SelectorBar::constructor,
               (void(*)(void *)) SelectorBar::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   SelectorButton::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "SelectorButton", "SelectorButton",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) SelectorButton::constructor,
               (void(*)(void *)) SelectorButton::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Stacker::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Stacker", "Stacker",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Stacker::constructor,
               (void(*)(void *)) Stacker::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   StatusBar::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "StatusBar", "StatusBar",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) StatusBar::constructor,
               (void(*)(void *)) StatusBar::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   StatusField::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "StatusField", "StatusField",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) StatusField::constructor,
               (void(*)(void *)) StatusField::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Tab::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Tab", "Tab",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Tab::constructor,
               (void(*)(void *)) Tab::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   TabControl::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "TabControl", "TabControl",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) TabControl::constructor,
               (void(*)(void *)) TabControl::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ToolBar::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ToolBar", "ToolBar",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ToolBar::constructor,
               (void(*)(void *)) ToolBar::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ToolButton::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ToolButton", "ToolButton",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ToolButton::constructor,
               (void(*)(void *)) ToolButton::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ToolSeparator::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ToolSeparator", "ToolSeparator",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ToolSeparator::constructor,
               (void(*)(void *)) ToolSeparator::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ToolTip::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ToolTip", "ToolTip",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ToolTip::constructor,
               (void(*)(void *)) ToolTip::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   UndoBuffer::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "UndoBuffer", "UndoBuffer",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) UndoBuffer::constructor,
               (void(*)(void *)) UndoBuffer::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ColorPicker::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ColorPicker", "ColorPicker",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ColorPicker::constructor,
               (void(*)(void *)) ColorPicker::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   CreateDirectoryDialog::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "CreateDirectoryDialog", "CreateDirectoryDialog",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) CreateDirectoryDialog::constructor,
               (void(*)(void *)) CreateDirectoryDialog::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FileDialog::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FileDialog", "FileDialog",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FileDialog::constructor,
               (void(*)(void *)) FileDialog::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FindDialog::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FindDialog", "FindDialog",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FindDialog::constructor,
               (void(*)(void *)) FindDialog::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GoToDialog::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GoToDialog", "GoToDialog",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) GoToDialog::constructor,
               (void(*)(void *)) GoToDialog::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   MessageBox::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "MessageBox", "MessageBox",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) MessageBox::constructor,
               (void(*)(void *)) MessageBox::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ReplaceDialog::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ReplaceDialog", "ReplaceDialog",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ReplaceDialog::constructor,
               (void(*)(void *)) ReplaceDialog::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   WindowList::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "WindowList", "WindowList",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) WindowList::constructor,
               (void(*)(void *)) WindowList::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   TVisionSkin_Window::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "TVisionSkin_Window", "TVisionSkin_Window",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) TVisionSkin_Window::constructor,
               (void(*)(void *)) TVisionSkin_Window::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   WindowsSkin_Button::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "WindowsSkin_Button", "WindowsSkin_Button",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) WindowsSkin_Button::constructor,
               (void(*)(void *)) WindowsSkin_Button::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   WindowsSkin_Window::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "WindowsSkin_Window", "WindowsSkin_Window",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) WindowsSkin_Window::constructor,
               (void(*)(void *)) WindowsSkin_Window::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DCOMClientObject::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DCOMClientObject", "DCOMClientObject",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DCOMClientObject::constructor,
               (void(*)(void *)) DCOMClientObject::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DCOMSendControl::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DCOMSendControl", "DCOMSendControl",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DCOMSendControl::constructor,
               (void(*)(void *)) DCOMSendControl::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DCOMServerObject::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DCOMServerObject", "DCOMServerObject",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DCOMServerObject::constructor,
               (void(*)(void *)) DCOMServerObject::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DCOMServerSocket::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DCOMServerSocket", "DCOMServerSocket",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DCOMServerSocket::constructor,
               (void(*)(void *)) DCOMServerSocket::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DCOMService::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DCOMService", "DCOMService",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DCOMService::constructor,
               (void(*)(void *)) DCOMService::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FileServerConnection::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FileServerConnection", "FileServerConnection",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FileServerConnection::constructor,
               (void(*)(void *)) FileServerConnection::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   HTTPFile::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "HTTPFile", "HTTPFile",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) HTTPFile::constructor,
               (void(*)(void *)) HTTPFile::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   NetworkClientFile::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "NetworkClientFile", "NetworkClientFile",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) NetworkClientFile::constructor,
               (void(*)(void *)) NetworkClientFile::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   SSLSocket::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "SSLSocket", "SSLSocket",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) SSLSocket::constructor,
               (void(*)(void *)) SSLSocket::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Service::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Service", "Service",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Service::constructor,
               (void(*)(void *)) Service::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Socket::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Socket", "Socket",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Socket::constructor,
               (void(*)(void *)) Socket::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Archive::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Archive", "Archive",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Archive::constructor,
               (void(*)(void *)) Archive::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ArchiveDir::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ArchiveDir", "ArchiveDir",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ArchiveDir::constructor,
               (void(*)(void *)) ArchiveDir::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   BufferedFile::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "BufferedFile", "BufferedFile",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) BufferedFile::constructor,
               (void(*)(void *)) BufferedFile::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ConsoleFile::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ConsoleFile", "ConsoleFile",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ConsoleFile::constructor,
               (void(*)(void *)) ConsoleFile::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   DualPipe::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "DualPipe", "DualPipe",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) DualPipe::constructor,
               (void(*)(void *)) DualPipe::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ECONGlobalSettings::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ECONGlobalSettings", "ECONGlobalSettings",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ECONGlobalSettings::constructor,
               (void(*)(void *)) ECONGlobalSettings::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   ECONParser::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "ECONParser", "ECONParser",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) ECONParser::constructor,
               (void(*)(void *)) ECONParser::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   File::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "File", "File",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) File::constructor,
               (void(*)(void *)) File::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   FileMonitor::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "FileMonitor", "FileMonitor",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) FileMonitor::constructor,
               (void(*)(void *)) FileMonitor::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GlobalAppSettings::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GlobalAppSettings", "GlobalAppSettings",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) GlobalAppSettings::constructor,
               (void(*)(void *)) GlobalAppSettings::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GlobalSettings::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GlobalSettings", "GlobalSettings",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) GlobalSettings::constructor,
               (void(*)(void *)) GlobalSettings::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GlobalSettingsData::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GlobalSettingsData", "GlobalSettingsData",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) GlobalSettingsData::constructor,
               (void(*)(void *)) GlobalSettingsData::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   GlobalSettingsDriver::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "GlobalSettingsDriver", "GlobalSettingsDriver",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) GlobalSettingsDriver::constructor,
               (void(*)(void *)) GlobalSettingsDriver::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   JSONGlobalSettings::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "JSONGlobalSettings", "JSONGlobalSettings",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) JSONGlobalSettings::constructor,
               (void(*)(void *)) JSONGlobalSettings::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   JSONParser::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "JSONParser", "JSONParser",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) JSONParser::constructor,
               (void(*)(void *)) JSONParser::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   OptionsMap::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "OptionsMap", "OptionsMap",
               sizeof(Instance *), 0,
               null,
               null,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   RepButton::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "RepButton", "RepButton",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) RepButton::constructor,
               (void(*)(void *)) RepButton::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   TempFile::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "TempFile", "TempFile",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) TempFile::constructor,
               (void(*)(void *)) TempFile::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   Thread::_cpp_class.setup(
         (XClass *)eC_registerClass(
               ClassType_normalClass,
               "CPP" "Thread", "Thread",
               sizeof(Instance *), 0,
               (C(bool) (*)(void *)) Thread::constructor,
               (void(*)(void *)) Thread::destructor,
               (module).impl,
               AccessMode_privateAccess, AccessMode_publicAccess));
   }
   return 0;
}


//////////////////////////////////////////////////////////////////////////////// ////////////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////////////
////                                                                        //// ////////////////////////
////    moved to cpp implementations                                        //// ////////////////////////
////                                                                        //// ////////////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////////////


////////////////////////////////////////////////////////////// [ecere]/ //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


///////////////////////////////////////////////////////// [ecere]/ecere //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


//////////////////////////////////////////////////// [ecere]/ecere::gfx //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////

void Bitmap::class_registration(CPPClass & _cpp_class)
{
}
void BitmapFormat::class_registration(CPPClass & _cpp_class)
{
}
void BitmapResource::class_registration(CPPClass & _cpp_class)
{
}
   ColorAlpha::ColorAlpha(unsigned char a, Color & color)
   {
      impl = COLORALPHA(a, color);
   }
void CubeMap::class_registration(CPPClass & _cpp_class)
{
}
void Display::class_registration(CPPClass & _cpp_class)
{
}
void DisplayDriver::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "AllocateBitmap", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/int ap5, /*1Aa*/C(PixelFormat) ap6, /*1Aa*/C(bool) ap7)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, allocateBitmap);
         DisplayDriver_allocateBitmap_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_allocateBitmap_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Bg*/TIH<Bitmap> ap2_l(ap2); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/ap3, /*3Kd*/ap4, /*3Kd*/ap5, /*3Hd*/(PixelFormat)ap6, /*3Hd*/(bool)ap7); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/int ap5, /*1Aa*/C(PixelFormat) ap6, /*1Aa*/C(bool) ap7))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, allocateBitmap)]);
            if(method) return method (ap1, ap2, ap3, ap4, ap5, ap6, ap7);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "AllocateIndices", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/int nIndices, /*1Aa*/C(bool) indices32bit)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, allocateIndices);
         DisplayDriver_allocateIndices_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_allocateIndices_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); void * ret = fn(*i, /*3Bd*/*ap1_l, /*3Kd*/nIndices, /*3Hd*/(bool)indices32bit); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void * (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/int nIndices, /*1Aa*/C(bool) indices32bit))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, allocateIndices)]);
            if(method) return method (ap1, nIndices, indices32bit);
         }
         return (void *)1;
      });


      addMethod(_cpp_class.impl, "AllocateMesh", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2, /*1Aa*/C(MeshFeatures) ap3, /*1Aa*/int nVertices)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, allocateMesh);
         DisplayDriver_allocateMesh_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_allocateMesh_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Cg*/Mesh ap2_l(ap2); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l, /*3Hd*/(MeshFeatures)ap3, /*3Kd*/nVertices); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2, /*1Aa*/C(MeshFeatures) ap3, /*1Aa*/int nVertices))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, allocateMesh)]);
            if(method) return method (ap1, ap2, ap3, nVertices);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "ApplyMaterial", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Material) * ap2, /*1Aa*/C(Mesh) * ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, applyMaterial);
         DisplayDriver_applyMaterial_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_applyMaterial_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Cg*/Material ap2_l(ap2); /*2Cg*/Mesh ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l, /*3Cd*/ap3_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Material) * ap2, /*1Aa*/C(Mesh) * ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, applyMaterial)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Area", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x1, /*1Aa*/int y1, /*1Aa*/int x2, /*1Aa*/int y2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, area);
         DisplayDriver_area_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_area_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/x1, /*3Kd*/y1, /*3Kd*/x2, /*3Kd*/y2);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x1, /*1Aa*/int y1, /*1Aa*/int x2, /*1Aa*/int y2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, area)]);
            if(method) return method (ap1, ap2, x1, y1, x2, y2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Blit", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, blit);
         DisplayDriver_blit_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_blit_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Bitmap> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/dx, /*3Kd*/dy, /*3Kd*/sx, /*3Kd*/sy, /*3Kd*/w, /*3Kd*/h);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, blit)]);
            if(method) return method (ap1, ap2, ap3, dx, dy, sx, sy, w, h);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "BlitDI", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, blitDI);
         DisplayDriver_blitDI_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_blitDI_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Bitmap> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/dx, /*3Kd*/dy, /*3Kd*/sx, /*3Kd*/sy, /*3Kd*/w, /*3Kd*/h);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, blitDI)]);
            if(method) return method (ap1, ap2, ap3, dx, dy, sx, sy, w, h);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Clear", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ClearType) ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, clear);
         DisplayDriver_clear_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_clear_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Hd*/(ClearType)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ClearType) ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, clear)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Clip", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Box) * ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, clip);
         DisplayDriver_clip_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_clip_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Id*/*(Box *)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Box) * ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, clip)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "ConvertBitmap", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/C(PixelFormat) ap3, /*1Aa*/C(ColorAlpha) * ap4)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, convertBitmap);
         DisplayDriver_convertBitmap_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_convertBitmap_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Bg*/TIH<Bitmap> ap2_l(ap2); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Hd*/(PixelFormat)ap3, /*3Hd*/(ColorAlpha *)ap4); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/C(PixelFormat) ap3, /*1Aa*/C(ColorAlpha) * ap4))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, convertBitmap)]);
            if(method) return method (ap1, ap2, ap3, ap4);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "CreateDisplay", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, createDisplay);
         DisplayDriver_createDisplay_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_createDisplay_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, createDisplay)]);
            if(method) return method (ap1);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "CreateDisplaySystem", (void *) +[](/*1Aa*/C(DisplaySystem) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, createDisplaySystem);
         DisplayDriver_createDisplaySystem_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_createDisplaySystem_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, createDisplaySystem)]);
            if(method) return method (ap1);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "DestroyDisplay", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, destroyDisplay);
         DisplayDriver_destroyDisplay_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_destroyDisplay_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, destroyDisplay)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "DestroyDisplaySystem", (void *) +[](/*1Aa*/C(DisplaySystem) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, destroyDisplaySystem);
         DisplayDriver_destroyDisplaySystem_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_destroyDisplaySystem_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, destroyDisplaySystem)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "DisplayPosition", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, displayPosition);
         DisplayDriver_displayPosition_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_displayPosition_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Kd*/ap2, /*3Kd*/ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, displayPosition)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "DisplaySize", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, displaySize);
         DisplayDriver_displaySize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_displaySize_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Kd*/ap2, /*3Kd*/ap3); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Display) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, displaySize)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "DrawLine", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x1, /*1Aa*/int y1, /*1Aa*/int x2, /*1Aa*/int y2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, drawLine);
         DisplayDriver_drawLine_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_drawLine_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/x1, /*3Kd*/y1, /*3Kd*/x2, /*3Kd*/y2);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x1, /*1Aa*/int y1, /*1Aa*/int x2, /*1Aa*/int y2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, drawLine)]);
            if(method) return method (ap1, ap2, x1, y1, x2, y2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "DrawPrimitives", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(PrimitiveSingle) * ap2, /*1Aa*/C(Mesh) * mesh)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, drawPrimitives);
         DisplayDriver_drawPrimitives_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_drawPrimitives_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Cg*/Mesh mesh_l(mesh); fn(*i, /*3Bd*/*ap1_l, /*3Id*/*(PrimitiveSingle *)ap2, /*3Cd*/mesh_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(PrimitiveSingle) * ap2, /*1Aa*/C(Mesh) * mesh))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, drawPrimitives)]);
            if(method) return method (ap1, ap2, mesh);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "DrawingChar", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/char ch)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, drawingChar);
         DisplayDriver_drawingChar_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_drawingChar_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/ch);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/char ch))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, drawingChar)]);
            if(method) return method (ap1, ap2, ch);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "EndUpdate", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, endUpdate);
         DisplayDriver_endUpdate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_endUpdate_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, endUpdate)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Filter", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, filter);
         DisplayDriver_filter_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_filter_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Bitmap> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/dx, /*3Kd*/dy, /*3Kd*/sx, /*3Kd*/sy, /*3Kd*/w, /*3Kd*/h, /*3Kd*/sw, /*3Kd*/sh);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, filter)]);
            if(method) return method (ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "FilterDI", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, filterDI);
         DisplayDriver_filterDI_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_filterDI_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Bitmap> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/dx, /*3Kd*/dy, /*3Kd*/sx, /*3Kd*/sy, /*3Kd*/w, /*3Kd*/h, /*3Kd*/sw, /*3Kd*/sh);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, filterDI)]);
            if(method) return method (ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "FontExtent", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Font) * ap2, constString text, /*1Aa*/int len, /*1Aa*/int * tw, /*1Aa*/int * th, /*1Aa*/int prevGlyph, /*1Aa*/int * rPrevGlyph, /*1Aa*/int * overHang)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, fontExtent);
         DisplayDriver_fontExtent_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_fontExtent_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Cg*/Font ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l, /*3Kd*/text, /*3Kd*/len, /*3Kd*/tw, /*3Kd*/th, /*3Kd*/prevGlyph, /*3Kd*/rPrevGlyph, /*3Kd*/overHang);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Font) * ap2, constString text, /*1Aa*/int len, /*1Aa*/int * tw, /*1Aa*/int * th, /*1Aa*/int prevGlyph, /*1Aa*/int * rPrevGlyph, /*1Aa*/int * overHang))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, fontExtent)]);
            if(method) return method (ap1, ap2, text, len, tw, th, prevGlyph, rPrevGlyph, overHang);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "FreeBitmap", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, freeBitmap);
         DisplayDriver_freeBitmap_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_freeBitmap_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Bg*/TIH<Bitmap> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, freeBitmap)]);
            if(method) return method (ap1, ap2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "FreeIndices", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(PrimitiveSingle) * group)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, freeIndices);
         DisplayDriver_freeIndices_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_freeIndices_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Id*/*(PrimitiveSingle *)group);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(PrimitiveSingle) * group))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, freeIndices)]);
            if(method) return method (ap1, group);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "FreeMesh", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, freeMesh);
         DisplayDriver_freeMesh_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_freeMesh_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Cg*/Mesh ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, freeMesh)]);
            if(method) return method (ap1, ap2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "GetBitmapSurface", (void *) +[](/*1Aa*/C(DisplaySystem) displaySystem, /*1Aa*/C(Surface) surface, /*1Aa*/C(Bitmap) bitmap, /*1Aa*/int ap1, /*1Aa*/int ap2, /*1Aa*/C(Box) * ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, getBitmapSurface);
         DisplayDriver_getBitmapSurface_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_getBitmapSurface_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> displaySystem_l(displaySystem); /*2Bg*/TIH<Surface> surface_l(surface); /*2Bg*/TIH<Bitmap> bitmap_l(bitmap); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*displaySystem_l, /*3Bd*/*surface_l, /*3Bd*/*bitmap_l, /*3Kd*/ap1, /*3Kd*/ap2, /*3Id*/*(Box *)ap3); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) displaySystem, /*1Aa*/C(Surface) surface, /*1Aa*/C(Bitmap) bitmap, /*1Aa*/int ap1, /*1Aa*/int ap2, /*1Aa*/C(Box) * ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, getBitmapSurface)]);
            if(method) return method (displaySystem, surface, bitmap, ap1, ap2, ap3);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "GetPixel", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x, /*1Aa*/int y)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, getPixel);
         DisplayDriver_getPixel_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_getPixel_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); C(ColorAlpha) ret = fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/x, /*3Kd*/y); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(ColorAlpha) (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x, /*1Aa*/int y))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, getPixel)]);
            if(method) return method (ap1, ap2, x, y);
         }
         return (C(ColorAlpha))1;
      });


      addMethod(_cpp_class.impl, "GetSurface", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) surface, /*1Aa*/int ap2, /*1Aa*/int ap3, /*1Aa*/C(Box) * ap4)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, getSurface);
         DisplayDriver_getSurface_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_getSurface_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> surface_l(surface); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*surface_l, /*3Kd*/ap2, /*3Kd*/ap3, /*3Id*/*(Box *)ap4); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) surface, /*1Aa*/int ap2, /*1Aa*/int ap3, /*1Aa*/C(Box) * ap4))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, getSurface)]);
            if(method) return method (ap1, surface, ap2, ap3, ap4);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "GrabScreen", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/uint ap5, /*1Aa*/uint ap6)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, grabScreen);
         DisplayDriver_grabScreen_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_grabScreen_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Bitmap> ap2_l(ap2); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/ap3, /*3Kd*/ap4, /*3Kd*/ap5, /*3Kd*/ap6); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/uint ap5, /*1Aa*/uint ap6))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, grabScreen)]);
            if(method) return method (ap1, ap2, ap3, ap4, ap5, ap6);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "LineStipple", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/uint pattern)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, lineStipple);
         DisplayDriver_lineStipple_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_lineStipple_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/pattern);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/uint pattern))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, lineStipple)]);
            if(method) return method (ap1, ap2, pattern);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "LoadFont", (void *) +[](/*1Aa*/C(DisplaySystem) displaySystem, /*1Aa*/const char * faceName, /*1Aa*/float size, /*1Aa*/C(FontFlags) flags, /*1Aa*/float outlineSize, /*1Aa*/float outlineFade)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, loadFont);
         DisplayDriver_loadFont_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_loadFont_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> displaySystem_l(displaySystem); C(Font) * ret = fn(*i, /*3Bd*/*displaySystem_l, /*3Kd*/faceName, /*3Kd*/size, /*3Hd*/(FontFlags)flags, /*3Kd*/outlineSize, /*3Kd*/outlineFade).impl; return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(Font) * (*) (/*1Aa*/C(DisplaySystem) displaySystem, /*1Aa*/const char * faceName, /*1Aa*/float size, /*1Aa*/C(FontFlags) flags, /*1Aa*/float outlineSize, /*1Aa*/float outlineFade))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, loadFont)]);
            if(method) return method (displaySystem, faceName, size, flags, outlineSize, outlineFade);
         }
         return (C(Font) *)null;
      });


      addMethod(_cpp_class.impl, "Lock", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, lock);
         DisplayDriver_lock_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_lock_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, lock)]);
            if(method) return method (ap1);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "LockIndices", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(PrimitiveSingle) * group)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, lockIndices);
         DisplayDriver_lockIndices_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_lockIndices_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); uint16 * ret = fn(*i, /*3Bd*/*ap1_l, /*3Id*/*(PrimitiveSingle *)group); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uint16 * (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(PrimitiveSingle) * group))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, lockIndices)]);
            if(method) return method (ap1, group);
         }
         return (uint16 *)1;
      });


      addMethod(_cpp_class.impl, "LockMesh", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2, /*1Aa*/C(MeshFeatures) flags)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, lockMesh);
         DisplayDriver_lockMesh_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_lockMesh_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Cg*/Mesh ap2_l(ap2); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l, /*3Hd*/(MeshFeatures)flags); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2, /*1Aa*/C(MeshFeatures) flags))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, lockMesh)]);
            if(method) return method (ap1, ap2, flags);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "LockSystem", (void *) +[](/*1Aa*/C(DisplaySystem) displaySystem)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, lockSystem);
         DisplayDriver_lockSystem_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_lockSystem_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> displaySystem_l(displaySystem); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*displaySystem_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) displaySystem))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, lockSystem)]);
            if(method) return method (displaySystem);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "MakeDDBitmap", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/C(bool) mipMaps, /*1Aa*/int cubeMapFace)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, makeDDBitmap);
         DisplayDriver_makeDDBitmap_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_makeDDBitmap_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Bg*/TIH<Bitmap> ap2_l(ap2); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Hd*/(bool)mipMaps, /*3Kd*/cubeMapFace); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Bitmap) ap2, /*1Aa*/C(bool) mipMaps, /*1Aa*/int cubeMapFace))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, makeDDBitmap)]);
            if(method) return method (ap1, ap2, mipMaps, cubeMapFace);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NextPage", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, nextPage);
         DisplayDriver_nextPage_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_nextPage_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, nextPage)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "PopMatrix", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(bool) ap2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, popMatrix);
         DisplayDriver_popMatrix_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_popMatrix_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Hd*/(bool)ap2);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(bool) ap2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, popMatrix)]);
            if(method) return method (ap1, ap2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "PushMatrix", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, pushMatrix);
         DisplayDriver_pushMatrix_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_pushMatrix_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, pushMatrix)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "PutPixel", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x, /*1Aa*/int y)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, putPixel);
         DisplayDriver_putPixel_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_putPixel_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/x, /*3Kd*/y);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x, /*1Aa*/int y))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, putPixel)]);
            if(method) return method (ap1, ap2, x, y);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Rectangle", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x1, /*1Aa*/int y1, /*1Aa*/int x2, /*1Aa*/int y2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, rectangle);
         DisplayDriver_rectangle_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_rectangle_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/x1, /*3Kd*/y1, /*3Kd*/x2, /*3Kd*/y2);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x1, /*1Aa*/int y1, /*1Aa*/int x2, /*1Aa*/int y2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, rectangle)]);
            if(method) return method (ap1, ap2, x1, y1, x2, y2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "ReleaseSurface", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, releaseSurface);
         DisplayDriver_releaseSurface_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_releaseSurface_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, releaseSurface)]);
            if(method) return method (ap1, ap2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "RestorePalette", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, restorePalette);
         DisplayDriver_restorePalette_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_restorePalette_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, restorePalette)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Scroll", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Box) * ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/C(Extent) * ap5)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, scroll);
         DisplayDriver_scroll_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_scroll_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Id*/*(Box *)ap2, /*3Kd*/ap3, /*3Kd*/ap4, /*3Id*/*(Extent *)ap5);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Box) * ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/C(Extent) * ap5))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, scroll)]);
            if(method) return method (ap1, ap2, ap3, ap4, ap5);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SelectMesh", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Mesh) * ap2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, selectMesh);
         DisplayDriver_selectMesh_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_selectMesh_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Cg*/Mesh ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Mesh) * ap2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, selectMesh)]);
            if(method) return method (ap1, ap2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetBackground", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ColorAlpha) ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setBackground);
         DisplayDriver_setBackground_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setBackground_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Hd*/(ColorAlpha)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ColorAlpha) ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setBackground)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetBlitTint", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ColorAlpha) ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setBlitTint);
         DisplayDriver_setBlitTint_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setBlitTint_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Hd*/(ColorAlpha)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ColorAlpha) ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setBlitTint)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetCamera", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Camera) ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setCamera);
         DisplayDriver_setCamera_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setCamera_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Camera> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Camera) ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setCamera)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetCameraVR", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Camera) ap2, /*1Aa*/int eye, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/void * fb, /*1Aa*/const C(Matrix) * prjMat)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setCameraVR);
         DisplayDriver_setCameraVR_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setCameraVR_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Camera> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/eye, /*3Kd*/w, /*3Kd*/h, /*3Kd*/fb, /*3Id*/*(Matrix *)prjMat);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Camera) ap2, /*1Aa*/int eye, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/void * fb, /*1Aa*/const C(Matrix) * prjMat))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setCameraVR)]);
            if(method) return method (ap1, ap2, eye, w, h, fb, prjMat);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetForeground", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ColorAlpha) ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setForeground);
         DisplayDriver_setForeground_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setForeground_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Hd*/(ColorAlpha)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(ColorAlpha) ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setForeground)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetLight", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/int ap2, /*1Aa*/C(Light) * ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setLight);
         DisplayDriver_setLight_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setLight_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Kd*/ap2, /*3Id*/*(Light *)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/int ap2, /*1Aa*/C(Light) * ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setLight)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetPalette", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(ColorAlpha) * ap2, /*1Aa*/C(bool) ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setPalette);
         DisplayDriver_setPalette_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setPalette_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Hd*/(ColorAlpha *)ap2, /*3Hd*/(bool)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(ColorAlpha) * ap2, /*1Aa*/C(bool) ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setPalette)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetRenderState", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(RenderState) ap2, /*1Aa*/uint ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setRenderState);
         DisplayDriver_setRenderState_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setRenderState_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Hd*/(RenderState)ap2, /*3Kd*/ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(RenderState) ap2, /*1Aa*/uint ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setRenderState)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetTransform", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Matrix) * ap2, /*1Aa*/C(bool) ap3, /*1Aa*/C(bool) ap4)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, setTransform);
         DisplayDriver_setTransform_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_setTransform_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Id*/*(Matrix *)ap2, /*3Hd*/(bool)ap3, /*3Hd*/(bool)ap4);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Matrix) * ap2, /*1Aa*/C(bool) ap3, /*1Aa*/C(bool) ap4))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, setTransform)]);
            if(method) return method (ap1, ap2, ap3, ap4);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "StartUpdate", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, startUpdate);
         DisplayDriver_startUpdate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_startUpdate_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, startUpdate)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Stretch", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, stretch);
         DisplayDriver_stretch_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_stretch_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Bitmap> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/dx, /*3Kd*/dy, /*3Kd*/sx, /*3Kd*/sy, /*3Kd*/w, /*3Kd*/h, /*3Kd*/sw, /*3Kd*/sh);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, stretch)]);
            if(method) return method (ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "StretchDI", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, stretchDI);
         DisplayDriver_stretchDI_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_stretchDI_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Bitmap> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/dx, /*3Kd*/dy, /*3Kd*/sx, /*3Kd*/sy, /*3Kd*/w, /*3Kd*/h, /*3Kd*/sw, /*3Kd*/sh);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/int dx, /*1Aa*/int dy, /*1Aa*/int sx, /*1Aa*/int sy, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/int sw, /*1Aa*/int sh))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, stretchDI)]);
            if(method) return method (ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Stretchf", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/float dx, /*1Aa*/float dy, /*1Aa*/float sx, /*1Aa*/float sy, /*1Aa*/float w, /*1Aa*/float h, /*1Aa*/float sw, /*1Aa*/float sh)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, stretchf);
         DisplayDriver_stretchf_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_stretchf_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Bitmap> ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/dx, /*3Kd*/dy, /*3Kd*/sx, /*3Kd*/sy, /*3Kd*/w, /*3Kd*/h, /*3Kd*/sw, /*3Kd*/sh);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Bitmap) ap3, /*1Aa*/float dx, /*1Aa*/float dy, /*1Aa*/float sx, /*1Aa*/float sy, /*1Aa*/float w, /*1Aa*/float h, /*1Aa*/float sw, /*1Aa*/float sh))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, stretchf)]);
            if(method) return method (ap1, ap2, ap3, dx, dy, sx, sy, w, h, sw, sh);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "TextExtent", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, constString text, /*1Aa*/int len, /*1Aa*/int * tw, /*1Aa*/int * th, /*1Aa*/int prevGlyph, /*1Aa*/int * rPrevGlyph, /*1Aa*/int * overHang)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, textExtent);
         DisplayDriver_textExtent_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_textExtent_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/text, /*3Kd*/len, /*3Kd*/tw, /*3Kd*/th, /*3Kd*/prevGlyph, /*3Kd*/rPrevGlyph, /*3Kd*/overHang);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, constString text, /*1Aa*/int len, /*1Aa*/int * tw, /*1Aa*/int * th, /*1Aa*/int prevGlyph, /*1Aa*/int * rPrevGlyph, /*1Aa*/int * overHang))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, textExtent)]);
            if(method) return method (ap1, ap2, text, len, tw, th, prevGlyph, rPrevGlyph, overHang);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "TextFont", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Font) * ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, textFont);
         DisplayDriver_textFont_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_textFont_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Cg*/Font ap3_l(ap3); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Cd*/ap3_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Font) * ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, textFont)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "TextOpacity", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(bool) ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, textOpacity);
         DisplayDriver_textOpacity_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_textOpacity_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Hd*/(bool)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(bool) ap3))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, textOpacity)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "UnloadFont", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Font) * ap2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, unloadFont);
         DisplayDriver_unloadFont_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_unloadFont_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Cg*/Font ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Font) * ap2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, unloadFont)]);
            if(method) return method (ap1, ap2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Unlock", (void *) +[](/*1Aa*/C(Display) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, unlock);
         DisplayDriver_unlock_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_unlock_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, unlock)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "UnlockIndices", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(PrimitiveSingle) * group, /*1Aa*/C(bool) indices32bit, /*1Aa*/int nIndices, /*1Aa*/void * maeb)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, unlockIndices);
         DisplayDriver_unlockIndices_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_unlockIndices_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Id*/*(PrimitiveSingle *)group, /*3Hd*/(bool)indices32bit, /*3Kd*/nIndices, /*3Kd*/maeb);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(PrimitiveSingle) * group, /*1Aa*/C(bool) indices32bit, /*1Aa*/int nIndices, /*1Aa*/void * maeb))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, unlockIndices)]);
            if(method) return method (ap1, group, indices32bit, nIndices, maeb);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "UnlockMesh", (void *) +[](/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2, /*1Aa*/C(MeshFeatures) flags)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, unlockMesh);
         DisplayDriver_unlockMesh_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_unlockMesh_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> ap1_l(ap1); /*2Cg*/Mesh ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Cd*/ap2_l, /*3Hd*/(MeshFeatures)flags);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) ap1, /*1Aa*/C(Mesh) * ap2, /*1Aa*/C(MeshFeatures) flags))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, unlockMesh)]);
            if(method) return method (ap1, ap2, flags);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "UnlockSystem", (void *) +[](/*1Aa*/C(DisplaySystem) displaySystem)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, unlockSystem);
         DisplayDriver_unlockSystem_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_unlockSystem_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<DisplaySystem> displaySystem_l(displaySystem); fn(*i, /*3Bd*/*displaySystem_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DisplaySystem) displaySystem))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, unlockSystem)]);
            if(method) return method (displaySystem);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Update", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Box) * ap2)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, update);
         DisplayDriver_update_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_update_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Id*/*(Box *)ap2);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Box) * ap2))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, update)]);
            if(method) return method (ap1, ap2);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "WriteText", (void *) +[](/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x, /*1Aa*/int y, constString text, /*1Aa*/int len, /*1Aa*/int prevGlyph, /*1Aa*/int * rPrevGlyph)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         DisplayDriver * i = ((C(Instance))null) ? (DisplayDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(DisplayDriver, writeText);
         DisplayDriver_writeText_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DisplayDriver_writeText_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Display> ap1_l(ap1); /*2Bg*/TIH<Surface> ap2_l(ap2); fn(*i, /*3Bd*/*ap1_l, /*3Bd*/*ap2_l, /*3Kd*/x, /*3Kd*/y, /*3Kd*/text, /*3Kd*/len, /*3Kd*/prevGlyph, /*3Kd*/rPrevGlyph);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Display) ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/int x, /*1Aa*/int y, constString text, /*1Aa*/int len, /*1Aa*/int prevGlyph, /*1Aa*/int * rPrevGlyph))(CO(DisplayDriver)->_vTbl)[M_VTBLID(DisplayDriver, writeText)]);
            if(method) return method (ap1, ap2, x, y, text, len, prevGlyph, rPrevGlyph);
         }
         return ;
      });


}
void DisplaySystem::class_registration(CPPClass & _cpp_class)
{
}
void DrawList::class_registration(CPPClass & _cpp_class)
{
}
void DrawManager::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "flush", (void *) +[](/*1Aa*/C(DrawManager) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DrawManager * i = (o_) ? (DrawManager *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DrawManager, flush);
         DrawManager_flush_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DrawManager_flush_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DrawManager) o_))(CO(DrawManager)->_vTbl)[M_VTBLID(DrawManager, flush)]);
            if(method) return method (o_);
         }
         return ;
      });


}
   FMTextAlignment::FMTextAlignment(Alignment horzAlignment, FMVerticalAlignment vertAlignment)
   {
      impl = FMTEXTALIGNMENT(horzAlignment, vertAlignment);
   }
   FontFlags::FontFlags(bool bold, bool italic, bool underline)
   {
      impl = FONTFLAGS(bold, italic, underline);
   }
void FontManager::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "onAtlasFull", (void *) +[](/*1Aa*/C(FontManager) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManager * i = (o_) ? (FontManager *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManager, onAtlasFull);
         FontManager_onAtlasFull_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManager_onAtlasFull_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManager) o_))(CO(FontManager)->_vTbl)[M_VTBLID(FontManager, onAtlasFull)]);
            if(method) return method (o_);
         }
         return ;
      });


}
void FontManagerRenderer::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "createTexture", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int width, /*1Aa*/int height)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, createTexture);
         FontManagerRenderer_createTexture_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_createTexture_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i, /*3Kd*/width, /*3Kd*/height); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int width, /*1Aa*/int height))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, createTexture)]);
            if(method) return method (o_, width, height);
         }
         return (int)1;
      });


      addMethod(_cpp_class.impl, "drawImage", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int targetx, /*1Aa*/int targety, /*1Aa*/int imageIndex, /*1Aa*/C(bool) useExtColor)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, drawImage);
         FontManagerRenderer_drawImage_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_drawImage_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/targetx, /*3Kd*/targety, /*3Kd*/imageIndex, /*3Hd*/(bool)useExtColor);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int targetx, /*1Aa*/int targety, /*1Aa*/int imageIndex, /*1Aa*/C(bool) useExtColor))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, drawImage)]);
            if(method) return method (o_, targetx, targety, imageIndex, useExtColor);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "drawImageAlt", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/byte * texdata, /*1Aa*/int targetx, /*1Aa*/int targety, /*1Aa*/int offsetx, /*1Aa*/int offsety, /*1Aa*/int width, /*1Aa*/int height)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, drawImageAlt);
         FontManagerRenderer_drawImageAlt_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_drawImageAlt_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/texdata, /*3Kd*/targetx, /*3Kd*/targety, /*3Kd*/offsetx, /*3Kd*/offsety, /*3Kd*/width, /*3Kd*/height);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/byte * texdata, /*1Aa*/int targetx, /*1Aa*/int targety, /*1Aa*/int offsetx, /*1Aa*/int offsety, /*1Aa*/int width, /*1Aa*/int height))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, drawImageAlt)]);
            if(method) return method (o_, texdata, targetx, targety, offsetx, offsety, width, height);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "drawImageCursor", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int targetx, /*1Aa*/int targety, /*1Aa*/int imageIndex)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, drawImageCursor);
         FontManagerRenderer_drawImageCursor_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_drawImageCursor_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/targetx, /*3Kd*/targety, /*3Kd*/imageIndex);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int targetx, /*1Aa*/int targety, /*1Aa*/int imageIndex))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, drawImageCursor)]);
            if(method) return method (o_, targetx, targety, imageIndex);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "drawImageFloat", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/float targetx, /*1Aa*/float targety, /*1Aa*/float angsin, /*1Aa*/float angcos, /*1Aa*/int imageIndex, /*1Aa*/C(bool) useExtColor)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, drawImageFloat);
         FontManagerRenderer_drawImageFloat_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_drawImageFloat_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/targetx, /*3Kd*/targety, /*3Kd*/angsin, /*3Kd*/angcos, /*3Kd*/imageIndex, /*3Hd*/(bool)useExtColor);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/float targetx, /*1Aa*/float targety, /*1Aa*/float angsin, /*1Aa*/float angcos, /*1Aa*/int imageIndex, /*1Aa*/C(bool) useExtColor))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, drawImageFloat)]);
            if(method) return method (o_, targetx, targety, angsin, angcos, imageIndex, useExtColor);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "flush", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, flush);
         FontManagerRenderer_flush_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_flush_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, flush)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "init", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int channelCount)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, init);
         FontManagerRenderer_init_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_init_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/channelCount); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int channelCount))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, init)]);
            if(method) return method (o_, channelCount);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "registerImage", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int offsetx, /*1Aa*/int offsety, /*1Aa*/int width, /*1Aa*/int height)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, registerImage);
         FontManagerRenderer_registerImage_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_registerImage_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i, /*3Kd*/offsetx, /*3Kd*/offsety, /*3Kd*/width, /*3Kd*/height); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int offsetx, /*1Aa*/int offsety, /*1Aa*/int width, /*1Aa*/int height))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, registerImage)]);
            if(method) return method (o_, offsetx, offsety, width, height);
         }
         return (int)1;
      });


      addMethod(_cpp_class.impl, "resetImages", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, resetImages);
         FontManagerRenderer_resetImages_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_resetImages_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, resetImages)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "resizeTexture", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int width, /*1Aa*/int height)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, resizeTexture);
         FontManagerRenderer_resizeTexture_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_resizeTexture_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i, /*3Kd*/width, /*3Kd*/height); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int width, /*1Aa*/int height))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, resizeTexture)]);
            if(method) return method (o_, width, height);
         }
         return (int)1;
      });


      addMethod(_cpp_class.impl, "setLayer", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/uint layerIndex)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, setLayer);
         FontManagerRenderer_setLayer_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_setLayer_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/layerIndex);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/uint layerIndex))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, setLayer)]);
            if(method) return method (o_, layerIndex);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "updateTexture", (void *) +[](/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int * rect, /*1Aa*/const byte * data)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FontManagerRenderer * i = (o_) ? (FontManagerRenderer *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FontManagerRenderer, updateTexture);
         FontManagerRenderer_updateTexture_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FontManagerRenderer_updateTexture_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/rect, /*3Kd*/data);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(FontManagerRenderer) o_, /*1Aa*/int * rect, /*1Aa*/const byte * data))(CO(FontManagerRenderer)->_vTbl)[M_VTBLID(FontManagerRenderer, updateTexture)]);
            if(method) return method (o_, rect, data);
         }
         return ;
      });


}
void FontRenderer::class_registration(CPPClass & _cpp_class)
{
}
void FontResource::class_registration(CPPClass & _cpp_class)
{
}
   LightFlags::LightFlags(bool off, bool spot, bool omni, bool attenuation)
   {
      impl = LIGHTFLAGS(off, spot, omni, attenuation);
   }
void Resource::class_registration(CPPClass & _cpp_class)
{
}
void Surface::class_registration(CPPClass & _cpp_class)
{
}

/////////////////////////////////////////// [ecere]/ecere::gfx::bitmaps //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


/////////////////////////////////////////// [ecere]/ecere::gfx::drivers //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


#undef noAB
GLAB noAB = GLAB { 0 };


#undef noEAB
GLEAB noEAB = GLEAB { 0 };

void DefaultShader::class_registration(CPPClass & _cpp_class)
{
}
void FreeBlockMap::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "onExpand", (void *) +[](/*1Aa*/C(FreeBlockMap) o_, /*1Aa*/C(GLBType) type, /*1Aa*/uint required)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         FreeBlockMap * i = (o_) ? (FreeBlockMap *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(FreeBlockMap, onExpand);
         FreeBlockMap_onExpand_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FreeBlockMap_onExpand_Functor::FunctionType) i->vTbl[vid];
            uint ret = fn(*i, /*3Hd*/(GLBType)type, /*3Kd*/required); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uint (*) (/*1Aa*/C(FreeBlockMap) o_, /*1Aa*/C(GLBType) type, /*1Aa*/uint required))(CO(FreeBlockMap)->_vTbl)[M_VTBLID(FreeBlockMap, onExpand)]);
            if(method) return method (o_, type, required);
         }
         return (uint)1;
      });


}
void GLMB::class_registration(CPPClass & _cpp_class)
{
}
void GLStats::class_registration(CPPClass & _cpp_class)
{
}
void LFBDisplayDriver::class_registration(CPPClass & _cpp_class)
{
}
void Shader::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "bindAttribs", (void *) +[](/*1Aa*/C(Shader) o_, /*1Aa*/int program)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Shader * i = (o_) ? (Shader *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Shader, bindAttribs);
         Shader_bindAttribs_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Shader_bindAttribs_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/program);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Shader) o_, /*1Aa*/int program))(CO(Shader)->_vTbl)[M_VTBLID(Shader, bindAttribs)]);
            if(method) return method (o_, program);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "getDefinitions", (void *) +[](/*1Aa*/C(Shader) o_, /*1Aa*/uint64 state)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Shader * i = (o_) ? (Shader *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Shader, getDefinitions);
         Shader_getDefinitions_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Shader_getDefinitions_Functor::FunctionType) i->vTbl[vid];
            ZString * ret = fn(*i, /*3Kd*/state); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(ZString) (*) (/*1Aa*/C(Shader) o_, /*1Aa*/uint64 state))(CO(Shader)->_vTbl)[M_VTBLID(Shader, getDefinitions)]);
            if(method) return method (o_, state);
         }
         return (C(ZString))null;
      });


      addMethod(_cpp_class.impl, "registerShader", (void *) +[](/*1Aa*/C(Shader) o_, /*1Aa*/int program, /*1Aa*/uint64 state)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Shader * i = (o_) ? (Shader *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Shader, registerShader);
         Shader_registerShader_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Shader_registerShader_Functor::FunctionType) i->vTbl[vid];
            C(CompiledShader) * ret = fn(*i, /*3Kd*/program, /*3Kd*/state).impl; return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(CompiledShader) * (*) (/*1Aa*/C(Shader) o_, /*1Aa*/int program, /*1Aa*/uint64 state))(CO(Shader)->_vTbl)[M_VTBLID(Shader, registerShader)]);
            if(method) return method (o_, program, state);
         }
         return (C(CompiledShader) *)null;
      });


      addMethod(_cpp_class.impl, "setMaterial", (void *) +[](/*1Aa*/C(Shader) o_, /*1Aa*/C(Material) * material, /*1Aa*/C(MeshFeatures) flags)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Shader * i = (o_) ? (Shader *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Shader, setMaterial);
         Shader_setMaterial_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Shader_setMaterial_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/Material material_l(material); fn(*i, /*3Cd*/material_l, /*3Hd*/(MeshFeatures)flags);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Shader) o_, /*1Aa*/C(Material) * material, /*1Aa*/C(MeshFeatures) flags))(CO(Shader)->_vTbl)[M_VTBLID(Shader, setMaterial)]);
            if(method) return method (o_, material, flags);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "setupDrawCommand", (void *) +[](/*1Aa*/C(Shader) o_, /*1Aa*/C(GLAB) * ab, /*1Aa*/uint vertexStride, /*1Aa*/uint baseVertex, /*1Aa*/uint drawID, /*1Aa*/void * transform)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Shader * i = (o_) ? (Shader *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Shader, setupDrawCommand);
         Shader_setupDrawCommand_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Shader_setupDrawCommand_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Id*/*(GLAB *)ab, /*3Kd*/vertexStride, /*3Kd*/baseVertex, /*3Kd*/drawID, /*3Kd*/transform);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Shader) o_, /*1Aa*/C(GLAB) * ab, /*1Aa*/uint vertexStride, /*1Aa*/uint baseVertex, /*1Aa*/uint drawID, /*1Aa*/void * transform))(CO(Shader)->_vTbl)[M_VTBLID(Shader, setupDrawCommand)]);
            if(method) return method (o_, ab, vertexStride, baseVertex, drawID, transform);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "updateMatrix", (void *) +[](/*1Aa*/C(Shader) o_, /*1Aa*/C(MatrixMode) mode, /*1Aa*/float * matrix, /*1Aa*/C(bool) isIdentity)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Shader * i = (o_) ? (Shader *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Shader, updateMatrix);
         Shader_updateMatrix_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Shader_updateMatrix_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Hd*/(MatrixMode)mode, /*3Kd*/matrix, /*3Hd*/(bool)isIdentity);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Shader) o_, /*1Aa*/C(MatrixMode) mode, /*1Aa*/float * matrix, /*1Aa*/C(bool) isIdentity))(CO(Shader)->_vTbl)[M_VTBLID(Shader, updateMatrix)]);
            if(method) return method (o_, mode, matrix, isIdentity);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "uploadUniforms", (void *) +[](/*1Aa*/C(Shader) o_, /*1Aa*/C(CompiledShader) * shader)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Shader * i = (o_) ? (Shader *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Shader, uploadUniforms);
         Shader_uploadUniforms_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Shader_uploadUniforms_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/CompiledShader shader_l(shader); fn(*i, /*3Cd*/shader_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Shader) o_, /*1Aa*/C(CompiledShader) * shader))(CO(Shader)->_vTbl)[M_VTBLID(Shader, uploadUniforms)]);
            if(method) return method (o_, shader);
         }
         return ;
      });


}

////////////////////////////////////////////////// [ecere]/ecere::gfx3D //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////

void Camera::class_registration(CPPClass & _cpp_class)
{
}
   FrameTrackBits::FrameTrackBits(FrameTrackType type, bool loop, EulerRotationOrder rotationOrder)
   {
      impl = FRAMETRACKBITS(type, loop, rotationOrder);
   }
void MeshSkin::class_registration(CPPClass & _cpp_class)
{
}
void ObjectFormat::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "Load", (void *) +[](/*1Aa*/C(Object) * object, /*1Aa*/const char * fileName, /*1Aa*/C(DisplaySystem) displaySystem, /*1Aa*/void * options)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         ObjectFormat * i = ((C(Instance))null) ? (ObjectFormat *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(ObjectFormat, load);
         ObjectFormat_load_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ObjectFormat_load_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/Object object_l(object); /*2Bg*/TIH<DisplaySystem> displaySystem_l(displaySystem); C(bool) ret = (C(bool))fn(*i, /*3Cd*/object_l, /*3Kd*/fileName, /*3Bd*/*displaySystem_l, /*3Kd*/options); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Object) * object, /*1Aa*/const char * fileName, /*1Aa*/C(DisplaySystem) displaySystem, /*1Aa*/void * options))(CO(ObjectFormat)->_vTbl)[M_VTBLID(ObjectFormat, load)]);
            if(method) return method (object, fileName, displaySystem, options);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Save", (void *) +[](/*1Aa*/C(Object) * object, /*1Aa*/const char * fileName, /*1Aa*/void * options)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         ObjectFormat * i = ((C(Instance))null) ? (ObjectFormat *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(ObjectFormat, save);
         ObjectFormat_save_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ObjectFormat_save_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/Object object_l(object); C(bool) ret = (C(bool))fn(*i, /*3Cd*/object_l, /*3Kd*/fileName, /*3Kd*/options); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Object) * object, /*1Aa*/const char * fileName, /*1Aa*/void * options))(CO(ObjectFormat)->_vTbl)[M_VTBLID(ObjectFormat, save)]);
            if(method) return method (object, fileName, options);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "listTextures", (void *) +[](/*1Aa*/C(File) f, /*1Aa*/const char * fileName, /*1Aa*/void * options)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         ObjectFormat * i = ((C(Instance))null) ? (ObjectFormat *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(ObjectFormat, listTextures);
         ObjectFormat_listTextures_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ObjectFormat_listTextures_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<File> f_l(f); TArray<C(String) _ARG int _ARG C(String)> ret = fn(*i, /*3Bd*/*f_l, /*3Kd*/fileName, /*3Kd*/options); return ret.impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(Array) (*) (/*1Aa*/C(File) f, /*1Aa*/const char * fileName, /*1Aa*/void * options))(CO(ObjectFormat)->_vTbl)[M_VTBLID(ObjectFormat, listTextures)]);
            if(method) return method (f, fileName, options);
         }
         return (C(Array))null;
      });


}
   PrimitiveGroupType::PrimitiveGroupType(RenderPrimitiveType primitiveType, bool vertexRange, bool indices32bit, bool sharedIndices, bool hide)
   {
      impl = PRIMITIVEGROUPTYPE(primitiveType, vertexRange, indices32bit, sharedIndices, hide);
   }

////////////////////////////////////////// [ecere]/ecere::gfx3D::meshes //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


//////////////////////////////////////////////////// [ecere]/ecere::gui //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////

void CommonControl::class_registration(CPPClass & _cpp_class)
{
}
void ControllableWindow::class_registration(CPPClass & _cpp_class)
{
}
void Cursor::class_registration(CPPClass & _cpp_class)
{
}
void GuiApplication::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "Cycle", (void *) +[](/*1Aa*/C(GuiApplication) o_, /*1Aa*/C(bool) idle)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         GuiApplication * i = (o_) ? (GuiApplication *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(GuiApplication, cycle);
         GuiApplication_cycle_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GuiApplication_cycle_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(bool)idle); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(GuiApplication) o_, /*1Aa*/C(bool) idle))(CO(GuiApplication)->_vTbl)[M_VTBLID(GuiApplication, cycle)]);
            if(method) return method (o_, idle);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Init", (void *) +[](/*1Aa*/C(GuiApplication) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         GuiApplication * i = (o_) ? (GuiApplication *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(GuiApplication, init);
         GuiApplication_init_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GuiApplication_init_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(GuiApplication) o_))(CO(GuiApplication)->_vTbl)[M_VTBLID(GuiApplication, init)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Terminate", (void *) +[](/*1Aa*/C(GuiApplication) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         GuiApplication * i = (o_) ? (GuiApplication *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(GuiApplication, terminate);
         GuiApplication_terminate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GuiApplication_terminate_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(GuiApplication) o_))(CO(GuiApplication)->_vTbl)[M_VTBLID(GuiApplication, terminate)]);
            if(method) return method (o_);
         }
         return ;
      });


}
void Interface::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "AcquireInput", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/C(bool) state)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, acquireInput);
         Interface_acquireInput_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_acquireInput_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*window_l, /*3Hd*/(bool)state); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) window, /*1Aa*/C(bool) state))(CO(Interface)->_vTbl)[M_VTBLID(Interface, acquireInput)]);
            if(method) return method (window, state);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "ActivateRootWindow", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, activateRootWindow);
         Interface_activateRootWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_activateRootWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, activateRootWindow)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "AllocateClipboard", (void *) +[](/*1Aa*/C(ClipBoard) * clipBoard, /*1Aa*/uint size)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, allocateClipboard);
         Interface_allocateClipboard_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_allocateClipboard_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/ClipBoard clipBoard_l(clipBoard); C(bool) ret = (C(bool))fn(*i, /*3Cd*/clipBoard_l, /*3Kd*/size); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ClipBoard) * clipBoard, /*1Aa*/uint size))(CO(Interface)->_vTbl)[M_VTBLID(Interface, allocateClipboard)]);
            if(method) return method (clipBoard, size);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "ClearClipboard", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, clearClipboard);
         Interface_clearClipboard_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_clearClipboard_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) ())(CO(Interface)->_vTbl)[M_VTBLID(Interface, clearClipboard)]);
            if(method) return method ();
         }
         return ;
      });


      addMethod(_cpp_class.impl, "CreateRootWindow", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, createRootWindow);
         Interface_createRootWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_createRootWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); void * ret = fn(*i, /*3Bd*/*window_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void * (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, createRootWindow)]);
            if(method) return method (window);
         }
         return (void *)1;
      });


      addMethod(_cpp_class.impl, "DestroyRootWindow", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, destroyRootWindow);
         Interface_destroyRootWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_destroyRootWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, destroyRootWindow)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "EnsureFullScreen", (void *) +[](/*1Aa*/C(bool) * fullScreen)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, ensureFullScreen);
         Interface_ensureFullScreen_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_ensureFullScreen_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Fd*/fullScreen);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(bool) * fullScreen))(CO(Interface)->_vTbl)[M_VTBLID(Interface, ensureFullScreen)]);
            if(method) return method (fullScreen);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "FlashRootWindow", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, flashRootWindow);
         Interface_flashRootWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_flashRootWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, flashRootWindow)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "GetCurrentMode", (void *) +[](/*1Aa*/C(bool) * fullScreen, /*1Aa*/C(Resolution) * resolution, /*1Aa*/C(PixelFormat) * colorDepth, /*1Aa*/int * refreshRate)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, getCurrentMode);
         Interface_getCurrentMode_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_getCurrentMode_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Fd*/fullScreen, /*3Hd*/(Resolution *)resolution, /*3Hd*/(PixelFormat *)colorDepth, /*3Kd*/refreshRate);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(bool) * fullScreen, /*1Aa*/C(Resolution) * resolution, /*1Aa*/C(PixelFormat) * colorDepth, /*1Aa*/int * refreshRate))(CO(Interface)->_vTbl)[M_VTBLID(Interface, getCurrentMode)]);
            if(method) return method (fullScreen, resolution, colorDepth, refreshRate);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "GetJoystickState", (void *) +[](/*1Aa*/int device, /*1Aa*/C(Joystick) * joystick)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, getJoystickState);
         Interface_getJoystickState_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_getJoystickState_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/device, /*3Id*/*(Joystick *)joystick); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/int device, /*1Aa*/C(Joystick) * joystick))(CO(Interface)->_vTbl)[M_VTBLID(Interface, getJoystickState)]);
            if(method) return method (device, joystick);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "GetKeyState", (void *) +[](/*1Aa*/C(Key) key)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, getKeyState);
         Interface_getKeyState_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_getKeyState_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Key)key); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Key) key))(CO(Interface)->_vTbl)[M_VTBLID(Interface, getKeyState)]);
            if(method) return method (key);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "GetMousePosition", (void *) +[](/*1Aa*/int * x, /*1Aa*/int * y)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, getMousePosition);
         Interface_getMousePosition_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_getMousePosition_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/x, /*3Kd*/y);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/int * x, /*1Aa*/int * y))(CO(Interface)->_vTbl)[M_VTBLID(Interface, getMousePosition)]);
            if(method) return method (x, y);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "GetMouseState", (void *) +[](/*1Aa*/C(MouseButtons) * buttons, /*1Aa*/int * x, /*1Aa*/int * y)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, getMouseState);
         Interface_getMouseState_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_getMouseState_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(MouseButtons *)buttons, /*3Kd*/x, /*3Kd*/y); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(MouseButtons) * buttons, /*1Aa*/int * x, /*1Aa*/int * y))(CO(Interface)->_vTbl)[M_VTBLID(Interface, getMouseState)]);
            if(method) return method (buttons, x, y);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "GetScreenArea", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/C(Box) * box)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, getScreenArea);
         Interface_getScreenArea_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_getScreenArea_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Id*/*(Box *)box);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/C(Box) * box))(CO(Interface)->_vTbl)[M_VTBLID(Interface, getScreenArea)]);
            if(method) return method (window, box);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "GraphicsDrivers", (void *) +[](/*1Aa*/int * numDrivers)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, graphicsDrivers);
         Interface_graphicsDrivers_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_graphicsDrivers_Functor::FunctionType) i->vTbl[vid];
            const char * * ret = fn(*i, /*3Kd*/numDrivers); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((const char * * (*) (/*1Aa*/int * numDrivers))(CO(Interface)->_vTbl)[M_VTBLID(Interface, graphicsDrivers)]);
            if(method) return method (numDrivers);
         }
         return (const char * *)null;
      });


      addMethod(_cpp_class.impl, "Initialize", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, initialize);
         Interface_initialize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_initialize_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) ())(CO(Interface)->_vTbl)[M_VTBLID(Interface, initialize)]);
            if(method) return method ();
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "LoadClipboard", (void *) +[](/*1Aa*/C(ClipBoard) * clipBoard)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, loadClipboard);
         Interface_loadClipboard_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_loadClipboard_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/ClipBoard clipBoard_l(clipBoard); C(bool) ret = (C(bool))fn(*i, /*3Cd*/clipBoard_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ClipBoard) * clipBoard))(CO(Interface)->_vTbl)[M_VTBLID(Interface, loadClipboard)]);
            if(method) return method (clipBoard);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Lock", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, lock);
         Interface_lock_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_lock_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, lock)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OffsetWindow", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/int * x, /*1Aa*/int * y)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, offsetWindow);
         Interface_offsetWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_offsetWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Kd*/x, /*3Kd*/y);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/int * x, /*1Aa*/int * y))(CO(Interface)->_vTbl)[M_VTBLID(Interface, offsetWindow)]);
            if(method) return method (window, x, y);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OrderRootWindow", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/C(bool) topMost)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, orderRootWindow);
         Interface_orderRootWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_orderRootWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Hd*/(bool)topMost);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/C(bool) topMost))(CO(Interface)->_vTbl)[M_VTBLID(Interface, orderRootWindow)]);
            if(method) return method (window, topMost);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "PositionRootWindow", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/C(bool) move, /*1Aa*/C(bool) resize)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, positionRootWindow);
         Interface_positionRootWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_positionRootWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Kd*/x, /*3Kd*/y, /*3Kd*/w, /*3Kd*/h, /*3Hd*/(bool)move, /*3Hd*/(bool)resize);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/C(bool) move, /*1Aa*/C(bool) resize))(CO(Interface)->_vTbl)[M_VTBLID(Interface, positionRootWindow)]);
            if(method) return method (window, x, y, w, h, move, resize);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "ProcessInput", (void *) +[](/*1Aa*/C(bool) processAll)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, processInput);
         Interface_processInput_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_processInput_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(bool)processAll); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(bool) processAll))(CO(Interface)->_vTbl)[M_VTBLID(Interface, processInput)]);
            if(method) return method (processAll);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "SaveClipboard", (void *) +[](/*1Aa*/C(ClipBoard) * clipBoard)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, saveClipboard);
         Interface_saveClipboard_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_saveClipboard_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/ClipBoard clipBoard_l(clipBoard); C(bool) ret = (C(bool))fn(*i, /*3Cd*/clipBoard_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ClipBoard) * clipBoard))(CO(Interface)->_vTbl)[M_VTBLID(Interface, saveClipboard)]);
            if(method) return method (clipBoard);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "ScreenMode", (void *) +[](/*1Aa*/C(bool) fullScreen, /*1Aa*/C(Resolution) resolution, /*1Aa*/C(PixelFormat) colorDepth, /*1Aa*/int refreshRate, /*1Aa*/C(bool) * textMode)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, screenMode);
         Interface_screenMode_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_screenMode_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(bool)fullScreen, /*3Hd*/(Resolution)resolution, /*3Hd*/(PixelFormat)colorDepth, /*3Kd*/refreshRate, /*3Fd*/textMode); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(bool) fullScreen, /*1Aa*/C(Resolution) resolution, /*1Aa*/C(PixelFormat) colorDepth, /*1Aa*/int refreshRate, /*1Aa*/C(bool) * textMode))(CO(Interface)->_vTbl)[M_VTBLID(Interface, screenMode)]);
            if(method) return method (fullScreen, resolution, colorDepth, refreshRate, textMode);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "SetCaret", (void *) +[](/*1Aa*/int caretX, /*1Aa*/int caretY, /*1Aa*/int size)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setCaret);
         Interface_setCaret_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setCaret_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/caretX, /*3Kd*/caretY, /*3Kd*/size);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/int caretX, /*1Aa*/int caretY, /*1Aa*/int size))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setCaret)]);
            if(method) return method (caretX, caretY, size);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetIcon", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/C(BitmapResource) icon)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setIcon);
         Interface_setIcon_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setIcon_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); /*2Bg*/TIH<BitmapResource> icon_l(icon); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*window_l, /*3Bd*/*icon_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) window, /*1Aa*/C(BitmapResource) icon))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setIcon)]);
            if(method) return method (window, icon);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "SetMouseCapture", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setMouseCapture);
         Interface_setMouseCapture_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setMouseCapture_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setMouseCapture)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetMouseCursor", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/C(SystemCursor) cursor)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setMouseCursor);
         Interface_setMouseCursor_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setMouseCursor_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Hd*/(SystemCursor)cursor);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/C(SystemCursor) cursor))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setMouseCursor)]);
            if(method) return method (window, cursor);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetMousePosition", (void *) +[](/*1Aa*/int x, /*1Aa*/int y)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setMousePosition);
         Interface_setMousePosition_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setMousePosition_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/x, /*3Kd*/y);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/int x, /*1Aa*/int y))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setMousePosition)]);
            if(method) return method (x, y);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetMouseRange", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/C(Box) * box)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setMouseRange);
         Interface_setMouseRange_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setMouseRange_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Id*/*(Box *)box);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/C(Box) * box))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setMouseRange)]);
            if(method) return method (window, box);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetRootWindowCaption", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/const char * name)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setRootWindowCaption);
         Interface_setRootWindowCaption_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setRootWindowCaption_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Kd*/name);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/const char * name))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setRootWindowCaption)]);
            if(method) return method (window, name);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetRootWindowColor", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setRootWindowColor);
         Interface_setRootWindowColor_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setRootWindowColor_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setRootWindowColor)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetRootWindowState", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/C(WindowState) state, /*1Aa*/C(bool) visible)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setRootWindowState);
         Interface_setRootWindowState_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setRootWindowState_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Hd*/(WindowState)state, /*3Hd*/(bool)visible);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/C(WindowState) state, /*1Aa*/C(bool) visible))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setRootWindowState)]);
            if(method) return method (window, state, visible);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetTimerResolution", (void *) +[](/*1Aa*/uint hertz)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, setTimerResolution);
         Interface_setTimerResolution_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_setTimerResolution_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/hertz);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/uint hertz))(CO(Interface)->_vTbl)[M_VTBLID(Interface, setTimerResolution)]);
            if(method) return method (hertz);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "StartMoving", (void *) +[](/*1Aa*/C(Window) window, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(bool) fromKeyBoard)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, startMoving);
         Interface_startMoving_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_startMoving_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(bool)fromKeyBoard);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(bool) fromKeyBoard))(CO(Interface)->_vTbl)[M_VTBLID(Interface, startMoving)]);
            if(method) return method (window, x, y, fromKeyBoard);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "StopMoving", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, stopMoving);
         Interface_stopMoving_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_stopMoving_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, stopMoving)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Terminate", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, terminate);
         Interface_terminate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_terminate_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) ())(CO(Interface)->_vTbl)[M_VTBLID(Interface, terminate)]);
            if(method) return method ();
         }
         return ;
      });


      addMethod(_cpp_class.impl, "UnloadClipboard", (void *) +[](/*1Aa*/C(ClipBoard) * clipBoard)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, unloadClipboard);
         Interface_unloadClipboard_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_unloadClipboard_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/ClipBoard clipBoard_l(clipBoard); fn(*i, /*3Cd*/clipBoard_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(ClipBoard) * clipBoard))(CO(Interface)->_vTbl)[M_VTBLID(Interface, unloadClipboard)]);
            if(method) return method (clipBoard);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Unlock", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, unlock);
         Interface_unlock_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_unlock_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, unlock)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "UpdateRootWindow", (void *) +[](/*1Aa*/C(Window) window)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, updateRootWindow);
         Interface_updateRootWindow_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_updateRootWindow_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> window_l(window); fn(*i, /*3Bd*/*window_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) window))(CO(Interface)->_vTbl)[M_VTBLID(Interface, updateRootWindow)]);
            if(method) return method (window);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Wait", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Interface * i = ((C(Instance))null) ? (Interface *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Interface, wait);
         Interface_wait_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Interface_wait_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) ())(CO(Interface)->_vTbl)[M_VTBLID(Interface, wait)]);
            if(method) return method ();
         }
         return ;
      });


}
   MouseButtons::MouseButtons(bool left, bool right, bool middle)
   {
      impl = MOUSEBUTTONS(left, right, middle);
   }
void Skin::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "CaptionFont", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, captionFont);
         Skin_captionFont_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_captionFont_Functor::FunctionType) i->vTbl[vid];
            FontResource * ret = fn(*i); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(FontResource) (*) ())(CO(Skin)->_vTbl)[M_VTBLID(Skin, captionFont)]);
            if(method) return method ();
         }
         return (C(FontResource))null;
      });


      addMethod(_cpp_class.impl, "CursorsBitmaps", (void *) +[](/*1Aa*/uint id, /*1Aa*/int * hotSpotX, /*1Aa*/int * hotSpotY, /*1Aa*/byte ** paletteShades)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, cursorsBitmaps);
         Skin_cursorsBitmaps_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_cursorsBitmaps_Functor::FunctionType) i->vTbl[vid];
            const char * ret = fn(*i, /*3Kd*/id, /*3Kd*/hotSpotX, /*3Kd*/hotSpotY, /*3Kd*/paletteShades); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((const char * (*) (/*1Aa*/uint id, /*1Aa*/int * hotSpotX, /*1Aa*/int * hotSpotY, /*1Aa*/byte ** paletteShades))(CO(Skin)->_vTbl)[M_VTBLID(Skin, cursorsBitmaps)]);
            if(method) return method (id, hotSpotX, hotSpotY, paletteShades);
         }
         return (const char *)null;
      });


      addMethod(_cpp_class.impl, "GetBitmap", (void *) +[](/*1Aa*/C(SkinBitmap) ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, getBitmap);
         Skin_getBitmap_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_getBitmap_Functor::FunctionType) i->vTbl[vid];
            BitmapResource * ret = fn(*i, /*3Hd*/(SkinBitmap)ap1); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(BitmapResource) (*) (/*1Aa*/C(SkinBitmap) ap1))(CO(Skin)->_vTbl)[M_VTBLID(Skin, getBitmap)]);
            if(method) return method (ap1);
         }
         return (C(BitmapResource))null;
      });


      addMethod(_cpp_class.impl, "GetDecorationsSize", (void *) +[](/*1Aa*/C(Window) ap1, /*1Aa*/C(MinMaxValue) * ap2, /*1Aa*/C(MinMaxValue) * ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, getDecorationsSize);
         Skin_getDecorationsSize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_getDecorationsSize_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Hd*/(MinMaxValue *)ap2, /*3Hd*/(MinMaxValue *)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) ap1, /*1Aa*/C(MinMaxValue) * ap2, /*1Aa*/C(MinMaxValue) * ap3))(CO(Skin)->_vTbl)[M_VTBLID(Skin, getDecorationsSize)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "HorizontalSBH", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, horizontalSBH);
         Skin_horizontalSBH_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_horizontalSBH_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) ())(CO(Skin)->_vTbl)[M_VTBLID(Skin, horizontalSBH)]);
            if(method) return method ();
         }
         return (int)1;
      });


      addMethod(_cpp_class.impl, "IsMouseMoving", (void *) +[](/*1Aa*/C(Window) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/int ap5)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, isMouseMoving);
         Skin_isMouseMoving_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_isMouseMoving_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> ap1_l(ap1); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Kd*/ap2, /*3Kd*/ap3, /*3Kd*/ap4, /*3Kd*/ap5); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/int ap5))(CO(Skin)->_vTbl)[M_VTBLID(Skin, isMouseMoving)]);
            if(method) return method (ap1, ap2, ap3, ap4, ap5);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "IsMouseResizing", (void *) +[](/*1Aa*/C(Window) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/int ap5, /*1Aa*/C(bool) * ap6, /*1Aa*/C(bool) * ap7, /*1Aa*/C(bool) * ap8, /*1Aa*/C(bool) * ap9)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, isMouseResizing);
         Skin_isMouseResizing_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_isMouseResizing_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> ap1_l(ap1); C(bool) ret = (C(bool))fn(*i, /*3Bd*/*ap1_l, /*3Kd*/ap2, /*3Kd*/ap3, /*3Kd*/ap4, /*3Kd*/ap5, /*3Fd*/ap6, /*3Fd*/ap7, /*3Fd*/ap8, /*3Fd*/ap9); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) ap1, /*1Aa*/int ap2, /*1Aa*/int ap3, /*1Aa*/int ap4, /*1Aa*/int ap5, /*1Aa*/C(bool) * ap6, /*1Aa*/C(bool) * ap7, /*1Aa*/C(bool) * ap8, /*1Aa*/C(bool) * ap9))(CO(Skin)->_vTbl)[M_VTBLID(Skin, isMouseResizing)]);
            if(method) return method (ap1, ap2, ap3, ap4, ap5, ap6, ap7, ap8, ap9);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "SetWindowArea", (void *) +[](/*1Aa*/C(Window) ap1, /*1Aa*/int * ap2, /*1Aa*/int * ap3, /*1Aa*/C(MinMaxValue) * ap4, /*1Aa*/C(MinMaxValue) * ap5, /*1Aa*/C(MinMaxValue) * ap6, /*1Aa*/C(MinMaxValue) * ap7)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, setWindowArea);
         Skin_setWindowArea_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_setWindowArea_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Kd*/ap2, /*3Kd*/ap3, /*3Hd*/(MinMaxValue *)ap4, /*3Hd*/(MinMaxValue *)ap5, /*3Hd*/(MinMaxValue *)ap6, /*3Hd*/(MinMaxValue *)ap7);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) ap1, /*1Aa*/int * ap2, /*1Aa*/int * ap3, /*1Aa*/C(MinMaxValue) * ap4, /*1Aa*/C(MinMaxValue) * ap5, /*1Aa*/C(MinMaxValue) * ap6, /*1Aa*/C(MinMaxValue) * ap7))(CO(Skin)->_vTbl)[M_VTBLID(Skin, setWindowArea)]);
            if(method) return method (ap1, ap2, ap3, ap4, ap5, ap6, ap7);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetWindowMinimum", (void *) +[](/*1Aa*/C(Window) ap1, /*1Aa*/C(MinMaxValue) * ap2, /*1Aa*/C(MinMaxValue) * ap3)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, setWindowMinimum);
         Skin_setWindowMinimum_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_setWindowMinimum_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> ap1_l(ap1); fn(*i, /*3Bd*/*ap1_l, /*3Hd*/(MinMaxValue *)ap2, /*3Hd*/(MinMaxValue *)ap3);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) ap1, /*1Aa*/C(MinMaxValue) * ap2, /*1Aa*/C(MinMaxValue) * ap3))(CO(Skin)->_vTbl)[M_VTBLID(Skin, setWindowMinimum)]);
            if(method) return method (ap1, ap2, ap3);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "ShowDecorations", (void *) +[](/*1Aa*/void * ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Window) ap3, /*1Aa*/const char * ap4, /*1Aa*/C(bool) ap5, /*1Aa*/C(bool) ap6)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, showDecorations);
         Skin_showDecorations_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_showDecorations_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Surface> ap2_l(ap2); /*2Bg*/TIH<Window> ap3_l(ap3); fn(*i, /*3Kd*/ap1, /*3Bd*/*ap2_l, /*3Bd*/*ap3_l, /*3Kd*/ap4, /*3Hd*/(bool)ap5, /*3Hd*/(bool)ap6);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/void * ap1, /*1Aa*/C(Surface) ap2, /*1Aa*/C(Window) ap3, /*1Aa*/const char * ap4, /*1Aa*/C(bool) ap5, /*1Aa*/C(bool) ap6))(CO(Skin)->_vTbl)[M_VTBLID(Skin, showDecorations)]);
            if(method) return method (ap1, ap2, ap3, ap4, ap5, ap6);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SystemFont", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, systemFont);
         Skin_systemFont_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_systemFont_Functor::FunctionType) i->vTbl[vid];
            FontResource * ret = fn(*i); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(FontResource) (*) ())(CO(Skin)->_vTbl)[M_VTBLID(Skin, systemFont)]);
            if(method) return method ();
         }
         return (C(FontResource))null;
      });


      addMethod(_cpp_class.impl, "UpdateNonClient", (void *) +[](/*1Aa*/void * ap1)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, updateNonClient);
         Skin_updateNonClient_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_updateNonClient_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/ap1);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/void * ap1))(CO(Skin)->_vTbl)[M_VTBLID(Skin, updateNonClient)]);
            if(method) return method (ap1);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "VerticalSBW", (void *) +[]()
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         Skin * i = ((C(Instance))null) ? (Skin *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(Skin, verticalSBW);
         Skin_verticalSBW_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Skin_verticalSBW_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) ())(CO(Skin)->_vTbl)[M_VTBLID(Skin, verticalSBW)]);
            if(method) return method ();
         }
         return (int)1;
      });


}
   SmartKey::SmartKey(KeyCode code, bool shift, bool ctrl, bool alt, Modifiers & modifiers)
   {
      impl = SMARTKEY(code, shift, ctrl, alt, modifiers);
   }
void Timer::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "DelayExpired", (void *) +[](/*1Aa*/any_object o_)
      {
         Timer * i = (Timer *)o_;
         // 'cp1' is empty
         int vid = M_VTBLID(Timer, delayExpired);
         Timer_delayExpired_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Timer_delayExpired_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(i->_userData); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/any_object o_))(CO(Timer)->_vTbl)[M_VTBLID(Timer, delayExpired)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


}
void Window::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "GetDecorationsSize", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(MinMaxValue) * w, /*1Aa*/C(MinMaxValue) * h)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, getDecorationsSize);
         Window_getDecorationsSize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_getDecorationsSize_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Hd*/(MinMaxValue *)w, /*3Hd*/(MinMaxValue *)h);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(MinMaxValue) * w, /*1Aa*/C(MinMaxValue) * h))(CO(Window)->_vTbl)[M_VTBLID(Window, getDecorationsSize)]);
            if(method) return method (o_, w, h);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "IsInside", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, isInside);
         Window_isInside_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_isInside_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y))(CO(Window)->_vTbl)[M_VTBLID(Window, isInside)]);
            if(method) return method (o_, x, y);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "IsMouseMoving", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, isMouseMoving);
         Window_isMouseMoving_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_isMouseMoving_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Kd*/w, /*3Kd*/h); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h))(CO(Window)->_vTbl)[M_VTBLID(Window, isMouseMoving)]);
            if(method) return method (o_, x, y, w, h);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "IsMouseResizing", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/C(bool) * resizeX, /*1Aa*/C(bool) * resizeY, /*1Aa*/C(bool) * resizeEndX, /*1Aa*/C(bool) * resizeEndY)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, isMouseResizing);
         Window_isMouseResizing_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_isMouseResizing_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Kd*/w, /*3Kd*/h, /*3Fd*/resizeX, /*3Fd*/resizeY, /*3Fd*/resizeEndX, /*3Fd*/resizeEndY); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h, /*1Aa*/C(bool) * resizeX, /*1Aa*/C(bool) * resizeY, /*1Aa*/C(bool) * resizeEndX, /*1Aa*/C(bool) * resizeEndY))(CO(Window)->_vTbl)[M_VTBLID(Window, isMouseResizing)]);
            if(method) return method (o_, x, y, w, h, resizeX, resizeY, resizeEndX, resizeEndY);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "IsOpaque", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, isOpaque);
         Window_isOpaque_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_isOpaque_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, isOpaque)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyActivate", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Window) window, /*1Aa*/C(bool) active, /*1Aa*/C(Window) previous)
      {
         XClass * cl = (window) ? (XClass *)(window)->_class : null;
         // 'cp1' is empty
         Window * i = (window) ? (Window *)INSTANCEL(window, cl) : null;
         int vid = M_VTBLID(Window, notifyActivate);
         Window_notifyActivate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_notifyActivate_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Window> window_l(window); /*2Bg*/TIH<Window> previous_l(previous); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*window_l, /*3Hd*/(bool)active, /*3Bd*/*previous_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Window) window, /*1Aa*/C(bool) active, /*1Aa*/C(Window) previous))(CO(Window)->_vTbl)[M_VTBLID(Window, notifyActivate)]);
            if(method) return method (o_, window, active, previous);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyDestroyed", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Window) window, /*1Aa*/C(DialogResult) result)
      {
         XClass * cl = (window) ? (XClass *)(window)->_class : null;
         // 'cp1' is empty
         Window * i = (window) ? (Window *)INSTANCEL(window, cl) : null;
         int vid = M_VTBLID(Window, notifyDestroyed);
         Window_notifyDestroyed_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_notifyDestroyed_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Window> window_l(window); fn(/*3Bd*/*o__l, /*3Bd*/*window_l, /*3Hd*/(DialogResult)result);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Window) window, /*1Aa*/C(DialogResult) result))(CO(Window)->_vTbl)[M_VTBLID(Window, notifyDestroyed)]);
            if(method) return method (o_, window, result);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "NotifySaved", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Window) window, /*1Aa*/const char * filePath)
      {
         XClass * cl = (window) ? (XClass *)(window)->_class : null;
         // 'cp1' is empty
         Window * i = (window) ? (Window *)INSTANCEL(window, cl) : null;
         int vid = M_VTBLID(Window, notifySaved);
         Window_notifySaved_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_notifySaved_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Window> window_l(window); fn(/*3Bd*/*o__l, /*3Bd*/*window_l, /*3Kd*/filePath);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Window) window, /*1Aa*/const char * filePath))(CO(Window)->_vTbl)[M_VTBLID(Window, notifySaved)]);
            if(method) return method (o_, window, filePath);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnActivate", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(bool) active, /*1Aa*/C(Window) previous, /*1Aa*/C(bool) * goOnWithActivation, /*1Aa*/C(bool) direct)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onActivate);
         Window_onActivate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onActivate_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> previous_l(previous); C(bool) ret = (C(bool))fn(*i, /*3Hd*/(bool)active, /*3Bd*/*previous_l, /*3Fd*/goOnWithActivation, /*3Hd*/(bool)direct); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(bool) active, /*1Aa*/C(Window) previous, /*1Aa*/C(bool) * goOnWithActivation, /*1Aa*/C(bool) direct))(CO(Window)->_vTbl)[M_VTBLID(Window, onActivate)]);
            if(method) return method (o_, active, previous, goOnWithActivation, direct);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnActivateClient", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Window) client, /*1Aa*/C(Window) previous)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onActivateClient);
         Window_onActivateClient_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onActivateClient_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> client_l(client); /*2Bg*/TIH<Window> previous_l(previous); fn(*i, /*3Bd*/*client_l, /*3Bd*/*previous_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Window) client, /*1Aa*/C(Window) previous))(CO(Window)->_vTbl)[M_VTBLID(Window, onActivateClient)]);
            if(method) return method (o_, client, previous);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnApplyGraphics", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onApplyGraphics);
         Window_onApplyGraphics_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onApplyGraphics_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onApplyGraphics)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnChildAddedOrRemoved", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Window) child, /*1Aa*/C(bool) removed)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onChildAddedOrRemoved);
         Window_onChildAddedOrRemoved_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onChildAddedOrRemoved_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> child_l(child); fn(*i, /*3Bd*/*child_l, /*3Hd*/(bool)removed);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Window) child, /*1Aa*/C(bool) removed))(CO(Window)->_vTbl)[M_VTBLID(Window, onChildAddedOrRemoved)]);
            if(method) return method (o_, child, removed);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnChildResized", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Window) child, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onChildResized);
         Window_onChildResized_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onChildResized_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> child_l(child); fn(*i, /*3Bd*/*child_l, /*3Kd*/x, /*3Kd*/y, /*3Kd*/w, /*3Kd*/h);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Window) child, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int w, /*1Aa*/int h))(CO(Window)->_vTbl)[M_VTBLID(Window, onChildResized)]);
            if(method) return method (o_, child, x, y, w, h);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnChildVisibilityToggled", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Window) child, /*1Aa*/C(bool) visible)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onChildVisibilityToggled);
         Window_onChildVisibilityToggled_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onChildVisibilityToggled_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> child_l(child); fn(*i, /*3Bd*/*child_l, /*3Hd*/(bool)visible);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Window) child, /*1Aa*/C(bool) visible))(CO(Window)->_vTbl)[M_VTBLID(Window, onChildVisibilityToggled)]);
            if(method) return method (o_, child, visible);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnClose", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(bool) parentClosing)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onClose);
         Window_onClose_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onClose_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(bool)parentClosing); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(bool) parentClosing))(CO(Window)->_vTbl)[M_VTBLID(Window, onClose)]);
            if(method) return method (o_, parentClosing);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnCreate", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onCreate);
         Window_onCreate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onCreate_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onCreate)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnDestroy", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onDestroy);
         Window_onDestroy_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onDestroy_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onDestroy)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnDestroyed", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onDestroyed);
         Window_onDestroyed_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onDestroyed_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onDestroyed)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnDrawOverChildren", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Surface) surface)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onDrawOverChildren);
         Window_onDrawOverChildren_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onDrawOverChildren_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Surface> surface_l(surface); fn(*i, /*3Bd*/*surface_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Surface) surface))(CO(Window)->_vTbl)[M_VTBLID(Window, onDrawOverChildren)]);
            if(method) return method (o_, surface);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnFileModified", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(FileChange) fileChange, /*1Aa*/const char * param)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onFileModified);
         Window_onFileModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onFileModified_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(FileChange)fileChange, /*3Kd*/param); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(FileChange) fileChange, /*1Aa*/const char * param))(CO(Window)->_vTbl)[M_VTBLID(Window, onFileModified)]);
            if(method) return method (o_, fileChange, param);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnHScroll", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ScrollBarAction) action, /*1Aa*/int position, /*1Aa*/C(Key) key)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onHScroll);
         Window_onHScroll_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onHScroll_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Hd*/(ScrollBarAction)action, /*3Kd*/position, /*3Hd*/(Key)key);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ScrollBarAction) action, /*1Aa*/int position, /*1Aa*/C(Key) key))(CO(Window)->_vTbl)[M_VTBLID(Window, onHScroll)]);
            if(method) return method (o_, action, position, key);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnKeyDown", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onKeyDown);
         Window_onKeyDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onKeyDown_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(Window)->_vTbl)[M_VTBLID(Window, onKeyDown)]);
            if(method) return method (o_, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnKeyHit", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onKeyHit);
         Window_onKeyHit_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onKeyHit_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(Window)->_vTbl)[M_VTBLID(Window, onKeyHit)]);
            if(method) return method (o_, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnKeyUp", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onKeyUp);
         Window_onKeyUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onKeyUp_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(Window)->_vTbl)[M_VTBLID(Window, onKeyUp)]);
            if(method) return method (o_, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLeftButtonDown", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onLeftButtonDown);
         Window_onLeftButtonDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onLeftButtonDown_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onLeftButtonDown)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLeftButtonUp", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onLeftButtonUp);
         Window_onLeftButtonUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onLeftButtonUp_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onLeftButtonUp)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLeftDoubleClick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onLeftDoubleClick);
         Window_onLeftDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onLeftDoubleClick_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onLeftDoubleClick)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLoadGraphics", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onLoadGraphics);
         Window_onLoadGraphics_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onLoadGraphics_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onLoadGraphics)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMiddleButtonDown", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMiddleButtonDown);
         Window_onMiddleButtonDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMiddleButtonDown_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onMiddleButtonDown)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMiddleButtonUp", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMiddleButtonUp);
         Window_onMiddleButtonUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMiddleButtonUp_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onMiddleButtonUp)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMiddleDoubleClick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMiddleDoubleClick);
         Window_onMiddleDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMiddleDoubleClick_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onMiddleDoubleClick)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMouseCaptureLost", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMouseCaptureLost);
         Window_onMouseCaptureLost_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMouseCaptureLost_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onMouseCaptureLost)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnMouseLeave", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMouseLeave);
         Window_onMouseLeave_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMouseLeave_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onMouseLeave)]);
            if(method) return method (o_, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMouseMove", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMouseMove);
         Window_onMouseMove_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMouseMove_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onMouseMove)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMouseOver", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMouseOver);
         Window_onMouseOver_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMouseOver_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onMouseOver)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMoving", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int * x, /*1Aa*/int * y, /*1Aa*/int w, /*1Aa*/int h)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMoving);
         Window_onMoving_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMoving_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Kd*/w, /*3Kd*/h); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int * x, /*1Aa*/int * y, /*1Aa*/int w, /*1Aa*/int h))(CO(Window)->_vTbl)[M_VTBLID(Window, onMoving)]);
            if(method) return method (o_, x, y, w, h);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMultiTouch", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(TouchPointerEvent) event, /*1Aa*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onMultiTouch);
         Window_onMultiTouch_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onMultiTouch_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo>> infos_l(infos); C(bool) ret = (C(bool))fn(*i, /*3Hd*/(TouchPointerEvent)event, /*3Bd*/*infos_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(TouchPointerEvent) event, /*1Aa*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onMultiTouch)]);
            if(method) return method (o_, event, infos, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnPosition", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int width, /*1Aa*/int height)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onPosition);
         Window_onPosition_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onPosition_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Kd*/width, /*3Kd*/height);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/int width, /*1Aa*/int height))(CO(Window)->_vTbl)[M_VTBLID(Window, onPosition)]);
            if(method) return method (o_, x, y, width, height);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnPostCreate", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onPostCreate);
         Window_onPostCreate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onPostCreate_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onPostCreate)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnRedraw", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Surface) surface)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onRedraw);
         Window_onRedraw_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onRedraw_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Surface> surface_l(surface); fn(*i, /*3Bd*/*surface_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Surface) surface))(CO(Window)->_vTbl)[M_VTBLID(Window, onRedraw)]);
            if(method) return method (o_, surface);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnResize", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int width, /*1Aa*/int height)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onResize);
         Window_onResize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onResize_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/width, /*3Kd*/height);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/int width, /*1Aa*/int height))(CO(Window)->_vTbl)[M_VTBLID(Window, onResize)]);
            if(method) return method (o_, width, height);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnResizing", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int * width, /*1Aa*/int * height)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onResizing);
         Window_onResizing_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onResizing_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/width, /*3Kd*/height); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int * width, /*1Aa*/int * height))(CO(Window)->_vTbl)[M_VTBLID(Window, onResizing)]);
            if(method) return method (o_, width, height);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnRightButtonDown", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onRightButtonDown);
         Window_onRightButtonDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onRightButtonDown_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onRightButtonDown)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnRightButtonUp", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onRightButtonUp);
         Window_onRightButtonUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onRightButtonUp_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onRightButtonUp)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnRightDoubleClick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onRightDoubleClick);
         Window_onRightDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onRightDoubleClick_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onRightDoubleClick)]);
            if(method) return method (o_, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnSaveFile", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/const char * fileName)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onSaveFile);
         Window_onSaveFile_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onSaveFile_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/fileName); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/const char * fileName))(CO(Window)->_vTbl)[M_VTBLID(Window, onSaveFile)]);
            if(method) return method (o_, fileName);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnStateChange", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(WindowState) state, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onStateChange);
         Window_onStateChange_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onStateChange_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(WindowState)state, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(WindowState) state, /*1Aa*/C(Modifiers) mods))(CO(Window)->_vTbl)[M_VTBLID(Window, onStateChange)]);
            if(method) return method (o_, state, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnSysKeyDown", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onSysKeyDown);
         Window_onSysKeyDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onSysKeyDown_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(Window)->_vTbl)[M_VTBLID(Window, onSysKeyDown)]);
            if(method) return method (o_, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnSysKeyHit", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onSysKeyHit);
         Window_onSysKeyHit_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onSysKeyHit_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(Window)->_vTbl)[M_VTBLID(Window, onSysKeyHit)]);
            if(method) return method (o_, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnSysKeyUp", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onSysKeyUp);
         Window_onSysKeyUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onSysKeyUp_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(Window)->_vTbl)[M_VTBLID(Window, onSysKeyUp)]);
            if(method) return method (o_, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnUnloadGraphics", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onUnloadGraphics);
         Window_onUnloadGraphics_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onUnloadGraphics_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, onUnloadGraphics)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnVScroll", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ScrollBarAction) action, /*1Aa*/int position, /*1Aa*/C(Key) key)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, onVScroll);
         Window_onVScroll_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_onVScroll_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Hd*/(ScrollBarAction)action, /*3Kd*/position, /*3Hd*/(Key)key);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ScrollBarAction) action, /*1Aa*/int position, /*1Aa*/C(Key) key))(CO(Window)->_vTbl)[M_VTBLID(Window, onVScroll)]);
            if(method) return method (o_, action, position, key);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "PreShowDecorations", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Font) * captionFont, /*1Aa*/C(Surface) surface, /*1Aa*/const char * name, /*1Aa*/C(bool) active, /*1Aa*/C(bool) moving)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, preShowDecorations);
         Window_preShowDecorations_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_preShowDecorations_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/Font captionFont_l(captionFont); /*2Bg*/TIH<Surface> surface_l(surface); fn(*i, /*3Cd*/captionFont_l, /*3Bd*/*surface_l, /*3Kd*/name, /*3Hd*/(bool)active, /*3Hd*/(bool)moving);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Font) * captionFont, /*1Aa*/C(Surface) surface, /*1Aa*/const char * name, /*1Aa*/C(bool) active, /*1Aa*/C(bool) moving))(CO(Window)->_vTbl)[M_VTBLID(Window, preShowDecorations)]);
            if(method) return method (o_, captionFont, surface, name, active, moving);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetBox", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Box) * box)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, setBox);
         Window_setBox_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_setBox_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Id*/*(Box *)box);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Box) * box))(CO(Window)->_vTbl)[M_VTBLID(Window, setBox)]);
            if(method) return method (o_, box);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetWindowArea", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/int * x, /*1Aa*/int * y, /*1Aa*/C(MinMaxValue) * w, /*1Aa*/C(MinMaxValue) * h, /*1Aa*/C(MinMaxValue) * cw, /*1Aa*/C(MinMaxValue) * ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, setWindowArea);
         Window_setWindowArea_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_setWindowArea_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(MinMaxValue *)w, /*3Hd*/(MinMaxValue *)h, /*3Hd*/(MinMaxValue *)cw, /*3Hd*/(MinMaxValue *)ch);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/int * x, /*1Aa*/int * y, /*1Aa*/C(MinMaxValue) * w, /*1Aa*/C(MinMaxValue) * h, /*1Aa*/C(MinMaxValue) * cw, /*1Aa*/C(MinMaxValue) * ch))(CO(Window)->_vTbl)[M_VTBLID(Window, setWindowArea)]);
            if(method) return method (o_, x, y, w, h, cw, ch);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetWindowMinimum", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(MinMaxValue) * mw, /*1Aa*/C(MinMaxValue) * mh)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, setWindowMinimum);
         Window_setWindowMinimum_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_setWindowMinimum_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Hd*/(MinMaxValue *)mw, /*3Hd*/(MinMaxValue *)mh);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(MinMaxValue) * mw, /*1Aa*/C(MinMaxValue) * mh))(CO(Window)->_vTbl)[M_VTBLID(Window, setWindowMinimum)]);
            if(method) return method (o_, mw, mh);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "ShowDecorations", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Font) * captionFont, /*1Aa*/C(Surface) surface, /*1Aa*/const char * name, /*1Aa*/C(bool) active, /*1Aa*/C(bool) moving)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, showDecorations);
         Window_showDecorations_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_showDecorations_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/Font captionFont_l(captionFont); /*2Bg*/TIH<Surface> surface_l(surface); fn(*i, /*3Cd*/captionFont_l, /*3Bd*/*surface_l, /*3Kd*/name, /*3Hd*/(bool)active, /*3Hd*/(bool)moving);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Font) * captionFont, /*1Aa*/C(Surface) surface, /*1Aa*/const char * name, /*1Aa*/C(bool) active, /*1Aa*/C(bool) moving))(CO(Window)->_vTbl)[M_VTBLID(Window, showDecorations)]);
            if(method) return method (o_, captionFont, surface, name, active, moving);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "UpdateNonClient", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Window * i = (o_) ? (Window *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Window, updateNonClient);
         Window_updateNonClient_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Window_updateNonClient_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_))(CO(Window)->_vTbl)[M_VTBLID(Window, updateNonClient)]);
            if(method) return method (o_);
         }
         return ;
      });


}
void WindowController::class_registration(CPPClass & _cpp_class)
{
}

////////////////////////////////////////// [ecere]/ecere::gui::controls //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////

void Button::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyClicked", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         Button * i = (button) ? (Button *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(Button, notifyClicked);
         Button_notifyClicked_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Button_notifyClicked_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Button> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Button)->_vTbl)[M_VTBLID(Button, notifyClicked)]);
            if(method) return method (o_, button, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyDoubleClick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         Button * i = (button) ? (Button *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(Button, notifyDoubleClick);
         Button_notifyDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Button_notifyDoubleClick_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Button> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Button)->_vTbl)[M_VTBLID(Button, notifyDoubleClick)]);
            if(method) return method (o_, button, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyMouseLeave", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         Button * i = (button) ? (Button *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(Button, notifyMouseLeave);
         Button_notifyMouseLeave_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Button_notifyMouseLeave_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Button> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/C(Modifiers) mods))(CO(Button)->_vTbl)[M_VTBLID(Button, notifyMouseLeave)]);
            if(method) return method (o_, button, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyMouseMove", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         Button * i = (button) ? (Button *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(Button, notifyMouseMove);
         Button_notifyMouseMove_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Button_notifyMouseMove_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Button> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Button)->_vTbl)[M_VTBLID(Button, notifyMouseMove)]);
            if(method) return method (o_, button, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyMouseOver", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         Button * i = (button) ? (Button *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(Button, notifyMouseOver);
         Button_notifyMouseOver_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Button_notifyMouseOver_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Button> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Button)->_vTbl)[M_VTBLID(Button, notifyMouseOver)]);
            if(method) return method (o_, button, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyPushed", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         Button * i = (button) ? (Button *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(Button, notifyPushed);
         Button_notifyPushed_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Button_notifyPushed_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Button> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Button)->_vTbl)[M_VTBLID(Button, notifyPushed)]);
            if(method) return method (o_, button, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyReleased", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         Button * i = (button) ? (Button *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(Button, notifyReleased);
         Button_notifyReleased_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Button_notifyReleased_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<Button> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(Button) button, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(Button)->_vTbl)[M_VTBLID(Button, notifyReleased)]);
            if(method) return method (o_, button, x, y, mods);
         }
         return (C(bool))1;
      });


}
void CalendarControl::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyChanged", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(CalendarControl) calendarControl, /*1Aa*/C(bool) close)
      {
         XClass * cl = (calendarControl) ? (XClass *)(calendarControl)->_class : null;
         // 'cp1' is empty
         CalendarControl * i = (calendarControl) ? (CalendarControl *)INSTANCEL(calendarControl, cl) : null;
         int vid = M_VTBLID(CalendarControl, notifyChanged);
         CalendarControl_notifyChanged_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (CalendarControl_notifyChanged_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<CalendarControl> calendarControl_l(calendarControl); fn(/*3Bd*/*o__l, /*3Bd*/*calendarControl_l, /*3Hd*/(bool)close);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(CalendarControl) calendarControl, /*1Aa*/C(bool) close))(CO(CalendarControl)->_vTbl)[M_VTBLID(CalendarControl, notifyChanged)]);
            if(method) return method (o_, calendarControl, close);
         }
         return ;
      });


}
void DataBox::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyChanged", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(DataBox) dataBox, /*1Aa*/C(bool) closingDropDown)
      {
         XClass * cl = (dataBox) ? (XClass *)(dataBox)->_class : null;
         // 'cp1' is empty
         DataBox * i = (dataBox) ? (DataBox *)INSTANCEL(dataBox, cl) : null;
         int vid = M_VTBLID(DataBox, notifyChanged);
         DataBox_notifyChanged_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DataBox_notifyChanged_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<DataBox> dataBox_l(dataBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*dataBox_l, /*3Hd*/(bool)closingDropDown); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(DataBox) dataBox, /*1Aa*/C(bool) closingDropDown))(CO(DataBox)->_vTbl)[M_VTBLID(DataBox, notifyChanged)]);
            if(method) return method (o_, dataBox, closingDropDown);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyModified", (void *) +[](/*1Aa*/C(Window) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DataBox * i = (o_) ? (DataBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DataBox, notifyModified);
         DataBox_notifyModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DataBox_notifyModified_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_))(CO(DataBox)->_vTbl)[M_VTBLID(DataBox, notifyModified)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnConfigure", (void *) +[](/*1Aa*/C(DataBox) o_, /*1Aa*/C(Window) editor)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DataBox * i = (o_) ? (DataBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DataBox, onConfigure);
         DataBox_onConfigure_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DataBox_onConfigure_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> editor_l(editor); fn(*i, /*3Bd*/*editor_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DataBox) o_, /*1Aa*/C(Window) editor))(CO(DataBox)->_vTbl)[M_VTBLID(DataBox, onConfigure)]);
            if(method) return method (o_, editor);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetData", (void *) +[](/*1Aa*/C(DataBox) o_, /*1Aa*/any_object newData, /*1Aa*/C(bool) closingDropDown)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DataBox * i = (o_) ? (DataBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DataBox, setData);
         DataBox_setData_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DataBox_setData_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/newData, /*3Hd*/(bool)closingDropDown);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DataBox) o_, /*1Aa*/any_object newData, /*1Aa*/C(bool) closingDropDown))(CO(DataBox)->_vTbl)[M_VTBLID(DataBox, setData)]);
            if(method) return method (o_, newData, closingDropDown);
         }
         return ;
      });


}
void DataField::class_registration(CPPClass & _cpp_class)
{
}
void DataRow::class_registration(CPPClass & _cpp_class)
{
}
void DirectoriesBox::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyModified", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(DirectoriesBox) dirsBox)
      {
         XClass * cl = (dirsBox) ? (XClass *)(dirsBox)->_class : null;
         // 'cp1' is empty
         DirectoriesBox * i = (dirsBox) ? (DirectoriesBox *)INSTANCEL(dirsBox, cl) : null;
         int vid = M_VTBLID(DirectoriesBox, notifyModified);
         DirectoriesBox_notifyModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DirectoriesBox_notifyModified_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<DirectoriesBox> dirsBox_l(dirsBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*dirsBox_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(DirectoriesBox) dirsBox))(CO(DirectoriesBox)->_vTbl)[M_VTBLID(DirectoriesBox, notifyModified)]);
            if(method) return method (o_, dirsBox);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyPathBoxModified", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(DirectoriesBox) dirsBox, /*1Aa*/C(PathBox) pathBox)
      {
         XClass * cl = (dirsBox) ? (XClass *)(dirsBox)->_class : null;
         // 'cp1' is empty
         DirectoriesBox * i = (dirsBox) ? (DirectoriesBox *)INSTANCEL(dirsBox, cl) : null;
         int vid = M_VTBLID(DirectoriesBox, notifyPathBoxModified);
         DirectoriesBox_notifyPathBoxModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DirectoriesBox_notifyPathBoxModified_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<DirectoriesBox> dirsBox_l(dirsBox); /*2Bg*/TIH<PathBox> pathBox_l(pathBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*dirsBox_l, /*3Bd*/*pathBox_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(DirectoriesBox) dirsBox, /*1Aa*/C(PathBox) pathBox))(CO(DirectoriesBox)->_vTbl)[M_VTBLID(DirectoriesBox, notifyPathBoxModified)]);
            if(method) return method (o_, dirsBox, pathBox);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnBrowsedDir", (void *) +[](/*1Aa*/C(DirectoriesBox) o_, /*1Aa*/char ** directory)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DirectoriesBox * i = (o_) ? (DirectoriesBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DirectoriesBox, onBrowsedDir);
         DirectoriesBox_onBrowsedDir_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DirectoriesBox_onBrowsedDir_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/directory); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DirectoriesBox) o_, /*1Aa*/char ** directory))(CO(DirectoriesBox)->_vTbl)[M_VTBLID(DirectoriesBox, onBrowsedDir)]);
            if(method) return method (o_, directory);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnChangedDir", (void *) +[](/*1Aa*/C(DirectoriesBox) o_, /*1Aa*/char ** directory)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DirectoriesBox * i = (o_) ? (DirectoriesBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DirectoriesBox, onChangedDir);
         DirectoriesBox_onChangedDir_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DirectoriesBox_onChangedDir_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/directory); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DirectoriesBox) o_, /*1Aa*/char ** directory))(CO(DirectoriesBox)->_vTbl)[M_VTBLID(DirectoriesBox, onChangedDir)]);
            if(method) return method (o_, directory);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnPrepareBrowseDir", (void *) +[](/*1Aa*/C(DirectoriesBox) o_, /*1Aa*/char ** directory)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DirectoriesBox * i = (o_) ? (DirectoriesBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DirectoriesBox, onPrepareBrowseDir);
         DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/directory); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(DirectoriesBox) o_, /*1Aa*/char ** directory))(CO(DirectoriesBox)->_vTbl)[M_VTBLID(DirectoriesBox, onPrepareBrowseDir)]);
            if(method) return method (o_, directory);
         }
         return (C(bool))1;
      });


}
void DropBox::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyClose", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox)
      {
         XClass * cl = (dropBox) ? (XClass *)(dropBox)->_class : null;
         // 'cp1' is empty
         DropBox * i = (dropBox) ? (DropBox *)INSTANCEL(dropBox, cl) : null;
         int vid = M_VTBLID(DropBox, notifyClose);
         DropBox_notifyClose_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DropBox_notifyClose_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<DropBox> dropBox_l(dropBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*dropBox_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox))(CO(DropBox)->_vTbl)[M_VTBLID(DropBox, notifyClose)]);
            if(method) return method (o_, dropBox);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyHighlight", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (dropBox) ? (XClass *)(dropBox)->_class : null;
         // 'cp1' is empty
         DropBox * i = (dropBox) ? (DropBox *)INSTANCEL(dropBox, cl) : null;
         int vid = M_VTBLID(DropBox, notifyHighlight);
         DropBox_notifyHighlight_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DropBox_notifyHighlight_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<DropBox> dropBox_l(dropBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*dropBox_l, /*3Bd*/*row_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods))(CO(DropBox)->_vTbl)[M_VTBLID(DropBox, notifyHighlight)]);
            if(method) return method (o_, dropBox, row, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifySelect", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (dropBox) ? (XClass *)(dropBox)->_class : null;
         // 'cp1' is empty
         DropBox * i = (dropBox) ? (DropBox *)INSTANCEL(dropBox, cl) : null;
         int vid = M_VTBLID(DropBox, notifySelect);
         DropBox_notifySelect_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DropBox_notifySelect_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<DropBox> dropBox_l(dropBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*dropBox_l, /*3Bd*/*row_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods))(CO(DropBox)->_vTbl)[M_VTBLID(DropBox, notifySelect)]);
            if(method) return method (o_, dropBox, row, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyTextEntry", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox, /*1Aa*/const char * string, /*1Aa*/C(bool) confirmed)
      {
         XClass * cl = (dropBox) ? (XClass *)(dropBox)->_class : null;
         // 'cp1' is empty
         DropBox * i = (dropBox) ? (DropBox *)INSTANCEL(dropBox, cl) : null;
         int vid = M_VTBLID(DropBox, notifyTextEntry);
         DropBox_notifyTextEntry_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DropBox_notifyTextEntry_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<DropBox> dropBox_l(dropBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*dropBox_l, /*3Kd*/string, /*3Hd*/(bool)confirmed); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(DropBox) dropBox, /*1Aa*/const char * string, /*1Aa*/C(bool) confirmed))(CO(DropBox)->_vTbl)[M_VTBLID(DropBox, notifyTextEntry)]);
            if(method) return method (o_, dropBox, string, confirmed);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnCloseDropDown", (void *) +[](/*1Aa*/C(DropBox) o_, /*1Aa*/C(Window) pullDown)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DropBox * i = (o_) ? (DropBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DropBox, onCloseDropDown);
         DropBox_onCloseDropDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DropBox_onCloseDropDown_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> pullDown_l(pullDown); fn(*i, /*3Bd*/*pullDown_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DropBox) o_, /*1Aa*/C(Window) pullDown))(CO(DropBox)->_vTbl)[M_VTBLID(DropBox, onCloseDropDown)]);
            if(method) return method (o_, pullDown);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnDropDown", (void *) +[](/*1Aa*/C(DropBox) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DropBox * i = (o_) ? (DropBox *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DropBox, onDropDown);
         DropBox_onDropDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DropBox_onDropDown_Functor::FunctionType) i->vTbl[vid];
            Window * ret = fn(*i); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(Window) (*) (/*1Aa*/C(DropBox) o_))(CO(DropBox)->_vTbl)[M_VTBLID(DropBox, onDropDown)]);
            if(method) return method (o_);
         }
         return (C(Window))null;
      });


}
void EditBox::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyCaretMove", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/int line, /*1Aa*/int charPos)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyCaretMove);
         EditBox_notifyCaretMove_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyCaretMove_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l, /*3Kd*/line, /*3Kd*/charPos);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/int line, /*1Aa*/int charPos))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyCaretMove)]);
            if(method) return method (o_, editBox, line, charPos);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "NotifyCharsAdded", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(BufferLocation) * before, /*1Aa*/C(BufferLocation) * after, /*1Aa*/C(bool) pasteOperation)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyCharsAdded);
         EditBox_notifyCharsAdded_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyCharsAdded_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l, /*3Id*/*(BufferLocation *)before, /*3Id*/*(BufferLocation *)after, /*3Hd*/(bool)pasteOperation); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(BufferLocation) * before, /*1Aa*/C(BufferLocation) * after, /*1Aa*/C(bool) pasteOperation))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyCharsAdded)]);
            if(method) return method (o_, editBox, before, after, pasteOperation);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyCharsDeleted", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(BufferLocation) * beforeLoc, /*1Aa*/C(BufferLocation) * after, /*1Aa*/C(bool) pasteOperation)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyCharsDeleted);
         EditBox_notifyCharsDeleted_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyCharsDeleted_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l, /*3Id*/*(BufferLocation *)beforeLoc, /*3Id*/*(BufferLocation *)after, /*3Hd*/(bool)pasteOperation); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(BufferLocation) * beforeLoc, /*1Aa*/C(BufferLocation) * after, /*1Aa*/C(bool) pasteOperation))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyCharsDeleted)]);
            if(method) return method (o_, editBox, beforeLoc, after, pasteOperation);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyDoubleClick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(EditLine) * line, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyDoubleClick);
         EditBox_notifyDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyDoubleClick_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); /*2Cg*/EditLine line_l(line); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l, /*3Cd*/line_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(EditLine) * line, /*1Aa*/C(Modifiers) mods))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyDoubleClick)]);
            if(method) return method (o_, editBox, line, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyDropped", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/int x, /*1Aa*/int y)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyDropped);
         EditBox_notifyDropped_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyDropped_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l, /*3Kd*/x, /*3Kd*/y); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/int x, /*1Aa*/int y))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyDropped)]);
            if(method) return method (o_, editBox, x, y);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyKeyDown", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyKeyDown);
         EditBox_notifyKeyDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyKeyDown_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyKeyDown)]);
            if(method) return method (o_, editBox, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyModified", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyModified);
         EditBox_notifyModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyModified_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyModified)]);
            if(method) return method (o_, editBox);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyOvrToggle", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(bool) overwrite)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyOvrToggle);
         EditBox_notifyOvrToggle_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyOvrToggle_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l, /*3Hd*/(bool)overwrite);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox, /*1Aa*/C(bool) overwrite))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyOvrToggle)]);
            if(method) return method (o_, editBox, overwrite);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "NotifyUnsetModified", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyUnsetModified);
         EditBox_notifyUnsetModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyUnsetModified_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyUnsetModified)]);
            if(method) return method (o_, editBox);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyUpdate", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox)
      {
         XClass * cl = (editBox) ? (XClass *)(editBox)->_class : null;
         // 'cp1' is empty
         EditBox * i = (editBox) ? (EditBox *)INSTANCEL(editBox, cl) : null;
         int vid = M_VTBLID(EditBox, notifyUpdate);
         EditBox_notifyUpdate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditBox_notifyUpdate_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditBox> editBox_l(editBox); fn(/*3Bd*/*o__l, /*3Bd*/*editBox_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditBox) editBox))(CO(EditBox)->_vTbl)[M_VTBLID(EditBox, notifyUpdate)]);
            if(method) return method (o_, editBox);
         }
         return ;
      });


}
void EditBoxStream::class_registration(CPPClass & _cpp_class)
{
}
void EditSyntaxHL::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "CanImpactOtherLines", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/C(EditLine) * line)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, canImpactOtherLines);
         EditSyntaxHL_canImpactOtherLines_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_canImpactOtherLines_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/EditLine line_l(line); C(bool) ret = (C(bool))fn(*i, /*3Cd*/line_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/C(EditLine) * line))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, canImpactOtherLines)]);
            if(method) return method (o_, line);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "FigureStartSyntaxStates", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/C(EditLine) * firstLine, /*1Aa*/C(bool) reset, /*1Aa*/C(EditLine) * viewLine)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, figureStartSyntaxStates);
         EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/EditLine firstLine_l(firstLine); /*2Cg*/EditLine viewLine_l(viewLine); fn(*i, /*3Cd*/firstLine_l, /*3Hd*/(bool)reset, /*3Cd*/viewLine_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/C(EditLine) * firstLine, /*1Aa*/C(bool) reset, /*1Aa*/C(EditLine) * viewLine))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, figureStartSyntaxStates)]);
            if(method) return method (o_, firstLine, reset, viewLine);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "GotSpace", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/C(bool) beforeEnd)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, gotSpace);
         EditSyntaxHL_gotSpace_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_gotSpace_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Hd*/(bool)beforeEnd);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/C(bool) beforeEnd))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, gotSpace)]);
            if(method) return method (o_, beforeEnd);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "InitDraw", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, initDraw);
         EditSyntaxHL_initDraw_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_initDraw_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(EditSyntaxHL) o_))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, initDraw)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "NextLine", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/char * buffer, /*1Aa*/int count)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, nextLine);
         EditSyntaxHL_nextLine_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_nextLine_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/buffer, /*3Kd*/count);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/char * buffer, /*1Aa*/int count))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, nextLine)]);
            if(method) return method (o_, buffer, count);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "ParseWord", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/char * buffer, /*1Aa*/int count, /*1Aa*/int wordLen)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, parseWord);
         EditSyntaxHL_parseWord_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_parseWord_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i, /*3Kd*/buffer, /*3Kd*/count, /*3Kd*/wordLen); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) (/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/char * buffer, /*1Aa*/int count, /*1Aa*/int wordLen))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, parseWord)]);
            if(method) return method (o_, buffer, count, wordLen);
         }
         return (int)1;
      });


      addMethod(_cpp_class.impl, "Process", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/char * word, /*1Aa*/int * wordLen, /*1Aa*/C(bool) beforeEndOfLine, /*1Aa*/C(Color) defaultTextColor, /*1Aa*/const char * buffer, /*1Aa*/int * ap1)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, process);
         EditSyntaxHL_process_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_process_Functor::FunctionType) i->vTbl[vid];
            C(Color) ret = fn(*i, /*3Kd*/word, /*3Kd*/wordLen, /*3Hd*/(bool)beforeEndOfLine, /*3Hd*/(Color)defaultTextColor, /*3Kd*/buffer, /*3Kd*/ap1); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(Color) (*) (/*1Aa*/C(EditSyntaxHL) o_, /*1Aa*/char * word, /*1Aa*/int * wordLen, /*1Aa*/C(bool) beforeEndOfLine, /*1Aa*/C(Color) defaultTextColor, /*1Aa*/const char * buffer, /*1Aa*/int * ap1))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, process)]);
            if(method) return method (o_, word, wordLen, beforeEndOfLine, defaultTextColor, buffer, ap1);
         }
         return (C(Color))1;
      });


      addMethod(_cpp_class.impl, "ResetState", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, resetState);
         EditSyntaxHL_resetState_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_resetState_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(EditSyntaxHL) o_))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, resetState)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "StartLine", (void *) +[](/*1Aa*/C(EditSyntaxHL) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         EditSyntaxHL * i = (o_) ? (EditSyntaxHL *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(EditSyntaxHL, startLine);
         EditSyntaxHL_startLine_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditSyntaxHL_startLine_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(EditSyntaxHL) o_))(CO(EditSyntaxHL)->_vTbl)[M_VTBLID(EditSyntaxHL, startLine)]);
            if(method) return method (o_);
         }
         return ;
      });


}
void EditableSelectorButton::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "OnRename", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(EditableSelectorButton) button, /*1Aa*/char ** oldName, /*1Aa*/char ** newName)
      {
         XClass * cl = (button) ? (XClass *)(button)->_class : null;
         // 'cp1' is empty
         EditableSelectorButton * i = (button) ? (EditableSelectorButton *)INSTANCEL(button, cl) : null;
         int vid = M_VTBLID(EditableSelectorButton, onRename);
         EditableSelectorButton_onRename_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (EditableSelectorButton_onRename_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<EditableSelectorButton> button_l(button); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*button_l, /*3Kd*/oldName, /*3Kd*/newName); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(EditableSelectorButton) button, /*1Aa*/char ** oldName, /*1Aa*/char ** newName))(CO(EditableSelectorButton)->_vTbl)[M_VTBLID(EditableSelectorButton, onRename)]);
            if(method) return method (o_, button, oldName, newName);
         }
         return (C(bool))1;
      });


}
void Label::class_registration(CPPClass & _cpp_class)
{
}
void ListBox::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyChanged", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyChanged);
         ListBox_notifyChanged_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyChanged_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyChanged)]);
            if(method) return method (o_, listBox, row);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyCollapse", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(bool) collapsed)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyCollapse);
         ListBox_notifyCollapse_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyCollapse_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(bool)collapsed); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(bool) collapsed))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyCollapse)]);
            if(method) return method (o_, listBox, row, collapsed);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyDoubleClick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyDoubleClick);
         ListBox_notifyDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyDoubleClick_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyDoubleClick)]);
            if(method) return method (o_, listBox, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyEditDone", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyEditDone);
         ListBox_notifyEditDone_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyEditDone_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyEditDone)]);
            if(method) return method (o_, listBox, row);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyEdited", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyEdited);
         ListBox_notifyEdited_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyEdited_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyEdited)]);
            if(method) return method (o_, listBox, row);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyEditing", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyEditing);
         ListBox_notifyEditing_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyEditing_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyEditing)]);
            if(method) return method (o_, listBox, row);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyHighlight", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyHighlight);
         ListBox_notifyHighlight_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyHighlight_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyHighlight)]);
            if(method) return method (o_, listBox, row, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyKeyDown", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyKeyDown);
         ListBox_notifyKeyDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyKeyDown_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyKeyDown)]);
            if(method) return method (o_, listBox, row, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyKeyHit", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyKeyHit);
         ListBox_notifyKeyHit_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyKeyHit_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyKeyHit)]);
            if(method) return method (o_, listBox, row, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyModified", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyModified);
         ListBox_notifyModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyModified_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyModified)]);
            if(method) return method (o_, listBox, row);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyMove", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyMove);
         ListBox_notifyMove_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyMove_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyMove)]);
            if(method) return method (o_, listBox, row, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyMoved", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyMoved);
         ListBox_notifyMoved_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyMoved_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(Modifiers)mods);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyMoved)]);
            if(method) return method (o_, listBox, row, mods);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "NotifyMovedField", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataField) field, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyMovedField);
         ListBox_notifyMovedField_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyMovedField_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataField> field_l(field); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*field_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataField) field, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyMovedField)]);
            if(method) return method (o_, listBox, field, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyReclick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyReclick);
         ListBox_notifyReclick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyReclick_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyReclick)]);
            if(method) return method (o_, listBox, row, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyResized", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataField) field, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyResized);
         ListBox_notifyResized_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyResized_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataField> field_l(field); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*field_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataField) field, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyResized)]);
            if(method) return method (o_, listBox, field, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifyRightClick", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifyRightClick);
         ListBox_notifyRightClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifyRightClick_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifyRightClick)]);
            if(method) return method (o_, listBox, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifySelect", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifySelect);
         ListBox_notifySelect_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifySelect_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataRow> row_l(row); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*row_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataRow) row, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifySelect)]);
            if(method) return method (o_, listBox, row, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "NotifySort", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataField) field, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (listBox) ? (XClass *)(listBox)->_class : null;
         // 'cp1' is empty
         ListBox * i = (listBox) ? (ListBox *)INSTANCEL(listBox, cl) : null;
         int vid = M_VTBLID(ListBox, notifySort);
         ListBox_notifySort_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ListBox_notifySort_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ListBox> listBox_l(listBox); /*2Bg*/TIH<DataField> field_l(field); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*listBox_l, /*3Bd*/*field_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ListBox) listBox, /*1Aa*/C(DataField) field, /*1Aa*/C(Modifiers) mods))(CO(ListBox)->_vTbl)[M_VTBLID(ListBox, notifySort)]);
            if(method) return method (o_, listBox, field, mods);
         }
         return (C(bool))1;
      });


}
void Menu::class_registration(CPPClass & _cpp_class)
{
}
void MenuDivider::class_registration(CPPClass & _cpp_class)
{
}
void MenuItem::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifySelect", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(MenuItem) selection, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (selection) ? (XClass *)(selection)->_class : null;
         // 'cp1' is empty
         MenuItem * i = (selection) ? (MenuItem *)INSTANCEL(selection, cl) : null;
         int vid = M_VTBLID(MenuItem, notifySelect);
         MenuItem_notifySelect_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (MenuItem_notifySelect_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<MenuItem> selection_l(selection); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*selection_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(MenuItem) selection, /*1Aa*/C(Modifiers) mods))(CO(MenuItem)->_vTbl)[M_VTBLID(MenuItem, notifySelect)]);
            if(method) return method (o_, selection, mods);
         }
         return (C(bool))1;
      });


}
void MenuPlacement::class_registration(CPPClass & _cpp_class)
{
}
void OldArray::class_registration(CPPClass & _cpp_class)
{
}
void PaneSplitter::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyResized", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(PaneSplitter) splitter)
      {
         XClass * cl = (splitter) ? (XClass *)(splitter)->_class : null;
         // 'cp1' is empty
         PaneSplitter * i = (splitter) ? (PaneSplitter *)INSTANCEL(splitter, cl) : null;
         int vid = M_VTBLID(PaneSplitter, notifyResized);
         PaneSplitter_notifyResized_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (PaneSplitter_notifyResized_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<PaneSplitter> splitter_l(splitter); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*splitter_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(PaneSplitter) splitter))(CO(PaneSplitter)->_vTbl)[M_VTBLID(PaneSplitter, notifyResized)]);
            if(method) return method (o_, splitter);
         }
         return (C(bool))1;
      });


}
void PathBox::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyModified", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(PathBox) pathBox)
      {
         XClass * cl = (pathBox) ? (XClass *)(pathBox)->_class : null;
         // 'cp1' is empty
         PathBox * i = (pathBox) ? (PathBox *)INSTANCEL(pathBox, cl) : null;
         int vid = M_VTBLID(PathBox, notifyModified);
         PathBox_notifyModified_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (PathBox_notifyModified_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<PathBox> pathBox_l(pathBox); C(bool) ret = (C(bool))fn(/*3Bd*/*o__l, /*3Bd*/*pathBox_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(PathBox) pathBox))(CO(PathBox)->_vTbl)[M_VTBLID(PathBox, notifyModified)]);
            if(method) return method (o_, pathBox);
         }
         return (C(bool))1;
      });


}
void Picture::class_registration(CPPClass & _cpp_class)
{
}
void PopupMenu::class_registration(CPPClass & _cpp_class)
{
}
void ProgressBar::class_registration(CPPClass & _cpp_class)
{
}
void SavingDataBox::class_registration(CPPClass & _cpp_class)
{
}
void ScrollBar::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "NotifyScrolling", (void *) +[](/*1Aa*/C(Window) o_, /*1Aa*/C(ScrollBar) scrollBar, /*1Aa*/C(ScrollBarAction) action, /*1Aa*/int position, /*1Aa*/C(Key) key)
      {
         XClass * cl = (scrollBar) ? (XClass *)(scrollBar)->_class : null;
         // 'cp1' is empty
         ScrollBar * i = (scrollBar) ? (ScrollBar *)INSTANCEL(scrollBar, cl) : null;
         int vid = M_VTBLID(ScrollBar, notifyScrolling);
         ScrollBar_notifyScrolling_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ScrollBar_notifyScrolling_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<Window> o__l(o_); /*2Bg*/TIH<ScrollBar> scrollBar_l(scrollBar); fn(/*3Bd*/*o__l, /*3Bd*/*scrollBar_l, /*3Hd*/(ScrollBarAction)action, /*3Kd*/position, /*3Hd*/(Key)key);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Window) o_, /*1Aa*/C(ScrollBar) scrollBar, /*1Aa*/C(ScrollBarAction) action, /*1Aa*/int position, /*1Aa*/C(Key) key))(CO(ScrollBar)->_vTbl)[M_VTBLID(ScrollBar, notifyScrolling)]);
            if(method) return method (o_, scrollBar, action, position, key);
         }
         return ;
      });


}
void SelectorBar::class_registration(CPPClass & _cpp_class)
{
}
void SelectorButton::class_registration(CPPClass & _cpp_class)
{
}
void Stacker::class_registration(CPPClass & _cpp_class)
{
}
void StatusBar::class_registration(CPPClass & _cpp_class)
{
}
void StatusField::class_registration(CPPClass & _cpp_class)
{
}
void Tab::class_registration(CPPClass & _cpp_class)
{
}
void TabControl::class_registration(CPPClass & _cpp_class)
{
}
void ToolBar::class_registration(CPPClass & _cpp_class)
{
}
void ToolButton::class_registration(CPPClass & _cpp_class)
{
}
void ToolSeparator::class_registration(CPPClass & _cpp_class)
{
}
void ToolTip::class_registration(CPPClass & _cpp_class)
{
}
void UndoBuffer::class_registration(CPPClass & _cpp_class)
{
}

/////////////////////////////////////////// [ecere]/ecere::gui::dialogs //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////

void ColorPicker::class_registration(CPPClass & _cpp_class)
{
}
void CreateDirectoryDialog::class_registration(CPPClass & _cpp_class)
{
}
void FileDialog::class_registration(CPPClass & _cpp_class)
{
}
void FindDialog::class_registration(CPPClass & _cpp_class)
{
}
void GoToDialog::class_registration(CPPClass & _cpp_class)
{
}
void MessageBox::class_registration(CPPClass & _cpp_class)
{
}
void ReplaceDialog::class_registration(CPPClass & _cpp_class)
{
}
void WindowList::class_registration(CPPClass & _cpp_class)
{
}

///////////////////////////////////////////// [ecere]/ecere::gui::skins //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////

void TVisionSkin_Window::class_registration(CPPClass & _cpp_class)
{
}
void WindowsSkin_Button::class_registration(CPPClass & _cpp_class)
{
}
void WindowsSkin_Window::class_registration(CPPClass & _cpp_class)
{
}

//////////////////////////////////////////////////// [ecere]/ecere::net //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////

void DCOMClientObject::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "CallVirtualMethod", (void *) +[](/*1Aa*/C(DCOMClientObject) o_, /*1Aa*/uint __ecereMethodID, /*1Aa*/C(SerialBuffer) __ecereBuffer)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DCOMClientObject * i = (o_) ? (DCOMClientObject *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DCOMClientObject, callVirtualMethod);
         DCOMClientObject_callVirtualMethod_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DCOMClientObject_callVirtualMethod_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<SerialBuffer> __ecereBuffer_l(__ecereBuffer); fn(*i, /*3Kd*/__ecereMethodID, /*3Bd*/*__ecereBuffer_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DCOMClientObject) o_, /*1Aa*/uint __ecereMethodID, /*1Aa*/C(SerialBuffer) __ecereBuffer))(CO(DCOMClientObject)->_vTbl)[M_VTBLID(DCOMClientObject, callVirtualMethod)]);
            if(method) return method (o_, __ecereMethodID, __ecereBuffer);
         }
         return ;
      });


}
void DCOMSendControl::class_registration(CPPClass & _cpp_class)
{
}
void DCOMServerObject::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "CallMethod", (void *) +[](/*1Aa*/C(DCOMServerObject) o_, /*1Aa*/uint __ecereMethodID, /*1Aa*/C(SerialBuffer) __ecereBuffer)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         DCOMServerObject * i = (o_) ? (DCOMServerObject *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(DCOMServerObject, callMethod);
         DCOMServerObject_callMethod_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (DCOMServerObject_callMethod_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<SerialBuffer> __ecereBuffer_l(__ecereBuffer); fn(*i, /*3Kd*/__ecereMethodID, /*3Bd*/*__ecereBuffer_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(DCOMServerObject) o_, /*1Aa*/uint __ecereMethodID, /*1Aa*/C(SerialBuffer) __ecereBuffer))(CO(DCOMServerObject)->_vTbl)[M_VTBLID(DCOMServerObject, callMethod)]);
            if(method) return method (o_, __ecereMethodID, __ecereBuffer);
         }
         return ;
      });


}
void DCOMServerSocket::class_registration(CPPClass & _cpp_class)
{
}
void DCOMService::class_registration(CPPClass & _cpp_class)
{
}
void FileServerConnection::class_registration(CPPClass & _cpp_class)
{
}
void HTTPFile::class_registration(CPPClass & _cpp_class)
{
}
void NetworkClientFile::class_registration(CPPClass & _cpp_class)
{
}
void SSLSocket::class_registration(CPPClass & _cpp_class)
{
}
void Service::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "OnAccept", (void *) +[](/*1Aa*/C(Service) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Service * i = (o_) ? (Service *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Service, onAccept);
         Service_onAccept_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Service_onAccept_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Service) o_))(CO(Service)->_vTbl)[M_VTBLID(Service, onAccept)]);
            if(method) return method (o_);
         }
         return ;
      });


}
void Socket::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "OnConnect", (void *) +[](/*1Aa*/C(Socket) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Socket * i = (o_) ? (Socket *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Socket, onConnect);
         Socket_onConnect_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Socket_onConnect_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Socket) o_))(CO(Socket)->_vTbl)[M_VTBLID(Socket, onConnect)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnDisconnect", (void *) +[](/*1Aa*/C(Socket) o_, /*1Aa*/int code)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Socket * i = (o_) ? (Socket *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Socket, onDisconnect);
         Socket_onDisconnect_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Socket_onDisconnect_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/code);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Socket) o_, /*1Aa*/int code))(CO(Socket)->_vTbl)[M_VTBLID(Socket, onDisconnect)]);
            if(method) return method (o_, code);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnEstablishConnection", (void *) +[](/*1Aa*/C(Socket) o_, /*1Aa*/int s)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Socket * i = (o_) ? (Socket *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Socket, onEstablishConnection);
         Socket_onEstablishConnection_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Socket_onEstablishConnection_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/s); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Socket) o_, /*1Aa*/int s))(CO(Socket)->_vTbl)[M_VTBLID(Socket, onEstablishConnection)]);
            if(method) return method (o_, s);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnReceive", (void *) +[](/*1Aa*/C(Socket) o_, /*1Aa*/const byte * buffer, /*1Aa*/uint count)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Socket * i = (o_) ? (Socket *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Socket, onReceive);
         Socket_onReceive_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Socket_onReceive_Functor::FunctionType) i->vTbl[vid];
            uint ret = fn(*i, /*3Kd*/buffer, /*3Kd*/count); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uint (*) (/*1Aa*/C(Socket) o_, /*1Aa*/const byte * buffer, /*1Aa*/uint count))(CO(Socket)->_vTbl)[M_VTBLID(Socket, onReceive)]);
            if(method) return method (o_, buffer, count);
         }
         return (uint)1;
      });


      addMethod(_cpp_class.impl, "OnReceivePacket", (void *) +[](/*1Aa*/C(Socket) o_, /*1Aa*/C(Packet) * packet)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Socket * i = (o_) ? (Socket *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Socket, onReceivePacket);
         Socket_onReceivePacket_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Socket_onReceivePacket_Functor::FunctionType) i->vTbl[vid];
            /*2Cg*/Packet packet_l(packet); fn(*i, /*3Cd*/packet_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Socket) o_, /*1Aa*/C(Packet) * packet))(CO(Socket)->_vTbl)[M_VTBLID(Socket, onReceivePacket)]);
            if(method) return method (o_, packet);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "ReceiveData", (void *) +[](/*1Aa*/C(Socket) o_, /*1Aa*/byte * buffer, /*1Aa*/int count, /*1Aa*/uint flags)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Socket * i = (o_) ? (Socket *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Socket, receiveData);
         Socket_receiveData_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Socket_receiveData_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i, /*3Kd*/buffer, /*3Kd*/count, /*3Kd*/flags); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) (/*1Aa*/C(Socket) o_, /*1Aa*/byte * buffer, /*1Aa*/int count, /*1Aa*/uint flags))(CO(Socket)->_vTbl)[M_VTBLID(Socket, receiveData)]);
            if(method) return method (o_, buffer, count, flags);
         }
         return (int)1;
      });


      addMethod(_cpp_class.impl, "SendData", (void *) +[](/*1Aa*/C(Socket) o_, /*1Aa*/const byte * buffer, /*1Aa*/int count, /*1Aa*/uint flags)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Socket * i = (o_) ? (Socket *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Socket, sendData);
         Socket_sendData_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Socket_sendData_Functor::FunctionType) i->vTbl[vid];
            int ret = fn(*i, /*3Kd*/buffer, /*3Kd*/count, /*3Kd*/flags); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((int (*) (/*1Aa*/C(Socket) o_, /*1Aa*/const byte * buffer, /*1Aa*/int count, /*1Aa*/uint flags))(CO(Socket)->_vTbl)[M_VTBLID(Socket, sendData)]);
            if(method) return method (o_, buffer, count, flags);
         }
         return (int)1;
      });


}

//////////////////////////////////////////////////// [ecere]/ecere::sys //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


#undef AnyFileChange
FileChange AnyFileChange = FileChange { true, true, true, true, true };

void Archive::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "Clear", (void *) +[](/*1Aa*/C(Archive) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, clear);
         Archive_clear_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_clear_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(Archive) o_))(CO(Archive)->_vTbl)[M_VTBLID(Archive, clear)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "FileExists", (void *) +[](/*1Aa*/C(Archive) o_, /*1Aa*/const char * fileName)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, fileExists);
         Archive_fileExists_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_fileExists_Functor::FunctionType) i->vTbl[vid];
            C(FileAttribs) ret = fn(*i, /*3Kd*/fileName); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(FileAttribs) (*) (/*1Aa*/C(Archive) o_, /*1Aa*/const char * fileName))(CO(Archive)->_vTbl)[M_VTBLID(Archive, fileExists)]);
            if(method) return method (o_, fileName);
         }
         return (C(FileAttribs))1;
      });


      addMethod(_cpp_class.impl, "FileOpen", (void *) +[](/*1Aa*/C(Archive) o_, /*1Aa*/const char * fileName)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, fileOpen);
         Archive_fileOpen_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_fileOpen_Functor::FunctionType) i->vTbl[vid];
            File * ret = fn(*i, /*3Kd*/fileName); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(File) (*) (/*1Aa*/C(Archive) o_, /*1Aa*/const char * fileName))(CO(Archive)->_vTbl)[M_VTBLID(Archive, fileOpen)]);
            if(method) return method (o_, fileName);
         }
         return (C(File))null;
      });


      addMethod(_cpp_class.impl, "FileOpenAtPosition", (void *) +[](/*1Aa*/C(Archive) o_, /*1Aa*/uint position)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, fileOpenAtPosition);
         Archive_fileOpenAtPosition_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_fileOpenAtPosition_Functor::FunctionType) i->vTbl[vid];
            File * ret = fn(*i, /*3Kd*/position); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(File) (*) (/*1Aa*/C(Archive) o_, /*1Aa*/uint position))(CO(Archive)->_vTbl)[M_VTBLID(Archive, fileOpenAtPosition)]);
            if(method) return method (o_, position);
         }
         return (C(File))null;
      });


      addMethod(_cpp_class.impl, "FileOpenCompressed", (void *) +[](/*1Aa*/C(Archive) o_, /*1Aa*/const char * fileName, /*1Aa*/C(bool) * isCompressed, /*1Aa*/uint64 * ucSize)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, fileOpenCompressed);
         Archive_fileOpenCompressed_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_fileOpenCompressed_Functor::FunctionType) i->vTbl[vid];
            File * ret = fn(*i, /*3Kd*/fileName, /*3Fd*/isCompressed, /*3Kd*/ucSize); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(File) (*) (/*1Aa*/C(Archive) o_, /*1Aa*/const char * fileName, /*1Aa*/C(bool) * isCompressed, /*1Aa*/uint64 * ucSize))(CO(Archive)->_vTbl)[M_VTBLID(Archive, fileOpenCompressed)]);
            if(method) return method (o_, fileName, isCompressed, ucSize);
         }
         return (C(File))null;
      });


      addMethod(_cpp_class.impl, "OpenDirectory", (void *) +[](/*1Aa*/C(Archive) o_, /*1Aa*/const char * name, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, openDirectory);
         Archive_openDirectory_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_openDirectory_Functor::FunctionType) i->vTbl[vid];
            ArchiveDir * ret = fn(*i, /*3Kd*/name, /*3Id*/*(FileStats *)stats, /*3Hd*/(ArchiveAddMode)addMode); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(ArchiveDir) (*) (/*1Aa*/C(Archive) o_, /*1Aa*/const char * name, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode))(CO(Archive)->_vTbl)[M_VTBLID(Archive, openDirectory)]);
            if(method) return method (o_, name, stats, addMode);
         }
         return (C(ArchiveDir))null;
      });


      addMethod(_cpp_class.impl, "SetBufferRead", (void *) +[](/*1Aa*/C(Archive) o_, /*1Aa*/uint bufferRead)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, setBufferRead);
         Archive_setBufferRead_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_setBufferRead_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/bufferRead);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Archive) o_, /*1Aa*/uint bufferRead))(CO(Archive)->_vTbl)[M_VTBLID(Archive, setBufferRead)]);
            if(method) return method (o_, bufferRead);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "SetBufferSize", (void *) +[](/*1Aa*/C(Archive) o_, /*1Aa*/uint bufferSize)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Archive * i = (o_) ? (Archive *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Archive, setBufferSize);
         Archive_setBufferSize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Archive_setBufferSize_Functor::FunctionType) i->vTbl[vid];
            fn(*i, /*3Kd*/bufferSize);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(Archive) o_, /*1Aa*/uint bufferSize))(CO(Archive)->_vTbl)[M_VTBLID(Archive, setBufferSize)]);
            if(method) return method (o_, bufferSize);
         }
         return ;
      });


}
void ArchiveDir::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "AddFromFile", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/C(File) input, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode, /*1Aa*/int compression, /*1Aa*/int * ratio, /*1Aa*/uint * newPosition)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, addFromFile);
         ArchiveDir_addFromFile_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_addFromFile_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<File> input_l(input); C(bool) ret = (C(bool))fn(*i, /*3Kd*/name, /*3Bd*/*input_l, /*3Id*/*(FileStats *)stats, /*3Hd*/(ArchiveAddMode)addMode, /*3Kd*/compression, /*3Kd*/ratio, /*3Kd*/newPosition); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/C(File) input, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode, /*1Aa*/int compression, /*1Aa*/int * ratio, /*1Aa*/uint * newPosition))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, addFromFile)]);
            if(method) return method (o_, name, input, stats, addMode, compression, ratio, newPosition);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "AddFromFileAtPosition", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/uint position, /*1Aa*/const char * name, /*1Aa*/C(File) input, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode, /*1Aa*/int compression, /*1Aa*/int * ratio, /*1Aa*/uint * newPosition)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, addFromFileAtPosition);
         ArchiveDir_addFromFileAtPosition_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_addFromFileAtPosition_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<File> input_l(input); C(bool) ret = (C(bool))fn(*i, /*3Kd*/position, /*3Kd*/name, /*3Bd*/*input_l, /*3Id*/*(FileStats *)stats, /*3Hd*/(ArchiveAddMode)addMode, /*3Kd*/compression, /*3Kd*/ratio, /*3Kd*/newPosition); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/uint position, /*1Aa*/const char * name, /*1Aa*/C(File) input, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode, /*1Aa*/int compression, /*1Aa*/int * ratio, /*1Aa*/uint * newPosition))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, addFromFileAtPosition)]);
            if(method) return method (o_, position, name, input, stats, addMode, compression, ratio, newPosition);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Delete", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * fileName)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, delete);
         ArchiveDir_delete_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_delete_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/fileName); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * fileName))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, delete)]);
            if(method) return method (o_, fileName);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "FileExists", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * fileName)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, fileExists);
         ArchiveDir_fileExists_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_fileExists_Functor::FunctionType) i->vTbl[vid];
            C(FileAttribs) ret = fn(*i, /*3Kd*/fileName); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(FileAttribs) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * fileName))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, fileExists)]);
            if(method) return method (o_, fileName);
         }
         return (C(FileAttribs))1;
      });


      addMethod(_cpp_class.impl, "FileOpen", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * fileName)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, fileOpen);
         ArchiveDir_fileOpen_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_fileOpen_Functor::FunctionType) i->vTbl[vid];
            File * ret = fn(*i, /*3Kd*/fileName); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(File) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * fileName))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, fileOpen)]);
            if(method) return method (o_, fileName);
         }
         return (C(File))null;
      });


      addMethod(_cpp_class.impl, "Move", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/C(ArchiveDir) to)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, move);
         ArchiveDir_move_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_move_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<ArchiveDir> to_l(to); C(bool) ret = (C(bool))fn(*i, /*3Kd*/name, /*3Bd*/*to_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/C(ArchiveDir) to))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, move)]);
            if(method) return method (o_, name, to);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OpenDirectory", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, openDirectory);
         ArchiveDir_openDirectory_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_openDirectory_Functor::FunctionType) i->vTbl[vid];
            ArchiveDir * ret = fn(*i, /*3Kd*/name, /*3Id*/*(FileStats *)stats, /*3Hd*/(ArchiveAddMode)addMode); return ret->impl;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(ArchiveDir) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/C(FileStats) * stats, /*1Aa*/C(ArchiveAddMode) addMode))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, openDirectory)]);
            if(method) return method (o_, name, stats, addMode);
         }
         return (C(ArchiveDir))null;
      });


      addMethod(_cpp_class.impl, "Rename", (void *) +[](/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/const char * newName)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         ArchiveDir * i = (o_) ? (ArchiveDir *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(ArchiveDir, rename);
         ArchiveDir_rename_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (ArchiveDir_rename_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/name, /*3Kd*/newName); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(ArchiveDir) o_, /*1Aa*/const char * name, /*1Aa*/const char * newName))(CO(ArchiveDir)->_vTbl)[M_VTBLID(ArchiveDir, rename)]);
            if(method) return method (o_, name, newName);
         }
         return (C(bool))1;
      });


}
   ArchiveOpenFlags::ArchiveOpenFlags(bool writeAccess, bool buffered, bool exclusive, bool waitLock)
   {
      impl = ARCHIVEOPENFLAGS(writeAccess, buffered, exclusive, waitLock);
   }
void BufferedFile::class_registration(CPPClass & _cpp_class)
{
}
void ConsoleFile::class_registration(CPPClass & _cpp_class)
{
}
void DualPipe::class_registration(CPPClass & _cpp_class)
{
}
void ECONGlobalSettings::class_registration(CPPClass & _cpp_class)
{
}
void ECONParser::class_registration(CPPClass & _cpp_class)
{
}
   ErrorCode::ErrorCode(ErrorLevel level, uint code)
   {
      impl = ERRORCODE(level, code);
   }
void File::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "Close", (void *) +[](/*1Aa*/C(File) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, close);
         File_close_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_close_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(File) o_))(CO(File)->_vTbl)[M_VTBLID(File, close)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "CloseInput", (void *) +[](/*1Aa*/C(File) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, closeInput);
         File_closeInput_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_closeInput_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(File) o_))(CO(File)->_vTbl)[M_VTBLID(File, closeInput)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "CloseOutput", (void *) +[](/*1Aa*/C(File) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, closeOutput);
         File_closeOutput_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_closeOutput_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(File) o_))(CO(File)->_vTbl)[M_VTBLID(File, closeOutput)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Eof", (void *) +[](/*1Aa*/C(File) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, eof);
         File_eof_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_eof_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_))(CO(File)->_vTbl)[M_VTBLID(File, eof)]);
            if(method) return method (o_);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "GetSize", (void *) +[](/*1Aa*/C(File) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, getSize);
         File_getSize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_getSize_Functor::FunctionType) i->vTbl[vid];
            uint64 ret = fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uint64 (*) (/*1Aa*/C(File) o_))(CO(File)->_vTbl)[M_VTBLID(File, getSize)]);
            if(method) return method (o_);
         }
         return (uint64)1;
      });


      addMethod(_cpp_class.impl, "Getc", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/char * ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, getc);
         File_getc_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_getc_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_, /*1Aa*/char * ch))(CO(File)->_vTbl)[M_VTBLID(File, getc)]);
            if(method) return method (o_, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Lock", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/C(FileLock) type, /*1Aa*/uint64 start, /*1Aa*/uint64 length, /*1Aa*/C(bool) wait)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, lock);
         File_lock_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_lock_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Hd*/(FileLock)type, /*3Kd*/start, /*3Kd*/length, /*3Hd*/(bool)wait); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_, /*1Aa*/C(FileLock) type, /*1Aa*/uint64 start, /*1Aa*/uint64 length, /*1Aa*/C(bool) wait))(CO(File)->_vTbl)[M_VTBLID(File, lock)]);
            if(method) return method (o_, type, start, length, wait);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Putc", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/char ch)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, putc);
         File_putc_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_putc_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_, /*1Aa*/char ch))(CO(File)->_vTbl)[M_VTBLID(File, putc)]);
            if(method) return method (o_, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Puts", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/const char * string)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, puts);
         File_puts_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_puts_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/string); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_, /*1Aa*/const char * string))(CO(File)->_vTbl)[M_VTBLID(File, puts)]);
            if(method) return method (o_, string);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Read", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/void * buffer, /*1Aa*/uintsize size, /*1Aa*/uintsize count)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, read);
         File_read_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_read_Functor::FunctionType) i->vTbl[vid];
            uintsize ret = fn(*i, /*3Kd*/buffer, /*3Kd*/size, /*3Kd*/count); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uintsize (*) (/*1Aa*/C(File) o_, /*1Aa*/void * buffer, /*1Aa*/uintsize size, /*1Aa*/uintsize count))(CO(File)->_vTbl)[M_VTBLID(File, read)]);
            if(method) return method (o_, buffer, size, count);
         }
         return (uintsize)1;
      });


      addMethod(_cpp_class.impl, "Seek", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/int64 pos, /*1Aa*/C(FileSeekMode) mode)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, seek);
         File_seek_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_seek_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/pos, /*3Hd*/(FileSeekMode)mode); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_, /*1Aa*/int64 pos, /*1Aa*/C(FileSeekMode) mode))(CO(File)->_vTbl)[M_VTBLID(File, seek)]);
            if(method) return method (o_, pos, mode);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Tell", (void *) +[](/*1Aa*/C(File) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, tell);
         File_tell_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_tell_Functor::FunctionType) i->vTbl[vid];
            uint64 ret = fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uint64 (*) (/*1Aa*/C(File) o_))(CO(File)->_vTbl)[M_VTBLID(File, tell)]);
            if(method) return method (o_);
         }
         return (uint64)1;
      });


      addMethod(_cpp_class.impl, "Truncate", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/uint64 size)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, truncate);
         File_truncate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_truncate_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/size); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_, /*1Aa*/uint64 size))(CO(File)->_vTbl)[M_VTBLID(File, truncate)]);
            if(method) return method (o_, size);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Unlock", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/uint64 start, /*1Aa*/uint64 length, /*1Aa*/C(bool) wait)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, unlock);
         File_unlock_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_unlock_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(*i, /*3Kd*/start, /*3Kd*/length, /*3Hd*/(bool)wait); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/C(File) o_, /*1Aa*/uint64 start, /*1Aa*/uint64 length, /*1Aa*/C(bool) wait))(CO(File)->_vTbl)[M_VTBLID(File, unlock)]);
            if(method) return method (o_, start, length, wait);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "Write", (void *) +[](/*1Aa*/C(File) o_, /*1Aa*/const void * buffer, /*1Aa*/uintsize size, /*1Aa*/uintsize count)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         File * i = (o_) ? (File *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(File, write);
         File_write_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (File_write_Functor::FunctionType) i->vTbl[vid];
            uintsize ret = fn(*i, /*3Kd*/buffer, /*3Kd*/size, /*3Kd*/count); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uintsize (*) (/*1Aa*/C(File) o_, /*1Aa*/const void * buffer, /*1Aa*/uintsize size, /*1Aa*/uintsize count))(CO(File)->_vTbl)[M_VTBLID(File, write)]);
            if(method) return method (o_, buffer, size, count);
         }
         return (uintsize)1;
      });


}
   FileChange::FileChange(bool created, bool renamed, bool modified, bool deleted, bool attribs)
   {
      impl = FILECHANGE(created, renamed, modified, deleted, attribs);
   }
void FileMonitor::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "OnDirNotify", (void *) +[](/*1Aa*/any_object o_, /*1Aa*/C(FileChange) action, /*1Aa*/const char * fileName, /*1Aa*/const char * param)
      {
         FileMonitor * i = (FileMonitor *)o_;
         // 'cp1' is empty
         int vid = M_VTBLID(FileMonitor, onDirNotify);
         FileMonitor_onDirNotify_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FileMonitor_onDirNotify_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(i->_userData, /*3Hd*/(FileChange)action, /*3Kd*/fileName, /*3Kd*/param); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/any_object o_, /*1Aa*/C(FileChange) action, /*1Aa*/const char * fileName, /*1Aa*/const char * param))(CO(FileMonitor)->_vTbl)[M_VTBLID(FileMonitor, onDirNotify)]);
            if(method) return method (o_, action, fileName, param);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnFileNotify", (void *) +[](/*1Aa*/any_object o_, /*1Aa*/C(FileChange) action, /*1Aa*/const char * param)
      {
         FileMonitor * i = (FileMonitor *)o_;
         // 'cp1' is empty
         int vid = M_VTBLID(FileMonitor, onFileNotify);
         FileMonitor_onFileNotify_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (FileMonitor_onFileNotify_Functor::FunctionType) i->vTbl[vid];
            C(bool) ret = (C(bool))fn(i->_userData, /*3Hd*/(FileChange)action, /*3Kd*/param); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/any_object o_, /*1Aa*/C(FileChange) action, /*1Aa*/const char * param))(CO(FileMonitor)->_vTbl)[M_VTBLID(FileMonitor, onFileNotify)]);
            if(method) return method (o_, action, param);
         }
         return (C(bool))1;
      });


}
void GlobalAppSettings::class_registration(CPPClass & _cpp_class)
{
}
void GlobalSettings::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "Load", (void *) +[](/*1Aa*/C(GlobalSettings) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         GlobalSettings * i = (o_) ? (GlobalSettings *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(GlobalSettings, load);
         GlobalSettings_load_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GlobalSettings_load_Functor::FunctionType) i->vTbl[vid];
            C(SettingsIOResult) ret = (C(SettingsIOResult))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(SettingsIOResult) (*) (/*1Aa*/C(GlobalSettings) o_))(CO(GlobalSettings)->_vTbl)[M_VTBLID(GlobalSettings, load)]);
            if(method) return method (o_);
         }
         return (C(SettingsIOResult))1;
      });


      addMethod(_cpp_class.impl, "OnAskReloadSettings", (void *) +[](/*1Aa*/C(GlobalSettings) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         GlobalSettings * i = (o_) ? (GlobalSettings *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(GlobalSettings, onAskReloadSettings);
         GlobalSettings_onAskReloadSettings_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GlobalSettings_onAskReloadSettings_Functor::FunctionType) i->vTbl[vid];
            fn(*i);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/C(GlobalSettings) o_))(CO(GlobalSettings)->_vTbl)[M_VTBLID(GlobalSettings, onAskReloadSettings)]);
            if(method) return method (o_);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "Save", (void *) +[](/*1Aa*/C(GlobalSettings) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         GlobalSettings * i = (o_) ? (GlobalSettings *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(GlobalSettings, save);
         GlobalSettings_save_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GlobalSettings_save_Functor::FunctionType) i->vTbl[vid];
            C(SettingsIOResult) ret = (C(SettingsIOResult))fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(SettingsIOResult) (*) (/*1Aa*/C(GlobalSettings) o_))(CO(GlobalSettings)->_vTbl)[M_VTBLID(GlobalSettings, save)]);
            if(method) return method (o_);
         }
         return (C(SettingsIOResult))1;
      });


}
void GlobalSettingsData::class_registration(CPPClass & _cpp_class)
{
}
void GlobalSettingsDriver::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "Load", (void *) +[](/*1Aa*/C(File) f, /*1Aa*/C(GlobalSettings) globalSettings)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         GlobalSettingsDriver * i = ((C(Instance))null) ? (GlobalSettingsDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(GlobalSettingsDriver, load);
         GlobalSettingsDriver_load_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GlobalSettingsDriver_load_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<File> f_l(f); /*2Bg*/TIH<GlobalSettings> globalSettings_l(globalSettings); C(SettingsIOResult) ret = (C(SettingsIOResult))fn(*i, /*3Bd*/*f_l, /*3Bd*/*globalSettings_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(SettingsIOResult) (*) (/*1Aa*/C(File) f, /*1Aa*/C(GlobalSettings) globalSettings))(CO(GlobalSettingsDriver)->_vTbl)[M_VTBLID(GlobalSettingsDriver, load)]);
            if(method) return method (f, globalSettings);
         }
         return (C(SettingsIOResult))1;
      });


      addMethod(_cpp_class.impl, "Save", (void *) +[](/*1Aa*/C(File) f, /*1Aa*/C(GlobalSettings) globalSettings)
      {
         XClass * cl = ((C(Instance))null) ? (XClass *)((C(Instance))null)->_class : null;
         // 'cp1' is empty
         GlobalSettingsDriver * i = ((C(Instance))null) ? (GlobalSettingsDriver *)INSTANCEL((C(Instance))null, cl) : null;
         int vid = M_VTBLID(GlobalSettingsDriver, save);
         GlobalSettingsDriver_save_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (GlobalSettingsDriver_save_Functor::FunctionType) i->vTbl[vid];
            /*2Bg*/TIH<File> f_l(f); /*2Bg*/TIH<GlobalSettings> globalSettings_l(globalSettings); C(SettingsIOResult) ret = (C(SettingsIOResult))fn(*i, /*3Bd*/*f_l, /*3Bd*/*globalSettings_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(SettingsIOResult) (*) (/*1Aa*/C(File) f, /*1Aa*/C(GlobalSettings) globalSettings))(CO(GlobalSettingsDriver)->_vTbl)[M_VTBLID(GlobalSettingsDriver, save)]);
            if(method) return method (f, globalSettings);
         }
         return (C(SettingsIOResult))1;
      });


}
void JSONGlobalSettings::class_registration(CPPClass & _cpp_class)
{
}
void JSONParser::class_registration(CPPClass & _cpp_class)
{
}
   MoveFileOptions::MoveFileOptions(bool overwrite, bool sync)
   {
      impl = MOVEFILEOPTIONS(overwrite, sync);
   }
void OptionsMap::class_registration(CPPClass & _cpp_class)
{
}
   PipeOpenMode::PipeOpenMode(bool output, bool error, bool input, bool showWindow)
   {
      impl = PIPEOPENMODE(output, error, input, showWindow);
   }
void RepButton::class_registration(CPPClass & _cpp_class)
{
}
void TempFile::class_registration(CPPClass & _cpp_class)
{
}
void Thread::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "Main", (void *) +[](/*1Aa*/C(Thread) o_)
      {
         XClass * cl = (o_) ? (XClass *)(o_)->_class : null;
         // 'cp1' is empty
         Thread * i = (o_) ? (Thread *)INSTANCEL(o_, cl) : null;
         int vid = M_VTBLID(Thread, main);
         Thread_main_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (Thread_main_Functor::FunctionType) i->vTbl[vid];
            uint ret = fn(*i); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((uint (*) (/*1Aa*/C(Thread) o_))(CO(Thread)->_vTbl)[M_VTBLID(Thread, main)]);
            if(method) return method (o_);
         }
         return (uint)1;
      });


}
