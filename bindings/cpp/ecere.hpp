// Preprocessor directives can be added at the beginning (Can't store them in AST)

/****************************************************************************
===========================================================================
   ecere Module
===========================================================================
****************************************************************************/
#if !defined(__ECERE_HPP__)
#define __ECERE_HPP__

#include "eC.hpp"
#include "ecere.h"

#undef Centimeters
#undef Degrees
#undef Feet
#undef Meters
#undef Radians
#undef Seconds
#undef TimeStamp

struct FreeSpots;
struct GLArrayTexture;
struct GLDrawCommand;
struct GLMultiDraw;
enum class GLTextureFilter : int;
enum class Alignment : int;
enum class AlphaWriteMode : int;
class Bitmap;
class BitmapFormat;
class BitmapResource;
enum class ClearType : int;
class Color;
class Color444;
class Color555;
class Color565;
class ColorAlpha;
struct ColorCMYK;
struct ColorHSV;
struct ColorKey;
struct ColorLab;
struct ColorRGB;
class ColorRGBA;
struct ColorRGBAf;
class CubeMap;
enum class DefinedColor : uint;
class Display;
class DisplayDriver;
class DisplayFlags;
class DisplaySystem;
template <class TC, C(Class) ** TCO> class TDisplaySystemResPtr;
typedef TDisplaySystemResPtr<C(DisplaySystemResPtr), &CO(DisplaySystemResPtr)> DisplaySystemResPtr;
class DrawList;
class DrawManager;
struct DrawSlot;
template <class TC, C(Class) ** TCO> class TFMFont;
typedef TFMFont<C(FMFont), &CO(FMFont)> FMFont;
struct FMPathDraw;
class FMTextAlignment;
enum class FMVerticalAlignment : int;
template <class TC, C(Class) ** TCO> class TFaceInfo;
typedef TFaceInfo<C(FaceInfo), &CO(FaceInfo)> FaceInfo;
enum class FillModeValue : int;
template <class TC, C(Class) ** TCO> class TFont;
typedef TFont<C(Font), &CO(Font)> Font;
class FontFlags;
struct FontInfo;
class FontManager;
class FontManagerRenderer;
class FontRenderer;
class FontResource;
class GLCapabilities;
enum class GLSamplesCount : int;
enum class GradientDirection : int;
template <class TC, C(Class) ** TCO> class THitRecord;
typedef THitRecord<C(HitRecord), &CO(HitRecord)> HitRecord;
struct Light;
class LightFlags;
enum class PixelFormat : int;
enum class RenderState : int;
struct RenderStateFloat;
enum class Resolution : int;
class Resource;
class Surface;
enum class SystemColor : uint;
struct PNGOptions;
class BlockEntry;
template <class TC, C(Class) ** TCO> class TCompiledDefaultShader;
typedef TCompiledDefaultShader<C(CompiledDefaultShader), &CO(CompiledDefaultShader)> CompiledDefaultShader;
template <class TC, C(Class) ** TCO> class TCompiledShader;
typedef TCompiledShader<C(CompiledShader), &CO(CompiledShader)> CompiledShader;
class DefaultShader;
class DefaultShaderBits;
class FreeBlockMap;
struct GLAB;
enum class GLAttribMode : int;
struct GLB;
enum class GLBType : int;
enum class GLBufferContents : int;
enum class GLBufferUsage : int;
struct GLCAB;
struct GLEAB;
struct GLFB;
enum class GLIMTKMode : int;
class GLMB;
enum class GLMSWhatToGet : int;
class GLStats;
template <class TC, C(Class) ** TCO> class TLFBDisplay;
typedef TLFBDisplay<C(LFBDisplay), &CO(LFBDisplay)> LFBDisplay;
class LFBDisplayDriver;
template <class TC, C(Class) ** TCO> class TLFBSurface;
typedef TLFBSurface<C(LFBSurface), &CO(LFBSurface)> LFBSurface;
template <class TC, C(Class) ** TCO> class TLFBSystem;
typedef TLFBSystem<C(LFBSystem), &CO(LFBSystem)> LFBSystem;
enum class LightMode : int;
enum class MatrixMode : int;
class Shader;
class ShaderModifiedUniforms;
enum class SwizzleMode : int;
class Camera;
enum class CameraType : int;
enum class ClippingPlane : int;
struct Euler;
enum class EulerRotationOrder : int;
enum class FovDirection : int;
struct FrameKey;
template <class TC, C(Class) ** TCO> class TFrameTrack;
typedef TFrameTrack<C(FrameTrack), &CO(FrameTrack)> FrameTrack;
class FrameTrackBits;
enum class FrameTrackType : uint16;
enum class FrustumPlacement : int;
struct Line;
template <class TC, C(Class) ** TCO> class TMaterial;
typedef TMaterial<C(Material), &CO(Material)> Material;
class MaterialFlags;
struct Matrix;
struct Matrixf;
template <class TC, C(Class) ** TCO> class TMesh;
typedef TMesh<C(Mesh), &CO(Mesh)> Mesh;
class MeshFeatures;
struct MeshMorph;
struct MeshPart;
class MeshSkin;
template <class TC, C(Class) ** TCO> class TObject;
typedef TObject<C(Object), &CO(Object)> Object;
class ObjectFlags;
class ObjectFormat;
struct Plane;
template <class TC, C(Class) ** TCO> class TPrimitiveGroup;
typedef TPrimitiveGroup<C(PrimitiveGroup), &CO(PrimitiveGroup)> PrimitiveGroup;
class PrimitiveGroupType;
struct PrimitiveSingle;
struct Quaternion;
enum class RenderPrimitiveType : uint;
struct SkinBone;
struct SkinVert;
struct Transform;
struct Vector3D;
struct Vector3Df;
template <class TC, C(Class) ** TCO> class TCube;
typedef TCube<C(Cube), &CO(Cube)> Cube;
template <class TC, C(Class) ** TCO> class TSkyBox;
typedef TSkyBox<C(SkyBox), &CO(SkyBox)> SkyBox;
template <class TC, C(Class) ** TCO> class TSphere;
typedef TSphere<C(Sphere), &CO(Sphere)> Sphere;
struct Anchor;
struct AnchorValue;
enum class AnchorValueType : int;
class BorderBits;
enum class BorderStyle : uint;
template <class TC, C(Class) ** TCO> class TClipBoard;
typedef TClipBoard<C(ClipBoard), &CO(ClipBoard)> ClipBoard;
class CommonControl;
class ControllableWindow;
enum class CreationActivationOption : int;
class Cursor;
enum class DialogResult : int64;
struct Extent;
class GuiApplication;
class Interface;
struct Joystick;
class Key;
enum class KeyCode : uint;
struct MiddleAnchorValue;
class Modifiers;
class MouseButtons;
class Percentage;
enum class PredefinedKey : uint;
struct SizeAnchor;
class Skin;
enum class SkinBitmap : int;
class SmartKey;
enum class SystemCursor : int;
class Timer;
enum class TouchPointerEvent : int;
struct TouchPointerInfo;
class Window;
class WindowController;
template <typename TP_V> class TWindowController;
enum class WindowState : int;
enum class BoxAlignment : int;
struct BufferLocation;
class Button;
enum class ButtonState : int;
class CalendarControl;
class DataBox;
class DataDisplayFlags;
class DataField;
struct DataFieldSort;
class DataRow;
class DirectoriesBox;
class DropBox;
class EditBox;
enum class EditBoxFindResult : int;
class EditBoxStream;
template <class TC, C(Class) ** TCO> class TEditLine;
typedef TEditLine<C(EditLine), &CO(EditLine)> EditLine;
class EditSyntaxHL;
class EditableSelectorButton;
class Label;
class ListBox;
class Menu;
class MenuDivider;
class MenuItem;
class MenuPlacement;
class OldArray;
class PaneSplitter;
class PathBox;
enum class PathTypeExpected : int;
class Picture;
class PopupMenu;
class ProgressBar;
class SavingDataBox;
class ScrollBar;
enum class ScrollBarAction : int;
enum class ScrollDirection : int;
class SelectorBar;
class SelectorButton;
class Stacker;
class StatusBar;
class StatusField;
class Tab;
class TabControl;
enum class TabsPlacement : int;
class ToolBar;
class ToolButton;
class ToolSeparator;
class ToolTip;
template <class TC, C(Class) ** TCO> class TUndoAction;
typedef TUndoAction<C(UndoAction), &CO(UndoAction)> UndoAction;
class UndoBuffer;
class ColorPicker;
class CreateDirectoryDialog;
class FileDialog;
enum class FileDialogType : int;
struct FileFilter;
enum class FileForceExtension : int;
struct FileName;
enum class FileNameType : int;
struct FileType;
class FindDialog;
class GoToDialog;
class MessageBox;
enum class MessageBoxType : int;
class ReplaceDialog;
class WindowList;
class TVisionSkin_Window;
class WindowsSkin_Button;
class WindowsSkin_Window;
class DCOMClientObject;
class DCOMSendControl;
class DCOMServerObject;
class DCOMServerSocket;
class DCOMService;
enum class DisconnectCode : int;
class FileServerConnection;
class HTTPFile;
class NetworkClientFile;
template <class TC, C(Class) ** TCO> class TPacket;
typedef TPacket<C(Packet), &CO(Packet)> Packet;
class SSLSocket;
class Service;
class Socket;
enum class SocketType : int;
class Archive;
enum class ArchiveAddMode : int;
class ArchiveDir;
class ArchiveOpenFlags;
struct Box;
class BufferedFile;
class Centimeters;
class CharCategories;
enum class CharCategory : int;
template <class TC, C(Class) ** TCO> class TCondition;
typedef TCondition<C(Condition), &CO(Condition)> Condition;
class ConsoleFile;
struct Date;
struct DateTime;
enum class DayOfTheWeek : int;
class Degrees;
class Distance;
class DualPipe;
class ECONGlobalSettings;
class ECONParser;
class ErrorCode;
enum class ErrorLevel : int;
class Feet;
class File;
class FileAttribs;
class FileChange;
struct FileListing;
enum class FileLock : int;
class FileMonitor;
enum class FileOpenMode : int;
enum class FileSeekMode : int;
class FileSize;
class FileSize64;
struct FileStats;
class GlobalAppSettings;
enum class GlobalSettingType : int;
class GlobalSettings;
class GlobalSettingsData;
class GlobalSettingsDriver;
enum class GuiErrorCode : uint;
enum class JSONFirstLetterCapitalization : int;
class JSONGlobalSettings;
class JSONParser;
enum class JSONResult : int;
class JSONTypeOptions;
enum class LoggingMode : int;
class Meters;
class MinMaxValue;
enum class Month : int;
class MoveFileOptions;
class OptionsMap;
class PipeOpenMode;
struct Point;
struct Pointd;
struct Pointf;
enum class PredefinedCharCategories : uint;
class Radians;
class RepButton;
class SecSince1970;
class Seconds;
template <class TC, C(Class) ** TCO> class TSemaphore;
typedef TSemaphore<C(Semaphore), &CO(Semaphore)> Semaphore;
enum class SetBool : uint;
enum class SettingsIOResult : int;
struct Size;
enum class SysErrorCode : uint;
class TempFile;
class Thread;
enum class ThreadPriority : int;
class Time;
class TimeStamp;
class TimeStamp32;
class UnicodeDecomposition;

int ecere_cpp_init(const Module & module);


struct FreeSpots : public TStruct<FreeSpots>
{
public:
   C(FreeSpots) impl;
   constexpr FreeSpots() : impl({}) { }
   constexpr FreeSpots(const C(FreeSpots) impl) : impl(impl) { }

   inline void init(/*1Ab*/uint count); // FreeSpots_init
   inline void markFree(/*1Ab*/int spot); // FreeSpots_markFree
   inline int next(); // FreeSpots_next
   inline void resize(/*1Ab*/uint count); // FreeSpots_resize

   inline FreeSpots(uint size, int * spots, int nextSpot, int used);

   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline FreeSpots::size_Prop & operator= (FreeSpots::size_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } size;
   struct spots_Prop
   {
      constexpr spots_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int * operator= (/*0H*/int * v);
      /*regSet*/inline FreeSpots::spots_Prop & operator= (FreeSpots::spots_Prop & prop);
      /*regGet*/inline operator /*0I*/int * () const;
   } spots;
   struct nextSpot_Prop
   {
      constexpr nextSpot_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FreeSpots::nextSpot_Prop & operator= (FreeSpots::nextSpot_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nextSpot;
   struct used_Prop
   {
      constexpr used_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FreeSpots::used_Prop & operator= (FreeSpots::used_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } used;
};

struct GLArrayTexture : public TStruct<GLArrayTexture>
{
public:
   C(GLArrayTexture) impl;
   constexpr GLArrayTexture() : impl({}) { }
   constexpr GLArrayTexture(const C(GLArrayTexture) impl) : impl(impl) { }

   inline void _init(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count, /*1Ab*/int format, /*1Ab*/bool setMaxLevel); // GLArrayTexture__init
   inline int allocateLayer(/*1Ab*/uint targetFBO); // GLArrayTexture_allocateLayer
   inline void bind(); // GLArrayTexture_bind
   inline void copy(/*1Ab*/GLArrayTexture & src, /*1Ab*/uint targetFBO); // GLArrayTexture_copy
   inline void copy(/*1Ac*/GLArrayTexture * src, /*1Ac*/uint targetFBO); // GLArrayTexture_copy
   inline void free(); // GLArrayTexture_free
   inline void freeLayer(/*1Ab*/int layer); // GLArrayTexture_freeLayer
   inline void init(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count); // GLArrayTexture_init
   inline void initMaxLevel(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count); // GLArrayTexture_initMaxLevel
   inline void initRGBAUShort(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count); // GLArrayTexture_initRGBAUShort
   inline void initRGBUShort(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count); // GLArrayTexture_initRGBUShort
   inline void initUShort(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count); // GLArrayTexture_initUShort
   inline void resize(/*1Ab*/uint numLayers, /*1Ab*/uint targetFBO); // GLArrayTexture_resize
   inline void set1x1Layer(/*1Ab*/int layer, /*1Ab*/ColorAlpha color, /*1Ab*/uint targetFBO); // GLArrayTexture_set1x1Layer
   inline void setFilter(/*1Ab*/GLTextureFilter minFilter, /*1Ab*/GLTextureFilter magFilter); // GLArrayTexture_setFilter
   inline void setLayer(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO); // GLArrayTexture_setLayer
   inline void setLayerCompressed(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uintsize sizeBytes, /*1Ab*/uint targetFBO); // GLArrayTexture_setLayerCompressed
   inline void setLayerFormat(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO, /*1Ab*/int format, /*1Ab*/int type); // GLArrayTexture_setLayerFormat
   inline void setLayerRGBAUShort(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO); // GLArrayTexture_setLayerRGBAUShort
   inline void setLayerRGBUShort(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO); // GLArrayTexture_setLayerRGBUShort
   inline void setLayerUShort(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO); // GLArrayTexture_setLayerUShort

   inline GLArrayTexture(uint texture, uint width, uint height, uint numLayers, uint numLevels, bool maxLevel, int format, FreeSpots spots);

   struct texture_Prop
   {
      constexpr texture_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLArrayTexture::texture_Prop & operator= (GLArrayTexture::texture_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } texture;
   struct width_Prop
   {
      constexpr width_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLArrayTexture::width_Prop & operator= (GLArrayTexture::width_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } width;
   struct height_Prop
   {
      constexpr height_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLArrayTexture::height_Prop & operator= (GLArrayTexture::height_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } height;
   struct numLayers_Prop
   {
      constexpr numLayers_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLArrayTexture::numLayers_Prop & operator= (GLArrayTexture::numLayers_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } numLayers;
   struct numLevels_Prop
   {
      constexpr numLevels_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLArrayTexture::numLevels_Prop & operator= (GLArrayTexture::numLevels_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } numLevels;
   struct maxLevel_Prop
   {
      constexpr maxLevel_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLArrayTexture::maxLevel_Prop & operator= (GLArrayTexture::maxLevel_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } maxLevel;
   struct format_Prop
   {
      constexpr format_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GLArrayTexture::format_Prop & operator= (GLArrayTexture::format_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } format;
   struct spots_Prop
   {
      constexpr spots_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FreeSpots operator= (/*0H*/FreeSpots v);
      /*regSet*/inline GLArrayTexture::spots_Prop & operator= (GLArrayTexture::spots_Prop & prop);
      /*regGet*/inline operator /*0I*/FreeSpots () const;
   } spots;
};

struct GLDrawCommand : public TStruct<GLDrawCommand>
{
public:
   C(GLDrawCommand) impl;
   constexpr GLDrawCommand() : impl({}) { }
   constexpr GLDrawCommand(const C(GLDrawCommand) impl) : impl(impl) { }

   inline GLDrawCommand(uint count, uint instanceCount, uint firstIndex, uint baseVertex, uint baseInstance);

   struct count_Prop
   {
      constexpr count_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLDrawCommand::count_Prop & operator= (GLDrawCommand::count_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } count;
   struct instanceCount_Prop
   {
      constexpr instanceCount_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLDrawCommand::instanceCount_Prop & operator= (GLDrawCommand::instanceCount_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } instanceCount;
   struct firstIndex_Prop
   {
      constexpr firstIndex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLDrawCommand::firstIndex_Prop & operator= (GLDrawCommand::firstIndex_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } firstIndex;
   struct baseVertex_Prop
   {
      constexpr baseVertex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLDrawCommand::baseVertex_Prop & operator= (GLDrawCommand::baseVertex_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } baseVertex;
   struct baseInstance_Prop
   {
      constexpr baseInstance_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLDrawCommand::baseInstance_Prop & operator= (GLDrawCommand::baseInstance_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } baseInstance;
};

struct GLMultiDraw : public TStruct<GLMultiDraw>
{
public:
   C(GLMultiDraw) impl;
   constexpr GLMultiDraw() : impl({}) { }
   constexpr GLMultiDraw(const C(GLMultiDraw) impl) : impl(impl) { }

   inline void addDrawCommand(/*1Ab*/uint indexCount, /*1Ab*/uint instanceCount, /*1Ab*/uint firstIndex, /*1Ab*/uint baseVertex, /*1Ab*/uint baseInstance); // GLMultiDraw_addDrawCommand
   inline void addDrawCommandCustomID(/*1Ab*/uint indexCount, /*1Ab*/uint instanceCount, /*1Ab*/uint firstIndex, /*1Ab*/uint baseVertex, /*1Ab*/uint baseInstance, /*1Ab*/uint layer); // GLMultiDraw_addDrawCommandCustomID
   inline int allocateIx(/*1Ab*/uint nIndices, /*1Ab*/uint indexSize, /*1Ab*/const void * data); // GLMultiDraw_allocateIx
   inline int allocateVbo(/*1Ab*/uint nVertices, /*1Ab*/uint vertexSize, /*1Ab*/const void * data); // GLMultiDraw_allocateVbo
   inline void draw(); // GLMultiDraw_draw
   inline void free(); // GLMultiDraw_free
   inline void freeIx(/*1Ab*/int baseIndex, /*1Ab*/uint indexSize, /*1Ab*/uint count); // GLMultiDraw_freeIx
   inline void freeVbo(/*1Ab*/int baseVertex, /*1Ab*/uint vertexSize, /*1Ab*/uint count); // GLMultiDraw_freeVbo
   inline void init(/*1Ab*/GLIMTKMode mode, /*1Ab*/uint minAlloc); // GLMultiDraw_init
   inline void prepare(/*1Ab*/int vertNCoords, /*1Ab*/int verticesStride); // GLMultiDraw_prepare
   inline void printStats(); // GLMultiDraw_printStats
   inline void resize(/*1Ab*/uint size); // GLMultiDraw_resize
   inline void resizeCommands(/*1Ab*/uint size); // GLMultiDraw_resizeCommands
   inline void resizeIDs(/*1Ab*/uint size); // GLMultiDraw_resizeIDs

   struct ix32_Prop
   {
      constexpr ix32_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } ix32;

   struct indexGLMB_Prop
   {
      constexpr indexGLMB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0Z*/const GLMB & operator= (/*0Z*/const GLMB & v);
      /*regSet*/inline GLMultiDraw::indexGLMB_Prop & operator= (GLMultiDraw::indexGLMB_Prop & prop);
      /*regGet*/inline operator /*0I*/GLMB * () const;
   } indexGLMB;
   struct vertexGLMB_Prop
   {
      constexpr vertexGLMB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0Z*/const GLMB & operator= (/*0Z*/const GLMB & v);
      /*regSet*/inline GLMultiDraw::vertexGLMB_Prop & operator= (GLMultiDraw::vertexGLMB_Prop & prop);
      /*regGet*/inline operator /*0I*/GLMB * () const;
   } vertexGLMB;
   struct idsAB_Prop
   {
      constexpr idsAB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLAB operator= (/*0H*/GLAB v);
      /*regSet*/inline GLMultiDraw::idsAB_Prop & operator= (GLMultiDraw::idsAB_Prop & prop);
      /*regGet*/inline operator /*0I*/GLAB () const;
   } idsAB;
   struct commandsB_Prop
   {
      constexpr commandsB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLCAB operator= (/*0H*/GLCAB v);
      /*regSet*/inline GLMultiDraw::commandsB_Prop & operator= (GLMultiDraw::commandsB_Prop & prop);
      /*regGet*/inline operator /*0I*/GLCAB () const;
   } commandsB;
   struct vao_Prop
   {
      constexpr vao_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::vao_Prop & operator= (GLMultiDraw::vao_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } vao;
   struct commandsCount_Prop
   {
      constexpr commandsCount_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::commandsCount_Prop & operator= (GLMultiDraw::commandsCount_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } commandsCount;
   struct drawMode_Prop
   {
      constexpr drawMode_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLIMTKMode operator= (/*0H*/GLIMTKMode v);
      /*regSet*/inline GLMultiDraw::drawMode_Prop & operator= (GLMultiDraw::drawMode_Prop & prop);
      /*regGet*/inline operator /*0I*/GLIMTKMode () const;
   } drawMode;
   struct commandsAlloced_Prop
   {
      constexpr commandsAlloced_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::commandsAlloced_Prop & operator= (GLMultiDraw::commandsAlloced_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } commandsAlloced;
   struct drawIDs_Prop
   {
      constexpr drawIDs_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint * operator= (/*0H*/uint * v);
      /*regSet*/inline GLMultiDraw::drawIDs_Prop & operator= (GLMultiDraw::drawIDs_Prop & prop);
      /*regGet*/inline operator /*0I*/uint * () const;
   } drawIDs;
   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::type_Prop & operator= (GLMultiDraw::type_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } type;
   struct idsAlloced_Prop
   {
      constexpr idsAlloced_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::idsAlloced_Prop & operator= (GLMultiDraw::idsAlloced_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } idsAlloced;
   struct totalInstances_Prop
   {
      constexpr totalInstances_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::totalInstances_Prop & operator= (GLMultiDraw::totalInstances_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } totalInstances;
   struct vertexStride_Prop
   {
      constexpr vertexStride_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::vertexStride_Prop & operator= (GLMultiDraw::vertexStride_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } vertexStride;
   struct transformsAB_Prop
   {
      constexpr transformsAB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLAB operator= (/*0H*/GLAB v);
      /*regSet*/inline GLMultiDraw::transformsAB_Prop & operator= (GLMultiDraw::transformsAB_Prop & prop);
      /*regGet*/inline operator /*0I*/GLAB () const;
   } transformsAB;
   struct transformSize_Prop
   {
      constexpr transformSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GLMultiDraw::transformSize_Prop & operator= (GLMultiDraw::transformSize_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } transformSize;
   struct transforms_Prop
   {
      constexpr transforms_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float * operator= (/*0H*/float * v);
      /*regSet*/inline GLMultiDraw::transforms_Prop & operator= (GLMultiDraw::transforms_Prop & prop);
      /*regGet*/inline operator /*0I*/float * () const;
   } transforms;
   struct lastTransformAB_Prop
   {
      constexpr lastTransformAB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::lastTransformAB_Prop & operator= (GLMultiDraw::lastTransformAB_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } lastTransformAB;
   struct lastIDAB_Prop
   {
      constexpr lastIDAB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::lastIDAB_Prop & operator= (GLMultiDraw::lastIDAB_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } lastIDAB;
   struct lastVBO_Prop
   {
      constexpr lastVBO_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::lastVBO_Prop & operator= (GLMultiDraw::lastVBO_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } lastVBO;
   struct lastIBO_Prop
   {
      constexpr lastIBO_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLMultiDraw::lastIBO_Prop & operator= (GLMultiDraw::lastIBO_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } lastIBO;
};

enum class GLTextureFilter : int
{
   nearest = GLTextureFilter_nearest,
   linear = GLTextureFilter_linear
};


#define REG_Bitmap(c) \
      Bitmap::class_registration(_cpp_class);

#define BITMAP_VIRTUAL_METHODS_PROTO(c) \

#define BITMAP_VIRTUAL_METHODS(c) \

class Bitmap : public Instance
{
public:
   inline Bitmap(Bitmap && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Bitmap & operator= (Bitmap && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Bitmap() : Bitmap((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Bitmap> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Bitmap * inst = new Bitmap(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Bitmap * inst = (Bitmap *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Bitmap & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Bitmap(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) allocate(/*1Ab*/const char * driverName, /*1Ab*/int width, /*1Ab*/int height, /*1Ab*/int stride, /*1Ab*/PixelFormat format, /*1Ab*/bool allocatePalette); // Bitmap_allocate
   inline C(bool) allocateDD(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/int width, /*1Ab*/int height); // Bitmap_allocateDD
   inline C(bool) convert(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/PixelFormat format, /*1Ab*/ColorAlpha * palette); // Bitmap_convert
   inline C(bool) copy(/*1Ab*/Bitmap & source); // Bitmap_copy
   inline C(bool) copy2(/*1Ab*/Bitmap & source, /*1Ab*/bool moveStuff); // Bitmap_copy2
   inline void free(); // Bitmap_free
   inline Surface getSurface(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Box & clip); // Bitmap_getSurface
   inline Surface getSurface(/*1Ac*/int x, /*1Ac*/int y, /*1Ac*/Box * clip); // Bitmap_getSurface
   inline void grab(/*1Ab*/Bitmap & src, /*1Ab*/int x, /*1Ab*/int y); // Bitmap_grab
   inline C(bool) load(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Bitmap_load
   inline C(bool) loadFromFile(/*1Ab*/File & file, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Bitmap_loadFromFile
   inline C(bool) loadGrayed(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Bitmap_loadGrayed
   inline C(bool) loadMipMaps(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Bitmap_loadMipMaps
   inline C(bool) loadMonochrome(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Bitmap_loadMonochrome
   inline C(bool) loadT(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Bitmap_loadT
   inline C(bool) loadTMipMaps(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Bitmap_loadTMipMaps
   inline C(bool) makeDD(/*1Ab*/DisplaySystem & displaySystem); // Bitmap_makeDD
   inline C(bool) makeMipMaps(/*1Ab*/DisplaySystem & displaySystem); // Bitmap_makeMipMaps
   inline Bitmap processDD(/*1Ab*/bool mipMaps, /*1Ab*/uint cubeMapFace, /*1Ab*/bool compress, /*1Ab*/int maxTextureSize, /*1Ab*/bool makePow2, /*1Ab*/int enforcedWidth, /*1Ab*/int enforcedHeight); // Bitmap_processDD
   inline C(ColorAlpha) * quantize(/*1Ab*/uint start, /*1Ab*/uint end); // Bitmap_quantize
   inline C(bool) save(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/void * options); // Bitmap_save
   inline void smoothEdges(/*1Ab*/int size); // Bitmap_smoothEdges

   static void class_registration(CPPClass & _cpp_class);

   inline Bitmap(int width, int height, PixelFormat pixelFormat, unsigned char * picture, uint stride, uint size, uint sizeBytes, ColorAlpha * palette, bool allocatePalette, bool transparent, int shadeShift, unsigned char * paletteShades, bool alphaBlend);

   struct width_Prop
   {
      constexpr width_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Bitmap::width_Prop & operator= (Bitmap::width_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } width;
   struct height_Prop
   {
      constexpr height_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Bitmap::height_Prop & operator= (Bitmap::height_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } height;
   struct pixelFormat_Prop
   {
      constexpr pixelFormat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/PixelFormat operator= (/*0H*/PixelFormat v);
      /*regSet*/inline Bitmap::pixelFormat_Prop & operator= (Bitmap::pixelFormat_Prop & prop);
      /*regGet*/inline operator /*0I*/PixelFormat () const;
   } pixelFormat;
   struct picture_Prop
   {
      constexpr picture_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char * operator= (/*0H*/unsigned char * v);
      /*regSet*/inline Bitmap::picture_Prop & operator= (Bitmap::picture_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char * () const;
   } picture;
   struct stride_Prop
   {
      constexpr stride_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline Bitmap::stride_Prop & operator= (Bitmap::stride_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } stride;
   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline Bitmap::size_Prop & operator= (Bitmap::size_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } size;
   struct sizeBytes_Prop
   {
      constexpr sizeBytes_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline Bitmap::sizeBytes_Prop & operator= (Bitmap::sizeBytes_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } sizeBytes;
   struct palette_Prop
   {
      constexpr palette_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha * operator= (/*0H*/ColorAlpha * v);
      /*regSet*/inline Bitmap::palette_Prop & operator= (Bitmap::palette_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha * () const;
   } palette;
   struct allocatePalette_Prop
   {
      constexpr allocatePalette_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Bitmap::allocatePalette_Prop & operator= (Bitmap::allocatePalette_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } allocatePalette;
   struct transparent_Prop
   {
      constexpr transparent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Bitmap::transparent_Prop & operator= (Bitmap::transparent_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } transparent;
   struct shadeShift_Prop
   {
      constexpr shadeShift_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Bitmap::shadeShift_Prop & operator= (Bitmap::shadeShift_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } shadeShift;
   struct paletteShades_Prop
   {
      constexpr paletteShades_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char * operator= (/*0H*/unsigned char * v);
      /*regSet*/inline Bitmap::paletteShades_Prop & operator= (Bitmap::paletteShades_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char * () const;
   } paletteShades;
   struct alphaBlend_Prop
   {
      constexpr alphaBlend_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Bitmap::alphaBlend_Prop & operator= (Bitmap::alphaBlend_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alphaBlend;
   struct displaySystem_Prop
   {
      constexpr displaySystem_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DisplaySystem operator= (/*0H*/DisplaySystem v);
      /*regSet*/inline Bitmap::displaySystem_Prop & operator= (Bitmap::displaySystem_Prop & prop);
      /*regGet*/inline operator /*0I*/DisplaySystem () const;
   } displaySystem;
   struct driverData_Prop
   {
      constexpr driverData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline Bitmap::driverData_Prop & operator= (Bitmap::driverData_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } driverData;
   struct keepData_Prop
   {
      constexpr keepData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Bitmap::keepData_Prop & operator= (Bitmap::keepData_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } keepData;
   struct mipMaps_Prop
   {
      constexpr mipMaps_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Bitmap::mipMaps_Prop & operator= (Bitmap::mipMaps_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } mipMaps;
   struct sRGB2Linear_Prop
   {
      constexpr sRGB2Linear_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Bitmap::sRGB2Linear_Prop & operator= (Bitmap::sRGB2Linear_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } sRGB2Linear;
   struct numMipMaps_Prop
   {
      constexpr numMipMaps_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Bitmap::numMipMaps_Prop & operator= (Bitmap::numMipMaps_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } numMipMaps;
   struct bitmaps_Prop
   {
      constexpr bitmaps_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/C(Bitmap)* operator= (/*0H*/C(Bitmap)* v);
      /*regSet*/inline Bitmap::bitmaps_Prop & operator= (Bitmap::bitmaps_Prop & prop);
      /*regGet*/inline operator /*0I*/C(Bitmap)* () const;
   } bitmaps;
};

class Color
{
public:
   C(Color) impl;
   constexpr Color() : impl(0) { }

   Color(DefinedColor impl) : impl((C(Color))impl) { }
   Color & operator =(DefinedColor impl) { this->impl = (C(Color))impl; return *this; }
   Color(SystemColor impl) : impl((C(Color))impl) { }
   Color & operator =(SystemColor impl) { this->impl = (C(Color))impl; return *this; }

   constexpr Color(C(Color) impl) : impl(impl) { }
   Color(unsigned char r, unsigned char g, unsigned char b)
   {
      impl = COLOR(r, g, b);
   }
   operator C(Color)() { return impl; }
   Color & operator =(C(Color) impl) { impl = impl; return *this; }
   bool operator ==(const Color & value) const { return impl == value.impl; }
   bool operator !=(const Color & value) const { return impl != value.impl; }
   inline operator ColorRGB() const;
   inline Color(const ColorRGB & c);
   inline Color & operator =(const ColorRGB & c);
   inline Color operator= (Color444 value);
   inline Color(Color444 value);
   inline operator Color444() const;
   inline Color operator= (Color555 value);
   inline Color(Color555 value);
   inline operator Color555() const;
   inline Color operator= (Color565 value);
   inline Color(Color565 value);
   inline operator Color565() const;
   inline Color operator= (ColorAlpha value);
   inline Color(ColorAlpha value);
   inline operator ColorAlpha() const;
   inline Color operator= (ColorRGBA value);
   inline Color(ColorRGBA value);
   inline operator ColorRGBA() const;

   struct r_Prop
   {
      constexpr r_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color::r_Prop & operator= (Color::r_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } r;
   struct g_Prop
   {
      constexpr g_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color::g_Prop & operator= (Color::g_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } g;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color::b_Prop & operator= (Color::b_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } b;
};

class ColorAlpha
{
public:
   C(ColorAlpha) impl;
   constexpr ColorAlpha() : impl(0) { }
   constexpr ColorAlpha(C(ColorAlpha) impl) : impl(impl) { }
   ColorAlpha(unsigned char a, Color & color);
   operator C(ColorAlpha)() { return impl; }
   ColorAlpha & operator =(C(ColorAlpha) impl) { impl = impl; return *this; }
   bool operator ==(const ColorAlpha & value) const { return impl == value.impl; }
   bool operator !=(const ColorAlpha & value) const { return impl != value.impl; }
   inline constexpr operator Color() const;
   inline constexpr ColorAlpha(const Color & c);
   inline constexpr ColorAlpha & operator =(const Color & c);
   inline ColorAlpha operator= (ColorRGBA value);
   inline ColorAlpha(ColorRGBA value);
   inline operator ColorRGBA() const;

   struct a_Prop
   {
      constexpr a_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline ColorAlpha::a_Prop & operator= (ColorAlpha::a_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } a;
   struct color_Prop
   {
      constexpr color_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline ColorAlpha::color_Prop & operator= (ColorAlpha::color_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } color;
};

template <class TC, C(Class) ** TCO>
class TFont : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct ascent_Prop
   {
      constexpr ascent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } ascent;
   struct descent_Prop
   {
      constexpr descent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } descent;
   ~TFont()
   {
      this->impl = null; // How to know not to delete?
   }
};

#define REG_FontManagerRenderer_createTexture(m, c)   REGVMETHOD(FontManagerRenderer, createTexture,   c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/int width, /*1Ab*/int height),                                                                                                        c, (/*4Im*/width, /*4Im*/height))
#define REG_FontManagerRenderer_drawImage(m, c)       REGVMETHOD(FontManagerRenderer, drawImage,       c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/int targetx, /*1Ab*/int targety, /*1Ab*/int imageIndex, /*1Ab*/bool useExtColor),                                                     c, (/*4Im*/targetx, /*4Im*/targety, /*4Im*/imageIndex, /*4Hm*/(bool)useExtColor))
#define REG_FontManagerRenderer_drawImageAlt(m, c)    REGVMETHOD(FontManagerRenderer, drawImageAlt,    c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/byte * texdata, /*1Ab*/int targetx, /*1Ab*/int targety, /*1Ab*/int offsetx, /*1Ab*/int offsety, /*1Ab*/int width, /*1Ab*/int height), c, (/*4Im*/texdata, /*4Im*/targetx, /*4Im*/targety, /*4Im*/offsetx, /*4Im*/offsety, /*4Im*/width, /*4Im*/height))
#define REG_FontManagerRenderer_drawImageCursor(m, c) REGVMETHOD(FontManagerRenderer, drawImageCursor, c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/int targetx, /*1Ab*/int targety, /*1Ab*/int imageIndex),                                                                              c, (/*4Im*/targetx, /*4Im*/targety, /*4Im*/imageIndex))
#define REG_FontManagerRenderer_drawImageFloat(m, c)  REGVMETHOD(FontManagerRenderer, drawImageFloat,  c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/float targetx, /*1Ab*/float targety, /*1Ab*/float angsin, /*1Ab*/float angcos, /*1Ab*/int imageIndex, /*1Ab*/bool useExtColor),       c, (/*4Im*/targetx, /*4Im*/targety, /*4Im*/angsin, /*4Im*/angcos, /*4Im*/imageIndex, /*4Hm*/(bool)useExtColor))
#define REG_FontManagerRenderer_flush(m, c)           REGVMETHOD(FontManagerRenderer, flush,           c::m, (/*1Ab*/FontManagerRenderer & self),                                                                                                                                             c, ())
#define REG_FontManagerRenderer_init(m, c)            REGVMETHOD(FontManagerRenderer, init,            c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/int channelCount),                                                                                                                    c, (/*4Im*/channelCount))
#define REG_FontManagerRenderer_registerImage(m, c)   REGVMETHOD(FontManagerRenderer, registerImage,   c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/int offsetx, /*1Ab*/int offsety, /*1Ab*/int width, /*1Ab*/int height),                                                                c, (/*4Im*/offsetx, /*4Im*/offsety, /*4Im*/width, /*4Im*/height))
#define REG_FontManagerRenderer_resetImages(m, c)     REGVMETHOD(FontManagerRenderer, resetImages,     c::m, (/*1Ab*/FontManagerRenderer & self),                                                                                                                                             c, ())
#define REG_FontManagerRenderer_resizeTexture(m, c)   REGVMETHOD(FontManagerRenderer, resizeTexture,   c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/int width, /*1Ab*/int height),                                                                                                        c, (/*4Im*/width, /*4Im*/height))
#define REG_FontManagerRenderer_setLayer(m, c)        REGVMETHOD(FontManagerRenderer, setLayer,        c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/uint layerIndex),                                                                                                                     c, (/*4Im*/layerIndex))
#define REG_FontManagerRenderer_updateTexture(m, c)   REGVMETHOD(FontManagerRenderer, updateTexture,   c::m, (/*1Ab*/FontManagerRenderer & self, /*1Ab*/int * rect, /*1Ab*/const byte * data),                                                                                                c, (/*4Im*/rect, /*4Im*/data))

#define REG_FontManagerRenderer(c) \
      FontManagerRenderer::class_registration(_cpp_class); \
      REG_FontManagerRenderer_createTexture(createTexture, c); \
      REG_FontManagerRenderer_drawImage(drawImage, c); \
      REG_FontManagerRenderer_drawImageAlt(drawImageAlt, c); \
      REG_FontManagerRenderer_drawImageCursor(drawImageCursor, c); \
      REG_FontManagerRenderer_drawImageFloat(drawImageFloat, c); \
      REG_FontManagerRenderer_flush(flush, c); \
      REG_FontManagerRenderer_init(init, c); \
      REG_FontManagerRenderer_registerImage(registerImage, c); \
      REG_FontManagerRenderer_resetImages(resetImages, c); \
      REG_FontManagerRenderer_resizeTexture(resizeTexture, c); \
      REG_FontManagerRenderer_setLayer(setLayer, c); \
      REG_FontManagerRenderer_updateTexture(updateTexture, c);

#define FONTMANAGERRENDERER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(createTexture, createTexture, c, FontManagerRenderer, \
      int, c & _ARG, , /*6Fj*/int width _ARG /*6Fj*/int height); \
   VIRTUAL_METHOD_PROTO(drawImage, drawImage, c, FontManagerRenderer, \
      void, c & _ARG, , /*6Fj*/int targetx _ARG /*6Fj*/int targety _ARG /*6Fj*/int imageIndex _ARG /*6Fj*/bool useExtColor); \
   VIRTUAL_METHOD_PROTO(drawImageAlt, drawImageAlt, c, FontManagerRenderer, \
      void, c & _ARG, , /*6Fj*/unsigned char * texdata _ARG /*6Fj*/int targetx _ARG /*6Fj*/int targety _ARG /*6Fj*/int offsetx _ARG /*6Fj*/int offsety _ARG /*6Fj*/int width _ARG /*6Fj*/int height); \
   VIRTUAL_METHOD_PROTO(drawImageCursor, drawImageCursor, c, FontManagerRenderer, \
      void, c & _ARG, , /*6Fj*/int targetx _ARG /*6Fj*/int targety _ARG /*6Fj*/int imageIndex); \
   VIRTUAL_METHOD_PROTO(drawImageFloat, drawImageFloat, c, FontManagerRenderer, \
      void, c & _ARG, , /*6Fj*/float targetx _ARG /*6Fj*/float targety _ARG /*6Fj*/float angsin _ARG /*6Fj*/float angcos _ARG /*6Fj*/int imageIndex _ARG /*6Fj*/bool useExtColor); \
   VIRTUAL_METHOD_PROTO(flush, flush, c, FontManagerRenderer, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(init, init, c, FontManagerRenderer, \
      bool, c & _ARG, , /*6Fj*/int channelCount); \
   VIRTUAL_METHOD_PROTO(registerImage, registerImage, c, FontManagerRenderer, \
      int, c & _ARG, , /*6Fj*/int offsetx _ARG /*6Fj*/int offsety _ARG /*6Fj*/int width _ARG /*6Fj*/int height); \
   VIRTUAL_METHOD_PROTO(resetImages, resetImages, c, FontManagerRenderer, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(resizeTexture, resizeTexture, c, FontManagerRenderer, \
      int, c & _ARG, , /*6Fj*/int width _ARG /*6Fj*/int height); \
   VIRTUAL_METHOD_PROTO(setLayer, setLayer, c, FontManagerRenderer, \
      void, c & _ARG, , /*6Fj*/uint layerIndex); \
   VIRTUAL_METHOD_PROTO(updateTexture, updateTexture, c, FontManagerRenderer, \
      void, c & _ARG, , /*6Fj*/int * rect _ARG /*6Fj*/const unsigned char * data);

#define FONTMANAGERRENDERER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(createTexture, createTexture, c, FontManagerRenderer, \
   int, c & _ARG, , /*6Fj*/int width _ARG /*6Fj*/int height, \
   return FontManagerRenderer_createTexture(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/width, /*7Al*/height);); \
VIRTUAL_METHOD(drawImage, drawImage, c, FontManagerRenderer, \
   void, c & _ARG, , /*6Fj*/int targetx _ARG /*6Fj*/int targety _ARG /*6Fj*/int imageIndex _ARG /*6Fj*/bool useExtColor, \
   FontManagerRenderer_drawImage(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/targetx, /*7Al*/targety, /*7Al*/imageIndex, /*7Al*/(C(bool))useExtColor);); \
VIRTUAL_METHOD(drawImageAlt, drawImageAlt, c, FontManagerRenderer, \
   void, c & _ARG, , /*6Fj*/unsigned char * texdata _ARG /*6Fj*/int targetx _ARG /*6Fj*/int targety _ARG /*6Fj*/int offsetx _ARG /*6Fj*/int offsety _ARG /*6Fj*/int width _ARG /*6Fj*/int height, \
   FontManagerRenderer_drawImageAlt(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/texdata, /*7Al*/targetx, /*7Al*/targety, /*7Al*/offsetx, /*7Al*/offsety, /*7Al*/width, /*7Al*/height);); \
VIRTUAL_METHOD(drawImageCursor, drawImageCursor, c, FontManagerRenderer, \
   void, c & _ARG, , /*6Fj*/int targetx _ARG /*6Fj*/int targety _ARG /*6Fj*/int imageIndex, \
   FontManagerRenderer_drawImageCursor(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/targetx, /*7Al*/targety, /*7Al*/imageIndex);); \
VIRTUAL_METHOD(drawImageFloat, drawImageFloat, c, FontManagerRenderer, \
   void, c & _ARG, , /*6Fj*/float targetx _ARG /*6Fj*/float targety _ARG /*6Fj*/float angsin _ARG /*6Fj*/float angcos _ARG /*6Fj*/int imageIndex _ARG /*6Fj*/bool useExtColor, \
   FontManagerRenderer_drawImageFloat(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/targetx, /*7Al*/targety, /*7Al*/angsin, /*7Al*/angcos, /*7Al*/imageIndex, /*7Al*/(C(bool))useExtColor);); \
VIRTUAL_METHOD(flush, flush, c, FontManagerRenderer, \
   void, c &, , , \
   FontManagerRenderer_flush(self ? self->impl : (C(FontManagerRenderer))null);); \
VIRTUAL_METHOD(init, init, c, FontManagerRenderer, \
   bool, c & _ARG, , /*6Fj*/int channelCount, \
   return (bool)FontManagerRenderer_init(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/channelCount);); \
VIRTUAL_METHOD(registerImage, registerImage, c, FontManagerRenderer, \
   int, c & _ARG, , /*6Fj*/int offsetx _ARG /*6Fj*/int offsety _ARG /*6Fj*/int width _ARG /*6Fj*/int height, \
   return FontManagerRenderer_registerImage(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/offsetx, /*7Al*/offsety, /*7Al*/width, /*7Al*/height);); \
VIRTUAL_METHOD(resetImages, resetImages, c, FontManagerRenderer, \
   void, c &, , , \
   FontManagerRenderer_resetImages(self ? self->impl : (C(FontManagerRenderer))null);); \
VIRTUAL_METHOD(resizeTexture, resizeTexture, c, FontManagerRenderer, \
   int, c & _ARG, , /*6Fj*/int width _ARG /*6Fj*/int height, \
   return FontManagerRenderer_resizeTexture(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/width, /*7Al*/height);); \
VIRTUAL_METHOD(setLayer, setLayer, c, FontManagerRenderer, \
   void, c & _ARG, , /*6Fj*/uint layerIndex, \
   FontManagerRenderer_setLayer(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/layerIndex);); \
VIRTUAL_METHOD(updateTexture, updateTexture, c, FontManagerRenderer, \
   void, c & _ARG, , /*6Fj*/int * rect _ARG /*6Fj*/const unsigned char * data, \
   FontManagerRenderer_updateTexture(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/rect, /*7Al*/data););

class FontManagerRenderer : public Instance
{
public:
   inline FontManagerRenderer(FontManagerRenderer && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FontManagerRenderer & operator= (FontManagerRenderer && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FontManagerRenderer() : FontManagerRenderer((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FontManagerRenderer> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FontManagerRenderer * inst = new FontManagerRenderer(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FontManagerRenderer * inst = (FontManagerRenderer *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FontManagerRenderer & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FontManagerRenderer(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct FontManagerRenderer_createTexture_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(FontManagerRenderer & , /*6Fj*/int width, /*6Fj*/int height);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( /*6Fj*/int width, /*6Fj*/int height);
   } createTexture;
   // inline static void register_createTexture(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_createTexture_Functor::FunctionType func)

   struct FontManagerRenderer_drawImage_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer & , /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int imageIndex, /*6Fj*/bool useExtColor);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int imageIndex, /*6Fj*/bool useExtColor);
   } drawImage;
   // inline static void register_drawImage(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImage_Functor::FunctionType func)

   struct FontManagerRenderer_drawImageAlt_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer & , /*6Fj*/unsigned char * texdata, /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int offsetx, /*6Fj*/int offsety, /*6Fj*/int width, /*6Fj*/int height);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/unsigned char * texdata, /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int offsetx, /*6Fj*/int offsety, /*6Fj*/int width, /*6Fj*/int height);
   } drawImageAlt;
   // inline static void register_drawImageAlt(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::FunctionType func)

   struct FontManagerRenderer_drawImageCursor_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer & , /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int imageIndex);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int imageIndex);
   } drawImageCursor;
   // inline static void register_drawImageCursor(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::FunctionType func)

   struct FontManagerRenderer_drawImageFloat_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer & , /*6Fj*/float targetx, /*6Fj*/float targety, /*6Fj*/float angsin, /*6Fj*/float angcos, /*6Fj*/int imageIndex, /*6Fj*/bool useExtColor);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/float targetx, /*6Fj*/float targety, /*6Fj*/float angsin, /*6Fj*/float angcos, /*6Fj*/int imageIndex, /*6Fj*/bool useExtColor);
   } drawImageFloat;
   // inline static void register_drawImageFloat(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::FunctionType func)

   struct FontManagerRenderer_flush_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } flush;
   // inline static void register_flush(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_flush_Functor::FunctionType func)

   struct FontManagerRenderer_init_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(FontManagerRenderer & , /*6Fj*/int channelCount);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int channelCount);
   } init;
   // inline static void register_init(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_init_Functor::FunctionType func)

   struct FontManagerRenderer_registerImage_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(FontManagerRenderer & , /*6Fj*/int offsetx, /*6Fj*/int offsety, /*6Fj*/int width, /*6Fj*/int height);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( /*6Fj*/int offsetx, /*6Fj*/int offsety, /*6Fj*/int width, /*6Fj*/int height);
   } registerImage;
   // inline static void register_registerImage(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_registerImage_Functor::FunctionType func)

   struct FontManagerRenderer_resetImages_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } resetImages;
   // inline static void register_resetImages(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_resetImages_Functor::FunctionType func)

   struct FontManagerRenderer_resizeTexture_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(FontManagerRenderer & , /*6Fj*/int width, /*6Fj*/int height);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( /*6Fj*/int width, /*6Fj*/int height);
   } resizeTexture;
   // inline static void register_resizeTexture(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::FunctionType func)

   struct FontManagerRenderer_setLayer_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer & , /*6Fj*/uint layerIndex);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/uint layerIndex);
   } setLayer;
   // inline static void register_setLayer(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_setLayer_Functor::FunctionType func)

   struct FontManagerRenderer_updateTexture_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManagerRenderer & , /*6Fj*/int * rect, /*6Fj*/const unsigned char * data);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int * rect, /*6Fj*/const unsigned char * data);
   } updateTexture;
   // inline static void register_updateTexture(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct fm_Prop
   {
      constexpr fm_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FontManager operator= (/*0H*/FontManager v);
      /*regSet*/inline FontManagerRenderer::fm_Prop & operator= (FontManagerRenderer::fm_Prop & prop);
      /*regGet*/inline operator /*0I*/FontManager () const;
   } fm;
};


#define REG_Resource(c) \
      Resource::class_registration(_cpp_class);

#define RESOURCE_VIRTUAL_METHODS_PROTO(c) \

#define RESOURCE_VIRTUAL_METHODS(c) \

class Resource : public Instance
{
public:
   inline Resource(Resource && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Resource & operator= (Resource && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Resource() : Resource((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Resource> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Resource * inst = new Resource(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Resource * inst = (Resource *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Resource & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Resource(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

enum class Alignment : int
{
   left = Alignment_left,
   right = Alignment_right,
   center = Alignment_center
};

enum class AlphaWriteMode : int
{
   dontWrite = AlphaWriteMode_dontWrite,
   write = AlphaWriteMode_write,
   blend = AlphaWriteMode_blend
};


#define REG_BitmapFormat(c) \
      BitmapFormat::class_registration(_cpp_class);

#define BITMAPFORMAT_VIRTUAL_METHODS_PROTO(c) \

#define BITMAPFORMAT_VIRTUAL_METHODS(c) \

class BitmapFormat : public Instance
{
public:
   inline BitmapFormat(BitmapFormat && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline BitmapFormat & operator= (BitmapFormat && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   BitmapFormat() : BitmapFormat((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<BitmapFormat> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         BitmapFormat * inst = new BitmapFormat(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      BitmapFormat * inst = (BitmapFormat *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(BitmapFormat & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline BitmapFormat(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_BitmapResource(c) \
      BitmapResource::class_registration(_cpp_class);

#define BITMAPRESOURCE_VIRTUAL_METHODS_PROTO(c) \

#define BITMAPRESOURCE_VIRTUAL_METHODS(c) \

class BitmapResource : public Resource
{
public:
   inline BitmapResource(BitmapResource && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline BitmapResource & operator= (BitmapResource && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   BitmapResource() : BitmapResource((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<BitmapResource> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         BitmapResource * inst = new BitmapResource(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      BitmapResource * inst = (BitmapResource *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(BitmapResource & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline BitmapResource(C(Instance) _impl, CPPClass & cl = _cpp_class) : Resource(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline BitmapResource(const char * fileName, bool grayed, bool monochrome, bool transparent, bool alphaBlend, bool mipMaps, bool keepData);

   struct fileName_Prop
   {
      constexpr fileName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline BitmapResource::fileName_Prop & operator= (BitmapResource::fileName_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } fileName;
   struct grayed_Prop
   {
      constexpr grayed_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BitmapResource::grayed_Prop & operator= (BitmapResource::grayed_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } grayed;
   struct monochrome_Prop
   {
      constexpr monochrome_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BitmapResource::monochrome_Prop & operator= (BitmapResource::monochrome_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } monochrome;
   struct transparent_Prop
   {
      constexpr transparent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BitmapResource::transparent_Prop & operator= (BitmapResource::transparent_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } transparent;
   struct alphaBlend_Prop
   {
      constexpr alphaBlend_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BitmapResource::alphaBlend_Prop & operator= (BitmapResource::alphaBlend_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alphaBlend;
   struct mipMaps_Prop
   {
      constexpr mipMaps_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BitmapResource::mipMaps_Prop & operator= (BitmapResource::mipMaps_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } mipMaps;
   struct keepData_Prop
   {
      constexpr keepData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BitmapResource::keepData_Prop & operator= (BitmapResource::keepData_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } keepData;
   struct bitmap_Prop
   {
      constexpr bitmap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Bitmap & operator= (/*0A*/const Bitmap & v);
      /*regSet*/inline BitmapResource::bitmap_Prop & operator= (BitmapResource::bitmap_Prop & prop);
      /*nstSet*/inline /*0C*/const Bitmap * operator= (/*0C*/const Bitmap * v);
      /*regGet*/inline operator /*0B*/TIH<Bitmap> () const;
      /*regGet*/inline TIH<Bitmap> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Bitmap () const;
      /*regGet*/inline operator /*0F*/Bitmap* () const;
   } bitmap;
   struct window_Prop
   {
      constexpr window_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
   } window;
};

enum class ClearType : int
{
   colorBuffer = ClearType_colorBuffer,
   depthBuffer = ClearType_depthBuffer,
   colorAndDepth = ClearType_colorAndDepth
};

class Color444
{
public:
   C(Color444) impl;
   constexpr Color444() : impl(0) { }
   constexpr Color444(C(Color444) impl) : impl(impl) { }
   Color444(unsigned char r, unsigned char g, unsigned char b)
   {
      impl = COLOR444(r, g, b);
   }
   operator C(Color444)() { return impl; }
   Color444 & operator =(C(Color444) impl) { impl = impl; return *this; }
   bool operator ==(const Color444 & value) const { return impl == value.impl; }
   bool operator !=(const Color444 & value) const { return impl != value.impl; }
   inline constexpr operator Color() const;
   inline constexpr Color444(const Color & c);
   inline constexpr Color444 & operator =(const Color & c);

   struct r_Prop
   {
      constexpr r_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color444::r_Prop & operator= (Color444::r_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } r;
   struct g_Prop
   {
      constexpr g_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color444::g_Prop & operator= (Color444::g_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } g;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color444::b_Prop & operator= (Color444::b_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } b;
};

class Color555
{
public:
   C(Color555) impl;
   constexpr Color555() : impl(0) { }
   constexpr Color555(C(Color555) impl) : impl(impl) { }
   Color555(unsigned char r, unsigned char g, unsigned char b)
   {
      impl = COLOR555(r, g, b);
   }
   operator C(Color555)() { return impl; }
   Color555 & operator =(C(Color555) impl) { impl = impl; return *this; }
   bool operator ==(const Color555 & value) const { return impl == value.impl; }
   bool operator !=(const Color555 & value) const { return impl != value.impl; }
   inline constexpr operator Color() const;
   inline constexpr Color555(const Color & c);
   inline constexpr Color555 & operator =(const Color & c);

   struct r_Prop
   {
      constexpr r_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color555::r_Prop & operator= (Color555::r_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } r;
   struct g_Prop
   {
      constexpr g_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color555::g_Prop & operator= (Color555::g_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } g;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color555::b_Prop & operator= (Color555::b_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } b;
};

class Color565
{
public:
   C(Color565) impl;
   constexpr Color565() : impl(0) { }
   constexpr Color565(C(Color565) impl) : impl(impl) { }
   Color565(unsigned char r, unsigned char g, unsigned char b)
   {
      impl = COLOR565(r, g, b);
   }
   operator C(Color565)() { return impl; }
   Color565 & operator =(C(Color565) impl) { impl = impl; return *this; }
   bool operator ==(const Color565 & value) const { return impl == value.impl; }
   bool operator !=(const Color565 & value) const { return impl != value.impl; }
   inline constexpr operator Color() const;
   inline constexpr Color565(const Color & c);
   inline constexpr Color565 & operator =(const Color & c);

   struct r_Prop
   {
      constexpr r_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color565::r_Prop & operator= (Color565::r_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } r;
   struct g_Prop
   {
      constexpr g_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color565::g_Prop & operator= (Color565::g_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } g;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline Color565::b_Prop & operator= (Color565::b_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } b;
};

struct ColorCMYK : public TStruct<ColorCMYK>
{
public:
   C(ColorCMYK) impl;
   constexpr ColorCMYK() : impl({}) { }
   constexpr ColorCMYK(const C(ColorCMYK) impl) : impl(impl) { }
   inline operator ColorRGB() const;
   inline ColorCMYK(const ColorRGB & c);
   inline ColorCMYK & operator =(const ColorRGB & c);

   inline ColorCMYK(float c, float m, float y, float k);

   struct c_Prop
   {
      constexpr c_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorCMYK::c_Prop & operator= (ColorCMYK::c_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } c;
   struct m_Prop
   {
      constexpr m_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorCMYK::m_Prop & operator= (ColorCMYK::m_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } m;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorCMYK::y_Prop & operator= (ColorCMYK::y_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } y;
   struct k_Prop
   {
      constexpr k_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorCMYK::k_Prop & operator= (ColorCMYK::k_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } k;
};

struct ColorHSV : public TStruct<ColorHSV>
{
public:
   C(ColorHSV) impl;
   constexpr ColorHSV() : impl({}) { }
   constexpr ColorHSV(const C(ColorHSV) impl) : impl(impl) { }
   inline operator ColorRGB() const;
   inline ColorHSV(const ColorRGB & c);
   inline ColorHSV & operator =(const ColorRGB & c);

   inline ColorHSV(Degrees h, float s, float v);

   struct h_Prop
   {
      constexpr h_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline ColorHSV::h_Prop & operator= (ColorHSV::h_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } h;
   struct s_Prop
   {
      constexpr s_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorHSV::s_Prop & operator= (ColorHSV::s_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } s;
   struct v_Prop
   {
      constexpr v_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorHSV::v_Prop & operator= (ColorHSV::v_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } v;
};

struct ColorKey : public TStruct<ColorKey>
{
public:
   C(ColorKey) impl;
   constexpr ColorKey() : impl({}) { }
   constexpr ColorKey(const C(ColorKey) impl) : impl(impl) { }

   inline ColorKey(ColorAlpha color, float percent);

   struct color_Prop
   {
      constexpr color_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha operator= (/*0H*/ColorAlpha v);
      /*regSet*/inline ColorKey::color_Prop & operator= (ColorKey::color_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha () const;
   } color;
   struct percent_Prop
   {
      constexpr percent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorKey::percent_Prop & operator= (ColorKey::percent_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } percent;
};

struct ColorLab : public TStruct<ColorLab>
{
public:
   C(ColorLab) impl;
   constexpr ColorLab() : impl({}) { }
   constexpr ColorLab(const C(ColorLab) impl) : impl(impl) { }
   inline operator ColorRGB() const;
   inline ColorLab(const ColorRGB & c);
   inline ColorLab & operator =(const ColorRGB & c);

   inline ColorLab(float l, float a, float b);

   struct l_Prop
   {
      constexpr l_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorLab::l_Prop & operator= (ColorLab::l_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } l;
   struct a_Prop
   {
      constexpr a_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorLab::a_Prop & operator= (ColorLab::a_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } a;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorLab::b_Prop & operator= (ColorLab::b_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } b;
};

struct ColorRGB : public TStruct<ColorRGB>
{
public:
   C(ColorRGB) impl;
   constexpr ColorRGB() : impl({}) { }
   constexpr ColorRGB(const C(ColorRGB) impl) : impl(impl) { }
   inline ColorRGB & operator= (Color value);
   inline ColorRGB(Color value);
   inline operator Color() const;
   inline ColorRGB & operator= (DefinedColor value);
   inline ColorRGB(DefinedColor value);
   inline ColorRGB & operator= (SystemColor value);
   inline ColorRGB(SystemColor value);

   inline ColorRGB(float r, float g, float b);

   struct r_Prop
   {
      constexpr r_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorRGB::r_Prop & operator= (ColorRGB::r_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } r;
   struct g_Prop
   {
      constexpr g_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorRGB::g_Prop & operator= (ColorRGB::g_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } g;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorRGB::b_Prop & operator= (ColorRGB::b_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } b;
};

class ColorRGBA
{
public:
   C(ColorRGBA) impl;
   constexpr ColorRGBA() : impl(0) { }
   constexpr ColorRGBA(C(ColorRGBA) impl) : impl(impl) { }
   ColorRGBA(unsigned char r, unsigned char g, unsigned char b, unsigned char a)
   {
      impl = COLORRGBA(r, g, b, a);
   }
   operator C(ColorRGBA)() { return impl; }
   ColorRGBA & operator =(C(ColorRGBA) impl) { impl = impl; return *this; }
   bool operator ==(const ColorRGBA & value) const { return impl == value.impl; }
   bool operator !=(const ColorRGBA & value) const { return impl != value.impl; }
   inline constexpr operator ColorAlpha() const;
   inline constexpr ColorRGBA(const ColorAlpha & c);
   inline constexpr ColorRGBA & operator =(const ColorAlpha & c);
   inline constexpr operator Color() const;
   inline constexpr ColorRGBA(const Color & c);
   inline constexpr ColorRGBA & operator =(const Color & c);

   struct r_Prop
   {
      constexpr r_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline ColorRGBA::r_Prop & operator= (ColorRGBA::r_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } r;
   struct g_Prop
   {
      constexpr g_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline ColorRGBA::g_Prop & operator= (ColorRGBA::g_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } g;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline ColorRGBA::b_Prop & operator= (ColorRGBA::b_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } b;
   struct a_Prop
   {
      constexpr a_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline ColorRGBA::a_Prop & operator= (ColorRGBA::a_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } a;
};

struct ColorRGBAf : public TStruct<ColorRGBAf>
{
public:
   C(ColorRGBAf) impl;
   constexpr ColorRGBAf() : impl({}) { }
   constexpr ColorRGBAf(const C(ColorRGBAf) impl) : impl(impl) { }
   inline operator ColorAlpha() const;
   inline ColorRGBAf(const ColorAlpha & c);
   inline ColorRGBAf & operator =(const ColorAlpha & c);
   inline operator Color() const;
   inline ColorRGBAf(const Color & c);
   inline ColorRGBAf & operator =(const Color & c);

   inline ColorRGBAf(float r, float g, float b, float a);

   struct r_Prop
   {
      constexpr r_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorRGBAf::r_Prop & operator= (ColorRGBAf::r_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } r;
   struct g_Prop
   {
      constexpr g_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorRGBAf::g_Prop & operator= (ColorRGBAf::g_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } g;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorRGBAf::b_Prop & operator= (ColorRGBAf::b_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } b;
   struct a_Prop
   {
      constexpr a_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline ColorRGBAf::a_Prop & operator= (ColorRGBAf::a_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } a;
};


#define REG_CubeMap(c) \
      CubeMap::class_registration(_cpp_class);

#define CUBEMAP_VIRTUAL_METHODS_PROTO(c) \

#define CUBEMAP_VIRTUAL_METHODS(c) \

class CubeMap : public Bitmap
{
public:
   inline CubeMap(CubeMap && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline CubeMap & operator= (CubeMap && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   CubeMap() : CubeMap((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<CubeMap> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         CubeMap * inst = new CubeMap(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      CubeMap * inst = (CubeMap *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(CubeMap & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline CubeMap(C(Instance) _impl, CPPClass & cl = _cpp_class) : Bitmap(_impl, cl) { }

   inline C(bool) load(/*1Ab*/DisplaySystem & displaySystem, constString * names, constString extension, /*1Ab*/bool oldStyle); // CubeMap_load
   inline C(bool) loadFromFiles(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/C(File) files[6], constString extension, /*1Ab*/bool oldStyle); // CubeMap_loadFromFiles

   static void class_registration(CPPClass & _cpp_class);
};

enum class DefinedColor : uint
{
   black = DefinedColor_black,
   dimGray = DefinedColor_dimGray,
   dimGrey = DefinedColor_dimGrey,
   gray = DefinedColor_gray,
   darkGray = DefinedColor_darkGray,
   darkGrey = DefinedColor_darkGrey,
   silver = DefinedColor_silver,
   lightGray = DefinedColor_lightGray,
   lightGrey = DefinedColor_lightGrey,
   gainsboro = DefinedColor_gainsboro,
   whiteSmoke = DefinedColor_whiteSmoke,
   white = DefinedColor_white,
   rosyBrown = DefinedColor_rosyBrown,
   indianRed = DefinedColor_indianRed,
   brown = DefinedColor_brown,
   fireBrick = DefinedColor_fireBrick,
   lightCoral = DefinedColor_lightCoral,
   maroon = DefinedColor_maroon,
   darkRed = DefinedColor_darkRed,
   red = DefinedColor_red,
   snow = DefinedColor_snow,
   mistyRose = DefinedColor_mistyRose,
   salmon = DefinedColor_salmon,
   tomato = DefinedColor_tomato,
   darkSalmon = DefinedColor_darkSalmon,
   coral = DefinedColor_coral,
   orangeRed = DefinedColor_orangeRed,
   lightSalmon = DefinedColor_lightSalmon,
   sienna = DefinedColor_sienna,
   seaShell = DefinedColor_seaShell,
   chocolate = DefinedColor_chocolate,
   saddleBrown = DefinedColor_saddleBrown,
   sandyBrown = DefinedColor_sandyBrown,
   peachPuff = DefinedColor_peachPuff,
   peru = DefinedColor_peru,
   linen = DefinedColor_linen,
   bisque = DefinedColor_bisque,
   darkOrange = DefinedColor_darkOrange,
   burlyWood = DefinedColor_burlyWood,
   tan = DefinedColor_tan,
   antiqueWhite = DefinedColor_antiqueWhite,
   navajoWhite = DefinedColor_navajoWhite,
   blanchedAlmond = DefinedColor_blanchedAlmond,
   papayaWhip = DefinedColor_papayaWhip,
   mocassin = DefinedColor_mocassin,
   moccasin = DefinedColor_moccasin,
   orange = DefinedColor_orange,
   wheat = DefinedColor_wheat,
   oldLace = DefinedColor_oldLace,
   floralWhite = DefinedColor_floralWhite,
   darkGoldenrod = DefinedColor_darkGoldenrod,
   goldenrod = DefinedColor_goldenrod,
   cornsilk = DefinedColor_cornsilk,
   gold = DefinedColor_gold,
   khaki = DefinedColor_khaki,
   lemonChiffon = DefinedColor_lemonChiffon,
   paleGoldenrod = DefinedColor_paleGoldenrod,
   darkKhaki = DefinedColor_darkKhaki,
   beige = DefinedColor_beige,
   lightGoldenRodYellow = DefinedColor_lightGoldenRodYellow,
   olive = DefinedColor_olive,
   yellow = DefinedColor_yellow,
   lightYellow = DefinedColor_lightYellow,
   ivory = DefinedColor_ivory,
   oliveDrab = DefinedColor_oliveDrab,
   yellowGreen = DefinedColor_yellowGreen,
   darkOliveGreen = DefinedColor_darkOliveGreen,
   greenYellow = DefinedColor_greenYellow,
   chartreuse = DefinedColor_chartreuse,
   lawnGreen = DefinedColor_lawnGreen,
   darkSeaGreen = DefinedColor_darkSeaGreen,
   forestGreen = DefinedColor_forestGreen,
   limeGreen = DefinedColor_limeGreen,
   lightGreen = DefinedColor_lightGreen,
   paleGreen = DefinedColor_paleGreen,
   darkGreen = DefinedColor_darkGreen,
   green = DefinedColor_green,
   lime = DefinedColor_lime,
   honeyDew = DefinedColor_honeyDew,
   seaGreen = DefinedColor_seaGreen,
   mediumSeaGreen = DefinedColor_mediumSeaGreen,
   springGreen = DefinedColor_springGreen,
   mintCream = DefinedColor_mintCream,
   mediumSpringGreen = DefinedColor_mediumSpringGreen,
   mediumAquaMarine = DefinedColor_mediumAquaMarine,
   aquamarine = DefinedColor_aquamarine,
   turquoise = DefinedColor_turquoise,
   lightSeaGreen = DefinedColor_lightSeaGreen,
   mediumTurquoise = DefinedColor_mediumTurquoise,
   darkSlateGray = DefinedColor_darkSlateGray,
   darkSlateGrey = DefinedColor_darkSlateGrey,
   paleTurquoise = DefinedColor_paleTurquoise,
   teal = DefinedColor_teal,
   darkCyan = DefinedColor_darkCyan,
   aqua = DefinedColor_aqua,
   cyan = DefinedColor_cyan,
   lightCyan = DefinedColor_lightCyan,
   azure = DefinedColor_azure,
   darkTurquoise = DefinedColor_darkTurquoise,
   cadetBlue = DefinedColor_cadetBlue,
   powderBlue = DefinedColor_powderBlue,
   lightBlue = DefinedColor_lightBlue,
   deepSkyBlue = DefinedColor_deepSkyBlue,
   skyBlue = DefinedColor_skyBlue,
   lightSkyBlue = DefinedColor_lightSkyBlue,
   steelBlue = DefinedColor_steelBlue,
   aliceBlue = DefinedColor_aliceBlue,
   dodgerBlue = DefinedColor_dodgerBlue,
   slateGray = DefinedColor_slateGray,
   slateGrey = DefinedColor_slateGrey,
   lightSlateGray = DefinedColor_lightSlateGray,
   lightSlateGrey = DefinedColor_lightSlateGrey,
   lightSteelBlue = DefinedColor_lightSteelBlue,
   cornflowerBlue = DefinedColor_cornflowerBlue,
   royalBlue = DefinedColor_royalBlue,
   midnightBlue = DefinedColor_midnightBlue,
   lavender = DefinedColor_lavender,
   navy = DefinedColor_navy,
   darkBlue = DefinedColor_darkBlue,
   mediumBlue = DefinedColor_mediumBlue,
   blue = DefinedColor_blue,
   ghostWhite = DefinedColor_ghostWhite,
   slateBlue = DefinedColor_slateBlue,
   darkSlateBlue = DefinedColor_darkSlateBlue,
   mediumSlateBlue = DefinedColor_mediumSlateBlue,
   mediumPurple = DefinedColor_mediumPurple,
   blueViolet = DefinedColor_blueViolet,
   indigo = DefinedColor_indigo,
   darkOrchid = DefinedColor_darkOrchid,
   darkViolet = DefinedColor_darkViolet,
   mediumOrchid = DefinedColor_mediumOrchid,
   thistle = DefinedColor_thistle,
   plum = DefinedColor_plum,
   violet = DefinedColor_violet,
   purple = DefinedColor_purple,
   darkMagenta = DefinedColor_darkMagenta,
   magenta = DefinedColor_magenta,
   fuschia = DefinedColor_fuschia,
   orchid = DefinedColor_orchid,
   mediumVioletRed = DefinedColor_mediumVioletRed,
   deepPink = DefinedColor_deepPink,
   hotPink = DefinedColor_hotPink,
   lavenderBlush = DefinedColor_lavenderBlush,
   paleVioletRed = DefinedColor_paleVioletRed,
   crimson = DefinedColor_crimson,
   pink = DefinedColor_pink,
   lightPink = DefinedColor_lightPink
};


#define REG_Display(c) \
      Display::class_registration(_cpp_class);

#define DISPLAY_VIRTUAL_METHODS_PROTO(c) \

#define DISPLAY_VIRTUAL_METHODS(c) \

class Display : public Instance
{
public:
   inline Display(Display && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Display & operator= (Display && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Display() : Display((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Display> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Display * inst = new Display(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Display * inst = (Display *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Display & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Display(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void applyMaterial(/*1Ab*/Material material, /*1Ab*/Mesh mesh); // Display_applyMaterial
   inline void collectHits(); // Display_collectHits
   inline C(bool) create(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/void * window); // Display_create
   inline C(bool) drawMesh(/*1Ab*/Object object); // Display_drawMesh
   inline C(bool) drawMeshEx(/*1Ab*/Object object, /*1Ab*/uint64 * id); // Display_drawMeshEx
   inline C(bool) drawObject(/*1Ab*/Object object); // Display_drawObject
   inline C(bool) drawObjectEx(/*1Ab*/Object object, /*1Ab*/uint64 * id); // Display_drawObjectEx
   inline void drawPrimitives(/*1Ab*/PrimitiveSingle & primitive, /*1Ab*/Mesh mesh); // Display_drawPrimitives
   inline void drawPrimitives(/*1Ac*/PrimitiveSingle * primitive, /*1Ac*/Mesh mesh); // Display_drawPrimitives
   inline void drawTranslucency(); // Display_drawTranslucency
   inline void endUpdate(); // Display_endUpdate
   inline void fontExtent(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height); // Display_fontExtent
   inline void fontExtent2(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang); // Display_fontExtent2
   inline int getHits(/*1Ab*/OldList & list); // Display_getHits
   inline int getHits(/*1Ac*/OldList * list); // Display_getHits
   inline C(bool) getIntersect(/*1Ab*/Vector3D & intersect); // Display_getIntersect
   inline C(bool) getIntersect(/*1Ac*/Vector3D * intersect); // Display_getIntersect
   inline Surface getSurface(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Box & clip); // Display_getSurface
   inline Surface getSurface(/*1Ac*/int x, /*1Ac*/int y, /*1Ac*/Box * clip); // Display_getSurface
   inline C(bool) grab(/*1Ab*/Bitmap & bitmap, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h); // Display_grab
   inline void intersectPolygons(); // Display_intersectPolygons
   inline C(bool) isObjectVisible(/*1Ab*/Object object); // Display_isObjectVisible
   inline C(bool) lock(/*1Ab*/bool render); // Display_lock
   inline void nextPage(); // Display_nextPage
   inline void popMatrix(); // Display_popMatrix
   inline void position(/*1Ab*/int x, /*1Ab*/int y); // Display_position
   inline void pushMatrix(); // Display_pushMatrix
   inline C(bool) resize(/*1Ab*/int width, /*1Ab*/int height); // Display_resize
   inline void restorePalette(); // Display_restorePalette
   inline void scroll(/*1Ab*/Box & scroll, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Extent & dirty); // Display_scroll
   inline void scroll(/*1Ac*/Box * scroll, /*1Ac*/int x, /*1Ac*/int y, /*1Ac*/Extent * dirty); // Display_scroll
   inline void selectMesh(/*1Ab*/Mesh mesh); // Display_selectMesh
   inline void setCamera(/*1Ab*/Surface & surface, /*1Ab*/const Camera & camera); // Display_setCamera
   inline void setCameraVR(/*1Ab*/Camera & camera, /*1Ab*/int eye, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/GLFB & output, /*1Ab*/const Matrix & prjMat); // Display_setCameraVR
   inline void setCameraVR(/*1Ac*/Camera & camera, /*1Ac*/int eye, /*1Ac*/int w, /*1Ac*/int h, /*1Ac*/GLFB * output, /*1Ac*/const Matrix * prjMat); // Display_setCameraVR
   inline void setLight(/*1Ab*/int id, /*1Ab*/Light & light); // Display_setLight
   inline void setLight(/*1Ac*/int id, /*1Ac*/Light * light); // Display_setLight
   inline void setLights(/*1Ab*/Object object); // Display_setLights
   inline void setPalette(/*1Ab*/ColorAlpha * palette, /*1Ab*/bool colorMatch); // Display_setPalette
   inline void setTransform(/*1Ab*/Matrix & matrix, /*1Ab*/bool viewSpace); // Display_setTransform
   inline void setTransform(/*1Ac*/Matrix * matrix, /*1Ac*/bool viewSpace); // Display_setTransform
   inline void startSelection(/*1Ab*/int pickX, /*1Ab*/int pickY, /*1Ab*/int pickW, /*1Ab*/int pickH); // Display_startSelection
   inline void startUpdate(); // Display_startUpdate
   inline void stopSelection(); // Display_stopSelection
   inline void unlock(); // Display_unlock
   inline void update(/*1Ab*/Box & updateBox); // Display_update
   inline void update(/*1Ac*/Box * updateBox); // Display_update

   static void class_registration(CPPClass & _cpp_class);

   inline Display(FillModeValue fillMode, bool depthTest, bool depthWrite, float fogDensity, Color fogColor, bool blend, Color ambient, bool alphaWrite, bool antiAlias, bool vSync, bool pickingPlanes, int maxFullSort, bool fullProjCheck, bool alphaBlend, bool useSharedMemory, GLCapabilities glCapabilities, int width, int height, void * driverData);

   struct fillMode_Prop
   {
      constexpr fillMode_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/FillModeValue operator= (/*0G*/FillModeValue v);
   } fillMode;
   struct depthTest_Prop
   {
      constexpr depthTest_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } depthTest;
   struct depthWrite_Prop
   {
      constexpr depthWrite_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } depthWrite;
   struct fogDensity_Prop
   {
      constexpr fogDensity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/float operator= (/*0G*/float v);
   } fogDensity;
   struct fogColor_Prop
   {
      constexpr fogColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Color operator= (/*0G*/Color v);
   } fogColor;
   struct blend_Prop
   {
      constexpr blend_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } blend;
   struct ambient_Prop
   {
      constexpr ambient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Color operator= (/*0G*/Color v);
   } ambient;
   struct alphaWrite_Prop
   {
      constexpr alphaWrite_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } alphaWrite;
   struct antiAlias_Prop
   {
      constexpr antiAlias_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } antiAlias;
   struct vSync_Prop
   {
      constexpr vSync_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } vSync;
   struct pickingPlanes_Prop
   {
      constexpr pickingPlanes_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } pickingPlanes;
   struct maxFullSort_Prop
   {
      constexpr maxFullSort_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Display::maxFullSort_Prop & operator= (Display::maxFullSort_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } maxFullSort;
   struct fullProjCheck_Prop
   {
      constexpr fullProjCheck_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Display::fullProjCheck_Prop & operator= (Display::fullProjCheck_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fullProjCheck;
   struct flags_Prop
   {
      constexpr flags_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/DisplayFlags () const;
   } flags;
   struct pixelFormat_Prop
   {
      constexpr pixelFormat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/PixelFormat () const;
   } pixelFormat;
   struct alphaBlend_Prop
   {
      constexpr alphaBlend_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Display::alphaBlend_Prop & operator= (Display::alphaBlend_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alphaBlend;
   struct useSharedMemory_Prop
   {
      constexpr useSharedMemory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Display::useSharedMemory_Prop & operator= (Display::useSharedMemory_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } useSharedMemory;
   struct systemWindow_Prop
   {
      constexpr systemWindow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/void * () const;
   } systemWindow;
   struct displaySystem_Prop
   {
      constexpr displaySystem_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DisplaySystem> () const;
      /*regGet*/inline TIH<DisplaySystem> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DisplaySystem () const;
      /*regGet*/inline operator /*0F*/DisplaySystem* () const;
   } displaySystem;
   struct glCapabilities_Prop
   {
      constexpr glCapabilities_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLCapabilities operator= (/*0H*/GLCapabilities v);
      /*regSet*/inline Display::glCapabilities_Prop & operator= (Display::glCapabilities_Prop & prop);
      /*regGet*/inline operator /*0I*/GLCapabilities () const;
   } glCapabilities;
   struct glVersion_Prop
   {
      constexpr glVersion_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } glVersion;

   struct width_Prop
   {
      constexpr width_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Display::width_Prop & operator= (Display::width_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } width;
   struct height_Prop
   {
      constexpr height_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Display::height_Prop & operator= (Display::height_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } height;
   struct driverData_Prop
   {
      constexpr driverData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline Display::driverData_Prop & operator= (Display::driverData_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } driverData;
};

#define REG_DisplayDriver_allocateBitmap(m, c)       REGVMETHOD(DisplayDriver, allocateBitmap,       c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Bitmap & ap2, /*1Ab*/int ap3, /*1Ab*/int ap4, /*1Ab*/int ap5, /*1Ab*/PixelFormat ap6, /*1Ab*/bool ap7),                                                              c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/ap4, /*4Im*/ap5, /*4Hm*/(PixelFormat)ap6, /*4Hm*/(bool)ap7))
#define REG_DisplayDriver_allocateIndices(m, c)      REGVMETHOD(DisplayDriver, allocateIndices,      c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/int nIndices, /*1Ab*/bool indices32bit),                                                                                                                             c, (/*4Im*/ap1, /*4Im*/nIndices, /*4Hm*/(bool)indices32bit))
#define REG_DisplayDriver_allocateMesh(m, c)         REGVMETHOD(DisplayDriver, allocateMesh,         c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Mesh ap2, /*1Ab*/MeshFeatures ap3, /*1Ab*/int nVertices),                                                                                                            c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(MeshFeatures)ap3, /*4Im*/nVertices))
#define REG_DisplayDriver_applyMaterial(m, c)        REGVMETHOD(DisplayDriver, applyMaterial,        c::m, (/*1Ab*/Display & ap1, /*1Ab*/Material ap2, /*1Ab*/Mesh ap3),                                                                                                                                            c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_area(m, c)                 REGVMETHOD(DisplayDriver, area,                 c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2),                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/x1, /*4Im*/y1, /*4Im*/x2, /*4Im*/y2))
#define REG_DisplayDriver_blit(m, c)                 REGVMETHOD(DisplayDriver, blit,                 c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Bitmap & ap3, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h),                                               c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/dx, /*4Im*/dy, /*4Im*/sx, /*4Im*/sy, /*4Im*/w, /*4Im*/h))
#define REG_DisplayDriver_blitDI(m, c)               REGVMETHOD(DisplayDriver, blitDI,               c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Bitmap & ap3, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h),                                               c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/dx, /*4Im*/dy, /*4Im*/sx, /*4Im*/sy, /*4Im*/w, /*4Im*/h))
#define REG_DisplayDriver_clear(m, c)                REGVMETHOD(DisplayDriver, clear,                c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/ClearType ap3),                                                                                                                                      c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(ClearType)ap3))
#define REG_DisplayDriver_clip(m, c)                 REGVMETHOD(DisplayDriver, clip,                 c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Box & ap3),                                                                                                                                          c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_convertBitmap(m, c)        REGVMETHOD(DisplayDriver, convertBitmap,        c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Bitmap & ap2, /*1Ab*/PixelFormat ap3, /*1Ab*/ColorAlpha * ap4),                                                                                                      c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(PixelFormat)ap3, /*4Hm*/(ColorAlpha *)ap4))
#define REG_DisplayDriver_createDisplay(m, c)        REGVMETHOD(DisplayDriver, createDisplay,        c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_createDisplaySystem(m, c)  REGVMETHOD(DisplayDriver, createDisplaySystem,  c::m, (/*1Ab*/DisplaySystem & ap1),                                                                                                                                                                            c, (/*4Im*/ap1))
#define REG_DisplayDriver_destroyDisplay(m, c)       REGVMETHOD(DisplayDriver, destroyDisplay,       c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_destroyDisplaySystem(m, c) REGVMETHOD(DisplayDriver, destroyDisplaySystem, c::m, (/*1Ab*/DisplaySystem & ap1),                                                                                                                                                                            c, (/*4Im*/ap1))
#define REG_DisplayDriver_displayPosition(m, c)      REGVMETHOD(DisplayDriver, displayPosition,      c::m, (/*1Ab*/Display & ap1, /*1Ab*/int ap2, /*1Ab*/int ap3),                                                                                                                                                  c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_displaySize(m, c)          REGVMETHOD(DisplayDriver, displaySize,          c::m, (/*1Ab*/Display & ap1, /*1Ab*/int ap2, /*1Ab*/int ap3),                                                                                                                                                  c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_drawLine(m, c)             REGVMETHOD(DisplayDriver, drawLine,             c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2),                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/x1, /*4Im*/y1, /*4Im*/x2, /*4Im*/y2))
#define REG_DisplayDriver_drawPrimitives(m, c)       REGVMETHOD(DisplayDriver, drawPrimitives,       c::m, (/*1Ab*/Display & ap1, /*1Ab*/PrimitiveSingle & ap2, /*1Ab*/Mesh mesh),                                                                                                                                  c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/mesh))
#define REG_DisplayDriver_drawingChar(m, c)          REGVMETHOD(DisplayDriver, drawingChar,          c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/char ch),                                                                                                                                            c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ch))
#define REG_DisplayDriver_endUpdate(m, c)            REGVMETHOD(DisplayDriver, endUpdate,            c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_filter(m, c)               REGVMETHOD(DisplayDriver, filter,               c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Bitmap & ap3, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh),                 c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/dx, /*4Im*/dy, /*4Im*/sx, /*4Im*/sy, /*4Im*/w, /*4Im*/h, /*4Im*/sw, /*4Im*/sh))
#define REG_DisplayDriver_filterDI(m, c)             REGVMETHOD(DisplayDriver, filterDI,             c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Bitmap & ap3, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh),                 c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/dx, /*4Im*/dy, /*4Im*/sx, /*4Im*/sy, /*4Im*/w, /*4Im*/h, /*4Im*/sw, /*4Im*/sh))
#define REG_DisplayDriver_fontExtent(m, c)           REGVMETHOD(DisplayDriver, fontExtent,           c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Font ap2, constString text, /*1Ab*/int len, /*1Ab*/int * tw, /*1Ab*/int * th, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang),                 c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/text, /*4Im*/len, /*4Im*/tw, /*4Im*/th, /*4Im*/prevGlyph, /*4Im*/rPrevGlyph, /*4Im*/overHang))
#define REG_DisplayDriver_freeBitmap(m, c)           REGVMETHOD(DisplayDriver, freeBitmap,           c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Bitmap & ap2),                                                                                                                                                       c, (/*4Im*/ap1, /*4Im*/ap2))
#define REG_DisplayDriver_freeIndices(m, c)          REGVMETHOD(DisplayDriver, freeIndices,          c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/PrimitiveSingle & group),                                                                                                                                            c, (/*4Im*/ap1, /*4Im*/group))
#define REG_DisplayDriver_freeMesh(m, c)             REGVMETHOD(DisplayDriver, freeMesh,             c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Mesh ap2),                                                                                                                                                           c, (/*4Im*/ap1, /*4Im*/ap2))
#define REG_DisplayDriver_getBitmapSurface(m, c)     REGVMETHOD(DisplayDriver, getBitmapSurface,     c::m, (/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/Surface & surface, /*1Ab*/Bitmap & bitmap, /*1Ab*/int ap1, /*1Ab*/int ap2, /*1Ab*/Box & ap3),                                                              c, (/*4Im*/displaySystem, /*4Im*/surface, /*4Im*/bitmap, /*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_getPixel(m, c)             REGVMETHOD(DisplayDriver, getPixel,             c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/int x, /*1Ab*/int y),                                                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/x, /*4Im*/y))
#define REG_DisplayDriver_getSurface(m, c)           REGVMETHOD(DisplayDriver, getSurface,           c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & surface, /*1Ab*/int ap2, /*1Ab*/int ap3, /*1Ab*/Box & ap4),                                                                                                      c, (/*4Im*/ap1, /*4Im*/surface, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/ap4))
#define REG_DisplayDriver_grabScreen(m, c)           REGVMETHOD(DisplayDriver, grabScreen,           c::m, (/*1Ab*/Display & ap1, /*1Ab*/Bitmap & ap2, /*1Ab*/int ap3, /*1Ab*/int ap4, /*1Ab*/uint ap5, /*1Ab*/uint ap6),                                                                                           c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/ap4, /*4Im*/ap5, /*4Im*/ap6))
#define REG_DisplayDriver_lineStipple(m, c)          REGVMETHOD(DisplayDriver, lineStipple,          c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/uint pattern),                                                                                                                                       c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/pattern))
#define REG_DisplayDriver_loadFont(m, c)             REGVMETHOD(DisplayDriver, loadFont,             c::m, (/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/const char * faceName, /*1Ab*/float size, /*1Ab*/FontFlags flags, /*1Ab*/float outlineSize, /*1Ab*/float outlineFade),                                     c, (/*4Im*/displaySystem, /*4Im*/faceName, /*4Im*/size, /*4Hm*/(FontFlags)flags, /*4Im*/outlineSize, /*4Im*/outlineFade))
#define REG_DisplayDriver_lock(m, c)                 REGVMETHOD(DisplayDriver, lock,                 c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_lockIndices(m, c)          REGVMETHOD(DisplayDriver, lockIndices,          c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/PrimitiveSingle & group),                                                                                                                                            c, (/*4Im*/ap1, /*4Im*/group))
#define REG_DisplayDriver_lockMesh(m, c)             REGVMETHOD(DisplayDriver, lockMesh,             c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Mesh ap2, /*1Ab*/MeshFeatures flags),                                                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(MeshFeatures)flags))
#define REG_DisplayDriver_lockSystem(m, c)           REGVMETHOD(DisplayDriver, lockSystem,           c::m, (/*1Ab*/DisplaySystem & displaySystem),                                                                                                                                                                  c, (/*4Im*/displaySystem))
#define REG_DisplayDriver_makeDDBitmap(m, c)         REGVMETHOD(DisplayDriver, makeDDBitmap,         c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Bitmap & ap2, /*1Ab*/bool mipMaps, /*1Ab*/int cubeMapFace),                                                                                                          c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(bool)mipMaps, /*4Im*/cubeMapFace))
#define REG_DisplayDriver_nextPage(m, c)             REGVMETHOD(DisplayDriver, nextPage,             c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_popMatrix(m, c)            REGVMETHOD(DisplayDriver, popMatrix,            c::m, (/*1Ab*/Display & ap1, /*1Ab*/bool ap2),                                                                                                                                                                 c, (/*4Im*/ap1, /*4Hm*/(bool)ap2))
#define REG_DisplayDriver_pushMatrix(m, c)           REGVMETHOD(DisplayDriver, pushMatrix,           c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_putPixel(m, c)             REGVMETHOD(DisplayDriver, putPixel,             c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/int x, /*1Ab*/int y),                                                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/x, /*4Im*/y))
#define REG_DisplayDriver_rectangle(m, c)            REGVMETHOD(DisplayDriver, rectangle,            c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2),                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/x1, /*4Im*/y1, /*4Im*/x2, /*4Im*/y2))
#define REG_DisplayDriver_releaseSurface(m, c)       REGVMETHOD(DisplayDriver, releaseSurface,       c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2),                                                                                                                                                            c, (/*4Im*/ap1, /*4Im*/ap2))
#define REG_DisplayDriver_restorePalette(m, c)       REGVMETHOD(DisplayDriver, restorePalette,       c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_scroll(m, c)               REGVMETHOD(DisplayDriver, scroll,               c::m, (/*1Ab*/Display & ap1, /*1Ab*/Box & ap2, /*1Ab*/int ap3, /*1Ab*/int ap4, /*1Ab*/Extent & ap5),                                                                                                           c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/ap4, /*4Im*/ap5))
#define REG_DisplayDriver_selectMesh(m, c)           REGVMETHOD(DisplayDriver, selectMesh,           c::m, (/*1Ab*/Display & ap1, /*1Ab*/Mesh ap2),                                                                                                                                                                 c, (/*4Im*/ap1, /*4Im*/ap2))
#define REG_DisplayDriver_setBackground(m, c)        REGVMETHOD(DisplayDriver, setBackground,        c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/ColorAlpha ap3),                                                                                                                                     c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(ColorAlpha)ap3))
#define REG_DisplayDriver_setBlitTint(m, c)          REGVMETHOD(DisplayDriver, setBlitTint,          c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/ColorAlpha ap3),                                                                                                                                     c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(ColorAlpha)ap3))
#define REG_DisplayDriver_setCamera(m, c)            REGVMETHOD(DisplayDriver, setCamera,            c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Camera & ap3),                                                                                                                                       c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_setCameraVR(m, c)          REGVMETHOD(DisplayDriver, setCameraVR,          c::m, (/*1Ab*/Display & ap1, /*1Ab*/Camera & ap2, /*1Ab*/int eye, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/void * fb, /*1Ab*/const Matrix & prjMat),                                                                 c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/eye, /*4Im*/w, /*4Im*/h, /*4Im*/fb, /*4Im*/prjMat))
#define REG_DisplayDriver_setForeground(m, c)        REGVMETHOD(DisplayDriver, setForeground,        c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/ColorAlpha ap3),                                                                                                                                     c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(ColorAlpha)ap3))
#define REG_DisplayDriver_setLight(m, c)             REGVMETHOD(DisplayDriver, setLight,             c::m, (/*1Ab*/Display & ap1, /*1Ab*/int ap2, /*1Ab*/Light & ap3),                                                                                                                                              c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_setPalette(m, c)           REGVMETHOD(DisplayDriver, setPalette,           c::m, (/*1Ab*/Display & ap1, /*1Ab*/ColorAlpha * ap2, /*1Ab*/bool ap3),                                                                                                                                        c, (/*4Im*/ap1, /*4Hm*/(ColorAlpha *)ap2, /*4Hm*/(bool)ap3))
#define REG_DisplayDriver_setRenderState(m, c)       REGVMETHOD(DisplayDriver, setRenderState,       c::m, (/*1Ab*/Display & ap1, /*1Ab*/RenderState ap2, /*1Ab*/uint ap3),                                                                                                                                         c, (/*4Im*/ap1, /*4Hm*/(RenderState)ap2, /*4Im*/ap3))
#define REG_DisplayDriver_setTransform(m, c)         REGVMETHOD(DisplayDriver, setTransform,         c::m, (/*1Ab*/Display & ap1, /*1Ab*/Matrix & ap2, /*1Ab*/bool ap3, /*1Ab*/bool ap4),                                                                                                                           c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(bool)ap3, /*4Hm*/(bool)ap4))
#define REG_DisplayDriver_startUpdate(m, c)          REGVMETHOD(DisplayDriver, startUpdate,          c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_stretch(m, c)              REGVMETHOD(DisplayDriver, stretch,              c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Bitmap & ap3, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh),                 c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/dx, /*4Im*/dy, /*4Im*/sx, /*4Im*/sy, /*4Im*/w, /*4Im*/h, /*4Im*/sw, /*4Im*/sh))
#define REG_DisplayDriver_stretchDI(m, c)            REGVMETHOD(DisplayDriver, stretchDI,            c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Bitmap & ap3, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh),                 c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/dx, /*4Im*/dy, /*4Im*/sx, /*4Im*/sy, /*4Im*/w, /*4Im*/h, /*4Im*/sw, /*4Im*/sh))
#define REG_DisplayDriver_stretchf(m, c)             REGVMETHOD(DisplayDriver, stretchf,             c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Bitmap & ap3, /*1Ab*/float dx, /*1Ab*/float dy, /*1Ab*/float sx, /*1Ab*/float sy, /*1Ab*/float w, /*1Ab*/float h, /*1Ab*/float sw, /*1Ab*/float sh), c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/dx, /*4Im*/dy, /*4Im*/sx, /*4Im*/sy, /*4Im*/w, /*4Im*/h, /*4Im*/sw, /*4Im*/sh))
#define REG_DisplayDriver_textExtent(m, c)           REGVMETHOD(DisplayDriver, textExtent,           c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, constString text, /*1Ab*/int len, /*1Ab*/int * tw, /*1Ab*/int * th, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang),                  c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/text, /*4Im*/len, /*4Im*/tw, /*4Im*/th, /*4Im*/prevGlyph, /*4Im*/rPrevGlyph, /*4Im*/overHang))
#define REG_DisplayDriver_textFont(m, c)             REGVMETHOD(DisplayDriver, textFont,             c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/Font ap3),                                                                                                                                           c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3))
#define REG_DisplayDriver_textOpacity(m, c)          REGVMETHOD(DisplayDriver, textOpacity,          c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/bool ap3),                                                                                                                                           c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(bool)ap3))
#define REG_DisplayDriver_unloadFont(m, c)           REGVMETHOD(DisplayDriver, unloadFont,           c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Font ap2),                                                                                                                                                           c, (/*4Im*/ap1, /*4Im*/ap2))
#define REG_DisplayDriver_unlock(m, c)               REGVMETHOD(DisplayDriver, unlock,               c::m, (/*1Ab*/Display & ap1),                                                                                                                                                                                  c, (/*4Im*/ap1))
#define REG_DisplayDriver_unlockIndices(m, c)        REGVMETHOD(DisplayDriver, unlockIndices,        c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/PrimitiveSingle & group, /*1Ab*/bool indices32bit, /*1Ab*/int nIndices, /*1Ab*/void * maeb),                                                                         c, (/*4Im*/ap1, /*4Im*/group, /*4Hm*/(bool)indices32bit, /*4Im*/nIndices, /*4Im*/maeb))
#define REG_DisplayDriver_unlockMesh(m, c)           REGVMETHOD(DisplayDriver, unlockMesh,           c::m, (/*1Ab*/DisplaySystem & ap1, /*1Ab*/Mesh ap2, /*1Ab*/MeshFeatures flags),                                                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2, /*4Hm*/(MeshFeatures)flags))
#define REG_DisplayDriver_unlockSystem(m, c)         REGVMETHOD(DisplayDriver, unlockSystem,         c::m, (/*1Ab*/DisplaySystem & displaySystem),                                                                                                                                                                  c, (/*4Im*/displaySystem))
#define REG_DisplayDriver_update(m, c)               REGVMETHOD(DisplayDriver, update,               c::m, (/*1Ab*/Display & ap1, /*1Ab*/Box & ap2),                                                                                                                                                                c, (/*4Im*/ap1, /*4Im*/ap2))
#define REG_DisplayDriver_writeText(m, c)            REGVMETHOD(DisplayDriver, writeText,            c::m, (/*1Ab*/Display & ap1, /*1Ab*/Surface & ap2, /*1Ab*/int x, /*1Ab*/int y, constString text, /*1Ab*/int len, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph),                                               c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/x, /*4Im*/y, /*4Im*/text, /*4Im*/len, /*4Im*/prevGlyph, /*4Im*/rPrevGlyph))

#define REG_DisplayDriver(c) \
      DisplayDriver::class_registration(_cpp_class); \
      REG_DisplayDriver_allocateBitmap(allocateBitmap, c); \
      REG_DisplayDriver_allocateIndices(allocateIndices, c); \
      REG_DisplayDriver_allocateMesh(allocateMesh, c); \
      REG_DisplayDriver_applyMaterial(applyMaterial, c); \
      REG_DisplayDriver_area(area, c); \
      REG_DisplayDriver_blit(blit, c); \
      REG_DisplayDriver_blitDI(blitDI, c); \
      REG_DisplayDriver_clear(clear, c); \
      REG_DisplayDriver_clip(clip, c); \
      REG_DisplayDriver_convertBitmap(convertBitmap, c); \
      REG_DisplayDriver_createDisplay(createDisplay, c); \
      REG_DisplayDriver_createDisplaySystem(createDisplaySystem, c); \
      REG_DisplayDriver_destroyDisplay(destroyDisplay, c); \
      REG_DisplayDriver_destroyDisplaySystem(destroyDisplaySystem, c); \
      REG_DisplayDriver_displayPosition(displayPosition, c); \
      REG_DisplayDriver_displaySize(displaySize, c); \
      REG_DisplayDriver_drawLine(drawLine, c); \
      REG_DisplayDriver_drawPrimitives(drawPrimitives, c); \
      REG_DisplayDriver_drawingChar(drawingChar, c); \
      REG_DisplayDriver_endUpdate(endUpdate, c); \
      REG_DisplayDriver_filter(filter, c); \
      REG_DisplayDriver_filterDI(filterDI, c); \
      REG_DisplayDriver_fontExtent(fontExtent, c); \
      REG_DisplayDriver_freeBitmap(freeBitmap, c); \
      REG_DisplayDriver_freeIndices(freeIndices, c); \
      REG_DisplayDriver_freeMesh(freeMesh, c); \
      REG_DisplayDriver_getBitmapSurface(getBitmapSurface, c); \
      REG_DisplayDriver_getPixel(getPixel, c); \
      REG_DisplayDriver_getSurface(getSurface, c); \
      REG_DisplayDriver_grabScreen(grabScreen, c); \
      REG_DisplayDriver_lineStipple(lineStipple, c); \
      REG_DisplayDriver_loadFont(loadFont, c); \
      REG_DisplayDriver_lock(lock, c); \
      REG_DisplayDriver_lockIndices(lockIndices, c); \
      REG_DisplayDriver_lockMesh(lockMesh, c); \
      REG_DisplayDriver_lockSystem(lockSystem, c); \
      REG_DisplayDriver_makeDDBitmap(makeDDBitmap, c); \
      REG_DisplayDriver_nextPage(nextPage, c); \
      REG_DisplayDriver_popMatrix(popMatrix, c); \
      REG_DisplayDriver_pushMatrix(pushMatrix, c); \
      REG_DisplayDriver_putPixel(putPixel, c); \
      REG_DisplayDriver_rectangle(rectangle, c); \
      REG_DisplayDriver_releaseSurface(releaseSurface, c); \
      REG_DisplayDriver_restorePalette(restorePalette, c); \
      REG_DisplayDriver_scroll(scroll, c); \
      REG_DisplayDriver_selectMesh(selectMesh, c); \
      REG_DisplayDriver_setBackground(setBackground, c); \
      REG_DisplayDriver_setBlitTint(setBlitTint, c); \
      REG_DisplayDriver_setCamera(setCamera, c); \
      REG_DisplayDriver_setCameraVR(setCameraVR, c); \
      REG_DisplayDriver_setForeground(setForeground, c); \
      REG_DisplayDriver_setLight(setLight, c); \
      REG_DisplayDriver_setPalette(setPalette, c); \
      REG_DisplayDriver_setRenderState(setRenderState, c); \
      REG_DisplayDriver_setTransform(setTransform, c); \
      REG_DisplayDriver_startUpdate(startUpdate, c); \
      REG_DisplayDriver_stretch(stretch, c); \
      REG_DisplayDriver_stretchDI(stretchDI, c); \
      REG_DisplayDriver_stretchf(stretchf, c); \
      REG_DisplayDriver_textExtent(textExtent, c); \
      REG_DisplayDriver_textFont(textFont, c); \
      REG_DisplayDriver_textOpacity(textOpacity, c); \
      REG_DisplayDriver_unloadFont(unloadFont, c); \
      REG_DisplayDriver_unlock(unlock, c); \
      REG_DisplayDriver_unlockIndices(unlockIndices, c); \
      REG_DisplayDriver_unlockMesh(unlockMesh, c); \
      REG_DisplayDriver_unlockSystem(unlockSystem, c); \
      REG_DisplayDriver_update(update, c); \
      REG_DisplayDriver_writeText(writeText, c);

#define DISPLAYDRIVER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(allocateBitmap, allocateBitmap, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/int ap5 _ARG /*6Fj*/PixelFormat ap6 _ARG /*6Fj*/bool ap7); \
   VIRTUAL_METHOD_PROTO(allocateIndices, allocateIndices, c, DisplayDriver, \
      void *, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/int nIndices _ARG /*6Fj*/bool indices32bit); \
   VIRTUAL_METHOD_PROTO(allocateMesh, allocateMesh, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2 _ARG /*6Fj*/MeshFeatures ap3 _ARG /*6Fj*/int nVertices); \
   VIRTUAL_METHOD_PROTO(applyMaterial, applyMaterial, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Material ap2 _ARG /*6Fj*/Mesh ap3); \
   VIRTUAL_METHOD_PROTO(area, area, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x1 _ARG /*6Fj*/int y1 _ARG /*6Fj*/int x2 _ARG /*6Fj*/int y2); \
   VIRTUAL_METHOD_PROTO(blit, blit, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h); \
   VIRTUAL_METHOD_PROTO(blitDI, blitDI, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h); \
   VIRTUAL_METHOD_PROTO(clear, clear, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ClearType ap3); \
   VIRTUAL_METHOD_PROTO(clip, clip, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Box & ap3); \
   VIRTUAL_METHOD_PROTO(convertBitmap, convertBitmap, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/PixelFormat ap3 _ARG /*6Fj*/ColorAlpha * ap4); \
   VIRTUAL_METHOD_PROTO(createDisplay, createDisplay, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(createDisplaySystem, createDisplaySystem, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1); \
   VIRTUAL_METHOD_PROTO(destroyDisplay, destroyDisplay, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(destroyDisplaySystem, destroyDisplaySystem, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1); \
   VIRTUAL_METHOD_PROTO(displayPosition, displayPosition, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3); \
   VIRTUAL_METHOD_PROTO(displaySize, displaySize, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3); \
   VIRTUAL_METHOD_PROTO(drawLine, drawLine, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x1 _ARG /*6Fj*/int y1 _ARG /*6Fj*/int x2 _ARG /*6Fj*/int y2); \
   VIRTUAL_METHOD_PROTO(drawPrimitives, drawPrimitives, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/PrimitiveSingle & ap2 _ARG /*6Fj*/Mesh mesh); \
   VIRTUAL_METHOD_PROTO(drawingChar, drawingChar, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/char ch); \
   VIRTUAL_METHOD_PROTO(endUpdate, endUpdate, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(filter, filter, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh); \
   VIRTUAL_METHOD_PROTO(filterDI, filterDI, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh); \
   VIRTUAL_METHOD_PROTO(fontExtent, fontExtent, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Font ap2 _ARG /*6Fj*/constString text _ARG /*6Fj*/int len _ARG /*6Fj*/int * tw _ARG /*6Fj*/int * th _ARG /*6Fj*/int prevGlyph _ARG /*6Fj*/int * rPrevGlyph _ARG /*6Fj*/int * overHang); \
   VIRTUAL_METHOD_PROTO(freeBitmap, freeBitmap, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2); \
   VIRTUAL_METHOD_PROTO(freeIndices, freeIndices, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/PrimitiveSingle & group); \
   VIRTUAL_METHOD_PROTO(freeMesh, freeMesh, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2); \
   VIRTUAL_METHOD_PROTO(getBitmapSurface, getBitmapSurface, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/Bitmap & bitmap _ARG /*6Fj*/int ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/Box & ap3); \
   VIRTUAL_METHOD_PROTO(getPixel, getPixel, c, DisplayDriver, \
      ColorAlpha, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x _ARG /*6Fj*/int y); \
   VIRTUAL_METHOD_PROTO(getSurface, getSurface, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/Box & ap4); \
   VIRTUAL_METHOD_PROTO(grabScreen, grabScreen, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/uint ap5 _ARG /*6Fj*/uint ap6); \
   VIRTUAL_METHOD_PROTO(lineStipple, lineStipple, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/uint pattern); \
   VIRTUAL_METHOD_PROTO(loadFont, loadFont, c, DisplayDriver, \
      Font, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem _ARG /*6Fj*/const char * faceName _ARG /*6Fj*/float size _ARG /*6Fj*/FontFlags flags _ARG /*6Fj*/float outlineSize _ARG /*6Fj*/float outlineFade); \
   VIRTUAL_METHOD_PROTO(lock, lock, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(lockIndices, lockIndices, c, DisplayDriver, \
      uint16 *, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/PrimitiveSingle & group); \
   VIRTUAL_METHOD_PROTO(lockMesh, lockMesh, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2 _ARG /*6Fj*/MeshFeatures flags); \
   VIRTUAL_METHOD_PROTO(lockSystem, lockSystem, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem); \
   VIRTUAL_METHOD_PROTO(makeDDBitmap, makeDDBitmap, c, DisplayDriver, \
      bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/bool mipMaps _ARG /*6Fj*/int cubeMapFace); \
   VIRTUAL_METHOD_PROTO(nextPage, nextPage, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(popMatrix, popMatrix, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/bool ap2); \
   VIRTUAL_METHOD_PROTO(pushMatrix, pushMatrix, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(putPixel, putPixel, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x _ARG /*6Fj*/int y); \
   VIRTUAL_METHOD_PROTO(rectangle, rectangle, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x1 _ARG /*6Fj*/int y1 _ARG /*6Fj*/int x2 _ARG /*6Fj*/int y2); \
   VIRTUAL_METHOD_PROTO(releaseSurface, releaseSurface, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2); \
   VIRTUAL_METHOD_PROTO(restorePalette, restorePalette, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(scroll, scroll, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Box & ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/Extent & ap5); \
   VIRTUAL_METHOD_PROTO(selectMesh, selectMesh, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Mesh ap2); \
   VIRTUAL_METHOD_PROTO(setBackground, setBackground, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ColorAlpha ap3); \
   VIRTUAL_METHOD_PROTO(setBlitTint, setBlitTint, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ColorAlpha ap3); \
   VIRTUAL_METHOD_PROTO(setCamera, setCamera, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Camera & ap3); \
   VIRTUAL_METHOD_PROTO(setCameraVR, setCameraVR, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Camera & ap2 _ARG /*6Fj*/int eye _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/void * fb _ARG /*6Fj*/const Matrix & prjMat); \
   VIRTUAL_METHOD_PROTO(setForeground, setForeground, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ColorAlpha ap3); \
   VIRTUAL_METHOD_PROTO(setLight, setLight, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/Light & ap3); \
   VIRTUAL_METHOD_PROTO(setPalette, setPalette, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/ColorAlpha * ap2 _ARG /*6Fj*/bool ap3); \
   VIRTUAL_METHOD_PROTO(setRenderState, setRenderState, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/RenderState ap2 _ARG /*6Fj*/uint ap3); \
   VIRTUAL_METHOD_PROTO(setTransform, setTransform, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Matrix & ap2 _ARG /*6Fj*/bool ap3 _ARG /*6Fj*/bool ap4); \
   VIRTUAL_METHOD_PROTO(startUpdate, startUpdate, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(stretch, stretch, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh); \
   VIRTUAL_METHOD_PROTO(stretchDI, stretchDI, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh); \
   VIRTUAL_METHOD_PROTO(stretchf, stretchf, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/float dx _ARG /*6Fj*/float dy _ARG /*6Fj*/float sx _ARG /*6Fj*/float sy _ARG /*6Fj*/float w _ARG /*6Fj*/float h _ARG /*6Fj*/float sw _ARG /*6Fj*/float sh); \
   VIRTUAL_METHOD_PROTO(textExtent, textExtent, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/constString text _ARG /*6Fj*/int len _ARG /*6Fj*/int * tw _ARG /*6Fj*/int * th _ARG /*6Fj*/int prevGlyph _ARG /*6Fj*/int * rPrevGlyph _ARG /*6Fj*/int * overHang); \
   VIRTUAL_METHOD_PROTO(textFont, textFont, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Font ap3); \
   VIRTUAL_METHOD_PROTO(textOpacity, textOpacity, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/bool ap3); \
   VIRTUAL_METHOD_PROTO(unloadFont, unloadFont, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Font ap2); \
   VIRTUAL_METHOD_PROTO(unlock, unlock, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1); \
   VIRTUAL_METHOD_PROTO(unlockIndices, unlockIndices, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/PrimitiveSingle & group _ARG /*6Fj*/bool indices32bit _ARG /*6Fj*/int nIndices _ARG /*6Fj*/void * maeb); \
   VIRTUAL_METHOD_PROTO(unlockMesh, unlockMesh, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2 _ARG /*6Fj*/MeshFeatures flags); \
   VIRTUAL_METHOD_PROTO(unlockSystem, unlockSystem, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem); \
   VIRTUAL_METHOD_PROTO(update, update, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Box & ap2); \
   VIRTUAL_METHOD_PROTO(writeText, writeText, c, DisplayDriver, \
      void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/constString text _ARG /*6Fj*/int len _ARG /*6Fj*/int prevGlyph _ARG /*6Fj*/int * rPrevGlyph);

#define DISPLAYDRIVER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(allocateBitmap, allocateBitmap, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/int ap5 _ARG /*6Fj*/PixelFormat ap6 _ARG /*6Fj*/bool ap7, \
   return (bool)DisplayDriver_allocateBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5, /*7Al*/(C(PixelFormat))ap6, /*7Al*/(C(bool))ap7);); \
VIRTUAL_METHOD(allocateIndices, allocateIndices, c, DisplayDriver, \
   void *, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/int nIndices _ARG /*6Fj*/bool indices32bit, \
   return DisplayDriver_allocateIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/nIndices, /*7Al*/(C(bool))indices32bit);); \
VIRTUAL_METHOD(allocateMesh, allocateMesh, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2 _ARG /*6Fj*/MeshFeatures ap3 _ARG /*6Fj*/int nVertices, \
   return (bool)DisplayDriver_allocateMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(MeshFeatures))ap3, /*7Al*/nVertices);); \
VIRTUAL_METHOD(applyMaterial, applyMaterial, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Material ap2 _ARG /*6Fj*/Mesh ap3, \
   DisplayDriver_applyMaterial(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl);); \
VIRTUAL_METHOD(area, area, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x1 _ARG /*6Fj*/int y1 _ARG /*6Fj*/int x2 _ARG /*6Fj*/int y2, \
   DisplayDriver_area(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x1, /*7Al*/y1, /*7Al*/x2, /*7Al*/y2);); \
VIRTUAL_METHOD(blit, blit, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h, \
   DisplayDriver_blit(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h);); \
VIRTUAL_METHOD(blitDI, blitDI, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h, \
   DisplayDriver_blitDI(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h);); \
VIRTUAL_METHOD(clear, clear, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ClearType ap3, \
   DisplayDriver_clear(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ClearType))ap3);); \
VIRTUAL_METHOD(clip, clip, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Box & ap3, \
   DisplayDriver_clip(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/&ap3.impl);); \
VIRTUAL_METHOD(convertBitmap, convertBitmap, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/PixelFormat ap3 _ARG /*6Fj*/ColorAlpha * ap4, \
   return (bool)DisplayDriver_convertBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(PixelFormat))ap3, /*7Al*/(C(ColorAlpha) *)ap4);); \
VIRTUAL_METHOD(createDisplay, createDisplay, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/Display & ap1, \
   return (bool)DisplayDriver_createDisplay(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(createDisplaySystem, createDisplaySystem, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1, \
   return (bool)DisplayDriver_createDisplaySystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(destroyDisplay, destroyDisplay, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1, \
   DisplayDriver_destroyDisplay(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(destroyDisplaySystem, destroyDisplaySystem, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1, \
   DisplayDriver_destroyDisplaySystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(displayPosition, displayPosition, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3, \
   DisplayDriver_displayPosition(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3);); \
VIRTUAL_METHOD(displaySize, displaySize, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3, \
   return (bool)DisplayDriver_displaySize(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3);); \
VIRTUAL_METHOD(drawLine, drawLine, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x1 _ARG /*6Fj*/int y1 _ARG /*6Fj*/int x2 _ARG /*6Fj*/int y2, \
   DisplayDriver_drawLine(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x1, /*7Al*/y1, /*7Al*/x2, /*7Al*/y2);); \
VIRTUAL_METHOD(drawPrimitives, drawPrimitives, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/PrimitiveSingle & ap2 _ARG /*6Fj*/Mesh mesh, \
   DisplayDriver_drawPrimitives(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl, /*7Al*/mesh.impl);); \
VIRTUAL_METHOD(drawingChar, drawingChar, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/char ch, \
   DisplayDriver_drawingChar(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ch);); \
VIRTUAL_METHOD(endUpdate, endUpdate, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1, \
   DisplayDriver_endUpdate(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(filter, filter, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh, \
   DisplayDriver_filter(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);); \
VIRTUAL_METHOD(filterDI, filterDI, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh, \
   DisplayDriver_filterDI(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);); \
VIRTUAL_METHOD(fontExtent, fontExtent, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Font ap2 _ARG /*6Fj*/constString text _ARG /*6Fj*/int len _ARG /*6Fj*/int * tw _ARG /*6Fj*/int * th _ARG /*6Fj*/int prevGlyph _ARG /*6Fj*/int * rPrevGlyph _ARG /*6Fj*/int * overHang, \
   DisplayDriver_fontExtent(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/text, /*7Al*/len, /*7Al*/tw, /*7Al*/th, /*7Al*/prevGlyph, /*7Al*/rPrevGlyph, /*7Al*/overHang);); \
VIRTUAL_METHOD(freeBitmap, freeBitmap, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2, \
   DisplayDriver_freeBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);); \
VIRTUAL_METHOD(freeIndices, freeIndices, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/PrimitiveSingle & group, \
   DisplayDriver_freeIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&group.impl);); \
VIRTUAL_METHOD(freeMesh, freeMesh, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2, \
   DisplayDriver_freeMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);); \
VIRTUAL_METHOD(getBitmapSurface, getBitmapSurface, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/Bitmap & bitmap _ARG /*6Fj*/int ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/Box & ap3, \
   return (bool)DisplayDriver_getBitmapSurface(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl, /*7Al*/surface.impl, /*7Al*/bitmap.impl, /*7Al*/ap1, /*7Al*/ap2, /*7Al*/&ap3.impl);); \
VIRTUAL_METHOD(getPixel, getPixel, c, DisplayDriver, \
   ColorAlpha, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x _ARG /*6Fj*/int y, \
   return DisplayDriver_getPixel(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(getSurface, getSurface, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/Box & ap4, \
   return (bool)DisplayDriver_getSurface(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/surface.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/&ap4.impl);); \
VIRTUAL_METHOD(grabScreen, grabScreen, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/uint ap5 _ARG /*6Fj*/uint ap6, \
   return (bool)DisplayDriver_grabScreen(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5, /*7Al*/ap6);); \
VIRTUAL_METHOD(lineStipple, lineStipple, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/uint pattern, \
   DisplayDriver_lineStipple(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/pattern);); \
VIRTUAL_METHOD(loadFont, loadFont, c, DisplayDriver, \
   Font, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem _ARG /*6Fj*/const char * faceName _ARG /*6Fj*/float size _ARG /*6Fj*/FontFlags flags _ARG /*6Fj*/float outlineSize _ARG /*6Fj*/float outlineFade, \
   C(Font) * retFont = DisplayDriver_loadFont(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl, /*7Al*/faceName, /*7Al*/size, /*7Al*/(C(FontFlags))flags, /*7Al*/outlineSize, /*7Al*/outlineFade); \
      return retFont;); \
VIRTUAL_METHOD(lock, lock, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/Display & ap1, \
   return (bool)DisplayDriver_lock(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(lockIndices, lockIndices, c, DisplayDriver, \
   uint16 *, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/PrimitiveSingle & group, \
   return DisplayDriver_lockIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&group.impl);); \
VIRTUAL_METHOD(lockMesh, lockMesh, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2 _ARG /*6Fj*/MeshFeatures flags, \
   return (bool)DisplayDriver_lockMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(MeshFeatures))flags);); \
VIRTUAL_METHOD(lockSystem, lockSystem, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem, \
   return (bool)DisplayDriver_lockSystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl);); \
VIRTUAL_METHOD(makeDDBitmap, makeDDBitmap, c, DisplayDriver, \
   bool, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Bitmap & ap2 _ARG /*6Fj*/bool mipMaps _ARG /*6Fj*/int cubeMapFace, \
   return (bool)DisplayDriver_makeDDBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(bool))mipMaps, /*7Al*/cubeMapFace);); \
VIRTUAL_METHOD(nextPage, nextPage, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1, \
   DisplayDriver_nextPage(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(popMatrix, popMatrix, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/bool ap2, \
   DisplayDriver_popMatrix(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/(C(bool))ap2);); \
VIRTUAL_METHOD(pushMatrix, pushMatrix, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1, \
   DisplayDriver_pushMatrix(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(putPixel, putPixel, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x _ARG /*6Fj*/int y, \
   DisplayDriver_putPixel(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(rectangle, rectangle, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x1 _ARG /*6Fj*/int y1 _ARG /*6Fj*/int x2 _ARG /*6Fj*/int y2, \
   DisplayDriver_rectangle(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x1, /*7Al*/y1, /*7Al*/x2, /*7Al*/y2);); \
VIRTUAL_METHOD(releaseSurface, releaseSurface, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2, \
   DisplayDriver_releaseSurface(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);); \
VIRTUAL_METHOD(restorePalette, restorePalette, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1, \
   DisplayDriver_restorePalette(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(scroll, scroll, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Box & ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/Extent & ap5, \
   DisplayDriver_scroll(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/&ap5.impl);); \
VIRTUAL_METHOD(selectMesh, selectMesh, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Mesh ap2, \
   DisplayDriver_selectMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);); \
VIRTUAL_METHOD(setBackground, setBackground, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ColorAlpha ap3, \
   DisplayDriver_setBackground(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ColorAlpha))ap3);); \
VIRTUAL_METHOD(setBlitTint, setBlitTint, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ColorAlpha ap3, \
   DisplayDriver_setBlitTint(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ColorAlpha))ap3);); \
VIRTUAL_METHOD(setCamera, setCamera, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Camera & ap3, \
   DisplayDriver_setCamera(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl);); \
VIRTUAL_METHOD(setCameraVR, setCameraVR, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Camera & ap2 _ARG /*6Fj*/int eye _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/void * fb _ARG /*6Fj*/const Matrix & prjMat, \
   DisplayDriver_setCameraVR(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/eye, /*7Al*/w, /*7Al*/h, /*7Al*/fb, /*7Al*/&prjMat.impl);); \
VIRTUAL_METHOD(setForeground, setForeground, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/ColorAlpha ap3, \
   DisplayDriver_setForeground(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ColorAlpha))ap3);); \
VIRTUAL_METHOD(setLight, setLight, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/Light & ap3, \
   DisplayDriver_setLight(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/&ap3.impl);); \
VIRTUAL_METHOD(setPalette, setPalette, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/ColorAlpha * ap2 _ARG /*6Fj*/bool ap3, \
   DisplayDriver_setPalette(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/(C(ColorAlpha) *)ap2, /*7Al*/(C(bool))ap3);); \
VIRTUAL_METHOD(setRenderState, setRenderState, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/RenderState ap2 _ARG /*6Fj*/uint ap3, \
   DisplayDriver_setRenderState(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/(C(RenderState))ap2, /*7Al*/ap3);); \
VIRTUAL_METHOD(setTransform, setTransform, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Matrix & ap2 _ARG /*6Fj*/bool ap3 _ARG /*6Fj*/bool ap4, \
   DisplayDriver_setTransform(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl, /*7Al*/(C(bool))ap3, /*7Al*/(C(bool))ap4);); \
VIRTUAL_METHOD(startUpdate, startUpdate, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1, \
   DisplayDriver_startUpdate(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(stretch, stretch, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh, \
   DisplayDriver_stretch(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);); \
VIRTUAL_METHOD(stretchDI, stretchDI, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/int dx _ARG /*6Fj*/int dy _ARG /*6Fj*/int sx _ARG /*6Fj*/int sy _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/int sw _ARG /*6Fj*/int sh, \
   DisplayDriver_stretchDI(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);); \
VIRTUAL_METHOD(stretchf, stretchf, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Bitmap & ap3 _ARG /*6Fj*/float dx _ARG /*6Fj*/float dy _ARG /*6Fj*/float sx _ARG /*6Fj*/float sy _ARG /*6Fj*/float w _ARG /*6Fj*/float h _ARG /*6Fj*/float sw _ARG /*6Fj*/float sh, \
   DisplayDriver_stretchf(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);); \
VIRTUAL_METHOD(textExtent, textExtent, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/constString text _ARG /*6Fj*/int len _ARG /*6Fj*/int * tw _ARG /*6Fj*/int * th _ARG /*6Fj*/int prevGlyph _ARG /*6Fj*/int * rPrevGlyph _ARG /*6Fj*/int * overHang, \
   DisplayDriver_textExtent(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/text, /*7Al*/len, /*7Al*/tw, /*7Al*/th, /*7Al*/prevGlyph, /*7Al*/rPrevGlyph, /*7Al*/overHang);); \
VIRTUAL_METHOD(textFont, textFont, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Font ap3, \
   DisplayDriver_textFont(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl);); \
VIRTUAL_METHOD(textOpacity, textOpacity, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/bool ap3, \
   DisplayDriver_textOpacity(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(bool))ap3);); \
VIRTUAL_METHOD(unloadFont, unloadFont, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Font ap2, \
   DisplayDriver_unloadFont(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);); \
VIRTUAL_METHOD(unlock, unlock, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1, \
   DisplayDriver_unlock(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);); \
VIRTUAL_METHOD(unlockIndices, unlockIndices, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/PrimitiveSingle & group _ARG /*6Fj*/bool indices32bit _ARG /*6Fj*/int nIndices _ARG /*6Fj*/void * maeb, \
   DisplayDriver_unlockIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&group.impl, /*7Al*/(C(bool))indices32bit, /*7Al*/nIndices, /*7Al*/maeb);); \
VIRTUAL_METHOD(unlockMesh, unlockMesh, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & ap1 _ARG /*6Fj*/Mesh ap2 _ARG /*6Fj*/MeshFeatures flags, \
   DisplayDriver_unlockMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(MeshFeatures))flags);); \
VIRTUAL_METHOD(unlockSystem, unlockSystem, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/DisplaySystem & displaySystem, \
   DisplayDriver_unlockSystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl);); \
VIRTUAL_METHOD(update, update, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Box & ap2, \
   DisplayDriver_update(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl);); \
VIRTUAL_METHOD(writeText, writeText, c, DisplayDriver, \
   void, c & _ARG, , /*6Fj*/Display & ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/constString text _ARG /*6Fj*/int len _ARG /*6Fj*/int prevGlyph _ARG /*6Fj*/int * rPrevGlyph, \
   DisplayDriver_writeText(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x, /*7Al*/y, /*7Al*/text, /*7Al*/len, /*7Al*/prevGlyph, /*7Al*/rPrevGlyph););

class DisplayDriver : public Instance
{
public:
   inline DisplayDriver(DisplayDriver && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DisplayDriver & operator= (DisplayDriver && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DisplayDriver() : DisplayDriver((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DisplayDriver> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DisplayDriver * inst = new DisplayDriver(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DisplayDriver * inst = (DisplayDriver *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DisplayDriver & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DisplayDriver(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct DisplayDriver_allocateBitmap_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5, /*6Fj*/PixelFormat ap6, /*6Fj*/bool ap7);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5, /*6Fj*/PixelFormat ap6, /*6Fj*/bool ap7);
   } allocateBitmap;
   // inline static void register_allocateBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_allocateBitmap_Functor::FunctionType func)

   struct DisplayDriver_allocateIndices_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void * (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/int nIndices, /*6Fj*/bool indices32bit);
      inline FunctionType operator= (FunctionType func);
      inline void * operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/int nIndices, /*6Fj*/bool indices32bit);
   } allocateIndices;
   // inline static void register_allocateIndices(CPPClass & cl, DisplayDriver::DisplayDriver_allocateIndices_Functor::FunctionType func)

   struct DisplayDriver_allocateMesh_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures ap3, /*6Fj*/int nVertices);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures ap3, /*6Fj*/int nVertices);
   } allocateMesh;
   // inline static void register_allocateMesh(CPPClass & cl, DisplayDriver::DisplayDriver_allocateMesh_Functor::FunctionType func)

   struct DisplayDriver_applyMaterial_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Material ap2, /*6Fj*/Mesh ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Material ap2, /*6Fj*/Mesh ap3);
   } applyMaterial;
   // inline static void register_applyMaterial(CPPClass & cl, DisplayDriver::DisplayDriver_applyMaterial_Functor::FunctionType func)

   struct DisplayDriver_area_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2);
   } area;
   // inline static void register_area(CPPClass & cl, DisplayDriver::DisplayDriver_area_Functor::FunctionType func)

   struct DisplayDriver_blit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h);
   } blit;
   // inline static void register_blit(CPPClass & cl, DisplayDriver::DisplayDriver_blit_Functor::FunctionType func)

   struct DisplayDriver_blitDI_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h);
   } blitDI;
   // inline static void register_blitDI(CPPClass & cl, DisplayDriver::DisplayDriver_blitDI_Functor::FunctionType func)

   struct DisplayDriver_clear_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ClearType ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ClearType ap3);
   } clear;
   // inline static void register_clear(CPPClass & cl, DisplayDriver::DisplayDriver_clear_Functor::FunctionType func)

   struct DisplayDriver_clip_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Box & ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Box & ap3);
   } clip;
   // inline static void register_clip(CPPClass & cl, DisplayDriver::DisplayDriver_clip_Functor::FunctionType func)

   struct DisplayDriver_convertBitmap_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/PixelFormat ap3, /*6Fj*/ColorAlpha * ap4);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/PixelFormat ap3, /*6Fj*/ColorAlpha * ap4);
   } convertBitmap;
   // inline static void register_convertBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_convertBitmap_Functor::FunctionType func)

   struct DisplayDriver_createDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Display & ap1);
   } createDisplay;
   // inline static void register_createDisplay(CPPClass & cl, DisplayDriver::DisplayDriver_createDisplay_Functor::FunctionType func)

   struct DisplayDriver_createDisplaySystem_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & ap1);
   } createDisplaySystem;
   // inline static void register_createDisplaySystem(CPPClass & cl, DisplayDriver::DisplayDriver_createDisplaySystem_Functor::FunctionType func)

   struct DisplayDriver_destroyDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1);
   } destroyDisplay;
   // inline static void register_destroyDisplay(CPPClass & cl, DisplayDriver::DisplayDriver_destroyDisplay_Functor::FunctionType func)

   struct DisplayDriver_destroyDisplaySystem_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1);
   } destroyDisplaySystem;
   // inline static void register_destroyDisplaySystem(CPPClass & cl, DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::FunctionType func)

   struct DisplayDriver_displayPosition_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3);
   } displayPosition;
   // inline static void register_displayPosition(CPPClass & cl, DisplayDriver::DisplayDriver_displayPosition_Functor::FunctionType func)

   struct DisplayDriver_displaySize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3);
   } displaySize;
   // inline static void register_displaySize(CPPClass & cl, DisplayDriver::DisplayDriver_displaySize_Functor::FunctionType func)

   struct DisplayDriver_drawLine_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2);
   } drawLine;
   // inline static void register_drawLine(CPPClass & cl, DisplayDriver::DisplayDriver_drawLine_Functor::FunctionType func)

   struct DisplayDriver_drawPrimitives_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/PrimitiveSingle & ap2, /*6Fj*/Mesh mesh);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/PrimitiveSingle & ap2, /*6Fj*/Mesh mesh);
   } drawPrimitives;
   // inline static void register_drawPrimitives(CPPClass & cl, DisplayDriver::DisplayDriver_drawPrimitives_Functor::FunctionType func)

   struct DisplayDriver_drawingChar_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/char ch);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/char ch);
   } drawingChar;
   // inline static void register_drawingChar(CPPClass & cl, DisplayDriver::DisplayDriver_drawingChar_Functor::FunctionType func)

   struct DisplayDriver_endUpdate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1);
   } endUpdate;
   // inline static void register_endUpdate(CPPClass & cl, DisplayDriver::DisplayDriver_endUpdate_Functor::FunctionType func)

   struct DisplayDriver_filter_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
   } filter;
   // inline static void register_filter(CPPClass & cl, DisplayDriver::DisplayDriver_filter_Functor::FunctionType func)

   struct DisplayDriver_filterDI_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
   } filterDI;
   // inline static void register_filterDI(CPPClass & cl, DisplayDriver::DisplayDriver_filterDI_Functor::FunctionType func)

   struct DisplayDriver_fontExtent_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Font ap2, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int * tw, /*6Fj*/int * th, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph, /*6Fj*/int * overHang);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Font ap2, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int * tw, /*6Fj*/int * th, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph, /*6Fj*/int * overHang);
   } fontExtent;
   // inline static void register_fontExtent(CPPClass & cl, DisplayDriver::DisplayDriver_fontExtent_Functor::FunctionType func)

   struct DisplayDriver_freeBitmap_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2);
   } freeBitmap;
   // inline static void register_freeBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_freeBitmap_Functor::FunctionType func)

   struct DisplayDriver_freeIndices_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group);
   } freeIndices;
   // inline static void register_freeIndices(CPPClass & cl, DisplayDriver::DisplayDriver_freeIndices_Functor::FunctionType func)

   struct DisplayDriver_freeMesh_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2);
   } freeMesh;
   // inline static void register_freeMesh(CPPClass & cl, DisplayDriver::DisplayDriver_freeMesh_Functor::FunctionType func)

   struct DisplayDriver_getBitmapSurface_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/Surface & surface, /*6Fj*/Bitmap & bitmap, /*6Fj*/int ap1, /*6Fj*/int ap2, /*6Fj*/Box & ap3);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/Surface & surface, /*6Fj*/Bitmap & bitmap, /*6Fj*/int ap1, /*6Fj*/int ap2, /*6Fj*/Box & ap3);
   } getBitmapSurface;
   // inline static void register_getBitmapSurface(CPPClass & cl, DisplayDriver::DisplayDriver_getBitmapSurface_Functor::FunctionType func)

   struct DisplayDriver_getPixel_Functor
   {
      [[no_unique_address]] int _[0];
      typedef ColorAlpha (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y);
      inline FunctionType operator= (FunctionType func);
      inline ColorAlpha operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y);
   } getPixel;
   // inline static void register_getPixel(CPPClass & cl, DisplayDriver::DisplayDriver_getPixel_Functor::FunctionType func)

   struct DisplayDriver_getSurface_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & surface, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/Box & ap4);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & surface, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/Box & ap4);
   } getSurface;
   // inline static void register_getSurface(CPPClass & cl, DisplayDriver::DisplayDriver_getSurface_Functor::FunctionType func)

   struct DisplayDriver_grabScreen_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/uint ap5, /*6Fj*/uint ap6);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Display & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/uint ap5, /*6Fj*/uint ap6);
   } grabScreen;
   // inline static void register_grabScreen(CPPClass & cl, DisplayDriver::DisplayDriver_grabScreen_Functor::FunctionType func)

   struct DisplayDriver_lineStipple_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/uint pattern);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/uint pattern);
   } lineStipple;
   // inline static void register_lineStipple(CPPClass & cl, DisplayDriver::DisplayDriver_lineStipple_Functor::FunctionType func)

   struct DisplayDriver_loadFont_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Font (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/const char * faceName, /*6Fj*/float size, /*6Fj*/FontFlags flags, /*6Fj*/float outlineSize, /*6Fj*/float outlineFade);
      inline FunctionType operator= (FunctionType func);
      inline Font operator()( /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/const char * faceName, /*6Fj*/float size, /*6Fj*/FontFlags flags, /*6Fj*/float outlineSize, /*6Fj*/float outlineFade);
   } loadFont;
   // inline static void register_loadFont(CPPClass & cl, DisplayDriver::DisplayDriver_loadFont_Functor::FunctionType func)

   struct DisplayDriver_lock_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Display & ap1);
   } lock;
   // inline static void register_lock(CPPClass & cl, DisplayDriver::DisplayDriver_lock_Functor::FunctionType func)

   struct DisplayDriver_lockIndices_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uint16 * (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group);
      inline FunctionType operator= (FunctionType func);
      inline uint16 * operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group);
   } lockIndices;
   // inline static void register_lockIndices(CPPClass & cl, DisplayDriver::DisplayDriver_lockIndices_Functor::FunctionType func)

   struct DisplayDriver_lockMesh_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures flags);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures flags);
   } lockMesh;
   // inline static void register_lockMesh(CPPClass & cl, DisplayDriver::DisplayDriver_lockMesh_Functor::FunctionType func)

   struct DisplayDriver_lockSystem_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & displaySystem);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & displaySystem);
   } lockSystem;
   // inline static void register_lockSystem(CPPClass & cl, DisplayDriver::DisplayDriver_lockSystem_Functor::FunctionType func)

   struct DisplayDriver_makeDDBitmap_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/bool mipMaps, /*6Fj*/int cubeMapFace);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/bool mipMaps, /*6Fj*/int cubeMapFace);
   } makeDDBitmap;
   // inline static void register_makeDDBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_makeDDBitmap_Functor::FunctionType func)

   struct DisplayDriver_nextPage_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1);
   } nextPage;
   // inline static void register_nextPage(CPPClass & cl, DisplayDriver::DisplayDriver_nextPage_Functor::FunctionType func)

   struct DisplayDriver_popMatrix_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/bool ap2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/bool ap2);
   } popMatrix;
   // inline static void register_popMatrix(CPPClass & cl, DisplayDriver::DisplayDriver_popMatrix_Functor::FunctionType func)

   struct DisplayDriver_pushMatrix_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1);
   } pushMatrix;
   // inline static void register_pushMatrix(CPPClass & cl, DisplayDriver::DisplayDriver_pushMatrix_Functor::FunctionType func)

   struct DisplayDriver_putPixel_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y);
   } putPixel;
   // inline static void register_putPixel(CPPClass & cl, DisplayDriver::DisplayDriver_putPixel_Functor::FunctionType func)

   struct DisplayDriver_rectangle_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2);
   } rectangle;
   // inline static void register_rectangle(CPPClass & cl, DisplayDriver::DisplayDriver_rectangle_Functor::FunctionType func)

   struct DisplayDriver_releaseSurface_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2);
   } releaseSurface;
   // inline static void register_releaseSurface(CPPClass & cl, DisplayDriver::DisplayDriver_releaseSurface_Functor::FunctionType func)

   struct DisplayDriver_restorePalette_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1);
   } restorePalette;
   // inline static void register_restorePalette(CPPClass & cl, DisplayDriver::DisplayDriver_restorePalette_Functor::FunctionType func)

   struct DisplayDriver_scroll_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Box & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/Extent & ap5);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Box & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/Extent & ap5);
   } scroll;
   // inline static void register_scroll(CPPClass & cl, DisplayDriver::DisplayDriver_scroll_Functor::FunctionType func)

   struct DisplayDriver_selectMesh_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Mesh ap2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Mesh ap2);
   } selectMesh;
   // inline static void register_selectMesh(CPPClass & cl, DisplayDriver::DisplayDriver_selectMesh_Functor::FunctionType func)

   struct DisplayDriver_setBackground_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3);
   } setBackground;
   // inline static void register_setBackground(CPPClass & cl, DisplayDriver::DisplayDriver_setBackground_Functor::FunctionType func)

   struct DisplayDriver_setBlitTint_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3);
   } setBlitTint;
   // inline static void register_setBlitTint(CPPClass & cl, DisplayDriver::DisplayDriver_setBlitTint_Functor::FunctionType func)

   struct DisplayDriver_setCamera_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Camera & ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Camera & ap3);
   } setCamera;
   // inline static void register_setCamera(CPPClass & cl, DisplayDriver::DisplayDriver_setCamera_Functor::FunctionType func)

   struct DisplayDriver_setCameraVR_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Camera & ap2, /*6Fj*/int eye, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * fb, /*6Fj*/const Matrix & prjMat);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Camera & ap2, /*6Fj*/int eye, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * fb, /*6Fj*/const Matrix & prjMat);
   } setCameraVR;
   // inline static void register_setCameraVR(CPPClass & cl, DisplayDriver::DisplayDriver_setCameraVR_Functor::FunctionType func)

   struct DisplayDriver_setForeground_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3);
   } setForeground;
   // inline static void register_setForeground(CPPClass & cl, DisplayDriver::DisplayDriver_setForeground_Functor::FunctionType func)

   struct DisplayDriver_setLight_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/Light & ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/Light & ap3);
   } setLight;
   // inline static void register_setLight(CPPClass & cl, DisplayDriver::DisplayDriver_setLight_Functor::FunctionType func)

   struct DisplayDriver_setPalette_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/ColorAlpha * ap2, /*6Fj*/bool ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/ColorAlpha * ap2, /*6Fj*/bool ap3);
   } setPalette;
   // inline static void register_setPalette(CPPClass & cl, DisplayDriver::DisplayDriver_setPalette_Functor::FunctionType func)

   struct DisplayDriver_setRenderState_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/RenderState ap2, /*6Fj*/uint ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/RenderState ap2, /*6Fj*/uint ap3);
   } setRenderState;
   // inline static void register_setRenderState(CPPClass & cl, DisplayDriver::DisplayDriver_setRenderState_Functor::FunctionType func)

   struct DisplayDriver_setTransform_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Matrix & ap2, /*6Fj*/bool ap3, /*6Fj*/bool ap4);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Matrix & ap2, /*6Fj*/bool ap3, /*6Fj*/bool ap4);
   } setTransform;
   // inline static void register_setTransform(CPPClass & cl, DisplayDriver::DisplayDriver_setTransform_Functor::FunctionType func)

   struct DisplayDriver_startUpdate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1);
   } startUpdate;
   // inline static void register_startUpdate(CPPClass & cl, DisplayDriver::DisplayDriver_startUpdate_Functor::FunctionType func)

   struct DisplayDriver_stretch_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
   } stretch;
   // inline static void register_stretch(CPPClass & cl, DisplayDriver::DisplayDriver_stretch_Functor::FunctionType func)

   struct DisplayDriver_stretchDI_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh);
   } stretchDI;
   // inline static void register_stretchDI(CPPClass & cl, DisplayDriver::DisplayDriver_stretchDI_Functor::FunctionType func)

   struct DisplayDriver_stretchf_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/float dx, /*6Fj*/float dy, /*6Fj*/float sx, /*6Fj*/float sy, /*6Fj*/float w, /*6Fj*/float h, /*6Fj*/float sw, /*6Fj*/float sh);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/float dx, /*6Fj*/float dy, /*6Fj*/float sx, /*6Fj*/float sy, /*6Fj*/float w, /*6Fj*/float h, /*6Fj*/float sw, /*6Fj*/float sh);
   } stretchf;
   // inline static void register_stretchf(CPPClass & cl, DisplayDriver::DisplayDriver_stretchf_Functor::FunctionType func)

   struct DisplayDriver_textExtent_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int * tw, /*6Fj*/int * th, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph, /*6Fj*/int * overHang);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int * tw, /*6Fj*/int * th, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph, /*6Fj*/int * overHang);
   } textExtent;
   // inline static void register_textExtent(CPPClass & cl, DisplayDriver::DisplayDriver_textExtent_Functor::FunctionType func)

   struct DisplayDriver_textFont_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Font ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Font ap3);
   } textFont;
   // inline static void register_textFont(CPPClass & cl, DisplayDriver::DisplayDriver_textFont_Functor::FunctionType func)

   struct DisplayDriver_textOpacity_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/bool ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/bool ap3);
   } textOpacity;
   // inline static void register_textOpacity(CPPClass & cl, DisplayDriver::DisplayDriver_textOpacity_Functor::FunctionType func)

   struct DisplayDriver_unloadFont_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Font ap2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Font ap2);
   } unloadFont;
   // inline static void register_unloadFont(CPPClass & cl, DisplayDriver::DisplayDriver_unloadFont_Functor::FunctionType func)

   struct DisplayDriver_unlock_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1);
   } unlock;
   // inline static void register_unlock(CPPClass & cl, DisplayDriver::DisplayDriver_unlock_Functor::FunctionType func)

   struct DisplayDriver_unlockIndices_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group, /*6Fj*/bool indices32bit, /*6Fj*/int nIndices, /*6Fj*/void * maeb);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group, /*6Fj*/bool indices32bit, /*6Fj*/int nIndices, /*6Fj*/void * maeb);
   } unlockIndices;
   // inline static void register_unlockIndices(CPPClass & cl, DisplayDriver::DisplayDriver_unlockIndices_Functor::FunctionType func)

   struct DisplayDriver_unlockMesh_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures flags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures flags);
   } unlockMesh;
   // inline static void register_unlockMesh(CPPClass & cl, DisplayDriver::DisplayDriver_unlockMesh_Functor::FunctionType func)

   struct DisplayDriver_unlockSystem_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/DisplaySystem & displaySystem);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/DisplaySystem & displaySystem);
   } unlockSystem;
   // inline static void register_unlockSystem(CPPClass & cl, DisplayDriver::DisplayDriver_unlockSystem_Functor::FunctionType func)

   struct DisplayDriver_update_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Box & ap2);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Box & ap2);
   } update;
   // inline static void register_update(CPPClass & cl, DisplayDriver::DisplayDriver_update_Functor::FunctionType func)

   struct DisplayDriver_writeText_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DisplayDriver & , /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph);
   } writeText;
   // inline static void register_writeText(CPPClass & cl, DisplayDriver::DisplayDriver_writeText_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};

class DisplayFlags
{
public:
   C(DisplayFlags) impl;
   constexpr DisplayFlags() : impl(0) { }
   constexpr DisplayFlags(C(DisplayFlags) impl) : impl(impl) { }
   operator C(DisplayFlags)() { return impl; }
   DisplayFlags & operator =(C(DisplayFlags) impl) { impl = impl; return *this; }
   bool operator ==(const DisplayFlags & value) const { return impl == value.impl; }
   bool operator !=(const DisplayFlags & value) const { return impl != value.impl; }

   struct fullScreen_Prop
   {
      constexpr fullScreen_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DisplayFlags::fullScreen_Prop & operator= (DisplayFlags::fullScreen_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fullScreen;
   struct flipping_Prop
   {
      constexpr flipping_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DisplayFlags::flipping_Prop & operator= (DisplayFlags::flipping_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } flipping;
   struct alpha_Prop
   {
      constexpr alpha_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DisplayFlags::alpha_Prop & operator= (DisplayFlags::alpha_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alpha;
   struct memBackBuffer_Prop
   {
      constexpr memBackBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DisplayFlags::memBackBuffer_Prop & operator= (DisplayFlags::memBackBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } memBackBuffer;
   struct text_Prop
   {
      constexpr text_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DisplayFlags::text_Prop & operator= (DisplayFlags::text_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } text;
   struct scrolling_Prop
   {
      constexpr scrolling_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DisplayFlags::scrolling_Prop & operator= (DisplayFlags::scrolling_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } scrolling;
   struct printer_Prop
   {
      constexpr printer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DisplayFlags::printer_Prop & operator= (DisplayFlags::printer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } printer;
};


#define REG_DisplaySystem(c) \
      DisplaySystem::class_registration(_cpp_class);

#define DISPLAYSYSTEM_VIRTUAL_METHODS_PROTO(c) \

#define DISPLAYSYSTEM_VIRTUAL_METHODS(c) \

class DisplaySystem : public Instance
{
public:
   inline DisplaySystem(DisplaySystem && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DisplaySystem & operator= (DisplaySystem && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DisplaySystem() : DisplaySystem((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DisplaySystem> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DisplaySystem * inst = new DisplaySystem(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DisplaySystem * inst = (DisplaySystem *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DisplaySystem & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DisplaySystem(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) addMaterial(/*1Ab*/Material material); // DisplaySystem_addMaterial
   inline C(OldLink) * addMesh(/*1Ab*/Mesh mesh); // DisplaySystem_addMesh
   inline C(Material) * addNamedMaterial(/*1Ab*/const char * name); // DisplaySystem_addNamedMaterial
   inline C(NamedLink) * addTexture(/*1Ab*/const char * name, /*1Ab*/Bitmap & bitmap); // DisplaySystem_addTexture
   inline void clearMaterials(); // DisplaySystem_clearMaterials
   inline void clearMeshes(); // DisplaySystem_clearMeshes
   inline void clearTextures(); // DisplaySystem_clearTextures
   inline C(bool) create(/*1Ab*/const char * driverName, /*1Ab*/void * window, /*1Ab*/bool fullScreen); // DisplaySystem_create
   inline void fontExtent(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height); // DisplaySystem_fontExtent
   inline void fontExtent2(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang); // DisplaySystem_fontExtent2
   inline C(Material) * getMaterial(/*1Ab*/const char * name); // DisplaySystem_getMaterial
   inline Bitmap getTexture(/*1Ab*/const char * name); // DisplaySystem_getTexture
   inline C(Font) * loadFont(/*1Ab*/const char * faceName, /*1Ab*/float size, /*1Ab*/FontFlags flags); // DisplaySystem_loadFont
   inline C(Font) * loadOutlineFont(/*1Ab*/const char * faceName, /*1Ab*/float size, /*1Ab*/FontFlags flags, /*1Ab*/float outlineSize, /*1Ab*/float outlineFade); // DisplaySystem_loadOutlineFont
   inline void * loadResource(/*1Ab*/Resource & resource); // DisplaySystem_loadResource
   inline void * loadResourceFM(/*1Ab*/Resource & resource, /*1Ab*/FontManager & fm); // DisplaySystem_loadResourceFM
   inline C(bool) lock(); // DisplaySystem_lock
   inline C(bool) removeMaterial(/*1Ab*/Material material); // DisplaySystem_removeMaterial
   inline C(bool) removeMesh(/*1Ab*/Mesh mesh); // DisplaySystem_removeMesh
   inline C(bool) removeTexture(/*1Ab*/const char * name); // DisplaySystem_removeTexture
   inline void unloadFont(/*1Ab*/Font font); // DisplaySystem_unloadFont
   inline void unloadResource(/*1Ab*/Resource & resource, /*1Ab*/DisplaySystemResPtr res); // DisplaySystem_unloadResource
   inline void unlock(); // DisplaySystem_unlock
   inline void * _LoadResource(/*1Ab*/Resource & resource, /*1Ab*/void * fm); // DisplaySystem__LoadResource

   static void class_registration(CPPClass & _cpp_class);

   inline DisplaySystem(PixelFormat pixelFormat, DisplayFlags flags);

   struct pixelFormat_Prop
   {
      constexpr pixelFormat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/PixelFormat operator= (/*0H*/PixelFormat v);
      /*regSet*/inline DisplaySystem::pixelFormat_Prop & operator= (DisplaySystem::pixelFormat_Prop & prop);
      /*regGet*/inline operator /*0I*/PixelFormat () const;
   } pixelFormat;
   struct flags_Prop
   {
      constexpr flags_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DisplayFlags operator= (/*0H*/DisplayFlags v);
      /*regSet*/inline DisplaySystem::flags_Prop & operator= (DisplaySystem::flags_Prop & prop);
      /*regGet*/inline operator /*0I*/DisplayFlags () const;
   } flags;
};

template <class TC, C(Class) ** TCO>
class TDisplaySystemResPtr : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;
   ~TDisplaySystemResPtr()
   {
      this->impl = null; // How to know not to delete?
   }
};


#define REG_DrawList(c) \
      DrawList::class_registration(_cpp_class);

#define DRAWLIST_VIRTUAL_METHODS_PROTO(c) \

#define DRAWLIST_VIRTUAL_METHODS(c) \

class DrawList : public Instance
{
public:
   inline DrawList(DrawList && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DrawList & operator= (DrawList && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DrawList() : DrawList((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DrawList> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DrawList * inst = new DrawList(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DrawList * inst = (DrawList *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DrawList & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DrawList(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void addObject(/*1Ab*/Object object); // DrawList_addObject
   inline void init(/*1Ab*/Matrix & sm, /*1Ab*/Matrix & vm, /*1Ab*/Vector3D & cp, /*1Ab*/Plane * vp, /*1Ab*/Plane * wp, /*1Ab*/int guessCount); // DrawList_init
   inline void init(/*1Ac*/Matrix * sm, /*1Ac*/Matrix * vm, /*1Ac*/Vector3D * cp, /*1Ac*/Plane * vp, /*1Ac*/Plane * wp, /*1Ac*/int guessCount); // DrawList_init
   inline void prepare(); // DrawList_prepare
   inline void render(/*1Ab*/Display & display); // DrawList_render

   static void class_registration(CPPClass & _cpp_class);
};

#define REG_DrawManager_flush(m, c) REGVMETHOD(DrawManager, flush, c::m, (/*1Ab*/DrawManager & self), c, ())

#define REG_DrawManager(c) \
      DrawManager::class_registration(_cpp_class); \
      REG_DrawManager_flush(flush, c);

#define DRAWMANAGER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(flush, flush, c, DrawManager, \
      void, c &, , );

#define DRAWMANAGER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(flush, flush, c, DrawManager, \
   void, c &, , , \
   DrawManager_flush(self ? self->impl : (C(DrawManager))null););

class DrawManager : public Instance
{
public:
   inline DrawManager(DrawManager && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DrawManager & operator= (DrawManager && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DrawManager() : DrawManager((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DrawManager> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DrawManager * inst = new DrawManager(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DrawManager * inst = (DrawManager *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DrawManager & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DrawManager(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void clear(); // DrawManager_clear
   inline void drawBarrier(); // DrawManager_drawBarrier
   inline void drawImage(/*1Ab*/int index, /*1Ab*/float offsetx, /*1Ab*/float offsety, /*1Ab*/float angsin, /*1Ab*/float angcos, /*1Ab*/ColorAlpha color); // DrawManager_drawImage
   inline void end(); // DrawManager_end
   inline void finish(); // DrawManager_finish
   inline C(bool) init(); // DrawManager_init
   inline void ready(/*1Ab*/int viewportWidth, /*1Ab*/int viewportHeight); // DrawManager_ready

   struct DrawManager_flush_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DrawManager &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } flush;
   // inline static void register_flush(CPPClass & cl, DrawManager::DrawManager_flush_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline DrawManager(bool renderingFlipped);

   struct renderingFlipped_Prop
   {
      constexpr renderingFlipped_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } renderingFlipped;
};

struct DrawSlot : public TStruct<DrawSlot>
{
public:
   C(DrawSlot) impl;
   constexpr DrawSlot() : impl({}) { }
   constexpr DrawSlot(const C(DrawSlot) impl) : impl(impl) { }

   struct object_Prop
   {
      constexpr object_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Object operator= (/*0H*/Object & v);
      /*regSet*/inline DrawSlot::object_Prop & operator= (DrawSlot::object_Prop & prop);
      /*regGet*/inline operator /*0I*/Object () const;
   } object;
   struct baseMap_Prop
   {
      constexpr baseMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Bitmap operator= (/*0H*/Bitmap v);
      /*regSet*/inline DrawSlot::baseMap_Prop & operator= (DrawSlot::baseMap_Prop & prop);
      /*regGet*/inline operator /*0I*/Bitmap () const;
   } baseMap;
};

template <class TC, C(Class) ** TCO>
class TFMFont : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline void setOutline(/*1Ab*/float size, /*1Ab*/float fade); // FMFont_setOutline

   struct link_Prop
   {
      constexpr link_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/TLinkElement<C(FMFont)> operator= (/*0H*/TLinkElement<C(FMFont)> v);
      /*regSet*/inline typename TFMFont<TC, TCO>::link_Prop & operator= (typename TFMFont<TC, TCO>::link_Prop & prop);
      /*regGet*/inline operator /*0I*/TLinkElement<C(FMFont)> () const;
   } link;
   ~TFMFont()
   {
      this->impl = null; // How to know not to delete?
   }
};

struct FMPathDraw : public TStruct<FMPathDraw>
{
public:
   C(FMPathDraw) impl;
   constexpr FMPathDraw() : impl({}) { }
   constexpr FMPathDraw(const C(FMPathDraw) impl) : impl(impl) { }

   inline FMPathDraw(int prevGlyphIndex, float middleAlign);

   struct prevGlyphIndex_Prop
   {
      constexpr prevGlyphIndex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FMPathDraw::prevGlyphIndex_Prop & operator= (FMPathDraw::prevGlyphIndex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } prevGlyphIndex;
   struct middleAlign_Prop
   {
      constexpr middleAlign_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FMPathDraw::middleAlign_Prop & operator= (FMPathDraw::middleAlign_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } middleAlign;
};

class FMTextAlignment
{
public:
   C(FMTextAlignment) impl;
   constexpr FMTextAlignment() : impl(0) { }
   constexpr FMTextAlignment(C(FMTextAlignment) impl) : impl(impl) { }
   FMTextAlignment(Alignment horzAlignment, FMVerticalAlignment vertAlignment);
   operator C(FMTextAlignment)() { return impl; }
   FMTextAlignment & operator =(C(FMTextAlignment) impl) { impl = impl; return *this; }
   bool operator ==(const FMTextAlignment & value) const { return impl == value.impl; }
   bool operator !=(const FMTextAlignment & value) const { return impl != value.impl; }

   struct horzAlignment_Prop
   {
      constexpr horzAlignment_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Alignment operator= (/*0H*/Alignment v);
      /*regSet*/inline FMTextAlignment::horzAlignment_Prop & operator= (FMTextAlignment::horzAlignment_Prop & prop);
      /*regGet*/inline operator /*0I*/Alignment () const;
   } horzAlignment;
   struct vertAlignment_Prop
   {
      constexpr vertAlignment_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FMVerticalAlignment operator= (/*0H*/FMVerticalAlignment v);
      /*regSet*/inline FMTextAlignment::vertAlignment_Prop & operator= (FMTextAlignment::vertAlignment_Prop & prop);
      /*regGet*/inline operator /*0I*/FMVerticalAlignment () const;
   } vertAlignment;
};

enum class FMVerticalAlignment : int
{
   baseline = FMVerticalAlignment_baseline,
   top = FMVerticalAlignment_top,
   middle = FMVerticalAlignment_middle,
   bottom = FMVerticalAlignment_bottom
};

template <class TC, C(Class) ** TCO>
class TFaceInfo : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct fileName_Prop
   {
      constexpr fileName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/char * operator= (/*0H*/char * v);
      /*regSet*/inline typename TFaceInfo<TC, TCO>::fileName_Prop & operator= (typename TFaceInfo<TC, TCO>::fileName_Prop & prop);
      /*regGet*/inline operator /*0I*/char * () const;
   } fileName;
   struct fakeItalic_Prop
   {
      constexpr fakeItalic_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TFaceInfo<TC, TCO>::fakeItalic_Prop & operator= (typename TFaceInfo<TC, TCO>::fakeItalic_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fakeItalic;
   struct fontID_Prop
   {
      constexpr fontID_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TFaceInfo<TC, TCO>::fontID_Prop & operator= (typename TFaceInfo<TC, TCO>::fontID_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } fontID;
   ~TFaceInfo()
   {
      this->impl = null; // How to know not to delete?
   }
};

enum class FillModeValue : int
{
   solid = FillModeValue_solid,
   wireframe = FillModeValue_wireframe
};

class FontFlags
{
public:
   C(FontFlags) impl;
   constexpr FontFlags() : impl(0) { }
   constexpr FontFlags(C(FontFlags) impl) : impl(impl) { }
   FontFlags(bool bold, bool italic, bool underline);
   operator C(FontFlags)() { return impl; }
   FontFlags & operator =(C(FontFlags) impl) { impl = impl; return *this; }
   bool operator ==(const FontFlags & value) const { return impl == value.impl; }
   bool operator !=(const FontFlags & value) const { return impl != value.impl; }

   struct bold_Prop
   {
      constexpr bold_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontFlags::bold_Prop & operator= (FontFlags::bold_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bold;
   struct italic_Prop
   {
      constexpr italic_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontFlags::italic_Prop & operator= (FontFlags::italic_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } italic;
   struct underline_Prop
   {
      constexpr underline_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontFlags::underline_Prop & operator= (FontFlags::underline_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } underline;
};

struct FontInfo : public TStruct<FontInfo>
{
public:
   C(FontInfo) impl;
   constexpr FontInfo() : impl({}) { }
   constexpr FontInfo(const C(FontInfo) impl) : impl(impl) { }

   inline FontInfo(bool fixedPitch, bool defaultOrAnsiCharSet);

   struct fixedPitch_Prop
   {
      constexpr fixedPitch_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontInfo::fixedPitch_Prop & operator= (FontInfo::fixedPitch_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fixedPitch;
   struct defaultOrAnsiCharSet_Prop
   {
      constexpr defaultOrAnsiCharSet_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontInfo::defaultOrAnsiCharSet_Prop & operator= (FontInfo::defaultOrAnsiCharSet_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } defaultOrAnsiCharSet;
};

#define REG_FontManager_onAtlasFull(m, c) REGVMETHOD(FontManager, onAtlasFull, c::m, (/*1Ab*/FontManager & self), c, ())

#define REG_FontManager(c) \
      FontManager::class_registration(_cpp_class); \
      REG_FontManager_onAtlasFull(onAtlasFull, c);

#define FONTMANAGER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(onAtlasFull, onAtlasFull, c, FontManager, \
      void, c &, , );

#define FONTMANAGER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(onAtlasFull, onAtlasFull, c, FontManager, \
   void, c &, , , \
   FontManager_onAtlasFull(self ? self->impl : (C(FontManager))null););

class FontManager : public Instance
{
public:
   inline FontManager(FontManager && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FontManager & operator= (FontManager && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FontManager() : FontManager((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FontManager> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FontManager * inst = new FontManager(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FontManager * inst = (FontManager *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FontManager & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FontManager(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(FMFont) * addFont(constString path, /*1Ab*/int glyphPaddingWidth); // FontManager_addFont
   inline C(FMFont) * addFontData(/*1Ab*/byte * data, /*1Ab*/int dataSize, /*1Ab*/int glyphPaddingWidth); // FontManager_addFontData
   inline void clearState(); // FontManager_clearState
   inline C(bool) create(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/int channelCount, /*1Ab*/int channelIndex, /*1Ab*/FontManagerRenderer & renderer); // FontManager_create
   inline int drawText(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * string, /*1Ab*/int stringlength); // FontManager_drawText
   inline int drawTextTruncate(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int truncatewidth, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/char * extstring, /*1Ab*/int extwidth); // FontManager_drawTextTruncate
   inline int drawTextWithCursor(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int cursoroffset); // FontManager_drawTextWithCursor
   inline C(bool) expandAtlas(/*1Ab*/int width, /*1Ab*/int height); // FontManager_expandAtlas
   inline void flush(/*1Ab*/bool rendererFlush); // FontManager_flush
   inline void flushUpdate(); // FontManager_flushUpdate
   inline void freeFont(/*1Ab*/FMFont font); // FontManager_freeFont
   inline void getAtlasSize(/*1Ab*/int * retwidth, /*1Ab*/int * retheight); // FontManager_getAtlasSize
   inline C(FMFont) * getFont(/*1Ab*/FontResource & fontResource); // FontManager_getFont
   inline void getFontExtent(/*1Ab*/int * retascent, /*1Ab*/int * retdescent); // FontManager_getFontExtent
   inline void getFontLimits(/*1Ab*/int * retlimitminy, /*1Ab*/int * retlimitmaxy); // FontManager_getFontLimits
   inline int getFontLineHeight(); // FontManager_getFontLineHeight
   inline int getTextBounds(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int * bounds); // FontManager_getTextBounds
   inline int getTextNearestOffset(/*1Ab*/int targetwidth, /*1Ab*/const char * string, /*1Ab*/int stringlength); // FontManager_getTextNearestOffset
   inline int getTextTruncateOffset(/*1Ab*/int truncatewidth, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int extwidth, /*1Ab*/int * retextflag, /*1Ab*/int * retfullwidth); // FontManager_getTextTruncateOffset
   inline int getTextWidth(/*1Ab*/const char * string, /*1Ab*/int stringlength); // FontManager_getTextWidth
   inline int getTextWidthTruncate(/*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int truncatewidth); // FontManager_getTextWidthTruncate
   inline const byte * getTextureData(/*1Ab*/int * width, /*1Ab*/int * height); // FontManager_getTextureData
   inline C(bool) initPathDraw(/*1Ab*/FMPathDraw & pathdraw); // FontManager_initPathDraw
   inline C(bool) initPathDraw(/*1Ac*/FMPathDraw * pathdraw); // FontManager_initPathDraw
   inline float pathDrawCharacter(/*1Ab*/FMPathDraw & pathdraw, /*1Ab*/float x, /*1Ab*/float y, /*1Ab*/float vectorx, /*1Ab*/float vectory, /*1Ab*/int unicode); // FontManager_pathDrawCharacter
   inline float pathDrawCharacter(/*1Ac*/FMPathDraw * pathdraw, /*1Ac*/float x, /*1Ac*/float y, /*1Ac*/float vectorx, /*1Ac*/float vectory, /*1Ac*/int unicode); // FontManager_pathDrawCharacter
   inline float pathDrawPredictAdvance(/*1Ab*/FMPathDraw & pathdraw, /*1Ab*/unichar unicode); // FontManager_pathDrawPredictAdvance
   inline float pathDrawPredictAdvance(/*1Ac*/FMPathDraw * pathdraw, /*1Ac*/unichar unicode); // FontManager_pathDrawPredictAdvance
   inline void popState(); // FontManager_popState
   inline void pushState(); // FontManager_pushState
   inline void removeFont(/*1Ab*/FMFont font); // FontManager_removeFont
   inline C(bool) resetAtlas(/*1Ab*/int width, /*1Ab*/int height); // FontManager_resetAtlas
   inline void setAlign(/*1Ab*/int align); // FontManager_setAlign
   inline void setFont(/*1Ab*/FMFont font); // FontManager_setFont
   inline void setFontImageProcessing(/*1Ab*/FMFont font, void (* processImage)(byte * image, int width, int height, int bytesperpixel, int bytesperline, int paddingwidth, void * opaquecontext), /*1Ab*/void * opaquecontext); // FontManager_setFontImageProcessing
   inline void setSize(/*1Ab*/int size); // FontManager_setSize
   inline void setState(/*1Ab*/FMFont font, /*1Ab*/int size, /*1Ab*/int align); // FontManager_setState
   inline C(bool) validateTexture(/*1Ab*/int * retdirtyrect); // FontManager_validateTexture

   struct FontManager_onAtlasFull_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(FontManager &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onAtlasFull;
   // inline static void register_onAtlasFull(CPPClass & cl, FontManager::FontManager_onAtlasFull_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct renderer_Prop
   {
      constexpr renderer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const FontManagerRenderer & operator= (/*0A*/const FontManagerRenderer & v);
      /*regSet*/inline FontManager::renderer_Prop & operator= (FontManager::renderer_Prop & prop);
      /*nstSet*/inline /*0C*/const FontManagerRenderer * operator= (/*0C*/const FontManagerRenderer * v);
      /*regGet*/inline operator /*0B*/TIH<FontManagerRenderer> () const;
      /*regGet*/inline TIH<FontManagerRenderer> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/FontManagerRenderer () const;
      /*regGet*/inline operator /*0F*/FontManagerRenderer* () const;
   } renderer;
};


#define REG_FontRenderer(c) \
      FontRenderer::class_registration(_cpp_class); \
      REG_FontManagerRenderer_createTexture(createTexture, c); \
      REG_FontManagerRenderer_drawImage(drawImage, c); \
      REG_FontManagerRenderer_drawImageAlt(drawImageAlt, c); \
      REG_FontManagerRenderer_drawImageCursor(drawImageCursor, c); \
      REG_FontManagerRenderer_drawImageFloat(drawImageFloat, c); \
      REG_FontManagerRenderer_flush(flush, c); \
      REG_FontManagerRenderer_init(init, c); \
      REG_FontManagerRenderer_registerImage(registerImage, c); \
      REG_FontManagerRenderer_resetImages(resetImages, c); \
      REG_FontManagerRenderer_resizeTexture(resizeTexture, c); \
      REG_FontManagerRenderer_setLayer(setLayer, c); \
      REG_FontManagerRenderer_updateTexture(updateTexture, c);

#define FONTRENDERER_VIRTUAL_METHODS_PROTO(c) \

#define FONTRENDERER_VIRTUAL_METHODS(c) \

class FontRenderer : public FontManagerRenderer
{
public:
   inline FontRenderer(FontRenderer && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FontRenderer & operator= (FontRenderer && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FontRenderer() : FontRenderer((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FontRenderer> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FontRenderer * inst = new FontRenderer(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FontRenderer * inst = (FontRenderer *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FontRenderer & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FontRenderer(C(Instance) _impl, CPPClass & cl = _cpp_class) : FontManagerRenderer(_impl, cl) { }

   inline void setColor(/*1Ab*/ColorAlpha color); // FontRenderer_setColor
   inline void setCursorColor(/*1Ab*/ColorAlpha color); // FontRenderer_setCursorColor
   inline void setExtColor(/*1Ab*/ColorAlpha color); // FontRenderer_setExtColor

   static void class_registration(CPPClass & _cpp_class);

   struct drawManager_Prop
   {
      constexpr drawManager_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const DrawManager & operator= (/*0A*/const DrawManager & v);
      /*nstSet*/inline /*0C*/const DrawManager * operator= (/*0C*/const DrawManager * v);
   } drawManager;
};


#define REG_FontResource(c) \
      FontResource::class_registration(_cpp_class);

#define FONTRESOURCE_VIRTUAL_METHODS_PROTO(c) \

#define FONTRESOURCE_VIRTUAL_METHODS(c) \

class FontResource : public Resource
{
public:
   inline FontResource(FontResource && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FontResource & operator= (FontResource && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FontResource() : FontResource((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FontResource> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FontResource * inst = new FontResource(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FontResource * inst = (FontResource *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FontResource & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FontResource(C(Instance) _impl, CPPClass & cl = _cpp_class) : Resource(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline FontResource(const char * faceName, float size, bool bold, bool italic, bool underline);

   struct faceName_Prop
   {
      constexpr faceName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FontResource::faceName_Prop & operator= (FontResource::faceName_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } faceName;
   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FontResource::size_Prop & operator= (FontResource::size_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } size;
   struct bold_Prop
   {
      constexpr bold_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontResource::bold_Prop & operator= (FontResource::bold_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bold;
   struct italic_Prop
   {
      constexpr italic_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontResource::italic_Prop & operator= (FontResource::italic_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } italic;
   struct underline_Prop
   {
      constexpr underline_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FontResource::underline_Prop & operator= (FontResource::underline_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } underline;
   struct font_Prop
   {
      constexpr font_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Font () const;
   } font;
   struct window_Prop
   {
      constexpr window_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
   } window;
   struct outlineSize_Prop
   {
      constexpr outlineSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FontResource::outlineSize_Prop & operator= (FontResource::outlineSize_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } outlineSize;
   struct outlineFade_Prop
   {
      constexpr outlineFade_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FontResource::outlineFade_Prop & operator= (FontResource::outlineFade_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } outlineFade;
   struct fmFont_Prop
   {
      constexpr fmFont_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/FMFont () const;
   } fmFont;
};

class GLCapabilities
{
public:
   C(GLCapabilities) impl;
   constexpr GLCapabilities() : impl(0) { }
   constexpr GLCapabilities(C(GLCapabilities) impl) : impl(impl) { }
   operator C(GLCapabilities)() { return impl; }
   GLCapabilities & operator =(C(GLCapabilities) impl) { impl = impl; return *this; }
   bool operator ==(const GLCapabilities & value) const { return impl == value.impl; }
   bool operator !=(const GLCapabilities & value) const { return impl != value.impl; }

   struct compatible_Prop
   {
      constexpr compatible_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::compatible_Prop & operator= (GLCapabilities::compatible_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } compatible;
   struct vertexBuffer_Prop
   {
      constexpr vertexBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::vertexBuffer_Prop & operator= (GLCapabilities::vertexBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } vertexBuffer;
   struct quads_Prop
   {
      constexpr quads_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::quads_Prop & operator= (GLCapabilities::quads_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } quads;
   struct intAndDouble_Prop
   {
      constexpr intAndDouble_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::intAndDouble_Prop & operator= (GLCapabilities::intAndDouble_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } intAndDouble;
   struct legacyFormats_Prop
   {
      constexpr legacyFormats_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::legacyFormats_Prop & operator= (GLCapabilities::legacyFormats_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } legacyFormats;
   struct nonPow2Textures_Prop
   {
      constexpr nonPow2Textures_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::nonPow2Textures_Prop & operator= (GLCapabilities::nonPow2Textures_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } nonPow2Textures;
   struct vertexPointer_Prop
   {
      constexpr vertexPointer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::vertexPointer_Prop & operator= (GLCapabilities::vertexPointer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } vertexPointer;
   struct legacy_Prop
   {
      constexpr legacy_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::legacy_Prop & operator= (GLCapabilities::legacy_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } legacy;
   struct shaders_Prop
   {
      constexpr shaders_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::shaders_Prop & operator= (GLCapabilities::shaders_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } shaders;
   struct fixedFunction_Prop
   {
      constexpr fixedFunction_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::fixedFunction_Prop & operator= (GLCapabilities::fixedFunction_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fixedFunction;
   struct immediate_Prop
   {
      constexpr immediate_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::immediate_Prop & operator= (GLCapabilities::immediate_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } immediate;
   struct frameBuffer_Prop
   {
      constexpr frameBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::frameBuffer_Prop & operator= (GLCapabilities::frameBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } frameBuffer;
   struct pointSize_Prop
   {
      constexpr pointSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::pointSize_Prop & operator= (GLCapabilities::pointSize_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } pointSize;
   struct vao_Prop
   {
      constexpr vao_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::vao_Prop & operator= (GLCapabilities::vao_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } vao;
   struct select_Prop
   {
      constexpr select_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::select_Prop & operator= (GLCapabilities::select_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } select;
   struct debug_Prop
   {
      constexpr debug_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::debug_Prop & operator= (GLCapabilities::debug_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } debug;
   struct gpuCommands_Prop
   {
      constexpr gpuCommands_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::gpuCommands_Prop & operator= (GLCapabilities::gpuCommands_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } gpuCommands;
   struct mdei_Prop
   {
      constexpr mdei_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLCapabilities::mdei_Prop & operator= (GLCapabilities::mdei_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } mdei;
   struct samples_Prop
   {
      constexpr samples_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLSamplesCount operator= (/*0H*/GLSamplesCount v);
      /*regSet*/inline GLCapabilities::samples_Prop & operator= (GLCapabilities::samples_Prop & prop);
      /*regGet*/inline operator /*0I*/GLSamplesCount () const;
   } samples;
};

enum class GLSamplesCount : int
{
   none = GLSamplesCount_none,
   ms2 = GLSamplesCount_ms2,
   ms4 = GLSamplesCount_ms4,
   ms8 = GLSamplesCount_ms8,
   ms16 = GLSamplesCount_ms16
};

enum class GradientDirection : int
{
   vertical = GradientDirection_vertical,
   horizontal = GradientDirection_horizontal
};

template <class TC, C(Class) ** TCO>
class THitRecord : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline int compare(/*1Ab*/THitRecord<TC, TCO> recordB, /*1Ab*/void * unused); // HitRecord_compare

   struct prev_Prop
   {
      constexpr prev_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/HitRecord operator= (/*0H*/HitRecord & v);
      /*regSet*/inline typename THitRecord<TC, TCO>::prev_Prop & operator= (typename THitRecord<TC, TCO>::prev_Prop & prop);
      /*regGet*/inline operator /*0I*/HitRecord () const;
   } prev;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/HitRecord operator= (/*0H*/HitRecord & v);
      /*regSet*/inline typename THitRecord<TC, TCO>::next_Prop & operator= (typename THitRecord<TC, TCO>::next_Prop & prop);
      /*regGet*/inline operator /*0I*/HitRecord () const;
   } next;
   struct pos_Prop
   {
      constexpr pos_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline typename THitRecord<TC, TCO>::pos_Prop & operator= (typename THitRecord<TC, TCO>::pos_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } pos;
   struct numTags_Prop
   {
      constexpr numTags_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline typename THitRecord<TC, TCO>::numTags_Prop & operator= (typename THitRecord<TC, TCO>::numTags_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } numTags;
   struct center_Prop
   {
      constexpr center_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3D operator= (/*0H*/Vector3D v);
      /*regSet*/inline typename THitRecord<TC, TCO>::center_Prop & operator= (typename THitRecord<TC, TCO>::center_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } center;
   ~THitRecord()
   {
      this->impl = null; // How to know not to delete?
   }
};

struct Light : public TStruct<Light>
{
public:
   C(Light) impl;
   constexpr Light() : impl({}) { }
   constexpr Light(const C(Light) impl) : impl(impl) { }

   inline Light(LightFlags flags, ColorRGB ambient, ColorRGB diffuse, ColorRGB specular, Vector3D direction, Quaternion orientation);

   struct flags_Prop
   {
      constexpr flags_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/LightFlags operator= (/*0H*/LightFlags v);
      /*regSet*/inline Light::flags_Prop & operator= (Light::flags_Prop & prop);
      /*regGet*/inline operator /*0I*/LightFlags () const;
   } flags;
   struct ambient_Prop
   {
      constexpr ambient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline Light::ambient_Prop & operator= (Light::ambient_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } ambient;
   struct diffuse_Prop
   {
      constexpr diffuse_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline Light::diffuse_Prop & operator= (Light::diffuse_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } diffuse;
   struct specular_Prop
   {
      constexpr specular_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline Light::specular_Prop & operator= (Light::specular_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } specular;
   struct direction_Prop
   {
      constexpr direction_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3D operator= (/*0H*/Vector3D v);
      /*regSet*/inline Light::direction_Prop & operator= (Light::direction_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } direction;
   struct orientation_Prop
   {
      constexpr orientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Quaternion operator= (/*0H*/Quaternion v);
      /*regSet*/inline Light::orientation_Prop & operator= (Light::orientation_Prop & prop);
      /*regGet*/inline operator /*0I*/Quaternion () const;
   } orientation;
   struct lightObject_Prop
   {
      constexpr lightObject_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Object operator= (/*0H*/Object & v);
      /*regSet*/inline Light::lightObject_Prop & operator= (Light::lightObject_Prop & prop);
      /*regGet*/inline operator /*0I*/Object () const;
   } lightObject;
   struct target_Prop
   {
      constexpr target_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Object operator= (/*0H*/Object & v);
      /*regSet*/inline Light::target_Prop & operator= (Light::target_Prop & prop);
      /*regGet*/inline operator /*0I*/Object () const;
   } target;
   struct fallOff_Prop
   {
      constexpr fallOff_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Light::fallOff_Prop & operator= (Light::fallOff_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } fallOff;
   struct hotSpot_Prop
   {
      constexpr hotSpot_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Light::hotSpot_Prop & operator= (Light::hotSpot_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } hotSpot;
   struct Kc_Prop
   {
      constexpr Kc_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Light::Kc_Prop & operator= (Light::Kc_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } Kc;
   struct Kl_Prop
   {
      constexpr Kl_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Light::Kl_Prop & operator= (Light::Kl_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } Kl;
   struct Kq_Prop
   {
      constexpr Kq_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Light::Kq_Prop & operator= (Light::Kq_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } Kq;
   struct start_Prop
   {
      constexpr start_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Light::start_Prop & operator= (Light::start_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } start;
   struct end_Prop
   {
      constexpr end_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Light::end_Prop & operator= (Light::end_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } end;
   struct multiplier_Prop
   {
      constexpr multiplier_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Light::multiplier_Prop & operator= (Light::multiplier_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } multiplier;
};

class LightFlags
{
public:
   C(LightFlags) impl;
   constexpr LightFlags() : impl(0) { }
   constexpr LightFlags(C(LightFlags) impl) : impl(impl) { }
   LightFlags(bool off, bool spot, bool omni, bool attenuation);
   operator C(LightFlags)() { return impl; }
   LightFlags & operator =(C(LightFlags) impl) { impl = impl; return *this; }
   bool operator ==(const LightFlags & value) const { return impl == value.impl; }
   bool operator !=(const LightFlags & value) const { return impl != value.impl; }

   struct off_Prop
   {
      constexpr off_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline LightFlags::off_Prop & operator= (LightFlags::off_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } off;
   struct spot_Prop
   {
      constexpr spot_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline LightFlags::spot_Prop & operator= (LightFlags::spot_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } spot;
   struct omni_Prop
   {
      constexpr omni_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline LightFlags::omni_Prop & operator= (LightFlags::omni_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } omni;
   struct attenuation_Prop
   {
      constexpr attenuation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline LightFlags::attenuation_Prop & operator= (LightFlags::attenuation_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } attenuation;
};

enum class PixelFormat : int
{
   pixelFormat4 = PixelFormat_pixelFormat4,
   pixelFormat8 = PixelFormat_pixelFormat8,
   pixelFormat444 = PixelFormat_pixelFormat444,
   pixelFormat555 = PixelFormat_pixelFormat555,
   pixelFormat565 = PixelFormat_pixelFormat565,
   pixelFormat888 = PixelFormat_pixelFormat888,
   pixelFormatAlpha = PixelFormat_pixelFormatAlpha,
   pixelFormatText = PixelFormat_pixelFormatText,
   pixelFormatRGBA = PixelFormat_pixelFormatRGBA,
   pixelFormatA16 = PixelFormat_pixelFormatA16,
   pixelFormatRGBAGL = PixelFormat_pixelFormatRGBAGL,
   pixelFormatETC2RGBA8 = PixelFormat_pixelFormatETC2RGBA8
};

enum class RenderState : int
{
   fillMode = RenderState_fillMode,
   depthTest = RenderState_depthTest,
   depthWrite = RenderState_depthWrite,
   fogDensity = RenderState_fogDensity,
   fogColor = RenderState_fogColor,
   blend = RenderState_blend,
   ambient = RenderState_ambient,
   alphaWrite = RenderState_alphaWrite,
   antiAlias = RenderState_antiAlias,
   vSync = RenderState_vSync
};

struct RenderStateFloat : public TStruct<RenderStateFloat>
{
public:
   C(RenderStateFloat) impl;
   constexpr RenderStateFloat() : impl({}) { }
   constexpr RenderStateFloat(const C(RenderStateFloat) impl) : impl(impl) { }

   inline RenderStateFloat(float f, uint ui);

   struct f_Prop
   {
      constexpr f_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline RenderStateFloat::f_Prop & operator= (RenderStateFloat::f_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } f;
   struct ui_Prop
   {
      constexpr ui_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline RenderStateFloat::ui_Prop & operator= (RenderStateFloat::ui_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } ui;
};

enum class Resolution : int
{
   resText80x25 = Resolution_resText80x25,
   res320x200 = Resolution_res320x200,
   res320x240 = Resolution_res320x240,
   res320x400 = Resolution_res320x400,
   res360x480 = Resolution_res360x480,
   res400x256 = Resolution_res400x256,
   res400x300 = Resolution_res400x300,
   res512x256 = Resolution_res512x256,
   res512x384 = Resolution_res512x384,
   res640x200 = Resolution_res640x200,
   res640x350 = Resolution_res640x350,
   res640x400 = Resolution_res640x400,
   res640x480 = Resolution_res640x480,
   res720x348 = Resolution_res720x348,
   res800x600 = Resolution_res800x600,
   res856x480 = Resolution_res856x480,
   res960x720 = Resolution_res960x720,
   res1024x768 = Resolution_res1024x768,
   res1152x864 = Resolution_res1152x864,
   res1280x1024 = Resolution_res1280x1024,
   res1600x1200 = Resolution_res1600x1200,
   res768x480 = Resolution_res768x480
};


#define REG_Surface(c) \
      Surface::class_registration(_cpp_class);

#define SURFACE_VIRTUAL_METHODS_PROTO(c) \

#define SURFACE_VIRTUAL_METHODS(c) \

class Surface : public Instance
{
public:
   inline Surface(Surface && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Surface & operator= (Surface && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Surface() : Surface((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Surface> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Surface * inst = new Surface(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Surface * inst = (Surface *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Surface & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Surface(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void area(/*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2); // Surface_area
   inline void bevel(/*1Ab*/bool inner, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h); // Surface_bevel
   inline void blit(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h); // Surface_blit
   template<typename... Args> inline void centerTextf(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * format, /*1Ab*/Args... args); // Surface_centerTextf
   inline void clear(/*1Ab*/ClearType type); // Surface_clear
   inline void clip(/*1Ab*/Box & box); // Surface_clip
   inline void clip(/*1Ac*/Box * box); // Surface_clip
   inline void drawLine(/*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2); // Surface_drawLine
   inline void _drawingChar(/*1Ab*/byte value); // Surface_drawingChar
   inline void filter(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh); // Surface_filter
   inline void filterHTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h); // Surface_filterHTile
   inline void filterVTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h); // Surface_filterVTile
   inline C(Color) getBackground(); // Surface_getBackground
   inline void getBox(/*1Ab*/Box & value); // Surface_getBox
   inline void getBox(/*1Ac*/Box * value); // Surface_getBox
   inline Display getDisplay(); // Surface_getDisplay
   inline C(Font) * getFont(); // Surface_getFont
   inline C(Color) getForeground(); // Surface_getForeground
   inline C(ColorAlpha) getPixel(/*1Ab*/int x, /*1Ab*/int y); // Surface_getPixel
   inline void getSize(/*1Ab*/int * w, /*1Ab*/int * h); // Surface_getSize
   inline C(bool) getTextOpacity(); // Surface_getTextOpacity
   inline void gradient(/*1Ab*/ColorKey * keys, /*1Ab*/int numKeys, /*1Ab*/float smoothness, /*1Ab*/GradientDirection direction, /*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2); // Surface_gradient
   inline void hLine(/*1Ab*/int x1, /*1Ab*/int x2, /*1Ab*/int y); // Surface_hLine
   inline void hTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h); // Surface_hTile
   inline void _lineStipple(/*1Ab*/uint value); // Surface_lineStipple
   inline void putPixel(/*1Ab*/int x, /*1Ab*/int y); // Surface_putPixel
   inline void rectangle(/*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2); // Surface_rectangle
   inline void setBackground(/*1Ab*/ColorAlpha value); // Surface_setBackground
   inline void setForeground(/*1Ab*/ColorAlpha value); // Surface_setForeground
   inline void stretch(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh); // Surface_stretch
   inline void stretchf(/*1Ab*/Bitmap & src, /*1Ab*/float dx, /*1Ab*/float dy, /*1Ab*/float sx, /*1Ab*/float sy, /*1Ab*/float w, /*1Ab*/float h, /*1Ab*/float sw, /*1Ab*/float sh); // Surface_stretchf
   inline void textExtent(/*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height); // Surface_textExtent
   inline void textExtent2(/*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang); // Surface_textExtent2
   inline void textFont(/*1Ab*/Font value); // Surface_textFont
   inline void _textOpacity(/*1Ab*/bool value); // Surface_textOpacity
   inline void thinBevel(/*1Ab*/bool inner, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h); // Surface_thinBevel
   inline void tile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h); // Surface_tile
   inline void vLine(/*1Ab*/int y1, /*1Ab*/int y2, /*1Ab*/int x); // Surface_vLine
   inline void vTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h); // Surface_vTile
   inline void writeText(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/int len); // Surface_writeText
   inline void writeText2(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph); // Surface_writeText2
   inline void writeTextDots(/*1Ab*/Alignment alignment, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int width, /*1Ab*/const char * text, /*1Ab*/int len); // Surface_writeTextDots
   template<typename... Args> inline void writeTextDotsf(/*1Ab*/Alignment alignment, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int width, /*1Ab*/const char * format, /*1Ab*/Args... args); // Surface_writeTextDotsf
   template<typename... Args> inline void writeTextf(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * format, /*1Ab*/Args... args); // Surface_writeTextf

   static void class_registration(CPPClass & _cpp_class);

   inline Surface(int width, int height, Point offset, Box box, Box unclippedBox, void * driverData, AlphaWriteMode alphaWrite, bool blend, ColorAlpha outlineColor, ColorAlpha foreground, ColorAlpha background, ColorAlpha blitTint, Color blackTint, uint lineStipple);

   struct alphaWrite_Prop
   {
      constexpr alphaWrite_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/AlphaWriteMode operator= (/*0H*/AlphaWriteMode v);
      /*regSet*/inline Surface::alphaWrite_Prop & operator= (Surface::alphaWrite_Prop & prop);
      /*regGet*/inline operator /*0I*/AlphaWriteMode () const;
   } alphaWrite;
   struct blend_Prop
   {
      constexpr blend_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Surface::blend_Prop & operator= (Surface::blend_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } blend;
   struct bitmap_Prop
   {
      constexpr bitmap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Bitmap> () const;
      /*regGet*/inline TIH<Bitmap> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Bitmap () const;
      /*regGet*/inline operator /*0F*/Bitmap* () const;
   } bitmap;
   struct outlineColor_Prop
   {
      constexpr outlineColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha operator= (/*0H*/ColorAlpha v);
      /*regSet*/inline Surface::outlineColor_Prop & operator= (Surface::outlineColor_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha () const;
   } outlineColor;
   struct foreground_Prop
   {
      constexpr foreground_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha operator= (/*0H*/ColorAlpha v);
      /*regSet*/inline Surface::foreground_Prop & operator= (Surface::foreground_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha () const;
   } foreground;
   struct background_Prop
   {
      constexpr background_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha operator= (/*0H*/ColorAlpha v);
      /*regSet*/inline Surface::background_Prop & operator= (Surface::background_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha () const;
   } background;
   struct blitTint_Prop
   {
      constexpr blitTint_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha operator= (/*0H*/ColorAlpha v);
      /*regSet*/inline Surface::blitTint_Prop & operator= (Surface::blitTint_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha () const;
   } blitTint;
   struct blackTint_Prop
   {
      constexpr blackTint_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline Surface::blackTint_Prop & operator= (Surface::blackTint_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } blackTint;
   struct lineStipple_Prop
   {
      constexpr lineStipple_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/uint operator= (/*0G*/uint v);
   } lineStipple;
   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Size () const;
   } size;
   struct display_Prop
   {
      constexpr display_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Display> () const;
      /*regGet*/inline TIH<Display> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Display () const;
      /*regGet*/inline operator /*0F*/Display* () const;
   } display;
   struct font_Prop
   {
      constexpr font_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Font operator= (/*0H*/Font & v);
      /*regSet*/inline Surface::font_Prop & operator= (Surface::font_Prop & prop);
      /*regGet*/inline operator /*0I*/Font () const;
   } font;
   struct textOpacity_Prop
   {
      constexpr textOpacity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Surface::textOpacity_Prop & operator= (Surface::textOpacity_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } textOpacity;
   struct drawingChar_Prop
   {
      constexpr drawingChar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/unsigned char operator= (/*0G*/unsigned char v);
   } drawingChar;
   struct clipping_Prop
   {
      constexpr clipping_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Box operator= (/*0G*/Box v);
   } clipping;

   struct width_Prop
   {
      constexpr width_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Surface::width_Prop & operator= (Surface::width_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } width;
   struct height_Prop
   {
      constexpr height_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Surface::height_Prop & operator= (Surface::height_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } height;
   struct offset_Prop
   {
      constexpr offset_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Point operator= (/*0H*/Point v);
      /*regSet*/inline Surface::offset_Prop & operator= (Surface::offset_Prop & prop);
      /*regGet*/inline operator /*0I*/Point () const;
   } offset;
   struct box_Prop
   {
      constexpr box_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Box operator= (/*0H*/Box v);
      /*regSet*/inline Surface::box_Prop & operator= (Surface::box_Prop & prop);
      /*regGet*/inline operator /*0I*/Box () const;
   } box;
   struct unclippedBox_Prop
   {
      constexpr unclippedBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Box operator= (/*0H*/Box v);
      /*regSet*/inline Surface::unclippedBox_Prop & operator= (Surface::unclippedBox_Prop & prop);
      /*regGet*/inline operator /*0I*/Box () const;
   } unclippedBox;
   struct driverData_Prop
   {
      constexpr driverData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline Surface::driverData_Prop & operator= (Surface::driverData_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } driverData;
};

enum class SystemColor : uint
{
   formColor = SystemColor_formColor,
   activeBorder = SystemColor_activeBorder,
   control = SystemColor_control,
   controlLight = SystemColor_controlLight,
   inactiveBorder = SystemColor_inactiveBorder,
   inactiveCaptionText = SystemColor_inactiveCaptionText,
   menu = SystemColor_menu,
   scrollBar = SystemColor_scrollBar
};

struct PNGOptions : public TStruct<PNGOptions>
{
public:
   C(PNGOptions) impl;
   constexpr PNGOptions() : impl({}) { }
   constexpr PNGOptions(const C(PNGOptions) impl) : impl(impl) { }

   inline PNGOptions(int zlibCompressionLevel);

   struct zlibCompressionLevel_Prop
   {
      constexpr zlibCompressionLevel_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PNGOptions::zlibCompressionLevel_Prop & operator= (PNGOptions::zlibCompressionLevel_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } zlibCompressionLevel;
};

template <class TC, C(Class) ** TCO>
class TCompiledShader : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline void free(); // CompiledShader_free

   struct program_Prop
   {
      constexpr program_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledShader<TC, TCO>::program_Prop & operator= (typename TCompiledShader<TC, TCO>::program_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } program;
   struct vertex_Prop
   {
      constexpr vertex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledShader<TC, TCO>::vertex_Prop & operator= (typename TCompiledShader<TC, TCO>::vertex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } vertex;
   struct fragment_Prop
   {
      constexpr fragment_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledShader<TC, TCO>::fragment_Prop & operator= (typename TCompiledShader<TC, TCO>::fragment_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } fragment;
   ~TCompiledShader()
   {
      this->impl = null; // How to know not to delete?
   }
};

#define REG_FreeBlockMap_onExpand(m, c) REGVMETHOD(FreeBlockMap, onExpand, c::m, (/*1Ab*/FreeBlockMap & self, /*1Ab*/GLBType type, /*1Ab*/uint required), c, (/*4Hm*/(GLBType)type, /*4Im*/required))

#define REG_FreeBlockMap(c) \
      FreeBlockMap::class_registration(_cpp_class); \
      REG_Container_copy(copy, c, TP_T, TP_I, TP_D); \
      REG_Container_delete(delete, c, TP_T, TP_I, TP_D); \
      REG_Container_free(free, c, TP_T, TP_I, TP_D); \
      REG_Container_freeIterator(freeIterator, c, TP_T, TP_I, TP_D); \
      REG_Container_getCount(getCount, c, TP_T, TP_I, TP_D); \
      REG_Container_getData(getData, c, TP_T, TP_I, TP_D); \
      REG_Container_getFirst(getFirst, c, TP_T, TP_I, TP_D); \
      REG_Container_getLast(getLast, c, TP_T, TP_I, TP_D); \
      REG_Container_getNext(getNext, c, TP_T, TP_I, TP_D); \
      REG_Container_getPrev(getPrev, c, TP_T, TP_I, TP_D); \
      REG_Container_move(move, c, TP_T, TP_I, TP_D); \
      REG_Container_remove(remove, c, TP_T, TP_I, TP_D); \
      REG_Container_removeAll(removeAll, c, TP_T, TP_I, TP_D); \
      REG_Container_sort(sort, c, TP_T, TP_I, TP_D); \
      REG_FreeBlockMap_onExpand(onExpand, c);

#define FREEBLOCKMAP_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(onExpand, onExpand, c, FreeBlockMap, \
      uint, c & _ARG, , /*6Fj*/GLBType type _ARG /*6Fj*/uint required);

#define FREEBLOCKMAP_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(onExpand, onExpand, c, FreeBlockMap, \
   uint, c & _ARG, , /*6Fj*/GLBType type _ARG /*6Fj*/uint required, \
   return FreeBlockMap_onExpand(self ? self->impl : (C(FreeBlockMap))null, /*7Al*/(C(GLBType))type, /*7Al*/required););

class FreeBlockMap : public TArray<BlockEntry, int, BlockEntry>
{
public:
   inline FreeBlockMap(FreeBlockMap && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FreeBlockMap & operator= (FreeBlockMap && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FreeBlockMap() : FreeBlockMap((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FreeBlockMap> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FreeBlockMap * inst = new FreeBlockMap(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FreeBlockMap * inst = (FreeBlockMap *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FreeBlockMap & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FreeBlockMap(C(Instance) _impl, CPPClass & cl = _cpp_class) : TArray<BlockEntry, int, BlockEntry>(_impl, cl) { }

   struct FreeBlockMap_onExpand_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uint (* FunctionType)(FreeBlockMap & , /*6Fj*/GLBType type, /*6Fj*/uint required);
      inline FunctionType operator= (FunctionType func);
      inline uint operator()( /*6Fj*/GLBType type, /*6Fj*/uint required);
   } onExpand;
   // inline static void register_onExpand(CPPClass & cl, FreeBlockMap::FreeBlockMap_onExpand_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};

struct GLB : public TStruct<GLB>
{
public:
   C(GLB) impl;
   constexpr GLB() : impl({}) { }
   constexpr GLB(const C(GLB) impl) : impl(impl) { }

   inline C(bool) _allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLB__allocate
   inline void _upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLB__upload
   inline C(bool) allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLB_allocate
   inline void copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size); // GLB_copy
   inline void copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size); // GLB_copy
   static inline void deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers); // GLB_deleteBuffers
   inline void free(); // GLB_free
   inline C(bool) resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID); // GLB_resize
   inline void upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLB_upload

   inline GLB(uint buffer);

   struct buffer_Prop
   {
      constexpr buffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLB::buffer_Prop & operator= (GLB::buffer_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } buffer;
};

#define REG_Shader_bindAttribs(m, c)      REGVMETHOD(Shader, bindAttribs,      c::m, (/*1Ab*/Shader & self, /*1Ab*/int program),                                                                                              c, (/*4Im*/program))
#define REG_Shader_getDefinitions(m, c)   REGVMETHOD(Shader, getDefinitions,   c::m, (/*1Ab*/Shader & self, /*1Ab*/uint64 state),                                                                                             c, (/*4Im*/state))
#define REG_Shader_registerShader(m, c)   REGVMETHOD(Shader, registerShader,   c::m, (/*1Ab*/Shader & self, /*1Ab*/int program, /*1Ab*/uint64 state),                                                                         c, (/*4Im*/program, /*4Im*/state))
#define REG_Shader_setMaterial(m, c)      REGVMETHOD(Shader, setMaterial,      c::m, (/*1Ab*/Shader & self, /*1Ab*/Material material, /*1Ab*/MeshFeatures flags),                                                             c, (/*4Im*/material, /*4Hm*/(MeshFeatures)flags))
#define REG_Shader_setupDrawCommand(m, c) REGVMETHOD(Shader, setupDrawCommand, c::m, (/*1Ab*/Shader & self, /*1Ab*/GLAB & ab, /*1Ab*/uint vertexStride, /*1Ab*/uint baseVertex, /*1Ab*/uint drawID, /*1Ab*/void * transform), c, (/*4Im*/ab, /*4Im*/vertexStride, /*4Im*/baseVertex, /*4Im*/drawID, /*4Im*/transform))
#define REG_Shader_updateMatrix(m, c)     REGVMETHOD(Shader, updateMatrix,     c::m, (/*1Ab*/Shader & self, /*1Ab*/MatrixMode mode, /*1Ab*/float * matrix, /*1Ab*/bool isIdentity),                                           c, (/*4Hm*/(MatrixMode)mode, /*4Im*/matrix, /*4Hm*/(bool)isIdentity))
#define REG_Shader_uploadUniforms(m, c)   REGVMETHOD(Shader, uploadUniforms,   c::m, (/*1Ab*/Shader & self, /*1Ab*/CompiledShader shader),                                                                                    c, (/*4Im*/shader))

#define REG_Shader(c) \
      Shader::class_registration(_cpp_class); \
      REG_Shader_bindAttribs(bindAttribs, c); \
      REG_Shader_getDefinitions(getDefinitions, c); \
      REG_Shader_registerShader(registerShader, c); \
      REG_Shader_setMaterial(setMaterial, c); \
      REG_Shader_setupDrawCommand(setupDrawCommand, c); \
      REG_Shader_updateMatrix(updateMatrix, c); \
      REG_Shader_uploadUniforms(uploadUniforms, c);

#define SHADER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(bindAttribs, bindAttribs, c, Shader, \
      void, c & _ARG, , /*6Fj*/int program); \
   VIRTUAL_METHOD_PROTO(getDefinitions, getDefinitions, c, Shader, \
      ZString *, c & _ARG, , /*6Fj*/uint64 state); \
   VIRTUAL_METHOD_PROTO(registerShader, registerShader, c, Shader, \
      CompiledShader, c & _ARG, , /*6Fj*/int program _ARG /*6Fj*/uint64 state); \
   VIRTUAL_METHOD_PROTO(setMaterial, setMaterial, c, Shader, \
      void, c & _ARG, , /*6Fj*/Material material _ARG /*6Fj*/MeshFeatures flags); \
   VIRTUAL_METHOD_PROTO(setupDrawCommand, setupDrawCommand, c, Shader, \
      void, c & _ARG, , /*6Fj*/GLAB & ab _ARG /*6Fj*/uint vertexStride _ARG /*6Fj*/uint baseVertex _ARG /*6Fj*/uint drawID _ARG /*6Fj*/void * transform); \
   VIRTUAL_METHOD_PROTO(updateMatrix, updateMatrix, c, Shader, \
      void, c & _ARG, , /*6Fj*/MatrixMode mode _ARG /*6Fj*/float * matrix _ARG /*6Fj*/bool isIdentity); \
   VIRTUAL_METHOD_PROTO(uploadUniforms, uploadUniforms, c, Shader, \
      void, c & _ARG, , /*6Fj*/CompiledShader shader);

#define SHADER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(bindAttribs, bindAttribs, c, Shader, \
   void, c & _ARG, , /*6Fj*/int program, \
   Shader_bindAttribs(self ? self->impl : (C(Shader))null, /*7Al*/program);); \
VIRTUAL_METHOD(getDefinitions, getDefinitions, c, Shader, \
   ZString *, c & _ARG, , /*6Fj*/uint64 state, \
   C(ZString) retZString = Shader_getDefinitions(self ? self->impl : (C(Shader))null, /*7Al*/state); \
      return BINDINGS_CLASS(retZString) ? (ZString *)INSTANCEL(retZString, retZString->_class) : (ZString *)0;); \
VIRTUAL_METHOD(registerShader, registerShader, c, Shader, \
   CompiledShader, c & _ARG, , /*6Fj*/int program _ARG /*6Fj*/uint64 state, \
   C(CompiledShader) * retCompiledShader = Shader_registerShader(self ? self->impl : (C(Shader))null, /*7Al*/program, /*7Al*/state); \
      return retCompiledShader;); \
VIRTUAL_METHOD(setMaterial, setMaterial, c, Shader, \
   void, c & _ARG, , /*6Fj*/Material material _ARG /*6Fj*/MeshFeatures flags, \
   Shader_setMaterial(self ? self->impl : (C(Shader))null, /*7Al*/material.impl, /*7Al*/(C(MeshFeatures))flags);); \
VIRTUAL_METHOD(setupDrawCommand, setupDrawCommand, c, Shader, \
   void, c & _ARG, , /*6Fj*/GLAB & ab _ARG /*6Fj*/uint vertexStride _ARG /*6Fj*/uint baseVertex _ARG /*6Fj*/uint drawID _ARG /*6Fj*/void * transform, \
   Shader_setupDrawCommand(self ? self->impl : (C(Shader))null, /*7Al*/&ab.impl, /*7Al*/vertexStride, /*7Al*/baseVertex, /*7Al*/drawID, /*7Al*/transform);); \
VIRTUAL_METHOD(updateMatrix, updateMatrix, c, Shader, \
   void, c & _ARG, , /*6Fj*/MatrixMode mode _ARG /*6Fj*/float * matrix _ARG /*6Fj*/bool isIdentity, \
   Shader_updateMatrix(self ? self->impl : (C(Shader))null, /*7Al*/(C(MatrixMode))mode, /*7Al*/matrix, /*7Al*/(C(bool))isIdentity);); \
VIRTUAL_METHOD(uploadUniforms, uploadUniforms, c, Shader, \
   void, c & _ARG, , /*6Fj*/CompiledShader shader, \
   Shader_uploadUniforms(self ? self->impl : (C(Shader))null, /*7Al*/shader.impl););

class Shader : public Instance
{
public:
   inline Shader(Shader && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Shader & operator= (Shader && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Shader() : Shader((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Shader> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Shader * inst = new Shader(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Shader * inst = (Shader *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Shader & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Shader(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) activate(); // Shader_activate
   inline void free(); // Shader_free
   inline C(CompiledShader) * load(/*1Ab*/uint64 state); // Shader_load
   inline void select(); // Shader_select

   struct Shader_bindAttribs_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Shader & , /*6Fj*/int program);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int program);
   } bindAttribs;
   // inline static void register_bindAttribs(CPPClass & cl, Shader::Shader_bindAttribs_Functor::FunctionType func)

   struct Shader_getDefinitions_Functor
   {
      [[no_unique_address]] int _[0];
      typedef ZString * (* FunctionType)(Shader & , /*6Fj*/uint64 state);
      inline FunctionType operator= (FunctionType func);
      inline ZString * operator()( /*6Fj*/uint64 state);
   } getDefinitions;
   // inline static void register_getDefinitions(CPPClass & cl, Shader::Shader_getDefinitions_Functor::FunctionType func)

   struct Shader_registerShader_Functor
   {
      [[no_unique_address]] int _[0];
      typedef CompiledShader (* FunctionType)(Shader & , /*6Fj*/int program, /*6Fj*/uint64 state);
      inline FunctionType operator= (FunctionType func);
      inline CompiledShader operator()( /*6Fj*/int program, /*6Fj*/uint64 state);
   } registerShader;
   // inline static void register_registerShader(CPPClass & cl, Shader::Shader_registerShader_Functor::FunctionType func)

   struct Shader_setMaterial_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Shader & , /*6Fj*/Material material, /*6Fj*/MeshFeatures flags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Material material, /*6Fj*/MeshFeatures flags);
   } setMaterial;
   // inline static void register_setMaterial(CPPClass & cl, Shader::Shader_setMaterial_Functor::FunctionType func)

   struct Shader_setupDrawCommand_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Shader & , /*6Fj*/GLAB & ab, /*6Fj*/uint vertexStride, /*6Fj*/uint baseVertex, /*6Fj*/uint drawID, /*6Fj*/void * transform);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/GLAB & ab, /*6Fj*/uint vertexStride, /*6Fj*/uint baseVertex, /*6Fj*/uint drawID, /*6Fj*/void * transform);
   } setupDrawCommand;
   // inline static void register_setupDrawCommand(CPPClass & cl, Shader::Shader_setupDrawCommand_Functor::FunctionType func)

   struct Shader_updateMatrix_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Shader & , /*6Fj*/MatrixMode mode, /*6Fj*/float * matrix, /*6Fj*/bool isIdentity);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/MatrixMode mode, /*6Fj*/float * matrix, /*6Fj*/bool isIdentity);
   } updateMatrix;
   // inline static void register_updateMatrix(CPPClass & cl, Shader::Shader_updateMatrix_Functor::FunctionType func)

   struct Shader_uploadUniforms_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Shader & , /*6Fj*/CompiledShader shader);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/CompiledShader shader);
   } uploadUniforms;
   // inline static void register_uploadUniforms(CPPClass & cl, Shader::Shader_uploadUniforms_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline Shader(/*CT-D*/constString vertexShaderFile, /*CT-D*/constString fragmentShaderFile, /*CT-D*/constString vertexShader, /*CT-D*/constString fragmentShader, uint64 state, ShaderModifiedUniforms modifiedUniforms);

   struct vertexShaderFile_Prop
   {
      constexpr vertexShaderFile_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*//*CT-D*/constString operator= (/*0G*//*CT-D*/constString v);
   } vertexShaderFile;
   struct fragmentShaderFile_Prop
   {
      constexpr fragmentShaderFile_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*//*CT-D*/constString operator= (/*0G*//*CT-D*/constString v);
   } fragmentShaderFile;
   struct vertexShader_Prop
   {
      constexpr vertexShader_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*//*CT-D*/constString operator= (/*0G*//*CT-D*/constString v);
   } vertexShader;
   struct fragmentShader_Prop
   {
      constexpr fragmentShader_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*//*CT-D*/constString operator= (/*0G*//*CT-D*/constString v);
   } fragmentShader;
   struct activeCompiledShader_Prop
   {
      constexpr activeCompiledShader_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/CompiledShader () const;
   } activeCompiledShader;

   struct state_Prop
   {
      constexpr state_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint64 operator= (/*0H*/uint64 v);
      /*regSet*/inline Shader::state_Prop & operator= (Shader::state_Prop & prop);
      /*regGet*/inline operator /*0I*/uint64 () const;
   } state;
   struct modifiedUniforms_Prop
   {
      constexpr modifiedUniforms_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ShaderModifiedUniforms operator= (/*0H*/ShaderModifiedUniforms v);
      /*regSet*/inline Shader::modifiedUniforms_Prop & operator= (Shader::modifiedUniforms_Prop & prop);
      /*regGet*/inline operator /*0I*/ShaderModifiedUniforms () const;
   } modifiedUniforms;
};

class BlockEntry
{
public:
   C(BlockEntry) impl;
   constexpr BlockEntry() : impl(0) { }
   constexpr BlockEntry(C(BlockEntry) impl) : impl(impl) { }
   BlockEntry(uint start, uint end)
   {
      impl = BLOCKENTRY(start, end);
   }
   operator C(BlockEntry)() { return impl; }
   BlockEntry & operator =(C(BlockEntry) impl) { impl = impl; return *this; }
   bool operator ==(const BlockEntry & value) const { return impl == value.impl; }
   bool operator !=(const BlockEntry & value) const { return impl != value.impl; }

   struct start_Prop
   {
      constexpr start_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline BlockEntry::start_Prop & operator= (BlockEntry::start_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } start;
   struct end_Prop
   {
      constexpr end_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline BlockEntry::end_Prop & operator= (BlockEntry::end_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } end;
};

template <class TC, C(Class) ** TCO>
class TCompiledDefaultShader : public TCompiledShader<TC, TCO>
{
public:
   using TCompiledShader<TC, TCO>::TCompiledShader;
   inline operator CompiledShader& () const { return *(CompiledShader *)this; }

   inline void registerUniforms(/*1Ab*/int program, /*1Ab*/DefaultShaderBits state); // CompiledDefaultShader_registerUniforms

   struct uPrjMatrix_Prop
   {
      constexpr uPrjMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uPrjMatrix_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uPrjMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uPrjMatrix;
   struct uMVMatrix_Prop
   {
      constexpr uMVMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMVMatrix_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMVMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMVMatrix;
   struct uTextureMatrix_Prop
   {
      constexpr uTextureMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uTextureMatrix_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uTextureMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uTextureMatrix;
   struct uNormalsMatrix_Prop
   {
      constexpr uNormalsMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uNormalsMatrix_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uNormalsMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uNormalsMatrix;
   struct uNormalsInvScale2_Prop
   {
      constexpr uNormalsInvScale2_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uNormalsInvScale2_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uNormalsInvScale2_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uNormalsInvScale2;
   struct uFogDensity_Prop
   {
      constexpr uFogDensity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uFogDensity_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uFogDensity_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uFogDensity;
   struct uFogColor_Prop
   {
      constexpr uFogColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uFogColor_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uFogColor_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uFogColor;
   struct uGlobalAmbient_Prop
   {
      constexpr uGlobalAmbient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uGlobalAmbient_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uGlobalAmbient_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uGlobalAmbient;
   struct uNearPlane_Prop
   {
      constexpr uNearPlane_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uNearPlane_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uNearPlane_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uNearPlane;
   struct uMatDiffuse_Prop
   {
      constexpr uMatDiffuse_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMatDiffuse_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMatDiffuse_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMatDiffuse;
   struct uMatAmbient_Prop
   {
      constexpr uMatAmbient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMatAmbient_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMatAmbient_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMatAmbient;
   struct uMatSpecular_Prop
   {
      constexpr uMatSpecular_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMatSpecular_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMatSpecular_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMatSpecular;
   struct uMatEmissive_Prop
   {
      constexpr uMatEmissive_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMatEmissive_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMatEmissive_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMatEmissive;
   struct uMatPower_Prop
   {
      constexpr uMatPower_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMatPower_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMatPower_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMatPower;
   struct uMatOpacity_Prop
   {
      constexpr uMatOpacity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMatOpacity_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMatOpacity_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMatOpacity;
   struct uDiffuseTex_Prop
   {
      constexpr uDiffuseTex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uDiffuseTex_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uDiffuseTex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uDiffuseTex;
   struct uBumpTex_Prop
   {
      constexpr uBumpTex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uBumpTex_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uBumpTex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uBumpTex;
   struct uSpecularTex_Prop
   {
      constexpr uSpecularTex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uSpecularTex_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uSpecularTex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uSpecularTex;
   struct uEnvTex_Prop
   {
      constexpr uEnvTex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uEnvTex_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uEnvTex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uEnvTex;
   struct uReflectTex_Prop
   {
      constexpr uReflectTex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uReflectTex_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uReflectTex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uReflectTex;
   struct uRefractionETA_Prop
   {
      constexpr uRefractionETA_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uRefractionETA_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uRefractionETA_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uRefractionETA;
   struct uMatReflectivity_Prop
   {
      constexpr uMatReflectivity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uMatReflectivity_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uMatReflectivity_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uMatReflectivity;
   struct uCubeMapMatrix_Prop
   {
      constexpr uCubeMapMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uCubeMapMatrix_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uCubeMapMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uCubeMapMatrix;
   struct uAlphaFuncValue_Prop
   {
      constexpr uAlphaFuncValue_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uAlphaFuncValue_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uAlphaFuncValue_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uAlphaFuncValue;
   struct uBlackTint_Prop
   {
      constexpr uBlackTint_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uBlackTint_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uBlackTint_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uBlackTint;
   struct uBoneMatrices_Prop
   {
      constexpr uBoneMatrices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uBoneMatrices_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uBoneMatrices_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uBoneMatrices;
   struct uBoneOffsets_Prop
   {
      constexpr uBoneOffsets_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::uBoneOffsets_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::uBoneOffsets_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } uBoneOffsets;
   struct initialSetup_Prop
   {
      constexpr initialSetup_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::initialSetup_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::initialSetup_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } initialSetup;
   struct useNearPlane_Prop
   {
      constexpr useNearPlane_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TCompiledDefaultShader<TC, TCO>::useNearPlane_Prop & operator= (typename TCompiledDefaultShader<TC, TCO>::useNearPlane_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } useNearPlane;
   ~TCompiledDefaultShader()
   {
      this->impl = null; // How to know not to delete?
   }
};


#define REG_DefaultShader(c) \
      DefaultShader::class_registration(_cpp_class); \
      REG_Shader_bindAttribs(bindAttribs, c); \
      REG_Shader_getDefinitions(getDefinitions, c); \
      REG_Shader_registerShader(registerShader, c); \
      REG_Shader_setMaterial(setMaterial, c); \
      REG_Shader_setupDrawCommand(setupDrawCommand, c); \
      REG_Shader_updateMatrix(updateMatrix, c); \
      REG_Shader_uploadUniforms(uploadUniforms, c);

#define DEFAULTSHADER_VIRTUAL_METHODS_PROTO(c) \

#define DEFAULTSHADER_VIRTUAL_METHODS(c) \

class DefaultShader : public Shader
{
public:
   inline DefaultShader(DefaultShader && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DefaultShader & operator= (DefaultShader && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DefaultShader() : DefaultShader((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DefaultShader> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DefaultShader * inst = new DefaultShader(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DefaultShader * inst = (DefaultShader *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DefaultShader & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DefaultShader(C(Instance) _impl, CPPClass & cl = _cpp_class) : Shader(_impl, cl) { }

   inline void debugging(/*1Ab*/bool on); // DefaultShader_debugging
   inline void fog(/*1Ab*/bool on); // DefaultShader_fog
   inline void lighting(/*1Ab*/bool on); // DefaultShader_lighting
   inline void setBoneMatrices(/*1Ab*/int n, /*1Ab*/const Matrixf * matrices); // DefaultShader_setBoneMatrices
   inline void setCamera(/*1Ab*/Camera & camera); // DefaultShader_setCamera
   inline void setColor(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b, /*1Ab*/float a); // DefaultShader_setColor
   inline void setFogColor(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b); // DefaultShader_setFogColor
   inline void setFogDensity(/*1Ab*/float density); // DefaultShader_setFogDensity
   inline void setGlobalAmbient(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b, /*1Ab*/float a); // DefaultShader_setGlobalAmbient
   inline void setLight(/*1Ab*/Display & display, /*1Ab*/uint id, /*1Ab*/Light & light); // DefaultShader_setLight
   inline void setLight(/*1Ac*/Display & display, /*1Ac*/uint id, /*1Ac*/Light * light); // DefaultShader_setLight
   inline void setPerVertexColor(/*1Ab*/bool perVertexColor); // DefaultShader_setPerVertexColor
   inline void setSimpleMaterial(/*1Ab*/ColorAlpha color, /*1Ab*/bool twoSided); // DefaultShader_setSimpleMaterial
   static inline DefaultShader shader(); // DefaultShader_shader
   inline void swizzle(/*1Ab*/SwizzleMode swizzle); // DefaultShader_swizzle
   inline void texturing(/*1Ab*/bool on); // DefaultShader_texturing
   inline void useExternalTexture(/*1Ab*/bool on); // DefaultShader_useExternalTexture

   static void class_registration(CPPClass & _cpp_class);

   inline DefaultShader(DefaultShaderBits backLightState, Color blackTint);

   struct blackTint_Prop
   {
      constexpr blackTint_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Color operator= (/*0G*/Color v);
   } blackTint;

   struct backLightState_Prop
   {
      constexpr backLightState_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DefaultShaderBits operator= (/*0H*/DefaultShaderBits v);
      /*regSet*/inline DefaultShader::backLightState_Prop & operator= (DefaultShader::backLightState_Prop & prop);
      /*regGet*/inline operator /*0I*/DefaultShaderBits () const;
   } backLightState;
};

class DefaultShaderBits
{
public:
   C(DefaultShaderBits) impl;
   constexpr DefaultShaderBits() : impl(0) { }
   constexpr DefaultShaderBits(C(DefaultShaderBits) impl) : impl(impl) { }
   operator C(DefaultShaderBits)() { return impl; }
   DefaultShaderBits & operator =(C(DefaultShaderBits) impl) { impl = impl; return *this; }
   bool operator ==(const DefaultShaderBits & value) const { return impl == value.impl; }
   bool operator !=(const DefaultShaderBits & value) const { return impl != value.impl; }

   struct lighting_Prop
   {
      constexpr lighting_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::lighting_Prop & operator= (DefaultShaderBits::lighting_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } lighting;
   struct nonLocalViewer_Prop
   {
      constexpr nonLocalViewer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::nonLocalViewer_Prop & operator= (DefaultShaderBits::nonLocalViewer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } nonLocalViewer;
   struct twoSided_Prop
   {
      constexpr twoSided_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::twoSided_Prop & operator= (DefaultShaderBits::twoSided_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } twoSided;
   struct specular_Prop
   {
      constexpr specular_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::specular_Prop & operator= (DefaultShaderBits::specular_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } specular;
   struct separateSpecular_Prop
   {
      constexpr separateSpecular_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::separateSpecular_Prop & operator= (DefaultShaderBits::separateSpecular_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } separateSpecular;
   struct blinnSpecular_Prop
   {
      constexpr blinnSpecular_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::blinnSpecular_Prop & operator= (DefaultShaderBits::blinnSpecular_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } blinnSpecular;
   struct lightBits_Prop
   {
      constexpr lightBits_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline DefaultShaderBits::lightBits_Prop & operator= (DefaultShaderBits::lightBits_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } lightBits;
   struct perVertexColor_Prop
   {
      constexpr perVertexColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::perVertexColor_Prop & operator= (DefaultShaderBits::perVertexColor_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } perVertexColor;
   struct swizzle_Prop
   {
      constexpr swizzle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SwizzleMode operator= (/*0H*/SwizzleMode v);
      /*regSet*/inline DefaultShaderBits::swizzle_Prop & operator= (DefaultShaderBits::swizzle_Prop & prop);
      /*regGet*/inline operator /*0I*/SwizzleMode () const;
   } swizzle;
   struct textureMatrix_Prop
   {
      constexpr textureMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::textureMatrix_Prop & operator= (DefaultShaderBits::textureMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } textureMatrix;
   struct texturing_Prop
   {
      constexpr texturing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::texturing_Prop & operator= (DefaultShaderBits::texturing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } texturing;
   struct alphaTest_Prop
   {
      constexpr alphaTest_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::alphaTest_Prop & operator= (DefaultShaderBits::alphaTest_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alphaTest;
   struct cubeMap_Prop
   {
      constexpr cubeMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::cubeMap_Prop & operator= (DefaultShaderBits::cubeMap_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } cubeMap;
   struct modelView_Prop
   {
      constexpr modelView_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::modelView_Prop & operator= (DefaultShaderBits::modelView_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } modelView;
   struct fog_Prop
   {
      constexpr fog_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::fog_Prop & operator= (DefaultShaderBits::fog_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fog;
   struct normalsMapping_Prop
   {
      constexpr normalsMapping_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::normalsMapping_Prop & operator= (DefaultShaderBits::normalsMapping_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } normalsMapping;
   struct specularMapping_Prop
   {
      constexpr specularMapping_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::specularMapping_Prop & operator= (DefaultShaderBits::specularMapping_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } specularMapping;
   struct environmentMapping_Prop
   {
      constexpr environmentMapping_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::environmentMapping_Prop & operator= (DefaultShaderBits::environmentMapping_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } environmentMapping;
   struct reflection_Prop
   {
      constexpr reflection_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::reflection_Prop & operator= (DefaultShaderBits::reflection_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } reflection;
   struct reflectionMap_Prop
   {
      constexpr reflectionMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::reflectionMap_Prop & operator= (DefaultShaderBits::reflectionMap_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } reflectionMap;
   struct refraction_Prop
   {
      constexpr refraction_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::refraction_Prop & operator= (DefaultShaderBits::refraction_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } refraction;
   struct debugging_Prop
   {
      constexpr debugging_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::debugging_Prop & operator= (DefaultShaderBits::debugging_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } debugging;
   struct constantColor_Prop
   {
      constexpr constantColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::constantColor_Prop & operator= (DefaultShaderBits::constantColor_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } constantColor;
   struct normalsInvScale2_Prop
   {
      constexpr normalsInvScale2_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::normalsInvScale2_Prop & operator= (DefaultShaderBits::normalsInvScale2_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } normalsInvScale2;
   struct externalTexture_Prop
   {
      constexpr externalTexture_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::externalTexture_Prop & operator= (DefaultShaderBits::externalTexture_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } externalTexture;
   struct blackTint_Prop
   {
      constexpr blackTint_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::blackTint_Prop & operator= (DefaultShaderBits::blackTint_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } blackTint;
   struct textureArray_Prop
   {
      constexpr textureArray_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::textureArray_Prop & operator= (DefaultShaderBits::textureArray_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } textureArray;
   struct multiDraw_Prop
   {
      constexpr multiDraw_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::multiDraw_Prop & operator= (DefaultShaderBits::multiDraw_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } multiDraw;
   struct transform3D_Prop
   {
      constexpr transform3D_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::transform3D_Prop & operator= (DefaultShaderBits::transform3D_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } transform3D;
   struct squishFactor_Prop
   {
      constexpr squishFactor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::squishFactor_Prop & operator= (DefaultShaderBits::squishFactor_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } squishFactor;
   struct bones_Prop
   {
      constexpr bones_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DefaultShaderBits::bones_Prop & operator= (DefaultShaderBits::bones_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bones;
};

struct GLAB : public TStruct<GLAB>
{
public:
   C(GLAB) impl;
   constexpr GLAB() : impl({}) { }
   constexpr GLAB(const C(GLAB) impl) : impl(impl) { }

   inline C(bool) _allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLB__allocate
   inline void _upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLB__upload
   inline C(bool) allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLB_allocate
   inline void copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size); // GLB_copy
   inline void copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size); // GLB_copy
   static inline void deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers); // GLB_deleteBuffers
   inline void free(); // GLB_free
   inline C(bool) resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID); // GLB_resize
   inline void upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLB_upload
   inline void use(/*1Ab*/GLBufferContents contents, /*1Ab*/int n, /*1Ab*/int type, /*1Ab*/uint stride, /*1Ab*/GLAttribMode mode, /*1Ab*/const void * pointer); // GLAB_use
   inline void useVertTrans(/*1Ab*/uint count, /*1Ab*/int n, /*1Ab*/int type, /*1Ab*/uint stride, /*1Ab*/GLAttribMode mode, /*1Ab*/const void * pointer); // GLAB_useVertTrans

   inline GLAB(uint buffer);

   struct buffer_Prop
   {
      constexpr buffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLAB::buffer_Prop & operator= (GLAB::buffer_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } buffer;
};

enum class GLAttribMode : int
{
   none = GLAttribMode_none,
   normalized = GLAttribMode_normalized,
   integer = GLAttribMode_integer,
   longDouble = GLAttribMode_longDouble
};

enum class GLBType : int
{
   elements = GLBType_elements,
   attributes = GLBType_attributes,
   commands = GLBType_commands
};

enum class GLBufferContents : int
{
   vertex = GLBufferContents_vertex,
   normal = GLBufferContents_normal,
   texCoord = GLBufferContents_texCoord,
   color = GLBufferContents_color,
   tangent1 = GLBufferContents_tangent1,
   tangent2 = GLBufferContents_tangent2,
   lightVector = GLBufferContents_lightVector,
   boneIndices1 = GLBufferContents_boneIndices1,
   boneIndices2 = GLBufferContents_boneIndices2,
   boneIndices3 = GLBufferContents_boneIndices3,
   boneWeights1 = GLBufferContents_boneWeights1,
   boneWeights2 = GLBufferContents_boneWeights2,
   boneWeights3 = GLBufferContents_boneWeights3
};

enum class GLBufferUsage : int
{
   staticDraw = GLBufferUsage_staticDraw,
   dynamicDraw = GLBufferUsage_dynamicDraw,
   streamDraw = GLBufferUsage_streamDraw
};

struct GLCAB : public TStruct<GLCAB>
{
public:
   C(GLCAB) impl;
   constexpr GLCAB() : impl({}) { }
   constexpr GLCAB(const C(GLCAB) impl) : impl(impl) { }

   inline C(bool) _allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLB__allocate
   inline void _upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLB__upload
   inline void copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size); // GLB_copy
   inline void copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size); // GLB_copy
   static inline void deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers); // GLB_deleteBuffers
   inline void free(); // GLB_free
   inline C(bool) resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID); // GLB_resize
   inline C(bool) allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLCAB_allocate
   inline void upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLCAB_upload

   inline GLCAB(uint buffer);

   struct buffer_Prop
   {
      constexpr buffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLCAB::buffer_Prop & operator= (GLCAB::buffer_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } buffer;
};

struct GLEAB : public TStruct<GLEAB>
{
public:
   C(GLEAB) impl;
   constexpr GLEAB() : impl({}) { }
   constexpr GLEAB(const C(GLEAB) impl) : impl(impl) { }

   inline C(bool) _allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLB__allocate
   inline void _upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLB__upload
   inline void copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size); // GLB_copy
   inline void copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size); // GLB_copy
   static inline void deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers); // GLB_deleteBuffers
   inline void free(); // GLB_free
   inline C(bool) resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID); // GLB_resize
   inline C(bool) allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage); // GLEAB_allocate
   inline void draw(/*1Ab*/int primType, /*1Ab*/int count, /*1Ab*/int type, /*1Ab*/const void * indices); // GLEAB_draw
   inline void draw2(/*1Ab*/int primType, /*1Ab*/int count, /*1Ab*/int type, /*1Ab*/const void * indices, /*1Ab*/uint baseVertex); // GLEAB_draw2
   inline void upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data); // GLEAB_upload

   inline GLEAB(uint buffer);

   struct buffer_Prop
   {
      constexpr buffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLEAB::buffer_Prop & operator= (GLEAB::buffer_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } buffer;
};

struct GLFB : public TStruct<GLFB>
{
public:
   C(GLFB) impl;
   constexpr GLFB() : impl({}) { }
   constexpr GLFB(const C(GLFB) impl) : impl(impl) { }

   inline void copy(/*1Ab*/const GLFB & src, /*1Ab*/const Box & srcExtent, /*1Ab*/const Box & dstExtent, /*1Ab*/ClearType buffers, /*1Ab*/bool filter); // GLFB_copy
   inline void copy(/*1Ac*/const GLFB * src, /*1Ac*/const Box * srcExtent, /*1Ac*/const Box * dstExtent, /*1Ac*/ClearType buffers, /*1Ac*/bool filter); // GLFB_copy
   inline void copyToTexture(); // GLFB_copyToTexture
   inline void free(); // GLFB_free
   inline void read(/*1Ab*/Bitmap & bitmap, /*1Ab*/ClearType buffer, /*1Ab*/bool sRGB); // GLFB_read
   inline C(bool) setup(/*1Ab*/bool textureFBO, /*1Ab*/bool allocTextures, /*1Ab*/int samples, /*1Ab*/int colorFormat, /*1Ab*/int depthFormat, /*1Ab*/int width, /*1Ab*/int height); // GLFB_setup

   inline GLFB(int w, int h, uint fbo, uint color, uint depth, uint samples, uint colorRBO, uint depthRBO, int depthFormat, int colorFormat);

   struct w_Prop
   {
      constexpr w_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GLFB::w_Prop & operator= (GLFB::w_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } w;
   struct h_Prop
   {
      constexpr h_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GLFB::h_Prop & operator= (GLFB::h_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } h;
   struct fbo_Prop
   {
      constexpr fbo_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLFB::fbo_Prop & operator= (GLFB::fbo_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } fbo;
   struct color_Prop
   {
      constexpr color_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLFB::color_Prop & operator= (GLFB::color_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } color;
   struct depth_Prop
   {
      constexpr depth_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLFB::depth_Prop & operator= (GLFB::depth_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } depth;
   struct samples_Prop
   {
      constexpr samples_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLFB::samples_Prop & operator= (GLFB::samples_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } samples;
   struct colorRBO_Prop
   {
      constexpr colorRBO_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLFB::colorRBO_Prop & operator= (GLFB::colorRBO_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } colorRBO;
   struct depthRBO_Prop
   {
      constexpr depthRBO_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline GLFB::depthRBO_Prop & operator= (GLFB::depthRBO_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } depthRBO;
   struct depthFormat_Prop
   {
      constexpr depthFormat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GLFB::depthFormat_Prop & operator= (GLFB::depthFormat_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } depthFormat;
   struct colorFormat_Prop
   {
      constexpr colorFormat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GLFB::colorFormat_Prop & operator= (GLFB::colorFormat_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } colorFormat;
};

enum class GLIMTKMode : int
{
   unset = GLIMTKMode_unset,
   points = GLIMTKMode_points,
   lines = GLIMTKMode_lines,
   lineLoop = GLIMTKMode_lineLoop,
   lineStrip = GLIMTKMode_lineStrip,
   triangles = GLIMTKMode_triangles,
   triangleStrip = GLIMTKMode_triangleStrip,
   triangleFan = GLIMTKMode_triangleFan,
   quads = GLIMTKMode_quads,
   quadStrip = GLIMTKMode_quadStrip,
   polygon = GLIMTKMode_polygon
};


#define REG_GLMB(c) \
      GLMB::class_registration(_cpp_class); \
      REG_Container_copy(copy, c, TP_T, TP_I, TP_D); \
      REG_Container_delete(delete, c, TP_T, TP_I, TP_D); \
      REG_Container_free(free, c, TP_T, TP_I, TP_D); \
      REG_Container_freeIterator(freeIterator, c, TP_T, TP_I, TP_D); \
      REG_Container_getCount(getCount, c, TP_T, TP_I, TP_D); \
      REG_Container_getData(getData, c, TP_T, TP_I, TP_D); \
      REG_Container_getFirst(getFirst, c, TP_T, TP_I, TP_D); \
      REG_Container_getLast(getLast, c, TP_T, TP_I, TP_D); \
      REG_Container_getNext(getNext, c, TP_T, TP_I, TP_D); \
      REG_Container_getPrev(getPrev, c, TP_T, TP_I, TP_D); \
      REG_Container_move(move, c, TP_T, TP_I, TP_D); \
      REG_Container_remove(remove, c, TP_T, TP_I, TP_D); \
      REG_Container_removeAll(removeAll, c, TP_T, TP_I, TP_D); \
      REG_Container_sort(sort, c, TP_T, TP_I, TP_D); \
      REG_FreeBlockMap_onExpand(onExpand, c);

#define GLMB_VIRTUAL_METHODS_PROTO(c) \

#define GLMB_VIRTUAL_METHODS(c) \

class GLMB : public FreeBlockMap
{
public:
   inline GLMB(GLMB && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GLMB & operator= (GLMB && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   GLMB() : GLMB((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GLMB> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GLMB * inst = new GLMB(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GLMB * inst = (GLMB *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GLMB & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GLMB(C(Instance) _impl, CPPClass & cl = _cpp_class) : FreeBlockMap(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct ab_Prop
   {
      constexpr ab_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLB operator= (/*0H*/GLB v);
      /*regSet*/inline GLMB::ab_Prop & operator= (GLMB::ab_Prop & prop);
      /*regGet*/inline operator /*0I*/GLB () const;
   } ab;
   struct keepSameBufferID_Prop
   {
      constexpr keepSameBufferID_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GLMB::keepSameBufferID_Prop & operator= (GLMB::keepSameBufferID_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } keepSameBufferID;
};

enum class GLMSWhatToGet : int
{
   modelViewMatrix = GLMSWhatToGet_modelViewMatrix,
   projectionMatrix = GLMSWhatToGet_projectionMatrix,
   textureMatrix = GLMSWhatToGet_textureMatrix
};


#define REG_GLStats(c) \
      GLStats::class_registration(_cpp_class);

#define GLSTATS_VIRTUAL_METHODS_PROTO(c) \

#define GLSTATS_VIRTUAL_METHODS(c) \

class GLStats : public Instance
{
public:
   inline GLStats(GLStats && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GLStats & operator= (GLStats && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   GLStats() : GLStats((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GLStats> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GLStats * inst = new GLStats(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GLStats * inst = (GLStats *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GLStats & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GLStats(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   static inline void allocBuffer(/*1Ab*/uint buf, /*1Ab*/uint size); // GLStats_allocBuffer
   static inline void allocTexture(/*1Ab*/uint tex, /*1Ab*/uint w, /*1Ab*/uint h, /*1Ab*/bool mipMaps); // GLStats_allocTexture
   static inline void freeBuffers(/*1Ab*/uint count, /*1Ab*/uint * bufs); // GLStats_freeBuffers
   static inline void freeTextures(/*1Ab*/uint count, /*1Ab*/uint * texs); // GLStats_freeTextures
   static inline void print(); // GLStats_print
   static inline void printBuf(/*1Ab*/char * output, /*1Ab*/uint size); // GLStats_printBuf

   static void class_registration(CPPClass & _cpp_class);
};

template <class TC, C(Class) ** TCO>
class TLFBDisplay : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct bitmap_Prop
   {
      constexpr bitmap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Bitmap operator= (/*0H*/Bitmap v);
      /*regSet*/inline typename TLFBDisplay<TC, TCO>::bitmap_Prop & operator= (typename TLFBDisplay<TC, TCO>::bitmap_Prop & prop);
      /*regGet*/inline operator /*0I*/Bitmap () const;
   } bitmap;
   struct updateBoxes_Prop
   {
      constexpr updateBoxes_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/OldList operator= (/*0H*/OldList v);
      /*regSet*/inline typename TLFBDisplay<TC, TCO>::updateBoxes_Prop & operator= (typename TLFBDisplay<TC, TCO>::updateBoxes_Prop & prop);
      /*regGet*/inline operator /*0I*/OldList () const;
   } updateBoxes;
   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TLFBDisplay<TC, TCO>::x_Prop & operator= (typename TLFBDisplay<TC, TCO>::x_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TLFBDisplay<TC, TCO>::y_Prop & operator= (typename TLFBDisplay<TC, TCO>::y_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } y;
   struct selfManaged_Prop
   {
      constexpr selfManaged_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TLFBDisplay<TC, TCO>::selfManaged_Prop & operator= (typename TLFBDisplay<TC, TCO>::selfManaged_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } selfManaged;
   ~TLFBDisplay()
   {
      this->impl = null; // How to know not to delete?
   }
};


#define REG_LFBDisplayDriver(c) \
      LFBDisplayDriver::class_registration(_cpp_class); \
      REG_DisplayDriver_allocateBitmap(allocateBitmap, c); \
      REG_DisplayDriver_allocateIndices(allocateIndices, c); \
      REG_DisplayDriver_allocateMesh(allocateMesh, c); \
      REG_DisplayDriver_applyMaterial(applyMaterial, c); \
      REG_DisplayDriver_area(area, c); \
      REG_DisplayDriver_blit(blit, c); \
      REG_DisplayDriver_blitDI(blitDI, c); \
      REG_DisplayDriver_clear(clear, c); \
      REG_DisplayDriver_clip(clip, c); \
      REG_DisplayDriver_convertBitmap(convertBitmap, c); \
      REG_DisplayDriver_createDisplay(createDisplay, c); \
      REG_DisplayDriver_createDisplaySystem(createDisplaySystem, c); \
      REG_DisplayDriver_destroyDisplay(destroyDisplay, c); \
      REG_DisplayDriver_destroyDisplaySystem(destroyDisplaySystem, c); \
      REG_DisplayDriver_displayPosition(displayPosition, c); \
      REG_DisplayDriver_displaySize(displaySize, c); \
      REG_DisplayDriver_drawLine(drawLine, c); \
      REG_DisplayDriver_drawPrimitives(drawPrimitives, c); \
      REG_DisplayDriver_drawingChar(drawingChar, c); \
      REG_DisplayDriver_endUpdate(endUpdate, c); \
      REG_DisplayDriver_filter(filter, c); \
      REG_DisplayDriver_filterDI(filterDI, c); \
      REG_DisplayDriver_fontExtent(fontExtent, c); \
      REG_DisplayDriver_freeBitmap(freeBitmap, c); \
      REG_DisplayDriver_freeIndices(freeIndices, c); \
      REG_DisplayDriver_freeMesh(freeMesh, c); \
      REG_DisplayDriver_getBitmapSurface(getBitmapSurface, c); \
      REG_DisplayDriver_getPixel(getPixel, c); \
      REG_DisplayDriver_getSurface(getSurface, c); \
      REG_DisplayDriver_grabScreen(grabScreen, c); \
      REG_DisplayDriver_lineStipple(lineStipple, c); \
      REG_DisplayDriver_loadFont(loadFont, c); \
      REG_DisplayDriver_lock(lock, c); \
      REG_DisplayDriver_lockIndices(lockIndices, c); \
      REG_DisplayDriver_lockMesh(lockMesh, c); \
      REG_DisplayDriver_lockSystem(lockSystem, c); \
      REG_DisplayDriver_makeDDBitmap(makeDDBitmap, c); \
      REG_DisplayDriver_nextPage(nextPage, c); \
      REG_DisplayDriver_popMatrix(popMatrix, c); \
      REG_DisplayDriver_pushMatrix(pushMatrix, c); \
      REG_DisplayDriver_putPixel(putPixel, c); \
      REG_DisplayDriver_rectangle(rectangle, c); \
      REG_DisplayDriver_releaseSurface(releaseSurface, c); \
      REG_DisplayDriver_restorePalette(restorePalette, c); \
      REG_DisplayDriver_scroll(scroll, c); \
      REG_DisplayDriver_selectMesh(selectMesh, c); \
      REG_DisplayDriver_setBackground(setBackground, c); \
      REG_DisplayDriver_setBlitTint(setBlitTint, c); \
      REG_DisplayDriver_setCamera(setCamera, c); \
      REG_DisplayDriver_setCameraVR(setCameraVR, c); \
      REG_DisplayDriver_setForeground(setForeground, c); \
      REG_DisplayDriver_setLight(setLight, c); \
      REG_DisplayDriver_setPalette(setPalette, c); \
      REG_DisplayDriver_setRenderState(setRenderState, c); \
      REG_DisplayDriver_setTransform(setTransform, c); \
      REG_DisplayDriver_startUpdate(startUpdate, c); \
      REG_DisplayDriver_stretch(stretch, c); \
      REG_DisplayDriver_stretchDI(stretchDI, c); \
      REG_DisplayDriver_stretchf(stretchf, c); \
      REG_DisplayDriver_textExtent(textExtent, c); \
      REG_DisplayDriver_textFont(textFont, c); \
      REG_DisplayDriver_textOpacity(textOpacity, c); \
      REG_DisplayDriver_unloadFont(unloadFont, c); \
      REG_DisplayDriver_unlock(unlock, c); \
      REG_DisplayDriver_unlockIndices(unlockIndices, c); \
      REG_DisplayDriver_unlockMesh(unlockMesh, c); \
      REG_DisplayDriver_unlockSystem(unlockSystem, c); \
      REG_DisplayDriver_update(update, c); \
      REG_DisplayDriver_writeText(writeText, c);

#define LFBDISPLAYDRIVER_VIRTUAL_METHODS_PROTO(c) \

#define LFBDISPLAYDRIVER_VIRTUAL_METHODS(c) \

class LFBDisplayDriver : public DisplayDriver
{
public:
   inline LFBDisplayDriver(LFBDisplayDriver && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline LFBDisplayDriver & operator= (LFBDisplayDriver && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   LFBDisplayDriver() : LFBDisplayDriver((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<LFBDisplayDriver> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         LFBDisplayDriver * inst = new LFBDisplayDriver(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      LFBDisplayDriver * inst = (LFBDisplayDriver *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(LFBDisplayDriver & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline LFBDisplayDriver(C(Instance) _impl, CPPClass & cl = _cpp_class) : DisplayDriver(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

template <class TC, C(Class) ** TCO>
class TLFBSurface : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct font_Prop
   {
      constexpr font_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Font operator= (/*0H*/Font & v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::font_Prop & operator= (typename TLFBSurface<TC, TCO>::font_Prop & prop);
      /*regGet*/inline operator /*0I*/Font () const;
   } font;
   struct opaqueText_Prop
   {
      constexpr opaqueText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::opaqueText_Prop & operator= (typename TLFBSurface<TC, TCO>::opaqueText_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } opaqueText;
   struct xOffset_Prop
   {
      constexpr xOffset_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::xOffset_Prop & operator= (typename TLFBSurface<TC, TCO>::xOffset_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } xOffset;
   struct writingText_Prop
   {
      constexpr writingText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::writingText_Prop & operator= (typename TLFBSurface<TC, TCO>::writingText_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } writingText;
   struct writingOutline_Prop
   {
      constexpr writingOutline_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::writingOutline_Prop & operator= (typename TLFBSurface<TC, TCO>::writingOutline_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } writingOutline;
   struct bitmap_Prop
   {
      constexpr bitmap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Bitmap operator= (/*0H*/Bitmap v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::bitmap_Prop & operator= (typename TLFBSurface<TC, TCO>::bitmap_Prop & prop);
      /*regGet*/inline operator /*0I*/Bitmap () const;
   } bitmap;
   struct foreground_Prop
   {
      constexpr foreground_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::foreground_Prop & operator= (typename TLFBSurface<TC, TCO>::foreground_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } foreground;
   struct background_Prop
   {
      constexpr background_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::background_Prop & operator= (typename TLFBSurface<TC, TCO>::background_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } background;
   struct foregroundRgb_Prop
   {
      constexpr foregroundRgb_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha operator= (/*0H*/ColorAlpha v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::foregroundRgb_Prop & operator= (typename TLFBSurface<TC, TCO>::foregroundRgb_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha () const;
   } foregroundRgb;
   struct stipple_Prop
   {
      constexpr stipple_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint16 operator= (/*0H*/uint16 v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::stipple_Prop & operator= (typename TLFBSurface<TC, TCO>::stipple_Prop & prop);
      /*regGet*/inline operator /*0I*/uint16 () const;
   } stipple;
   struct drawingChar_Prop
   {
      constexpr drawingChar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char operator= (/*0H*/unsigned char v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::drawingChar_Prop & operator= (typename TLFBSurface<TC, TCO>::drawingChar_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char () const;
   } drawingChar;
   struct paletteShades_Prop
   {
      constexpr paletteShades_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char * operator= (/*0H*/unsigned char * v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::paletteShades_Prop & operator= (typename TLFBSurface<TC, TCO>::paletteShades_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char * () const;
   } paletteShades;
   struct clearing_Prop
   {
      constexpr clearing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TLFBSurface<TC, TCO>::clearing_Prop & operator= (typename TLFBSurface<TC, TCO>::clearing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } clearing;
   ~TLFBSurface()
   {
      this->impl = null; // How to know not to delete?
   }
};

template <class TC, C(Class) ** TCO>
class TLFBSystem : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct format_Prop
   {
      constexpr format_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TLFBSystem<TC, TCO>::format_Prop & operator= (typename TLFBSystem<TC, TCO>::format_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } format;
   struct palette_Prop
   {
      constexpr palette_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorAlpha * operator= (/*0H*/ColorAlpha * v);
      /*regSet*/inline typename TLFBSystem<TC, TCO>::palette_Prop & operator= (typename TLFBSystem<TC, TCO>::palette_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorAlpha * () const;
   } palette;
   ~TLFBSystem()
   {
      this->impl = null; // How to know not to delete?
   }
};

enum class LightMode : int
{
   off = LightMode_off,
   dir = LightMode_dir,
   pos = LightMode_pos,
   posAtt = LightMode_posAtt,
   posSpot = LightMode_posSpot,
   posSpotAtt = LightMode_posSpotAtt
};

enum class MatrixMode : int
{
   modelView = MatrixMode_modelView,
   projection = MatrixMode_projection,
   texture = MatrixMode_texture
};

class ShaderModifiedUniforms
{
public:
   C(ShaderModifiedUniforms) impl;
   constexpr ShaderModifiedUniforms() : impl(0) { }
   constexpr ShaderModifiedUniforms(C(ShaderModifiedUniforms) impl) : impl(impl) { }
   operator C(ShaderModifiedUniforms)() { return impl; }
   ShaderModifiedUniforms & operator =(C(ShaderModifiedUniforms) impl) { impl = impl; return *this; }
   bool operator ==(const ShaderModifiedUniforms & value) const { return impl == value.impl; }
   bool operator !=(const ShaderModifiedUniforms & value) const { return impl != value.impl; }

   struct matMV_Prop
   {
      constexpr matMV_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ShaderModifiedUniforms::matMV_Prop & operator= (ShaderModifiedUniforms::matMV_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } matMV;
   struct light_Prop
   {
      constexpr light_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ShaderModifiedUniforms::light_Prop & operator= (ShaderModifiedUniforms::light_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } light;
   struct material_Prop
   {
      constexpr material_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ShaderModifiedUniforms::material_Prop & operator= (ShaderModifiedUniforms::material_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } material;
   struct matPrj_Prop
   {
      constexpr matPrj_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ShaderModifiedUniforms::matPrj_Prop & operator= (ShaderModifiedUniforms::matPrj_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } matPrj;
   struct matTex_Prop
   {
      constexpr matTex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ShaderModifiedUniforms::matTex_Prop & operator= (ShaderModifiedUniforms::matTex_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } matTex;
   struct pos_Prop
   {
      constexpr pos_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ShaderModifiedUniforms::pos_Prop & operator= (ShaderModifiedUniforms::pos_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } pos;
   struct layer_Prop
   {
      constexpr layer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ShaderModifiedUniforms::layer_Prop & operator= (ShaderModifiedUniforms::layer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } layer;
};

enum class SwizzleMode : int
{
   off = SwizzleMode_off,
   alpha = SwizzleMode_alpha,
   red = SwizzleMode_red
};

class PrimitiveGroupType
{
public:
   C(PrimitiveGroupType) impl;
   constexpr PrimitiveGroupType() : impl(0) { }

   PrimitiveGroupType(RenderPrimitiveType impl) : impl((C(PrimitiveGroupType))impl) { }
   PrimitiveGroupType & operator =(RenderPrimitiveType impl) { this->impl = (C(PrimitiveGroupType))impl; return *this; }

   constexpr PrimitiveGroupType(C(PrimitiveGroupType) impl) : impl(impl) { }
   PrimitiveGroupType(RenderPrimitiveType primitiveType, bool vertexRange, bool indices32bit, bool sharedIndices, bool hide);
   operator C(PrimitiveGroupType)() { return impl; }
   PrimitiveGroupType & operator =(C(PrimitiveGroupType) impl) { impl = impl; return *this; }
   bool operator ==(const PrimitiveGroupType & value) const { return impl == value.impl; }
   bool operator !=(const PrimitiveGroupType & value) const { return impl != value.impl; }

   struct primitiveType_Prop
   {
      constexpr primitiveType_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/RenderPrimitiveType operator= (/*0H*/RenderPrimitiveType v);
      /*regSet*/inline PrimitiveGroupType::primitiveType_Prop & operator= (PrimitiveGroupType::primitiveType_Prop & prop);
      /*regGet*/inline operator /*0I*/RenderPrimitiveType () const;
   } primitiveType;
   struct vertexRange_Prop
   {
      constexpr vertexRange_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PrimitiveGroupType::vertexRange_Prop & operator= (PrimitiveGroupType::vertexRange_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } vertexRange;
   struct indices32bit_Prop
   {
      constexpr indices32bit_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PrimitiveGroupType::indices32bit_Prop & operator= (PrimitiveGroupType::indices32bit_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } indices32bit;
   struct sharedIndices_Prop
   {
      constexpr sharedIndices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PrimitiveGroupType::sharedIndices_Prop & operator= (PrimitiveGroupType::sharedIndices_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } sharedIndices;
   struct hide_Prop
   {
      constexpr hide_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PrimitiveGroupType::hide_Prop & operator= (PrimitiveGroupType::hide_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hide;
};


#define REG_Camera(c) \
      Camera::class_registration(_cpp_class);

#define CAMERA_VIRTUAL_METHODS_PROTO(c) \

#define CAMERA_VIRTUAL_METHODS(c) \

class Camera : public Instance
{
public:
   inline Camera(Camera && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Camera & operator= (Camera && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Camera() : Camera((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Camera> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Camera * inst = new Camera(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Camera * inst = (Camera *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Camera & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Camera(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void adjustAngle(/*1Ab*/Quaternion & angle); // Camera_adjustAngle
   inline void adjustAngle(/*1Ac*/Quaternion * angle); // Camera_adjustAngle
   inline void adjustPosition(/*1Ab*/Vector3D & position); // Camera_adjustPosition
   inline void adjustPosition(/*1Ac*/Vector3D * position); // Camera_adjustPosition
   inline void move(/*1Ab*/Vector3D & direction); // Camera_move
   inline void move(/*1Ac*/Vector3D * direction); // Camera_move
   inline C(bool) pointsVisible(/*1Ab*/Vector3D * points, /*1Ab*/int numPoints, /*1Ab*/double threshold); // Camera_pointsVisible
   inline C(bool) project(/*1Ab*/Vector3D & vector, /*1Ab*/Vector3D & point); // Camera_project
   inline C(bool) project(/*1Ac*/Vector3D * vector, /*1Ac*/Vector3D * point); // Camera_project
   inline C(bool) projectSize(/*1Ab*/Vector3D & vector, /*1Ab*/Point & point); // Camera_projectSize
   inline C(bool) projectSize(/*1Ac*/Vector3D * vector, /*1Ac*/Point * point); // Camera_projectSize
   inline void rotatePitch(/*1Ab*/Angle amount, /*1Ab*/Angle min, /*1Ab*/Angle max); // Camera_rotatePitch
   inline void rotateRoll(/*1Ab*/Angle amount, /*1Ab*/Angle min, /*1Ab*/Angle max); // Camera_rotateRoll
   inline void rotateYaw(/*1Ab*/Angle amount, /*1Ab*/Angle min, /*1Ab*/Angle max); // Camera_rotateYaw
   inline void setup(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/const Point & origin); // Camera_setup
   inline void setup(/*1Ac*/int width, /*1Ac*/int height, /*1Ac*/const Point * origin); // Camera_setup
   inline void setupVR(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/const Matrix & prjMatrix); // Camera_setupVR
   inline void setupVR(/*1Ac*/int width, /*1Ac*/int height, /*1Ac*/const Matrix * prjMatrix); // Camera_setupVR
   inline void slerp(/*1Ab*/float amount); // Camera_slerp
   inline C(bool) sphereVisible(/*1Ab*/Vector3D & center, /*1Ab*/float radius); // Camera_sphereVisible
   inline C(bool) sphereVisible(/*1Ac*/Vector3D * center, /*1Ac*/float radius); // Camera_sphereVisible
   inline void transformMatrix(/*1Ab*/Matrix & dest, /*1Ab*/Matrix & src); // Camera_transformMatrix
   inline void transformMatrix(/*1Ac*/Matrix * dest, /*1Ac*/Matrix * src); // Camera_transformMatrix
   inline void transformNormal(/*1Ab*/Vector3D & dest, /*1Ab*/Vector3D & src); // Camera_transformNormal
   inline void transformNormal(/*1Ac*/Vector3D * dest, /*1Ac*/Vector3D * src); // Camera_transformNormal
   inline void transformPoint(/*1Ab*/Vector3D & dest, /*1Ab*/Vector3D & src); // Camera_transformPoint
   inline void transformPoint(/*1Ac*/Vector3D * dest, /*1Ac*/Vector3D * src); // Camera_transformPoint
   inline void unproject(/*1Ab*/Vector3D & point, /*1Ab*/Vector3D & vector); // Camera_unproject
   inline void unproject(/*1Ac*/Vector3D * point, /*1Ac*/Vector3D * vector); // Camera_unproject
   inline void untransform(/*1Ab*/Vector3D & src, /*1Ab*/Vector3D & result); // Camera_untransform
   inline void untransform(/*1Ac*/Vector3D * src, /*1Ac*/Vector3D * result); // Camera_untransform
   inline C(bool) update(); // Camera_update
   inline void setCPosition(/*1Ab*/Vector3D & value); // Camera_setCPosition
   inline void setCPosition(/*1Ac*/Vector3D * value); // Camera_setCPosition
   inline void setViewMatrix(/*1Ab*/Matrix & value); // Camera_setViewMatrix
   inline void setViewMatrix(/*1Ac*/Matrix * value); // Camera_setViewMatrix

   static void class_registration(CPPClass & _cpp_class);

   inline Camera(CameraType type, Vector3D position, Quaternion orientation, Euler eulerOrientation, Degrees fov, float zMin, float zMax);

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/CameraType operator= (/*0H*/CameraType v);
      /*regSet*/inline Camera::type_Prop & operator= (Camera::type_Prop & prop);
      /*regGet*/inline operator /*0I*/CameraType () const;
   } type;
   struct position_Prop
   {
      constexpr position_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3D operator= (/*0H*/Vector3D v);
      /*regSet*/inline Camera::position_Prop & operator= (Camera::position_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } position;
   struct orientation_Prop
   {
      constexpr orientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Quaternion operator= (/*0H*/Quaternion v);
      /*regSet*/inline Camera::orientation_Prop & operator= (Camera::orientation_Prop & prop);
      /*regGet*/inline operator /*0I*/Quaternion () const;
   } orientation;
   struct eulerOrientation_Prop
   {
      constexpr eulerOrientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Euler operator= (/*0H*/Euler v);
      /*regSet*/inline Camera::eulerOrientation_Prop & operator= (Camera::eulerOrientation_Prop & prop);
      /*regGet*/inline operator /*0I*/Euler () const;
   } eulerOrientation;
   struct cPosition_Prop
   {
      constexpr cPosition_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } cPosition;
   struct cOrientation_Prop
   {
      constexpr cOrientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Quaternion () const;
   } cOrientation;
   struct fov_Prop
   {
      constexpr fov_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Camera::fov_Prop & operator= (Camera::fov_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } fov;
   struct zMin_Prop
   {
      constexpr zMin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Camera::zMin_Prop & operator= (Camera::zMin_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } zMin;
   struct zMax_Prop
   {
      constexpr zMax_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Camera::zMax_Prop & operator= (Camera::zMax_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } zMax;
   struct target_Prop
   {
      constexpr target_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Object operator= (/*0H*/Object & v);
      /*regSet*/inline Camera::target_Prop & operator= (Camera::target_Prop & prop);
      /*regGet*/inline operator /*0I*/Object () const;
   } target;
   struct fovDirection_Prop
   {
      constexpr fovDirection_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FovDirection operator= (/*0H*/FovDirection v);
      /*regSet*/inline Camera::fovDirection_Prop & operator= (Camera::fovDirection_Prop & prop);
      /*regGet*/inline operator /*0I*/FovDirection () const;
   } fovDirection;
   struct aspectRatio_Prop
   {
      constexpr aspectRatio_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Camera::aspectRatio_Prop & operator= (Camera::aspectRatio_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } aspectRatio;
   struct focal_Prop
   {
      constexpr focal_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Size operator= (/*0H*/Size v);
      /*regSet*/inline Camera::focal_Prop & operator= (Camera::focal_Prop & prop);
      /*regGet*/inline operator /*0I*/Size () const;
   } focal;
};

enum class CameraType : int
{
   fixed = CameraType_fixed,
   fixedQuaternion = CameraType_fixedQuaternion,
   attached = CameraType_attached,
   attachedQuaternion = CameraType_attachedQuaternion,
   lookAt = CameraType_lookAt,
   lookAtObject = CameraType_lookAtObject
};

enum class ClippingPlane : int
{
   left = ClippingPlane_left,
   right = ClippingPlane_right,
   top = ClippingPlane_top,
   bottom = ClippingPlane_bottom,
   near = ClippingPlane_near,
   far = ClippingPlane_far
};

struct Euler : public TStruct<Euler>
{
public:
   C(Euler) impl;
   constexpr Euler() : impl({}) { }
   constexpr Euler(const C(Euler) impl) : impl(impl) { }
   inline operator Quaternion() const;
   inline Euler(const Quaternion & q);
   inline Euler & operator =(const Quaternion & q);

   inline void add(/*1Ab*/const Euler & e1, /*1Ab*/const Euler & e2); // Euler_add
   inline void add(/*1Ac*/const Euler * e1, /*1Ac*/const Euler * e2); // Euler_add
   inline void fromMatrix(/*1Ab*/const Matrix & m, /*1Ab*/EulerRotationOrder order); // Euler_fromMatrix
   inline void fromMatrix(/*1Ac*/const Matrix * m, /*1Ac*/EulerRotationOrder order); // Euler_fromMatrix
   inline void fromQuaternion(/*1Ab*/const Quaternion & q, /*1Ab*/EulerRotationOrder order); // Euler_fromQuaternion
   inline void fromQuaternion(/*1Ac*/const Quaternion * q, /*1Ac*/EulerRotationOrder order); // Euler_fromQuaternion

   inline Euler(Degrees yaw, Degrees pitch, Degrees roll);

   struct yaw_Prop
   {
      constexpr yaw_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Euler::yaw_Prop & operator= (Euler::yaw_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } yaw;
   struct pitch_Prop
   {
      constexpr pitch_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Euler::pitch_Prop & operator= (Euler::pitch_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } pitch;
   struct roll_Prop
   {
      constexpr roll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Degrees operator= (/*0H*/Degrees v);
      /*regSet*/inline Euler::roll_Prop & operator= (Euler::roll_Prop & prop);
      /*regGet*/inline operator /*0I*/Degrees () const;
      /*regGet*/inline operator /*0J*/C(Angle) () const;
   } roll;
};

enum class EulerRotationOrder : int
{
   xyz = EulerRotationOrder_xyz,
   xzy = EulerRotationOrder_xzy,
   yxz = EulerRotationOrder_yxz,
   yzx = EulerRotationOrder_yzx,
   zxy = EulerRotationOrder_zxy,
   zyx = EulerRotationOrder_zyx
};

enum class FovDirection : int
{
   widest = FovDirection_widest,
   horizontal = FovDirection_horizontal,
   vertical = FovDirection_vertical
};

struct FrameKey : public TStruct<FrameKey>
{
public:
   C(FrameKey) impl;
   constexpr FrameKey() : impl({}) { }
   constexpr FrameKey(const C(FrameKey) impl) : impl(impl) { }

   inline FrameKey(uint frame, float tension, float continuity, float bias, float easeFrom, float easeTo, Vector3Df position, Quaternion orientation, Vector3Df scaling, float roll, float fov, ColorRGB color, float hotSpot, float fallOff, float weight, bool hide);

   struct frame_Prop
   {
      constexpr frame_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline FrameKey::frame_Prop & operator= (FrameKey::frame_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } frame;
   struct tension_Prop
   {
      constexpr tension_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::tension_Prop & operator= (FrameKey::tension_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } tension;
   struct continuity_Prop
   {
      constexpr continuity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::continuity_Prop & operator= (FrameKey::continuity_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } continuity;
   struct bias_Prop
   {
      constexpr bias_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::bias_Prop & operator= (FrameKey::bias_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } bias;
   struct easeFrom_Prop
   {
      constexpr easeFrom_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::easeFrom_Prop & operator= (FrameKey::easeFrom_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } easeFrom;
   struct easeTo_Prop
   {
      constexpr easeTo_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::easeTo_Prop & operator= (FrameKey::easeTo_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } easeTo;
   struct position_Prop
   {
      constexpr position_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3Df operator= (/*0H*/Vector3Df v);
      /*regSet*/inline FrameKey::position_Prop & operator= (FrameKey::position_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } position;
   struct orientation_Prop
   {
      constexpr orientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Quaternion operator= (/*0H*/Quaternion v);
      /*regSet*/inline FrameKey::orientation_Prop & operator= (FrameKey::orientation_Prop & prop);
      /*regGet*/inline operator /*0I*/Quaternion () const;
   } orientation;
   struct scaling_Prop
   {
      constexpr scaling_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3Df operator= (/*0H*/Vector3Df v);
      /*regSet*/inline FrameKey::scaling_Prop & operator= (FrameKey::scaling_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } scaling;
   struct roll_Prop
   {
      constexpr roll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::roll_Prop & operator= (FrameKey::roll_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } roll;
   struct fov_Prop
   {
      constexpr fov_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::fov_Prop & operator= (FrameKey::fov_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } fov;
   struct color_Prop
   {
      constexpr color_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline FrameKey::color_Prop & operator= (FrameKey::color_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } color;
   struct hotSpot_Prop
   {
      constexpr hotSpot_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::hotSpot_Prop & operator= (FrameKey::hotSpot_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } hotSpot;
   struct fallOff_Prop
   {
      constexpr fallOff_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::fallOff_Prop & operator= (FrameKey::fallOff_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } fallOff;
   struct weight_Prop
   {
      constexpr weight_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline FrameKey::weight_Prop & operator= (FrameKey::weight_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } weight;
   struct hide_Prop
   {
      constexpr hide_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FrameKey::hide_Prop & operator= (FrameKey::hide_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hide;
};

template <class TC, C(Class) ** TCO>
class TFrameTrack : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FrameTrackBits operator= (/*0H*/FrameTrackBits v);
      /*regSet*/inline typename TFrameTrack<TC, TCO>::type_Prop & operator= (typename TFrameTrack<TC, TCO>::type_Prop & prop);
      /*regGet*/inline operator /*0I*/FrameTrackBits () const;
   } type;
   struct numKeys_Prop
   {
      constexpr numKeys_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline typename TFrameTrack<TC, TCO>::numKeys_Prop & operator= (typename TFrameTrack<TC, TCO>::numKeys_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } numKeys;
   struct morphIndex_Prop
   {
      constexpr morphIndex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TFrameTrack<TC, TCO>::morphIndex_Prop & operator= (typename TFrameTrack<TC, TCO>::morphIndex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } morphIndex;
   ~TFrameTrack()
   {
      this->impl = null; // How to know not to delete?
   }
};

class FrameTrackBits
{
public:
   C(FrameTrackBits) impl;
   constexpr FrameTrackBits() : impl(0) { }
   constexpr FrameTrackBits(C(FrameTrackBits) impl) : impl(impl) { }
   FrameTrackBits(FrameTrackType type, bool loop, EulerRotationOrder rotationOrder);
   operator C(FrameTrackBits)() { return impl; }
   FrameTrackBits & operator =(C(FrameTrackBits) impl) { impl = impl; return *this; }
   bool operator ==(const FrameTrackBits & value) const { return impl == value.impl; }
   bool operator !=(const FrameTrackBits & value) const { return impl != value.impl; }

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FrameTrackType operator= (/*0H*/FrameTrackType v);
      /*regSet*/inline FrameTrackBits::type_Prop & operator= (FrameTrackBits::type_Prop & prop);
      /*regGet*/inline operator /*0I*/FrameTrackType () const;
   } type;
   struct loop_Prop
   {
      constexpr loop_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FrameTrackBits::loop_Prop & operator= (FrameTrackBits::loop_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } loop;
   struct rotationOrder_Prop
   {
      constexpr rotationOrder_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/EulerRotationOrder operator= (/*0H*/EulerRotationOrder v);
      /*regSet*/inline FrameTrackBits::rotationOrder_Prop & operator= (FrameTrackBits::rotationOrder_Prop & prop);
      /*regGet*/inline operator /*0I*/EulerRotationOrder () const;
   } rotationOrder;
};

enum class FrameTrackType : uint16
{
   position = FrameTrackType_position,
   rotation = FrameTrackType_rotation,
   scaling = FrameTrackType_scaling,
   fov = FrameTrackType_fov,
   roll = FrameTrackType_roll,
   colorChange = FrameTrackType_colorChange,
   morph = FrameTrackType_morph,
   hotSpot = FrameTrackType_hotSpot,
   fallOff = FrameTrackType_fallOff,
   hide = FrameTrackType_hide,
   rYaw = FrameTrackType_rYaw,
   rPitch = FrameTrackType_rPitch,
   rRoll = FrameTrackType_rRoll
};

enum class FrustumPlacement : int
{
   outside = FrustumPlacement_outside,
   inside = FrustumPlacement_inside,
   intersecting = FrustumPlacement_intersecting
};

struct Line : public TStruct<Line>
{
public:
   C(Line) impl;
   constexpr Line() : impl({}) { }
   constexpr Line(const C(Line) impl) : impl(impl) { }

   inline C(bool) intersectSphere(/*1Ab*/double radius, /*1Ab*/double * t); // Line_intersectSphere

   inline Line(Vector3D p0, Vector3D delta);

   struct p0_Prop
   {
      constexpr p0_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3D operator= (/*0H*/Vector3D v);
      /*regSet*/inline Line::p0_Prop & operator= (Line::p0_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } p0;
   struct delta_Prop
   {
      constexpr delta_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3D operator= (/*0H*/Vector3D v);
      /*regSet*/inline Line::delta_Prop & operator= (Line::delta_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } delta;
};

template <class TC, C(Class) ** TCO>
class TMaterial : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline void free(); // Material_free

   struct shader_Prop
   {
      constexpr shader_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Shader & operator= (/*0A*/const Shader & v);
      /*regSet*/inline typename TMaterial<TC, TCO>::shader_Prop & operator= (typename TMaterial<TC, TCO>::shader_Prop & prop);
      /*nstSet*/inline /*0C*/const Shader * operator= (/*0C*/const Shader * v);
      /*regGet*/inline operator /*0B*/TIH<Shader> () const;
      /*regGet*/inline TIH<Shader> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Shader () const;
      /*regGet*/inline operator /*0F*/Shader* () const;
   } shader;

   struct prev_Prop
   {
      constexpr prev_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Material operator= (/*0H*/Material & v);
      /*regSet*/inline typename TMaterial<TC, TCO>::prev_Prop & operator= (typename TMaterial<TC, TCO>::prev_Prop & prop);
      /*regGet*/inline operator /*0I*/Material () const;
   } prev;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Material operator= (/*0H*/Material & v);
      /*regSet*/inline typename TMaterial<TC, TCO>::next_Prop & operator= (typename TMaterial<TC, TCO>::next_Prop & prop);
      /*regGet*/inline operator /*0I*/Material () const;
   } next;
   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/char * operator= (/*0H*/char * v);
      /*regSet*/inline typename TMaterial<TC, TCO>::name_Prop & operator= (typename TMaterial<TC, TCO>::name_Prop & prop);
      /*regGet*/inline operator /*0I*/char * () const;
   } name;
   struct opacity_Prop
   {
      constexpr opacity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline typename TMaterial<TC, TCO>::opacity_Prop & operator= (typename TMaterial<TC, TCO>::opacity_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } opacity;
   struct diffuse_Prop
   {
      constexpr diffuse_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline typename TMaterial<TC, TCO>::diffuse_Prop & operator= (typename TMaterial<TC, TCO>::diffuse_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } diffuse;
   struct ambient_Prop
   {
      constexpr ambient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline typename TMaterial<TC, TCO>::ambient_Prop & operator= (typename TMaterial<TC, TCO>::ambient_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } ambient;
   struct specular_Prop
   {
      constexpr specular_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline typename TMaterial<TC, TCO>::specular_Prop & operator= (typename TMaterial<TC, TCO>::specular_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } specular;
   struct emissive_Prop
   {
      constexpr emissive_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ColorRGB operator= (/*0H*/ColorRGB v);
      /*regSet*/inline typename TMaterial<TC, TCO>::emissive_Prop & operator= (typename TMaterial<TC, TCO>::emissive_Prop & prop);
      /*regGet*/inline operator /*0I*/ColorRGB () const;
   } emissive;
   struct power_Prop
   {
      constexpr power_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline typename TMaterial<TC, TCO>::power_Prop & operator= (typename TMaterial<TC, TCO>::power_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } power;
   struct baseMap_Prop
   {
      constexpr baseMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Bitmap operator= (/*0H*/Bitmap v);
      /*regSet*/inline typename TMaterial<TC, TCO>::baseMap_Prop & operator= (typename TMaterial<TC, TCO>::baseMap_Prop & prop);
      /*regGet*/inline operator /*0I*/Bitmap () const;
   } baseMap;
   struct bumpMap_Prop
   {
      constexpr bumpMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Bitmap operator= (/*0H*/Bitmap v);
      /*regSet*/inline typename TMaterial<TC, TCO>::bumpMap_Prop & operator= (typename TMaterial<TC, TCO>::bumpMap_Prop & prop);
      /*regGet*/inline operator /*0I*/Bitmap () const;
   } bumpMap;
   struct specularMap_Prop
   {
      constexpr specularMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Bitmap operator= (/*0H*/Bitmap v);
      /*regSet*/inline typename TMaterial<TC, TCO>::specularMap_Prop & operator= (typename TMaterial<TC, TCO>::specularMap_Prop & prop);
      /*regGet*/inline operator /*0I*/Bitmap () const;
   } specularMap;
   struct reflectMap_Prop
   {
      constexpr reflectMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Bitmap operator= (/*0H*/Bitmap v);
      /*regSet*/inline typename TMaterial<TC, TCO>::reflectMap_Prop & operator= (typename TMaterial<TC, TCO>::reflectMap_Prop & prop);
      /*regGet*/inline operator /*0I*/Bitmap () const;
   } reflectMap;
   struct envMap_Prop
   {
      constexpr envMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/CubeMap operator= (/*0H*/CubeMap v);
      /*regSet*/inline typename TMaterial<TC, TCO>::envMap_Prop & operator= (typename TMaterial<TC, TCO>::envMap_Prop & prop);
      /*regGet*/inline operator /*0I*/CubeMap () const;
   } envMap;
   struct reflectivity_Prop
   {
      constexpr reflectivity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline typename TMaterial<TC, TCO>::reflectivity_Prop & operator= (typename TMaterial<TC, TCO>::reflectivity_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } reflectivity;
   struct refractiveIndex_Prop
   {
      constexpr refractiveIndex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline typename TMaterial<TC, TCO>::refractiveIndex_Prop & operator= (typename TMaterial<TC, TCO>::refractiveIndex_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } refractiveIndex;
   struct refractiveIndexContainer_Prop
   {
      constexpr refractiveIndexContainer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline typename TMaterial<TC, TCO>::refractiveIndexContainer_Prop & operator= (typename TMaterial<TC, TCO>::refractiveIndexContainer_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } refractiveIndexContainer;
   struct flags_Prop
   {
      constexpr flags_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/MaterialFlags operator= (/*0H*/MaterialFlags v);
      /*regSet*/inline typename TMaterial<TC, TCO>::flags_Prop & operator= (typename TMaterial<TC, TCO>::flags_Prop & prop);
      /*regGet*/inline operator /*0I*/MaterialFlags () const;
   } flags;
   struct uScale_Prop
   {
      constexpr uScale_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline typename TMaterial<TC, TCO>::uScale_Prop & operator= (typename TMaterial<TC, TCO>::uScale_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } uScale;
   struct vScale_Prop
   {
      constexpr vScale_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline typename TMaterial<TC, TCO>::vScale_Prop & operator= (typename TMaterial<TC, TCO>::vScale_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } vScale;
   ~TMaterial()
   {
      this->impl = null; // How to know not to delete?
   }
};

class MaterialFlags
{
public:
   C(MaterialFlags) impl;
   constexpr MaterialFlags() : impl(0) { }
   constexpr MaterialFlags(C(MaterialFlags) impl) : impl(impl) { }
   operator C(MaterialFlags)() { return impl; }
   MaterialFlags & operator =(C(MaterialFlags) impl) { impl = impl; return *this; }
   bool operator ==(const MaterialFlags & value) const { return impl == value.impl; }
   bool operator !=(const MaterialFlags & value) const { return impl != value.impl; }

   struct doubleSided_Prop
   {
      constexpr doubleSided_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::doubleSided_Prop & operator= (MaterialFlags::doubleSided_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } doubleSided;
   struct translucent_Prop
   {
      constexpr translucent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::translucent_Prop & operator= (MaterialFlags::translucent_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } translucent;
   struct tile_Prop
   {
      constexpr tile_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::tile_Prop & operator= (MaterialFlags::tile_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } tile;
   struct noFog_Prop
   {
      constexpr noFog_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::noFog_Prop & operator= (MaterialFlags::noFog_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noFog;
   struct singleSideLight_Prop
   {
      constexpr singleSideLight_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::singleSideLight_Prop & operator= (MaterialFlags::singleSideLight_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } singleSideLight;
   struct separateSpecular_Prop
   {
      constexpr separateSpecular_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::separateSpecular_Prop & operator= (MaterialFlags::separateSpecular_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } separateSpecular;
   struct cubeMap_Prop
   {
      constexpr cubeMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::cubeMap_Prop & operator= (MaterialFlags::cubeMap_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } cubeMap;
   struct noLighting_Prop
   {
      constexpr noLighting_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::noLighting_Prop & operator= (MaterialFlags::noLighting_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noLighting;
   struct partlyTransparent_Prop
   {
      constexpr partlyTransparent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::partlyTransparent_Prop & operator= (MaterialFlags::partlyTransparent_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } partlyTransparent;
   struct setupTextures_Prop
   {
      constexpr setupTextures_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::setupTextures_Prop & operator= (MaterialFlags::setupTextures_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } setupTextures;
   struct update_Prop
   {
      constexpr update_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::update_Prop & operator= (MaterialFlags::update_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } update;
   struct constantColor_Prop
   {
      constexpr constantColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MaterialFlags::constantColor_Prop & operator= (MaterialFlags::constantColor_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } constantColor;
};

struct Matrix : public TStruct<Matrix>
{
public:
   C(Matrix) impl;
   constexpr Matrix() : impl({}) { }
   constexpr Matrix(const C(Matrix) impl) : impl(impl) { }
   inline operator Quaternion() const;
   inline Matrix(const Quaternion & q);
   inline Matrix & operator =(const Quaternion & q);

   inline double determinant(); // Matrix_determinant
   inline void identity(); // Matrix_identity
   inline void inverse(/*1Ab*/const Matrix & source); // Matrix_inverse
   inline void inverse(/*1Ac*/const Matrix * source); // Matrix_inverse
   inline void inverseTransposeTransform(/*1Ab*/const Matrix & source); // Matrix_inverseTransposeTransform
   inline void inverseTransposeTransform(/*1Ac*/const Matrix * source); // Matrix_inverseTransposeTransform
   inline void multiply(/*1Ab*/const Matrix & a, /*1Ab*/const Matrix & b); // Matrix_multiply
   inline void multiply(/*1Ac*/const Matrix * a, /*1Ac*/const Matrix * b); // Matrix_multiply
   inline void multiply3x4(/*1Ab*/const Matrix & a, /*1Ab*/const Matrix & b); // Matrix_multiply3x4
   inline void multiply3x4(/*1Ac*/const Matrix * a, /*1Ac*/const Matrix * b); // Matrix_multiply3x4
   inline void rotate(/*1Ab*/const Quaternion & quat); // Matrix_rotate
   inline void rotate(/*1Ac*/const Quaternion * quat); // Matrix_rotate
   inline void rotationQuaternion(/*1Ab*/const Quaternion & quat); // Matrix_rotationQuaternion
   inline void rotationQuaternion(/*1Ac*/const Quaternion * quat); // Matrix_rotationQuaternion
   inline void scale(/*1Ab*/double sx, /*1Ab*/double sy, /*1Ab*/double sz); // Matrix_scale
   inline void toEuler(/*1Ab*/Euler & euler); // Matrix_toEuler
   inline void toEuler(/*1Ac*/Euler * euler); // Matrix_toEuler
   inline void translate(/*1Ab*/double tx, /*1Ab*/double ty, /*1Ab*/double tz); // Matrix_translate
   inline void transpose(/*1Ab*/const Matrix & source); // Matrix_transpose
   inline void transpose(/*1Ac*/const Matrix * source); // Matrix_transpose
   inline C(bool) isIdentity(); // Matrix_isIdentity
};

struct Matrixf : public TStruct<Matrixf>
{
public:
   C(Matrixf) impl;
   constexpr Matrixf() : impl({}) { }
   constexpr Matrixf(const C(Matrixf) impl) : impl(impl) { }
   inline operator Matrix() const;
   inline Matrixf(const Matrix & m);
   inline Matrixf & operator =(const Matrix & m);

   inline void identity(); // Matrixf_identity
   inline void fromMatrix(/*1Ab*/Matrix & m); // Matrixf_fromMatrix
   inline void fromMatrix(/*1Ac*/Matrix * m); // Matrixf_fromMatrix
};

template <class TC, C(Class) ** TCO>
class TMesh : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline C(PrimitiveGroup) * addPrimitiveGroup(/*1Ab*/PrimitiveGroupType flags, /*1Ab*/int nIndices); // Mesh_addPrimitiveGroup
   inline C(bool) allocate(/*1Ab*/MeshFeatures what, /*1Ab*/int nVertices, /*1Ab*/DisplaySystem & displaySystem); // Mesh_allocate
   inline C(bool) allocatePrimitive(/*1Ab*/PrimitiveSingle & primitive, /*1Ab*/PrimitiveGroupType flags, /*1Ab*/int nIndices); // Mesh_allocatePrimitive
   inline C(bool) allocatePrimitive(/*1Ac*/PrimitiveSingle * primitive, /*1Ac*/PrimitiveGroupType flags, /*1Ac*/int nIndices); // Mesh_allocatePrimitive
   inline void applyMaterial(/*1Ab*/Material material); // Mesh_applyMaterial
   inline void applyMorphs(/*1Ab*/bool recomputeNormals); // Mesh_applyMorphs
   inline void applySkin(); // Mesh_applySkin
   inline C(bool) applyTranslucency(/*1Ab*/Object object); // Mesh_applyTranslucency
   inline void combineMorphs(/*1Ab*/TArray<C(bool) _ARG int _ARG C(bool)> & combined); // Mesh_combineMorphs
   inline void computeNormals(); // Mesh_computeNormals
   inline void computeNormals2(/*1Ab*/bool computeNormals, /*1Ab*/bool computeTangents); // Mesh_computeNormals2
   inline void computeNormals3(/*1Ab*/bool computeNormals, /*1Ab*/bool computeTangents, /*1Ab*/bool unlock); // Mesh_computeNormals3
   inline C(Mesh) * copy(); // Mesh_copy
   inline int findClosestVertex(/*1Ab*/const Vector3D & local, /*1Ab*/Vector3Df & actual); // Mesh_findClosestVertex
   inline int findClosestVertex(/*1Ac*/const Vector3D * local, /*1Ac*/Vector3Df * actual); // Mesh_findClosestVertex
   inline void free(/*1Ab*/MeshFeatures what); // Mesh_free
   inline void freeCPUVertexAttributes(/*1Ab*/MeshFeatures what); // Mesh_freeCPUVertexAttributes
   inline void freePrimitive(/*1Ab*/PrimitiveSingle & primitive); // Mesh_freePrimitive
   inline void freePrimitive(/*1Ac*/PrimitiveSingle * primitive); // Mesh_freePrimitive
   inline void freePrimitiveGroup(/*1Ab*/PrimitiveGroup group); // Mesh_freePrimitiveGroup
   inline void * getData(); // Mesh_getData
   inline C(bool) lock(/*1Ab*/MeshFeatures flags); // Mesh_lock
   inline C(bool) lockPrimitive(/*1Ab*/PrimitiveSingle & primitive); // Mesh_lockPrimitive
   inline C(bool) lockPrimitive(/*1Ac*/PrimitiveSingle * primitive); // Mesh_lockPrimitive
   inline C(bool) lockPrimitiveGroup(/*1Ab*/PrimitiveGroup group); // Mesh_lockPrimitiveGroup
   inline void setData(/*1Ab*/void * value); // Mesh_setData
   inline void unapplySkin(); // Mesh_unapplySkin
   inline C(bool) unapplyTranslucency(/*1Ab*/Object object); // Mesh_unapplyTranslucency
   inline void unlock(/*1Ab*/MeshFeatures flags); // Mesh_unlock
   inline void unlockPrimitive(/*1Ab*/PrimitiveSingle & primitive); // Mesh_unlockPrimitive
   inline void unlockPrimitive(/*1Ac*/PrimitiveSingle * primitive); // Mesh_unlockPrimitive
   inline void unlockPrimitiveGroup(/*1Ab*/PrimitiveGroup group); // Mesh_unlockPrimitiveGroup
   inline C(bool) upload(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/bool uploadTextures, /*1Ab*/GLMB & mab, /*1Ab*/GLMB & meab, /*1Ab*/int nAT, /*1Ab*/GLArrayTexture * mAT); // Mesh_upload
   inline void uploadPrimitive(/*1Ab*/PrimitiveSingle & g, /*1Ab*/DisplaySystem & displaySystem, /*1Ab*/bool uploadTextures, /*1Ab*/int nAT, /*1Ab*/GLArrayTexture * mAT, /*1Ab*/bool clearData, /*1Ab*/bool unlockAndDelete); // Mesh_uploadPrimitive
   inline void uploadPrimitive(/*1Ac*/PrimitiveSingle * g, /*1Ac*/DisplaySystem & displaySystem, /*1Ac*/bool uploadTextures, /*1Ac*/int nAT, /*1Ac*/GLArrayTexture * mAT, /*1Ac*/bool clearData, /*1Ac*/bool unlockAndDelete); // Mesh_uploadPrimitive
   inline void uploadTexture(/*1Ab*/Bitmap & bitmap, /*1Ab*/DisplaySystem & displaySystem, /*1Ab*/GLArrayTexture & at); // Mesh_uploadTexture
   inline void uploadTexture(/*1Ac*/Bitmap & bitmap, /*1Ac*/DisplaySystem & displaySystem, /*1Ac*/GLArrayTexture * at); // Mesh_uploadTexture
   inline void fixMorphSkin(); // Mesh_fixMorphSkin
   inline void fixSkeletonBones(/*1Ab*/SkinBone * bone, /*1Ab*/int boneIx); // Mesh_fixSkeletonBones

   struct nVertices_Prop
   {
      constexpr nVertices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TMesh<TC, TCO>::nVertices_Prop & operator= (typename TMesh<TC, TCO>::nVertices_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nVertices;
   struct nIndices_Prop
   {
      constexpr nIndices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TMesh<TC, TCO>::nIndices_Prop & operator= (typename TMesh<TC, TCO>::nIndices_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nIndices;
   struct meab_Prop
   {
      constexpr meab_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const GLMB & operator= (/*0A*/const GLMB & v);
      /*regSet*/inline typename TMesh<TC, TCO>::meab_Prop & operator= (typename TMesh<TC, TCO>::meab_Prop & prop);
      /*nstSet*/inline /*0C*/const GLMB * operator= (/*0C*/const GLMB * v);
      /*regGet*/inline operator /*0F*/GLMB* () const;
   } meab;
   struct baseIndex_Prop
   {
      constexpr baseIndex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TMesh<TC, TCO>::baseIndex_Prop & operator= (typename TMesh<TC, TCO>::baseIndex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } baseIndex;
   struct baseVertex_Prop
   {
      constexpr baseVertex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TMesh<TC, TCO>::baseVertex_Prop & operator= (typename TMesh<TC, TCO>::baseVertex_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } baseVertex;
   struct indices_Prop
   {
      constexpr indices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint * operator= (/*0H*/uint * v);
      /*regSet*/inline typename TMesh<TC, TCO>::indices_Prop & operator= (typename TMesh<TC, TCO>::indices_Prop & prop);
      /*regGet*/inline operator /*0I*/uint * () const;
   } indices;
   struct groups_Prop
   {
      constexpr groups_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/OldList () const;
   } groups;
   struct flags_Prop
   {
      constexpr flags_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/MeshFeatures operator= (/*0H*/MeshFeatures v);
      /*regSet*/inline typename TMesh<TC, TCO>::flags_Prop & operator= (typename TMesh<TC, TCO>::flags_Prop & prop);
      /*regGet*/inline operator /*0I*/MeshFeatures () const;
   } flags;
   struct skin_Prop
   {
      constexpr skin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const MeshSkin & operator= (/*0A*/const MeshSkin & v);
      /*regSet*/inline typename TMesh<TC, TCO>::skin_Prop & operator= (typename TMesh<TC, TCO>::skin_Prop & prop);
      /*nstSet*/inline /*0C*/const MeshSkin * operator= (/*0C*/const MeshSkin * v);
      /*regGet*/inline operator /*0B*/TIH<MeshSkin> () const;
      /*regGet*/inline TIH<MeshSkin> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/MeshSkin () const;
      /*regGet*/inline operator /*0F*/MeshSkin* () const;
   } skin;
   struct dupVerts_Prop
   {
      constexpr dupVerts_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const TArray<int _ARG int _ARG int> & operator= (/*0A*/const TArray<int _ARG int _ARG int> & v);
      /*regSet*/inline typename TMesh<TC, TCO>::dupVerts_Prop & operator= (typename TMesh<TC, TCO>::dupVerts_Prop & prop);
      /*nstSet*/inline /*0C*/const TArray<int _ARG int _ARG int> * operator= (/*0C*/const TArray<int _ARG int _ARG int> * v);
      /*regGet*/inline operator /*0B*/TIH<TArray<int _ARG int _ARG int>> () const;
      /*regGet*/inline TIH<TArray<int _ARG int _ARG int>> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/TArray<int _ARG int _ARG int> () const;
      /*regGet*/inline operator /*0F*/TArray<int _ARG int _ARG int>* () const;
   } dupVerts;
   struct morphs_Prop
   {
      constexpr morphs_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const TArray<MeshMorph _ARG int _ARG MeshMorph> & operator= (/*0A*/const TArray<MeshMorph _ARG int _ARG MeshMorph> & v);
      /*regSet*/inline typename TMesh<TC, TCO>::morphs_Prop & operator= (typename TMesh<TC, TCO>::morphs_Prop & prop);
      /*nstSet*/inline /*0C*/const TArray<MeshMorph _ARG int _ARG MeshMorph> * operator= (/*0C*/const TArray<MeshMorph _ARG int _ARG MeshMorph> * v);
      /*regGet*/inline operator /*0B*/TIH<TArray<MeshMorph _ARG int _ARG MeshMorph>> () const;
      /*regGet*/inline TIH<TArray<MeshMorph _ARG int _ARG MeshMorph>> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/TArray<MeshMorph _ARG int _ARG MeshMorph> () const;
      /*regGet*/inline operator /*0F*/TArray<MeshMorph _ARG int _ARG MeshMorph>* () const;
   } morphs;
   struct unmorphedMesh_Prop
   {
      constexpr unmorphedMesh_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Mesh operator= (/*0H*/Mesh & v);
      /*regSet*/inline typename TMesh<TC, TCO>::unmorphedMesh_Prop & operator= (typename TMesh<TC, TCO>::unmorphedMesh_Prop & prop);
      /*regGet*/inline operator /*0I*/Mesh () const;
   } unmorphedMesh;
   struct nTranslucentPrimitives_Prop
   {
      constexpr nTranslucentPrimitives_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } nTranslucentPrimitives;
   struct parts_Prop
   {
      constexpr parts_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const TArray<MeshPart _ARG int _ARG MeshPart> & operator= (/*0A*/const TArray<MeshPart _ARG int _ARG MeshPart> & v);
      /*regSet*/inline typename TMesh<TC, TCO>::parts_Prop & operator= (typename TMesh<TC, TCO>::parts_Prop & prop);
      /*nstSet*/inline /*0C*/const TArray<MeshPart _ARG int _ARG MeshPart> * operator= (/*0C*/const TArray<MeshPart _ARG int _ARG MeshPart> * v);
      /*regGet*/inline operator /*0B*/TIH<TArray<MeshPart _ARG int _ARG MeshPart>> () const;
      /*regGet*/inline TIH<TArray<MeshPart _ARG int _ARG MeshPart>> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/TArray<MeshPart _ARG int _ARG MeshPart> () const;
      /*regGet*/inline operator /*0F*/TArray<MeshPart _ARG int _ARG MeshPart>* () const;
   } parts;
   ~TMesh()
   {
      this->impl = null; // How to know not to delete?
   }
};

class MeshFeatures
{
public:
   C(MeshFeatures) impl;
   constexpr MeshFeatures() : impl(0) { }
   constexpr MeshFeatures(C(MeshFeatures) impl) : impl(impl) { }
   operator C(MeshFeatures)() { return impl; }
   MeshFeatures & operator =(C(MeshFeatures) impl) { impl = impl; return *this; }
   bool operator ==(const MeshFeatures & value) const { return impl == value.impl; }
   bool operator !=(const MeshFeatures & value) const { return impl != value.impl; }

   struct vertices_Prop
   {
      constexpr vertices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::vertices_Prop & operator= (MeshFeatures::vertices_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } vertices;
   struct normals_Prop
   {
      constexpr normals_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::normals_Prop & operator= (MeshFeatures::normals_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } normals;
   struct texCoords1_Prop
   {
      constexpr texCoords1_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::texCoords1_Prop & operator= (MeshFeatures::texCoords1_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } texCoords1;
   struct texCoords2_Prop
   {
      constexpr texCoords2_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::texCoords2_Prop & operator= (MeshFeatures::texCoords2_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } texCoords2;
   struct doubleNormals_Prop
   {
      constexpr doubleNormals_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::doubleNormals_Prop & operator= (MeshFeatures::doubleNormals_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } doubleNormals;
   struct doubleVertices_Prop
   {
      constexpr doubleVertices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::doubleVertices_Prop & operator= (MeshFeatures::doubleVertices_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } doubleVertices;
   struct colors_Prop
   {
      constexpr colors_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::colors_Prop & operator= (MeshFeatures::colors_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } colors;
   struct lightVectors_Prop
   {
      constexpr lightVectors_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::lightVectors_Prop & operator= (MeshFeatures::lightVectors_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } lightVectors;
   struct tangents_Prop
   {
      constexpr tangents_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::tangents_Prop & operator= (MeshFeatures::tangents_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } tangents;
   struct intVertices_Prop
   {
      constexpr intVertices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::intVertices_Prop & operator= (MeshFeatures::intVertices_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } intVertices;
   struct memAllocOnly_Prop
   {
      constexpr memAllocOnly_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::memAllocOnly_Prop & operator= (MeshFeatures::memAllocOnly_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } memAllocOnly;
   struct interleaved_Prop
   {
      constexpr interleaved_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::interleaved_Prop & operator= (MeshFeatures::interleaved_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } interleaved;
   struct ownMEAB_Prop
   {
      constexpr ownMEAB_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::ownMEAB_Prop & operator= (MeshFeatures::ownMEAB_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } ownMEAB;
   struct bones_Prop
   {
      constexpr bones_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshFeatures::bones_Prop & operator= (MeshFeatures::bones_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bones;
};

struct MeshMorph : public TStruct<MeshMorph>
{
public:
   C(MeshMorph) impl;
   constexpr MeshMorph() : impl({}) { }
   constexpr MeshMorph(const C(MeshMorph) impl) : impl(impl) { }

   struct target_Prop
   {
      constexpr target_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Mesh operator= (/*0H*/Mesh & v);
      /*regSet*/inline MeshMorph::target_Prop & operator= (MeshMorph::target_Prop & prop);
      /*regGet*/inline operator /*0I*/Mesh () const;
   } target;
   struct weight_Prop
   {
      constexpr weight_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline MeshMorph::weight_Prop & operator= (MeshMorph::weight_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } weight;
   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/char * operator= (/*0H*/char * v);
      /*regSet*/inline MeshMorph::name_Prop & operator= (MeshMorph::name_Prop & prop);
      /*regGet*/inline operator /*0I*/char * () const;
   } name;
   struct updated_Prop
   {
      constexpr updated_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshMorph::updated_Prop & operator= (MeshMorph::updated_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } updated;
   struct firstV_Prop
   {
      constexpr firstV_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline MeshMorph::firstV_Prop & operator= (MeshMorph::firstV_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } firstV;
   struct lastV_Prop
   {
      constexpr lastV_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline MeshMorph::lastV_Prop & operator= (MeshMorph::lastV_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } lastV;
};

struct MeshPart : public TStruct<MeshPart>
{
public:
   C(MeshPart) impl;
   constexpr MeshPart() : impl({}) { }
   constexpr MeshPart(const C(MeshPart) impl) : impl(impl) { }

   inline MeshPart(uint64 id, uint start, uint count);

   struct id_Prop
   {
      constexpr id_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint64 operator= (/*0H*/uint64 v);
      /*regSet*/inline MeshPart::id_Prop & operator= (MeshPart::id_Prop & prop);
      /*regGet*/inline operator /*0I*/uint64 () const;
   } id;
   struct start_Prop
   {
      constexpr start_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline MeshPart::start_Prop & operator= (MeshPart::start_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } start;
   struct count_Prop
   {
      constexpr count_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline MeshPart::count_Prop & operator= (MeshPart::count_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } count;
};


#define REG_MeshSkin(c) \
      MeshSkin::class_registration(_cpp_class);

#define MESHSKIN_VIRTUAL_METHODS_PROTO(c) \

#define MESHSKIN_VIRTUAL_METHODS(c) \

class MeshSkin : public Instance
{
public:
   inline MeshSkin(MeshSkin && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline MeshSkin & operator= (MeshSkin && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   MeshSkin() : MeshSkin((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<MeshSkin> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         MeshSkin * inst = new MeshSkin(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      MeshSkin * inst = (MeshSkin *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(MeshSkin & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline MeshSkin(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline MeshSkin(Matrix bindShapeMatrix);

   struct bindShapeMatrix_Prop
   {
      constexpr bindShapeMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Matrix operator= (/*0H*/Matrix v);
      /*regSet*/inline MeshSkin::bindShapeMatrix_Prop & operator= (MeshSkin::bindShapeMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/Matrix () const;
   } bindShapeMatrix;
   struct bones_Prop
   {
      constexpr bones_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/TArray<SkinBone _ARG int _ARG SkinBone> operator= (/*0H*/TArray<SkinBone _ARG int _ARG SkinBone> v);
      /*regSet*/inline MeshSkin::bones_Prop & operator= (MeshSkin::bones_Prop & prop);
      /*regGet*/inline operator /*0I*/TArray<SkinBone _ARG int _ARG SkinBone> () const;
   } bones;
   struct skinVerts_Prop
   {
      constexpr skinVerts_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/TArray<SkinVert _ARG int _ARG SkinVert> operator= (/*0H*/TArray<SkinVert _ARG int _ARG SkinVert> v);
      /*regSet*/inline MeshSkin::skinVerts_Prop & operator= (MeshSkin::skinVerts_Prop & prop);
      /*regGet*/inline operator /*0I*/TArray<SkinVert _ARG int _ARG SkinVert> () const;
   } skinVerts;
   struct invShape_Prop
   {
      constexpr invShape_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Matrix operator= (/*0H*/Matrix v);
      /*regSet*/inline MeshSkin::invShape_Prop & operator= (MeshSkin::invShape_Prop & prop);
      /*regGet*/inline operator /*0I*/Matrix () const;
   } invShape;
   struct bsIsIdentity_Prop
   {
      constexpr bsIsIdentity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MeshSkin::bsIsIdentity_Prop & operator= (MeshSkin::bsIsIdentity_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bsIsIdentity;
};

template <class TC, C(Class) ** TCO>
class TObject : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline void add(/*1Ab*/TObject<TC, TCO> object); // Object_add
   inline void addFrameTrack(/*1Ab*/FrameTrack track); // Object_addFrameTrack
   inline C(bool) addName(/*1Ab*/TObject<TC, TCO> object, /*1Ab*/const char * name); // Object_addName
   inline void animate(/*1Ab*/int frame); // Object_animate
   inline void applyMorphs(/*1Ab*/bool recomputeNormals); // Object_applyMorphs
   inline void applySkins(); // Object_applySkins
   inline void combineMorphs(); // Object_combineMorphs
   inline void _delete(/*1Ab*/TObject<TC, TCO> child, /*1Ab*/DisplaySystem & displaySystem); // Object_delete
   inline void doubleSided(/*1Ab*/bool flag); // Object_doubleSided
   inline void duplicate(/*1Ab*/TObject<TC, TCO> model); // Object_duplicate
   inline void duplicate2(/*1Ab*/TObject<TC, TCO> model, /*1Ab*/bool takeOwnership); // Object_duplicate2
   inline C(Object) * find(/*1Ab*/const char * name); // Object_find
   inline void free(/*1Ab*/const DisplaySystem & displaySystem); // Object_free
   inline void freeMesh(/*1Ab*/DisplaySystem & displaySystem); // Object_freeMesh
   inline void initialize(); // Object_initialize
   inline C(Mesh) * initializeMesh(/*1Ab*/DisplaySystem & displaySystem); // Object_initializeMesh
   inline C(FrustumPlacement) insideFrustum(/*1Ab*/Plane * planes); // Object_insideFrustum
   inline C(bool) intersectsGroundPolygon(/*1Ab*/int count, /*1Ab*/Pointf * pointfs); // Object_intersectsGroundPolygon
   inline void inverseKinematics(/*1Ab*/int boneIX, /*1Ab*/TArray<Euler _ARG int _ARG Euler> & limits, /*1Ab*/int vertex, /*1Ab*/const Vector3D & target, /*1Ab*/int maxDepth); // Object_inverseKinematics
   inline void inverseKinematics(/*1Ac*/int boneIX, /*1Ac*/TArray<Euler _ARG int _ARG Euler> & limits, /*1Ac*/int vertex, /*1Ac*/const Vector3D * target, /*1Ac*/int maxDepth); // Object_inverseKinematics
   inline C(bool) load(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem); // Object_load
   inline C(bool) loadEx(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem, /*1Ab*/void * options); // Object_loadEx
   inline C(bool) merge(/*1Ab*/DisplaySystem & displaySystem); // Object_merge
   inline C(bool) mergeEx(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/MeshFeatures deleteCPUAttrOptions); // Object_mergeEx
   inline void move(/*1Ab*/Vector3D & direction); // Object_move
   inline void move(/*1Ac*/Vector3D * direction); // Object_move
   inline void remove(/*1Ab*/TObject<TC, TCO> child); // Object_remove
   inline void resetPose(); // Object_resetPose
   inline void rotateEuler(/*1Ab*/Euler & rotation, /*1Ab*/Euler & min, /*1Ab*/Euler & max); // Object_rotateEuler
   inline void rotateEuler(/*1Ac*/Euler * rotation, /*1Ac*/Euler * min, /*1Ac*/Euler * max); // Object_rotateEuler
   inline C(bool) save(/*1Ab*/const char * fileName, /*1Ab*/const char * type); // Object_save
   inline C(bool) saveEx(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/void * options); // Object_saveEx
   inline void setMinMaxRadius(/*1Ab*/bool processMesh); // Object_setMinMaxRadius
   inline void updateTransform(); // Object_updateTransform
   inline void upload(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/GLMB & mab, /*1Ab*/GLMB & meab, /*1Ab*/int nAT, /*1Ab*/GLArrayTexture * mAT); // Object_upload
   static inline TArray<C(String) _ARG int _ARG C(String)> listTextures(/*1Ab*/File & file, /*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/void * options); // Object_listTextures

   struct transform_Prop
   {
      constexpr transform_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Transform operator= (/*0H*/Transform v);
      /*regSet*/inline typename TObject<TC, TCO>::transform_Prop & operator= (typename TObject<TC, TCO>::transform_Prop & prop);
      /*regGet*/inline operator /*0I*/Transform () const;
   } transform;
   struct eulerOrientation_Prop
   {
      constexpr eulerOrientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Euler operator= (/*0H*/Euler v);
      /*regSet*/inline typename TObject<TC, TCO>::eulerOrientation_Prop & operator= (typename TObject<TC, TCO>::eulerOrientation_Prop & prop);
      /*regGet*/inline operator /*0I*/Euler () const;
   } eulerOrientation;
   struct material_Prop
   {
      constexpr material_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Material operator= (/*0H*/Material & v);
      /*regSet*/inline typename TObject<TC, TCO>::material_Prop & operator= (typename TObject<TC, TCO>::material_Prop & prop);
      /*regGet*/inline operator /*0I*/Material () const;
   } material;
   struct max_Prop
   {
      constexpr max_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } max;
   struct min_Prop
   {
      constexpr min_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } min;
   struct center_Prop
   {
      constexpr center_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } center;
   struct radius_Prop
   {
      constexpr radius_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/float () const;
   } radius;
   struct wmax_Prop
   {
      constexpr wmax_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } wmax;
   struct wmin_Prop
   {
      constexpr wmin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } wmin;
   struct wcenter_Prop
   {
      constexpr wcenter_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } wcenter;
   struct wradius_Prop
   {
      constexpr wradius_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/double () const;
   } wradius;
   struct tag_Prop
   {
      constexpr tag_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline typename TObject<TC, TCO>::tag_Prop & operator= (typename TObject<TC, TCO>::tag_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } tag;
   struct frame_Prop
   {
      constexpr frame_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TObject<TC, TCO>::frame_Prop & operator= (typename TObject<TC, TCO>::frame_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } frame;
   struct startFrame_Prop
   {
      constexpr startFrame_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TObject<TC, TCO>::startFrame_Prop & operator= (typename TObject<TC, TCO>::startFrame_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } startFrame;
   struct endFrame_Prop
   {
      constexpr endFrame_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TObject<TC, TCO>::endFrame_Prop & operator= (typename TObject<TC, TCO>::endFrame_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } endFrame;
   struct mesh_Prop
   {
      constexpr mesh_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Mesh operator= (/*0H*/Mesh & v);
      /*regSet*/inline typename TObject<TC, TCO>::mesh_Prop & operator= (typename TObject<TC, TCO>::mesh_Prop & prop);
      /*regGet*/inline operator /*0I*/Mesh () const;
   } mesh;
   struct camera_Prop
   {
      constexpr camera_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Camera> () const;
      /*regGet*/inline TIH<Camera> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Camera () const;
      /*regGet*/inline operator /*0F*/Camera* () const;
   } camera;
   struct firstChild_Prop
   {
      constexpr firstChild_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Object () const;
   } firstChild;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Object () const;
   } next;
   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline typename TObject<TC, TCO>::name_Prop & operator= (typename TObject<TC, TCO>::name_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } name;
   struct matrix_Prop
   {
      constexpr matrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Matrix () const;
   } matrix;
   struct cameraTarget_Prop
   {
      constexpr cameraTarget_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Object operator= (/*0H*/Object & v);
      /*regSet*/inline typename TObject<TC, TCO>::cameraTarget_Prop & operator= (typename TObject<TC, TCO>::cameraTarget_Prop & prop);
      /*regGet*/inline operator /*0I*/Object () const;
   } cameraTarget;
   struct flags_Prop
   {
      constexpr flags_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ObjectFlags operator= (/*0H*/ObjectFlags v);
      /*regSet*/inline typename TObject<TC, TCO>::flags_Prop & operator= (typename TObject<TC, TCO>::flags_Prop & prop);
      /*regGet*/inline operator /*0I*/ObjectFlags () const;
   } flags;
   struct parent_Prop
   {
      constexpr parent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Object () const;
   } parent;
   struct numChildren_Prop
   {
      constexpr numChildren_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/uint () const;
   } numChildren;
   struct light_Prop
   {
      constexpr light_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Light operator= (/*0H*/Light v);
      /*regSet*/inline typename TObject<TC, TCO>::light_Prop & operator= (typename TObject<TC, TCO>::light_Prop & prop);
      /*regGet*/inline operator /*0I*/Light () const;
   } light;
   struct rotationOrder_Prop
   {
      constexpr rotationOrder_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/EulerRotationOrder operator= (/*0H*/EulerRotationOrder v);
      /*regSet*/inline typename TObject<TC, TCO>::rotationOrder_Prop & operator= (typename TObject<TC, TCO>::rotationOrder_Prop & prop);
      /*regGet*/inline operator /*0I*/EulerRotationOrder () const;
   } rotationOrder;
   struct displaySystem_Prop
   {
      constexpr displaySystem_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const DisplaySystem & operator= (/*0A*/const DisplaySystem & v);
      /*regSet*/inline typename TObject<TC, TCO>::displaySystem_Prop & operator= (typename TObject<TC, TCO>::displaySystem_Prop & prop);
      /*nstSet*/inline /*0C*/const DisplaySystem * operator= (/*0C*/const DisplaySystem * v);
      /*regGet*/inline operator /*0B*/TIH<DisplaySystem> () const;
      /*regGet*/inline TIH<DisplaySystem> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DisplaySystem () const;
      /*regGet*/inline operator /*0F*/DisplaySystem* () const;
   } displaySystem;
   ~TObject()
   {
      this->impl = null; // How to know not to delete?
   }
};

class ObjectFlags
{
public:
   C(ObjectFlags) impl;
   constexpr ObjectFlags() : impl(0) { }
   constexpr ObjectFlags(C(ObjectFlags) impl) : impl(impl) { }
   operator C(ObjectFlags)() { return impl; }
   ObjectFlags & operator =(C(ObjectFlags) impl) { impl = impl; return *this; }
   bool operator ==(const ObjectFlags & value) const { return impl == value.impl; }
   bool operator !=(const ObjectFlags & value) const { return impl != value.impl; }

   struct root_Prop
   {
      constexpr root_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::root_Prop & operator= (ObjectFlags::root_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } root;
   struct viewSpace_Prop
   {
      constexpr viewSpace_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::viewSpace_Prop & operator= (ObjectFlags::viewSpace_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } viewSpace;
   struct ownMesh_Prop
   {
      constexpr ownMesh_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::ownMesh_Prop & operator= (ObjectFlags::ownMesh_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } ownMesh;
   struct translucent_Prop
   {
      constexpr translucent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::translucent_Prop & operator= (ObjectFlags::translucent_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } translucent;
   struct flipWindings_Prop
   {
      constexpr flipWindings_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::flipWindings_Prop & operator= (ObjectFlags::flipWindings_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } flipWindings;
   struct keysLoaded_Prop
   {
      constexpr keysLoaded_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::keysLoaded_Prop & operator= (ObjectFlags::keysLoaded_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } keysLoaded;
   struct transform_Prop
   {
      constexpr transform_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::transform_Prop & operator= (ObjectFlags::transform_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } transform;
   struct mesh_Prop
   {
      constexpr mesh_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::mesh_Prop & operator= (ObjectFlags::mesh_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } mesh;
   struct light_Prop
   {
      constexpr light_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::light_Prop & operator= (ObjectFlags::light_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } light;
   struct camera_Prop
   {
      constexpr camera_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::camera_Prop & operator= (ObjectFlags::camera_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } camera;
   struct localMatrixSet_Prop
   {
      constexpr localMatrixSet_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::localMatrixSet_Prop & operator= (ObjectFlags::localMatrixSet_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } localMatrixSet;
   struct computeLightVectors_Prop
   {
      constexpr computeLightVectors_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::computeLightVectors_Prop & operator= (ObjectFlags::computeLightVectors_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } computeLightVectors;
   struct skinApplied_Prop
   {
      constexpr skinApplied_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::skinApplied_Prop & operator= (ObjectFlags::skinApplied_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } skinApplied;
   struct hide_Prop
   {
      constexpr hide_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::hide_Prop & operator= (ObjectFlags::hide_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hide;
   struct skeleton_Prop
   {
      constexpr skeleton_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::skeleton_Prop & operator= (ObjectFlags::skeleton_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } skeleton;
   struct bone_Prop
   {
      constexpr bone_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ObjectFlags::bone_Prop & operator= (ObjectFlags::bone_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bone;
   struct hierarchy_Prop
   {
      constexpr hierarchy_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ObjectFlags::hierarchy_Prop & operator= (ObjectFlags::hierarchy_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } hierarchy;
};

#define REG_ObjectFormat_load(m, c)         REGVMETHOD(ObjectFormat, load,         c::m, (/*1Ab*/Object object, /*1Ab*/const char * fileName, /*1Ab*/DisplaySystem & displaySystem, /*1Ab*/void * options), c, (/*4Im*/object, /*4Im*/fileName, /*4Im*/displaySystem, /*4Im*/options))
#define REG_ObjectFormat_save(m, c)         REGVMETHOD(ObjectFormat, save,         c::m, (/*1Ab*/Object object, /*1Ab*/const char * fileName, /*1Ab*/void * options),                                       c, (/*4Im*/object, /*4Im*/fileName, /*4Im*/options))
#define REG_ObjectFormat_listTextures(m, c) REGVMETHOD(ObjectFormat, listTextures, c::m, (/*1Ab*/File & f, /*1Ab*/const char * fileName, /*1Ab*/void * options),                                            c, (/*4Im*/f, /*4Im*/fileName, /*4Im*/options))

#define REG_ObjectFormat(c) \
      ObjectFormat::class_registration(_cpp_class); \
      REG_ObjectFormat_load(load, c); \
      REG_ObjectFormat_save(save, c); \
      REG_ObjectFormat_listTextures(listTextures, c);

#define OBJECTFORMAT_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(load, load, c, ObjectFormat, \
      bool, c & _ARG, , /*6Fj*/Object object _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/DisplaySystem & displaySystem _ARG /*6Fj*/void * options); \
   VIRTUAL_METHOD_PROTO(save, save, c, ObjectFormat, \
      bool, c & _ARG, , /*6Fj*/Object object _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/void * options); \
   VIRTUAL_METHOD_PROTO(listTextures, listTextures, c, ObjectFormat, \
      TArray<C(String) _ARG int _ARG C(String)>, c & _ARG, , /*6Fj*/File & f _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/void * options);

#define OBJECTFORMAT_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(load, load, c, ObjectFormat, \
   bool, c & _ARG, , /*6Fj*/Object object _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/DisplaySystem & displaySystem _ARG /*6Fj*/void * options, \
   return (bool)ObjectFormat_load(self ? self->impl : (C(ObjectFormat))null, /*7Al*/object.impl, /*7Al*/fileName, /*7Al*/displaySystem.impl, /*7Al*/options);); \
VIRTUAL_METHOD(save, save, c, ObjectFormat, \
   bool, c & _ARG, , /*6Fj*/Object object _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/void * options, \
   return (bool)ObjectFormat_save(self ? self->impl : (C(ObjectFormat))null, /*7Al*/object.impl, /*7Al*/fileName, /*7Al*/options);); \
VIRTUAL_METHOD(listTextures, listTextures, c, ObjectFormat, \
   TArray<C(String) _ARG int _ARG C(String)>, c & _ARG, , /*6Fj*/File & f _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/void * options, \
   C(Array) retArray = ObjectFormat_listTextures(self ? self->impl : (C(ObjectFormat))null, /*7Al*/f.impl, /*7Al*/fileName, /*7Al*/options); \
      return TArray<C(String) _ARG int _ARG C(String)>(retArray););

class ObjectFormat : public Instance
{
public:
   inline ObjectFormat(ObjectFormat && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ObjectFormat & operator= (ObjectFormat && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ObjectFormat() : ObjectFormat((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ObjectFormat> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ObjectFormat * inst = new ObjectFormat(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ObjectFormat * inst = (ObjectFormat *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ObjectFormat & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ObjectFormat(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct ObjectFormat_load_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(ObjectFormat & , /*6Fj*/Object object, /*6Fj*/const char * fileName, /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/void * options);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Object object, /*6Fj*/const char * fileName, /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/void * options);
   } load;
   // inline static void register_load(CPPClass & cl, ObjectFormat::ObjectFormat_load_Functor::FunctionType func)

   struct ObjectFormat_save_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(ObjectFormat & , /*6Fj*/Object object, /*6Fj*/const char * fileName, /*6Fj*/void * options);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Object object, /*6Fj*/const char * fileName, /*6Fj*/void * options);
   } save;
   // inline static void register_save(CPPClass & cl, ObjectFormat::ObjectFormat_save_Functor::FunctionType func)

   struct ObjectFormat_listTextures_Functor
   {
      [[no_unique_address]] int _[0];
      typedef TArray<C(String) _ARG int _ARG C(String)> (* FunctionType)(ObjectFormat & , /*6Fj*/File & f, /*6Fj*/const char * fileName, /*6Fj*/void * options);
      inline FunctionType operator= (FunctionType func);
      inline TArray<C(String) _ARG int _ARG C(String)> operator()( /*6Fj*/File & f, /*6Fj*/const char * fileName, /*6Fj*/void * options);
   } listTextures;
   // inline static void register_listTextures(CPPClass & cl, ObjectFormat::ObjectFormat_listTextures_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};

struct Plane : public TStruct<Plane>
{
public:
   C(Plane) impl;
   constexpr Plane() : impl({}) { }
   constexpr Plane(const C(Plane) impl) : impl(impl) { }

   inline void fromPointNormal(/*1Ab*/const Vector3D & normal, /*1Ab*/const Vector3D & point); // Plane_fromPointNormal
   inline void fromPointNormal(/*1Ac*/const Vector3D * normal, /*1Ac*/const Vector3D * point); // Plane_fromPointNormal
   inline void fromPoints(/*1Ab*/const Vector3D & v1, /*1Ab*/const Vector3D & v2, /*1Ab*/const Vector3D & v3); // Plane_fromPoints
   inline void fromPoints(/*1Ac*/const Vector3D * v1, /*1Ac*/const Vector3D * v2, /*1Ac*/const Vector3D * v3); // Plane_fromPoints
   inline void fromPointsf(/*1Ab*/const Vector3Df & v1, /*1Ab*/const Vector3Df & v2, /*1Ab*/const Vector3Df & v3); // Plane_fromPointsf
   inline void fromPointsf(/*1Ac*/const Vector3Df * v1, /*1Ac*/const Vector3Df * v2, /*1Ac*/const Vector3Df * v3); // Plane_fromPointsf
   inline void intersectLine(/*1Ab*/const Line & line, /*1Ab*/Vector3D & result); // Plane_intersectLine
   inline void intersectLine(/*1Ac*/const Line * line, /*1Ac*/Vector3D * result); // Plane_intersectLine
   inline void intersectLinef(/*1Ab*/const Line & line, /*1Ab*/Vector3Df & result); // Plane_intersectLinef
   inline void intersectLinef(/*1Ac*/const Line * line, /*1Ac*/Vector3Df * result); // Plane_intersectLinef
   inline int intersectLinefT(/*1Ab*/const Line & line, /*1Ab*/Vector3Df & result, /*1Ab*/double * rt); // Plane_intersectLinefT
   inline int intersectLinefT(/*1Ac*/const Line * line, /*1Ac*/Vector3Df * result, /*1Ac*/double * rt); // Plane_intersectLinefT
   inline void multMatrix(/*1Ab*/const Plane & source, /*1Ab*/const Matrix & inverseTranspose); // Plane_multMatrix
   inline void multMatrix(/*1Ac*/const Plane * source, /*1Ac*/const Matrix * inverseTranspose); // Plane_multMatrix

   inline Plane(double a, double b, double c, Vector3D normal, double d);

   struct a_Prop
   {
      constexpr a_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Plane::a_Prop & operator= (Plane::a_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } a;
   struct b_Prop
   {
      constexpr b_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Plane::b_Prop & operator= (Plane::b_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } b;
   struct c_Prop
   {
      constexpr c_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Plane::c_Prop & operator= (Plane::c_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } c;
   struct normal_Prop
   {
      constexpr normal_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3D operator= (/*0H*/Vector3D v);
      /*regSet*/inline Plane::normal_Prop & operator= (Plane::normal_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } normal;
   struct d_Prop
   {
      constexpr d_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Plane::d_Prop & operator= (Plane::d_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } d;
};

template <class TC, C(Class) ** TCO>
class TPrimitiveGroup : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct prev_Prop
   {
      constexpr prev_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/PrimitiveGroup operator= (/*0H*/PrimitiveGroup & v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::prev_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::prev_Prop & prop);
      /*regGet*/inline operator /*0I*/PrimitiveGroup () const;
   } prev;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/PrimitiveGroup operator= (/*0H*/PrimitiveGroup & v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::next_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::next_Prop & prop);
      /*regGet*/inline operator /*0I*/PrimitiveGroup () const;
   } next;
   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/PrimitiveGroupType operator= (/*0H*/PrimitiveGroupType v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::type_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::type_Prop & prop);
      /*regGet*/inline operator /*0I*/PrimitiveGroupType () const;
   } type;
   struct baseIndexMesh_Prop
   {
      constexpr baseIndexMesh_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::baseIndexMesh_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::baseIndexMesh_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } baseIndexMesh;
   struct baseIndexBuffer_Prop
   {
      constexpr baseIndexBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::baseIndexBuffer_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::baseIndexBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } baseIndexBuffer;
   struct indices_Prop
   {
      constexpr indices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint16 * operator= (/*0H*/uint16 * v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::indices_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::indices_Prop & prop);
      /*regGet*/inline operator /*0I*/uint16 * () const;
   } indices;
   struct indices32_Prop
   {
      constexpr indices32_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint * operator= (/*0H*/uint * v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::indices32_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::indices32_Prop & prop);
      /*regGet*/inline operator /*0I*/uint * () const;
   } indices32;
   struct nIndices_Prop
   {
      constexpr nIndices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::nIndices_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::nIndices_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nIndices;
   struct first_Prop
   {
      constexpr first_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::first_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::first_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } first;
   struct nVertices_Prop
   {
      constexpr nVertices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::nVertices_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::nVertices_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nVertices;
   struct material_Prop
   {
      constexpr material_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Material operator= (/*0H*/Material & v);
      /*regSet*/inline typename TPrimitiveGroup<TC, TCO>::material_Prop & operator= (typename TPrimitiveGroup<TC, TCO>::material_Prop & prop);
      /*regGet*/inline operator /*0I*/Material () const;
   } material;
   ~TPrimitiveGroup()
   {
      this->impl = null; // How to know not to delete?
   }
};

struct PrimitiveSingle : public TStruct<PrimitiveSingle>
{
public:
   C(PrimitiveSingle) impl;
   constexpr PrimitiveSingle() : impl({}) { }
   constexpr PrimitiveSingle(const C(PrimitiveSingle) impl) : impl(impl) { }

   inline PrimitiveSingle(PrimitiveGroupType type, int baseIndexMesh, int baseIndexBuffer, uint16 * indices, uint * indices32, int nIndices, int first, int nVertices);

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/PrimitiveGroupType operator= (/*0H*/PrimitiveGroupType v);
      /*regSet*/inline PrimitiveSingle::type_Prop & operator= (PrimitiveSingle::type_Prop & prop);
      /*regGet*/inline operator /*0I*/PrimitiveGroupType () const;
   } type;
   struct baseIndexMesh_Prop
   {
      constexpr baseIndexMesh_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PrimitiveSingle::baseIndexMesh_Prop & operator= (PrimitiveSingle::baseIndexMesh_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } baseIndexMesh;
   struct baseIndexBuffer_Prop
   {
      constexpr baseIndexBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PrimitiveSingle::baseIndexBuffer_Prop & operator= (PrimitiveSingle::baseIndexBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } baseIndexBuffer;
   struct indices_Prop
   {
      constexpr indices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint16 * operator= (/*0H*/uint16 * v);
      /*regSet*/inline PrimitiveSingle::indices_Prop & operator= (PrimitiveSingle::indices_Prop & prop);
      /*regGet*/inline operator /*0I*/uint16 * () const;
   } indices;
   struct indices32_Prop
   {
      constexpr indices32_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint * operator= (/*0H*/uint * v);
      /*regSet*/inline PrimitiveSingle::indices32_Prop & operator= (PrimitiveSingle::indices32_Prop & prop);
      /*regGet*/inline operator /*0I*/uint * () const;
   } indices32;
   struct nIndices_Prop
   {
      constexpr nIndices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PrimitiveSingle::nIndices_Prop & operator= (PrimitiveSingle::nIndices_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nIndices;
   struct first_Prop
   {
      constexpr first_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PrimitiveSingle::first_Prop & operator= (PrimitiveSingle::first_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } first;
   struct nVertices_Prop
   {
      constexpr nVertices_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PrimitiveSingle::nVertices_Prop & operator= (PrimitiveSingle::nVertices_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nVertices;
   struct material_Prop
   {
      constexpr material_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Material operator= (/*0H*/Material & v);
      /*regSet*/inline PrimitiveSingle::material_Prop & operator= (PrimitiveSingle::material_Prop & prop);
      /*regGet*/inline operator /*0I*/Material () const;
   } material;
   struct data_Prop
   {
      constexpr data_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline PrimitiveSingle::data_Prop & operator= (PrimitiveSingle::data_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } data;
   struct middle_Prop
   {
      constexpr middle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3Df operator= (/*0H*/Vector3Df v);
      /*regSet*/inline PrimitiveSingle::middle_Prop & operator= (PrimitiveSingle::middle_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } middle;
   struct plane_Prop
   {
      constexpr plane_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Plane operator= (/*0H*/Plane v);
      /*regSet*/inline PrimitiveSingle::plane_Prop & operator= (PrimitiveSingle::plane_Prop & prop);
      /*regGet*/inline operator /*0I*/Plane () const;
   } plane;
};

struct Quaternion : public TStruct<Quaternion>
{
public:
   C(Quaternion) impl;
   constexpr Quaternion() : impl({}) { }
   constexpr Quaternion(const C(Quaternion) impl) : impl(impl) { }

   inline void divide(/*1Ab*/const Quaternion & q1, /*1Ab*/const Quaternion & q2); // Quaternion_divide
   inline void divide(/*1Ac*/const Quaternion * q1, /*1Ac*/const Quaternion * q2); // Quaternion_divide
   inline void identity(); // Quaternion_identity
   inline void inverse(/*1Ab*/const Quaternion & source); // Quaternion_inverse
   inline void inverse(/*1Ac*/const Quaternion * source); // Quaternion_inverse
   inline void multiply(/*1Ab*/const Quaternion & q1, /*1Ab*/const Quaternion & q2); // Quaternion_multiply
   inline void multiply(/*1Ac*/const Quaternion * q1, /*1Ac*/const Quaternion * q2); // Quaternion_multiply
   inline void normalize(/*1Ab*/const Quaternion & source); // Quaternion_normalize
   inline void normalize(/*1Ac*/const Quaternion * source); // Quaternion_normalize
   inline void pitch(/*1Ab*/Angle angle); // Quaternion_pitch
   inline void roll(/*1Ab*/Angle angle); // Quaternion_roll
   inline void rotatePitch(/*1Ab*/Angle pitch); // Quaternion_rotatePitch
   inline void rotateRoll(/*1Ab*/Angle roll); // Quaternion_rotateRoll
   inline void rotateYaw(/*1Ab*/Angle yaw); // Quaternion_rotateYaw
   inline void rotateYawPitch(/*1Ab*/Angle yaw, /*1Ab*/Angle pitch); // Quaternion_rotateYawPitch
   inline void rotationAxis(/*1Ab*/const Vector3D & axis, /*1Ab*/Angle angle); // Quaternion_rotationAxis
   inline void rotationAxis(/*1Ac*/const Vector3D * axis, /*1Ac*/Angle angle); // Quaternion_rotationAxis
   inline void rotationDirection(/*1Ab*/const Vector3D & direction); // Quaternion_rotationDirection
   inline void rotationDirection(/*1Ac*/const Vector3D * direction); // Quaternion_rotationDirection
   inline void rotationEuler(/*1Ab*/const Euler & euler, /*1Ab*/EulerRotationOrder rotationOrder); // Quaternion_rotationEuler
   inline void rotationEuler(/*1Ac*/const Euler * euler, /*1Ac*/EulerRotationOrder rotationOrder); // Quaternion_rotationEuler
   inline void rotationMatrix(/*1Ab*/const Matrix & m); // Quaternion_rotationMatrix
   inline void rotationMatrix(/*1Ac*/const Matrix * m); // Quaternion_rotationMatrix
   inline void rotationYawPitchRoll(/*1Ab*/const Euler & euler); // Quaternion_rotationYawPitchRoll
   inline void rotationYawPitchRoll(/*1Ac*/const Euler * euler); // Quaternion_rotationYawPitchRoll
   inline void slerp(/*1Ab*/const Quaternion & from, /*1Ab*/const Quaternion & to, /*1Ab*/float t); // Quaternion_slerp
   inline void slerp(/*1Ac*/const Quaternion * from, /*1Ac*/const Quaternion * to, /*1Ac*/float t); // Quaternion_slerp
   inline void toDirection(/*1Ab*/Vector3D & direction); // Quaternion_toDirection
   inline void toDirection(/*1Ac*/Vector3D * direction); // Quaternion_toDirection
   inline void yaw(/*1Ab*/Angle angle); // Quaternion_yaw
   inline void yawPitch(/*1Ab*/Angle yaw, /*1Ab*/Angle pitch); // Quaternion_yawPitch
   inline void rotateQuats(/*1Ab*/const Quaternion & qPitch, /*1Ab*/const Quaternion & qYaw, /*1Ab*/const Quaternion & qRoll, /*1Ab*/EulerRotationOrder rotationOrder); // Quaternion_rotateQuats
   inline void rotateQuats(/*1Ac*/const Quaternion * qPitch, /*1Ac*/const Quaternion * qYaw, /*1Ac*/const Quaternion * qRoll, /*1Ac*/EulerRotationOrder rotationOrder); // Quaternion_rotateQuats

   inline Quaternion(double w, double x, double y, double z);

   struct w_Prop
   {
      constexpr w_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Quaternion::w_Prop & operator= (Quaternion::w_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } w;
   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Quaternion::x_Prop & operator= (Quaternion::x_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Quaternion::y_Prop & operator= (Quaternion::y_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } y;
   struct z_Prop
   {
      constexpr z_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Quaternion::z_Prop & operator= (Quaternion::z_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } z;
};

enum class RenderPrimitiveType : uint
{
   dot = RenderPrimitiveType_dot,
   lines = RenderPrimitiveType_lines,
   triangles = RenderPrimitiveType_triangles,
   triStrip = RenderPrimitiveType_triStrip,
   triFan = RenderPrimitiveType_triFan,
   quads = RenderPrimitiveType_quads,
   quadStrip = RenderPrimitiveType_quadStrip,
   lineStrip = RenderPrimitiveType_lineStrip
};

struct SkinBone : public TStruct<SkinBone>
{
public:
   C(SkinBone) impl;
   constexpr SkinBone() : impl({}) { }
   constexpr SkinBone(const C(SkinBone) impl) : impl(impl) { }

   inline SkinBone(char * name, Matrix invBindMatrix, Matrix bsInvBindMatrix);

   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/char * operator= (/*0H*/char * v);
      /*regSet*/inline SkinBone::name_Prop & operator= (SkinBone::name_Prop & prop);
      /*regGet*/inline operator /*0I*/char * () const;
   } name;
   struct invBindMatrix_Prop
   {
      constexpr invBindMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Matrix operator= (/*0H*/Matrix v);
      /*regSet*/inline SkinBone::invBindMatrix_Prop & operator= (SkinBone::invBindMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/Matrix () const;
   } invBindMatrix;
   struct bsInvBindMatrix_Prop
   {
      constexpr bsInvBindMatrix_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Matrix operator= (/*0H*/Matrix v);
      /*regSet*/inline SkinBone::bsInvBindMatrix_Prop & operator= (SkinBone::bsInvBindMatrix_Prop & prop);
      /*regGet*/inline operator /*0I*/Matrix () const;
   } bsInvBindMatrix;
   struct object_Prop
   {
      constexpr object_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Object operator= (/*0H*/Object & v);
      /*regSet*/inline SkinBone::object_Prop & operator= (SkinBone::object_Prop & prop);
      /*regGet*/inline operator /*0I*/Object () const;
   } object;
   struct min_Prop
   {
      constexpr min_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3Df operator= (/*0H*/Vector3Df v);
      /*regSet*/inline SkinBone::min_Prop & operator= (SkinBone::min_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } min;
   struct max_Prop
   {
      constexpr max_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3Df operator= (/*0H*/Vector3Df v);
      /*regSet*/inline SkinBone::max_Prop & operator= (SkinBone::max_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } max;
   struct origTransform_Prop
   {
      constexpr origTransform_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Transform operator= (/*0H*/Transform v);
      /*regSet*/inline SkinBone::origTransform_Prop & operator= (SkinBone::origTransform_Prop & prop);
      /*regGet*/inline operator /*0I*/Transform () const;
   } origTransform;
};

struct SkinVert : public TStruct<SkinVert>
{
public:
   C(SkinVert) impl;
   constexpr SkinVert() : impl({}) { }
   constexpr SkinVert(const C(SkinVert) impl) : impl(impl) { }
};

struct Transform : public TStruct<Transform>
{
public:
   C(Transform) impl;
   constexpr Transform() : impl({}) { }
   constexpr Transform(const C(Transform) impl) : impl(impl) { }
   inline operator Matrix() const;
   inline Transform(const Matrix & m);
   inline Transform & operator =(const Matrix & m);

   inline void getMatrix3x4f(/*1Ab*/float m[12]); // Transform_getMatrix3x4f

   inline Transform(Vector3D position, Quaternion orientation, Vector3Df scaling);

   struct position_Prop
   {
      constexpr position_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3D operator= (/*0H*/Vector3D v);
      /*regSet*/inline Transform::position_Prop & operator= (Transform::position_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3D () const;
   } position;
   struct orientation_Prop
   {
      constexpr orientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Quaternion operator= (/*0H*/Quaternion v);
      /*regSet*/inline Transform::orientation_Prop & operator= (Transform::orientation_Prop & prop);
      /*regGet*/inline operator /*0I*/Quaternion () const;
   } orientation;
   struct scaling_Prop
   {
      constexpr scaling_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Vector3Df operator= (/*0H*/Vector3Df v);
      /*regSet*/inline Transform::scaling_Prop & operator= (Transform::scaling_Prop & prop);
      /*regGet*/inline operator /*0I*/Vector3Df () const;
   } scaling;
};

struct Vector3D : public TStruct<Vector3D>
{
public:
   C(Vector3D) impl;
   constexpr Vector3D() : impl({}) { }
   constexpr Vector3D(const C(Vector3D) impl) : impl(impl) { }

   inline void add(/*1Ab*/const Vector3D & vector1, /*1Ab*/const Vector3D & vector2); // Vector3D_add
   inline void add(/*1Ac*/const Vector3D * vector1, /*1Ac*/const Vector3D * vector2); // Vector3D_add
   inline void crossProduct(/*1Ab*/const Vector3D & vector1, /*1Ab*/const Vector3D & vector2); // Vector3D_crossProduct
   inline void crossProduct(/*1Ac*/const Vector3D * vector1, /*1Ac*/const Vector3D * vector2); // Vector3D_crossProduct
   inline void divideMatrix(/*1Ab*/const Vector3D & v, /*1Ab*/const Matrix & m); // Vector3D_divideMatrix
   inline void divideMatrix(/*1Ac*/const Vector3D * v, /*1Ac*/const Matrix * m); // Vector3D_divideMatrix
   inline double dotProduct(/*1Ab*/const Vector3D & vector2); // Vector3D_dotProduct
   inline double dotProduct(/*1Ac*/const Vector3D * vector2); // Vector3D_dotProduct
   inline double dotProductf(/*1Ab*/const Vector3Df & vector2); // Vector3D_dotProductf
   inline double dotProductf(/*1Ac*/const Vector3Df * vector2); // Vector3D_dotProductf
   inline void multMatrix(/*1Ab*/const Vector3D & source, /*1Ab*/const Matrix & matrix); // Vector3D_multMatrix
   inline void multMatrix(/*1Ac*/const Vector3D * source, /*1Ac*/const Matrix * matrix); // Vector3D_multMatrix
   inline void multMatrixf(/*1Ab*/const Vector3Df & source, /*1Ab*/const Matrix & matrix); // Vector3D_multMatrixf
   inline void multMatrixf(/*1Ac*/const Vector3Df * source, /*1Ac*/const Matrix * matrix); // Vector3D_multMatrixf
   inline void multQuaternion(/*1Ab*/const Vector3D & s, /*1Ab*/const Quaternion & quat); // Vector3D_multQuaternion
   inline void multQuaternion(/*1Ac*/const Vector3D * s, /*1Ac*/const Quaternion * quat); // Vector3D_multQuaternion
   inline void normalize(/*1Ab*/const Vector3D & source); // Vector3D_normalize
   inline void normalize(/*1Ac*/const Vector3D * source); // Vector3D_normalize
   inline void scale(/*1Ab*/const Vector3D & vector1, /*1Ab*/double s); // Vector3D_scale
   inline void scale(/*1Ac*/const Vector3D * vector1, /*1Ac*/double s); // Vector3D_scale
   inline void subtract(/*1Ab*/const Vector3D & vector1, /*1Ab*/const Vector3D & vector2); // Vector3D_subtract
   inline void subtract(/*1Ac*/const Vector3D * vector1, /*1Ac*/const Vector3D * vector2); // Vector3D_subtract

   inline Vector3D(double x, double y, double z);

   struct length_Prop
   {
      constexpr length_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/double () const;
   } length;
   struct lengthApprox_Prop
   {
      constexpr lengthApprox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/double () const;
   } lengthApprox;

   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Vector3D::x_Prop & operator= (Vector3D::x_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Vector3D::y_Prop & operator= (Vector3D::y_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } y;
   struct z_Prop
   {
      constexpr z_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Vector3D::z_Prop & operator= (Vector3D::z_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } z;
};

struct Vector3Df : public TStruct<Vector3Df>
{
public:
   C(Vector3Df) impl;
   constexpr Vector3Df() : impl({}) { }
   constexpr Vector3Df(const C(Vector3Df) impl) : impl(impl) { }

   inline void add(/*1Ab*/const Vector3Df & vector1, /*1Ab*/const Vector3Df & vector2); // Vector3Df_add
   inline void add(/*1Ac*/const Vector3Df * vector1, /*1Ac*/const Vector3Df * vector2); // Vector3Df_add
   inline void crossProduct(/*1Ab*/const Vector3Df & vector1, /*1Ab*/const Vector3Df & vector2); // Vector3Df_crossProduct
   inline void crossProduct(/*1Ac*/const Vector3Df * vector1, /*1Ac*/const Vector3Df * vector2); // Vector3Df_crossProduct
   inline void divideMatrix(/*1Ab*/const Vector3Df & source, /*1Ab*/const Matrix & matrix); // Vector3Df_divideMatrix
   inline void divideMatrix(/*1Ac*/const Vector3Df * source, /*1Ac*/const Matrix * matrix); // Vector3Df_divideMatrix
   inline double dotProduct(/*1Ab*/const Vector3Df & vector2); // Vector3Df_dotProduct
   inline double dotProduct(/*1Ac*/const Vector3Df * vector2); // Vector3Df_dotProduct
   inline void multMatrix(/*1Ab*/const Vector3Df & source, /*1Ab*/const Matrix & matrix); // Vector3Df_multMatrix
   inline void multMatrix(/*1Ac*/const Vector3Df * source, /*1Ac*/const Matrix * matrix); // Vector3Df_multMatrix
   inline void multQuaternion(/*1Ab*/const Vector3Df & source, /*1Ab*/const Quaternion & quat); // Vector3Df_multQuaternion
   inline void multQuaternion(/*1Ac*/const Vector3Df * source, /*1Ac*/const Quaternion * quat); // Vector3Df_multQuaternion
   inline void normalize(/*1Ab*/const Vector3Df & source); // Vector3Df_normalize
   inline void normalize(/*1Ac*/const Vector3Df * source); // Vector3Df_normalize
   inline void scale(/*1Ab*/const Vector3Df & vector1, /*1Ab*/float s); // Vector3Df_scale
   inline void scale(/*1Ac*/const Vector3Df * vector1, /*1Ac*/float s); // Vector3Df_scale
   inline void subtract(/*1Ab*/const Vector3Df & vector1, /*1Ab*/const Vector3Df & vector2); // Vector3Df_subtract
   inline void subtract(/*1Ac*/const Vector3Df * vector1, /*1Ac*/const Vector3Df * vector2); // Vector3Df_subtract

   inline Vector3Df(float x, float y, float z);

   struct length_Prop
   {
      constexpr length_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/float () const;
   } length;
   struct lengthApprox_Prop
   {
      constexpr lengthApprox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/float () const;
   } lengthApprox;

   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Vector3Df::x_Prop & operator= (Vector3Df::x_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Vector3Df::y_Prop & operator= (Vector3Df::y_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } y;
   struct z_Prop
   {
      constexpr z_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Vector3Df::z_Prop & operator= (Vector3Df::z_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } z;
};

template <class TC, C(Class) ** TCO>
class TCube : public TObject<TC, TCO>
{
public:
   using TObject<TC, TCO>::TObject;
   inline operator Object& () const { return *(Object *)this; }

   inline C(bool) create(/*1Ab*/const DisplaySystem & displaySystem); // Cube_create

   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Vector3Df operator= (/*0G*/Vector3Df v);
   } size;
   ~TCube()
   {
      this->impl = null; // How to know not to delete?
   }
};

template <class TC, C(Class) ** TCO>
class TSkyBox : public TObject<TC, TCO>
{
public:
   using TObject<TC, TCO>::TObject;
   inline operator Object& () const { return *(Object *)this; }

   inline C(bool) create(/*1Ab*/DisplaySystem & displaySystem); // SkyBox_create
   inline void render(/*1Ab*/Camera & camera, /*1Ab*/Display & display); // SkyBox_render

   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Vector3Df operator= (/*0G*/Vector3Df v);
   } size;
   struct folder_Prop
   {
      constexpr folder_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/const char * operator= (/*0G*/const char * v);
   } folder;
   struct extension_Prop
   {
      constexpr extension_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/const char * operator= (/*0G*/const char * v);
   } extension;
   struct newStyle_Prop
   {
      constexpr newStyle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } newStyle;
   struct cubeMap_Prop
   {
      constexpr cubeMap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const CubeMap & operator= (/*0A*/const CubeMap & v);
      /*nstSet*/inline /*0C*/const CubeMap * operator= (/*0C*/const CubeMap * v);
   } cubeMap;
   ~TSkyBox()
   {
      this->impl = null; // How to know not to delete?
   }
};

template <class TC, C(Class) ** TCO>
class TSphere : public TObject<TC, TCO>
{
public:
   using TObject<TC, TCO>::TObject;
   inline operator Object& () const { return *(Object *)this; }

   inline C(bool) create(/*1Ab*/DisplaySystem & displaySystem); // Sphere_create

   struct numLat_Prop
   {
      constexpr numLat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/int operator= (/*0G*/int v);
   } numLat;
   struct numLon_Prop
   {
      constexpr numLon_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/int operator= (/*0G*/int v);
   } numLon;
   struct flattenedBody_Prop
   {
      constexpr flattenedBody_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/float operator= (/*0G*/float v);
   } flattenedBody;
   ~TSphere()
   {
      this->impl = null; // How to know not to delete?
   }
};

class BorderBits
{
public:
   C(BorderBits) impl;
   constexpr BorderBits() : impl(0) { }

   BorderBits(BorderStyle impl) : impl((C(BorderBits))impl) { }
   BorderBits & operator =(BorderStyle impl) { this->impl = (C(BorderBits))impl; return *this; }

   constexpr BorderBits(C(BorderBits) impl) : impl(impl) { }
   operator C(BorderBits)() { return impl; }
   BorderBits & operator =(C(BorderBits) impl) { impl = impl; return *this; }
   bool operator ==(const BorderBits & value) const { return impl == value.impl; }
   bool operator !=(const BorderBits & value) const { return impl != value.impl; }

   struct contour_Prop
   {
      constexpr contour_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BorderBits::contour_Prop & operator= (BorderBits::contour_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } contour;
   struct fixed_Prop
   {
      constexpr fixed_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BorderBits::fixed_Prop & operator= (BorderBits::fixed_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fixed;
   struct sizable_Prop
   {
      constexpr sizable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BorderBits::sizable_Prop & operator= (BorderBits::sizable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } sizable;
   struct deep_Prop
   {
      constexpr deep_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BorderBits::deep_Prop & operator= (BorderBits::deep_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } deep;
   struct bevel_Prop
   {
      constexpr bevel_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BorderBits::bevel_Prop & operator= (BorderBits::bevel_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bevel;
   struct thin_Prop
   {
      constexpr thin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline BorderBits::thin_Prop & operator= (BorderBits::thin_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } thin;
};

class Key
{
public:
   C(Key) impl;
   constexpr Key() : impl(0) { }

   Key(KeyCode impl) : impl((C(Key))impl) { }
   Key & operator =(KeyCode impl) { this->impl = (C(Key))impl; return *this; }
   Key(PredefinedKey impl) : impl((C(Key))impl) { }
   Key & operator =(PredefinedKey impl) { this->impl = (C(Key))impl; return *this; }

   constexpr Key(C(Key) impl) : impl(impl) { }
   operator C(Key)() { return impl; }
   Key & operator =(C(Key) impl) { impl = impl; return *this; }
   bool operator ==(const Key & value) const { return impl == value.impl; }
   bool operator !=(const Key & value) const { return impl != value.impl; }
   inline constexpr operator SmartKey() const;

   struct code_Prop
   {
      constexpr code_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/KeyCode operator= (/*0H*/KeyCode v);
      /*regSet*/inline Key::code_Prop & operator= (Key::code_Prop & prop);
      /*regGet*/inline operator /*0I*/KeyCode () const;
   } code;
   struct shift_Prop
   {
      constexpr shift_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Key::shift_Prop & operator= (Key::shift_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } shift;
   struct ctrl_Prop
   {
      constexpr ctrl_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Key::ctrl_Prop & operator= (Key::ctrl_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } ctrl;
   struct alt_Prop
   {
      constexpr alt_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Key::alt_Prop & operator= (Key::alt_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alt;
   struct cmd_Prop
   {
      constexpr cmd_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Key::cmd_Prop & operator= (Key::cmd_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } cmd;
   struct modifiers_Prop
   {
      constexpr modifiers_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Modifiers operator= (/*0H*/Modifiers v);
      /*regSet*/inline Key::modifiers_Prop & operator= (Key::modifiers_Prop & prop);
      /*regGet*/inline operator /*0I*/Modifiers () const;
   } modifiers;
};

#define REG_Window_getDecorationsSize(m, c)       REGVMETHOD(Window, getDecorationsSize,       c::m, (/*1Ab*/Window & self, /*1Ab*/MinMaxValue * w, /*1Ab*/MinMaxValue * h),                                                                                                                       c, (/*4Hm*/(MinMaxValue *)w, /*4Hm*/(MinMaxValue *)h))
#define REG_Window_isInside(m, c)                 REGVMETHOD(Window, isInside,                 c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y),                                                                                                                                           c, (/*4Im*/x, /*4Im*/y))
#define REG_Window_isMouseMoving(m, c)            REGVMETHOD(Window, isMouseMoving,            c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h),                                                                                                               c, (/*4Im*/x, /*4Im*/y, /*4Im*/w, /*4Im*/h))
#define REG_Window_isMouseResizing(m, c)          REGVMETHOD(Window, isMouseResizing,          c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/C(bool) * resizeX, /*1Ab*/C(bool) * resizeY, /*1Ab*/C(bool) * resizeEndX, /*1Ab*/C(bool) * resizeEndY), c, (/*4Im*/x, /*4Im*/y, /*4Im*/w, /*4Im*/h, /*4Hm*/(C(bool) *)resizeX, /*4Hm*/(C(bool) *)resizeY, /*4Hm*/(C(bool) *)resizeEndX, /*4Hm*/(C(bool) *)resizeEndY))
#define REG_Window_isOpaque(m, c)                 REGVMETHOD(Window, isOpaque,                 c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_notifyActivate(m, c)           REGVMETHOD(Window, notifyActivate,           c::m, (/*1Ab*/Window & self, /*1Ab*/Window & window, /*1Ab*/bool active, /*1Ab*/Window & previous),                                                                                                 c, (/*4Im*/self, /*4Im*/window, /*4Hm*/(bool)active, /*4Im*/previous))
#define REG_Window_notifyDestroyed(m, c)          REGVMETHOD(Window, notifyDestroyed,          c::m, (/*1Ab*/Window & self, /*1Ab*/Window & window, /*1Ab*/DialogResult result),                                                                                                                   c, (/*4Im*/self, /*4Im*/window, /*4Hm*/(DialogResult)result))
#define REG_Window_notifySaved(m, c)              REGVMETHOD(Window, notifySaved,              c::m, (/*1Ab*/Window & self, /*1Ab*/Window & window, /*1Ab*/const char * filePath),                                                                                                                 c, (/*4Im*/self, /*4Im*/window, /*4Im*/filePath))
#define REG_Window_onActivate(m, c)               REGVMETHOD(Window, onActivate,               c::m, (/*1Ab*/Window & self, /*1Ab*/bool active, /*1Ab*/Window & previous, /*1Ab*/C(bool) * goOnWithActivation, /*1Ab*/bool direct),                                                                c, (/*4Hm*/(bool)active, /*4Im*/previous, /*4Hm*/(C(bool) *)goOnWithActivation, /*4Hm*/(bool)direct))
#define REG_Window_onActivateClient(m, c)         REGVMETHOD(Window, onActivateClient,         c::m, (/*1Ab*/Window & self, /*1Ab*/Window & client, /*1Ab*/Window & previous),                                                                                                                     c, (/*4Im*/client, /*4Im*/previous))
#define REG_Window_onApplyGraphics(m, c)          REGVMETHOD(Window, onApplyGraphics,          c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onChildAddedOrRemoved(m, c)    REGVMETHOD(Window, onChildAddedOrRemoved,    c::m, (/*1Ab*/Window & self, /*1Ab*/Window & child, /*1Ab*/bool removed),                                                                                                                           c, (/*4Im*/child, /*4Hm*/(bool)removed))
#define REG_Window_onChildResized(m, c)           REGVMETHOD(Window, onChildResized,           c::m, (/*1Ab*/Window & self, /*1Ab*/Window & child, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h),                                                                                        c, (/*4Im*/child, /*4Im*/x, /*4Im*/y, /*4Im*/w, /*4Im*/h))
#define REG_Window_onChildVisibilityToggled(m, c) REGVMETHOD(Window, onChildVisibilityToggled, c::m, (/*1Ab*/Window & self, /*1Ab*/Window & child, /*1Ab*/bool visible),                                                                                                                           c, (/*4Im*/child, /*4Hm*/(bool)visible))
#define REG_Window_onClose(m, c)                  REGVMETHOD(Window, onClose,                  c::m, (/*1Ab*/Window & self, /*1Ab*/bool parentClosing),                                                                                                                                            c, (/*4Hm*/(bool)parentClosing))
#define REG_Window_onCreate(m, c)                 REGVMETHOD(Window, onCreate,                 c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onDestroy(m, c)                REGVMETHOD(Window, onDestroy,                c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onDestroyed(m, c)              REGVMETHOD(Window, onDestroyed,              c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onDrawOverChildren(m, c)       REGVMETHOD(Window, onDrawOverChildren,       c::m, (/*1Ab*/Window & self, /*1Ab*/Surface & surface),                                                                                                                                             c, (/*4Im*/surface))
#define REG_Window_onFileModified(m, c)           REGVMETHOD(Window, onFileModified,           c::m, (/*1Ab*/Window & self, /*1Ab*/FileChange fileChange, /*1Ab*/const char * param),                                                                                                              c, (/*4Hm*/(FileChange)fileChange, /*4Im*/param))
#define REG_Window_onHScroll(m, c)                REGVMETHOD(Window, onHScroll,                c::m, (/*1Ab*/Window & self, /*1Ab*/ScrollBarAction action, /*1Ab*/int position, /*1Ab*/Key key),                                                                                                   c, (/*4Hm*/(ScrollBarAction)action, /*4Im*/position, /*4Hm*/(Key)key))
#define REG_Window_onKeyDown(m, c)                REGVMETHOD(Window, onKeyDown,                c::m, (/*1Ab*/Window & self, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                                                                    c, (/*4Hm*/(Key)key, /*4Im*/ch))
#define REG_Window_onKeyHit(m, c)                 REGVMETHOD(Window, onKeyHit,                 c::m, (/*1Ab*/Window & self, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                                                                    c, (/*4Hm*/(Key)key, /*4Im*/ch))
#define REG_Window_onKeyUp(m, c)                  REGVMETHOD(Window, onKeyUp,                  c::m, (/*1Ab*/Window & self, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                                                                    c, (/*4Hm*/(Key)key, /*4Im*/ch))
#define REG_Window_onLeftButtonDown(m, c)         REGVMETHOD(Window, onLeftButtonDown,         c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onLeftButtonUp(m, c)           REGVMETHOD(Window, onLeftButtonUp,           c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onLeftDoubleClick(m, c)        REGVMETHOD(Window, onLeftDoubleClick,        c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onLoadGraphics(m, c)           REGVMETHOD(Window, onLoadGraphics,           c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onMiddleButtonDown(m, c)       REGVMETHOD(Window, onMiddleButtonDown,       c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onMiddleButtonUp(m, c)         REGVMETHOD(Window, onMiddleButtonUp,         c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onMiddleDoubleClick(m, c)      REGVMETHOD(Window, onMiddleDoubleClick,      c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onMouseCaptureLost(m, c)       REGVMETHOD(Window, onMouseCaptureLost,       c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onMouseLeave(m, c)             REGVMETHOD(Window, onMouseLeave,             c::m, (/*1Ab*/Window & self, /*1Ab*/Modifiers mods),                                                                                                                                                c, (/*4Hm*/(Modifiers)mods))
#define REG_Window_onMouseMove(m, c)              REGVMETHOD(Window, onMouseMove,              c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onMouseOver(m, c)              REGVMETHOD(Window, onMouseOver,              c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onMoving(m, c)                 REGVMETHOD(Window, onMoving,                 c::m, (/*1Ab*/Window & self, /*1Ab*/int * x, /*1Ab*/int * y, /*1Ab*/int w, /*1Ab*/int h),                                                                                                           c, (/*4Im*/x, /*4Im*/y, /*4Im*/w, /*4Im*/h))
#define REG_Window_onMultiTouch(m, c)             REGVMETHOD(Window, onMultiTouch,             c::m, (/*1Ab*/Window & self, /*1Ab*/TouchPointerEvent event, /*1Ab*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Ab*/Modifiers mods),                                        c, (/*4Hm*/(TouchPointerEvent)event, /*4Im*/infos, /*4Hm*/(Modifiers)mods))
#define REG_Window_onPosition(m, c)               REGVMETHOD(Window, onPosition,               c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int width, /*1Ab*/int height),                                                                                                      c, (/*4Im*/x, /*4Im*/y, /*4Im*/width, /*4Im*/height))
#define REG_Window_onPostCreate(m, c)             REGVMETHOD(Window, onPostCreate,             c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onRedraw(m, c)                 REGVMETHOD(Window, onRedraw,                 c::m, (/*1Ab*/Window & self, /*1Ab*/Surface & surface),                                                                                                                                             c, (/*4Im*/surface))
#define REG_Window_onResize(m, c)                 REGVMETHOD(Window, onResize,                 c::m, (/*1Ab*/Window & self, /*1Ab*/int width, /*1Ab*/int height),                                                                                                                                  c, (/*4Im*/width, /*4Im*/height))
#define REG_Window_onResizing(m, c)               REGVMETHOD(Window, onResizing,               c::m, (/*1Ab*/Window & self, /*1Ab*/int * width, /*1Ab*/int * height),                                                                                                                              c, (/*4Im*/width, /*4Im*/height))
#define REG_Window_onRightButtonDown(m, c)        REGVMETHOD(Window, onRightButtonDown,        c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onRightButtonUp(m, c)          REGVMETHOD(Window, onRightButtonUp,          c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onRightDoubleClick(m, c)       REGVMETHOD(Window, onRightDoubleClick,       c::m, (/*1Ab*/Window & self, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                                                                    c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Window_onSaveFile(m, c)               REGVMETHOD(Window, onSaveFile,               c::m, (/*1Ab*/Window & self, /*1Ab*/const char * fileName),                                                                                                                                         c, (/*4Im*/fileName))
#define REG_Window_onStateChange(m, c)            REGVMETHOD(Window, onStateChange,            c::m, (/*1Ab*/Window & self, /*1Ab*/WindowState state, /*1Ab*/Modifiers mods),                                                                                                                      c, (/*4Hm*/(WindowState)state, /*4Hm*/(Modifiers)mods))
#define REG_Window_onSysKeyDown(m, c)             REGVMETHOD(Window, onSysKeyDown,             c::m, (/*1Ab*/Window & self, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                                                                    c, (/*4Hm*/(Key)key, /*4Im*/ch))
#define REG_Window_onSysKeyHit(m, c)              REGVMETHOD(Window, onSysKeyHit,              c::m, (/*1Ab*/Window & self, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                                                                    c, (/*4Hm*/(Key)key, /*4Im*/ch))
#define REG_Window_onSysKeyUp(m, c)               REGVMETHOD(Window, onSysKeyUp,               c::m, (/*1Ab*/Window & self, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                                                                    c, (/*4Hm*/(Key)key, /*4Im*/ch))
#define REG_Window_onUnloadGraphics(m, c)         REGVMETHOD(Window, onUnloadGraphics,         c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())
#define REG_Window_onVScroll(m, c)                REGVMETHOD(Window, onVScroll,                c::m, (/*1Ab*/Window & self, /*1Ab*/ScrollBarAction action, /*1Ab*/int position, /*1Ab*/Key key),                                                                                                   c, (/*4Hm*/(ScrollBarAction)action, /*4Im*/position, /*4Hm*/(Key)key))
#define REG_Window_preShowDecorations(m, c)       REGVMETHOD(Window, preShowDecorations,       c::m, (/*1Ab*/Window & self, /*1Ab*/Font captionFont, /*1Ab*/Surface & surface, /*1Ab*/const char * name, /*1Ab*/bool active, /*1Ab*/bool moving),                                                  c, (/*4Im*/captionFont, /*4Im*/surface, /*4Im*/name, /*4Hm*/(bool)active, /*4Hm*/(bool)moving))
#define REG_Window_setBox(m, c)                   REGVMETHOD(Window, setBox,                   c::m, (/*1Ab*/Window & self, /*1Ab*/Box & box),                                                                                                                                                     c, (/*4Im*/box))
#define REG_Window_setWindowArea(m, c)            REGVMETHOD(Window, setWindowArea,            c::m, (/*1Ab*/Window & self, /*1Ab*/int * x, /*1Ab*/int * y, /*1Ab*/MinMaxValue * w, /*1Ab*/MinMaxValue * h, /*1Ab*/MinMaxValue * cw, /*1Ab*/MinMaxValue * ch),                                     c, (/*4Im*/x, /*4Im*/y, /*4Hm*/(MinMaxValue *)w, /*4Hm*/(MinMaxValue *)h, /*4Hm*/(MinMaxValue *)cw, /*4Hm*/(MinMaxValue *)ch))
#define REG_Window_setWindowMinimum(m, c)         REGVMETHOD(Window, setWindowMinimum,         c::m, (/*1Ab*/Window & self, /*1Ab*/MinMaxValue * mw, /*1Ab*/MinMaxValue * mh),                                                                                                                     c, (/*4Hm*/(MinMaxValue *)mw, /*4Hm*/(MinMaxValue *)mh))
#define REG_Window_showDecorations(m, c)          REGVMETHOD(Window, showDecorations,          c::m, (/*1Ab*/Window & self, /*1Ab*/Font captionFont, /*1Ab*/Surface & surface, /*1Ab*/const char * name, /*1Ab*/bool active, /*1Ab*/bool moving),                                                  c, (/*4Im*/captionFont, /*4Im*/surface, /*4Im*/name, /*4Hm*/(bool)active, /*4Hm*/(bool)moving))
#define REG_Window_updateNonClient(m, c)          REGVMETHOD(Window, updateNonClient,          c::m, (/*1Ab*/Window & self),                                                                                                                                                                       c, ())

#define REG_Window(c) \
      Window::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define WINDOW_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(getDecorationsSize, getDecorationsSize, c, Window, \
      void, c & _ARG, , /*6Fj*/MinMaxValue * w _ARG /*6Fj*/MinMaxValue * h); \
   VIRTUAL_METHOD_PROTO(isInside, isInside, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y); \
   VIRTUAL_METHOD_PROTO(isMouseMoving, isMouseMoving, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h); \
   VIRTUAL_METHOD_PROTO(isMouseResizing, isMouseResizing, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Cj*/C(bool) * resizeX _ARG /*6Cj*/C(bool) * resizeY _ARG /*6Cj*/C(bool) * resizeEndX _ARG /*6Cj*/C(bool) * resizeEndY); \
   VIRTUAL_METHOD_PROTO(isOpaque, isOpaque, c, Window, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(notifyActivate, notifyActivate, c, Window, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Window & window _ARG /*6Fj*/bool active _ARG /*6Fj*/Window & previous); \
   VIRTUAL_METHOD_PROTO(notifyDestroyed, notifyDestroyed, c, Window, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Window & window _ARG /*6Fj*/DialogResult result); \
   VIRTUAL_METHOD_PROTO(notifySaved, notifySaved, c, Window, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Window & window _ARG /*6Fj*/const char * filePath); \
   VIRTUAL_METHOD_PROTO(onActivate, onActivate, c, Window, \
      bool, c & _ARG, , /*6Fj*/bool active _ARG /*6Fj*/Window & previous _ARG /*6Cj*/C(bool) * goOnWithActivation _ARG /*6Fj*/bool direct); \
   VIRTUAL_METHOD_PROTO(onActivateClient, onActivateClient, c, Window, \
      void, c & _ARG, , /*6Fj*/Window & client _ARG /*6Fj*/Window & previous); \
   VIRTUAL_METHOD_PROTO(onApplyGraphics, onApplyGraphics, c, Window, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(onChildAddedOrRemoved, onChildAddedOrRemoved, c, Window, \
      void, c & _ARG, , /*6Fj*/Window & child _ARG /*6Fj*/bool removed); \
   VIRTUAL_METHOD_PROTO(onChildResized, onChildResized, c, Window, \
      void, c & _ARG, , /*6Fj*/Window & child _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h); \
   VIRTUAL_METHOD_PROTO(onChildVisibilityToggled, onChildVisibilityToggled, c, Window, \
      void, c & _ARG, , /*6Fj*/Window & child _ARG /*6Fj*/bool visible); \
   VIRTUAL_METHOD_PROTO(onClose, onClose, c, Window, \
      bool, c & _ARG, , /*6Fj*/bool parentClosing); \
   VIRTUAL_METHOD_PROTO(onCreate, onCreate, c, Window, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(onDestroy, onDestroy, c, Window, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(onDestroyed, onDestroyed, c, Window, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(onDrawOverChildren, onDrawOverChildren, c, Window, \
      void, c & _ARG, , /*6Fj*/Surface & surface); \
   VIRTUAL_METHOD_PROTO(onFileModified, onFileModified, c, Window, \
      bool, c & _ARG, , /*6Fj*/FileChange fileChange _ARG /*6Fj*/const char * param); \
   VIRTUAL_METHOD_PROTO(onHScroll, onHScroll, c, Window, \
      void, c & _ARG, , /*6Fj*/ScrollBarAction action _ARG /*6Fj*/int position _ARG /*6Fj*/Key key); \
   VIRTUAL_METHOD_PROTO(onKeyDown, onKeyDown, c, Window, \
      bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(onKeyHit, onKeyHit, c, Window, \
      bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(onKeyUp, onKeyUp, c, Window, \
      bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(onLeftButtonDown, onLeftButtonDown, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onLeftButtonUp, onLeftButtonUp, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onLeftDoubleClick, onLeftDoubleClick, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onLoadGraphics, onLoadGraphics, c, Window, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(onMiddleButtonDown, onMiddleButtonDown, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onMiddleButtonUp, onMiddleButtonUp, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onMiddleDoubleClick, onMiddleDoubleClick, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onMouseCaptureLost, onMouseCaptureLost, c, Window, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(onMouseLeave, onMouseLeave, c, Window, \
      bool, c & _ARG, , /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onMouseMove, onMouseMove, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onMouseOver, onMouseOver, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onMoving, onMoving, c, Window, \
      bool, c & _ARG, , /*6Fj*/int * x _ARG /*6Fj*/int * y _ARG /*6Fj*/int w _ARG /*6Fj*/int h); \
   VIRTUAL_METHOD_PROTO(onMultiTouch, onMultiTouch, c, Window, \
      bool, c & _ARG, , /*6Fj*/TouchPointerEvent event _ARG /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onPosition, onPosition, c, Window, \
      void, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int width _ARG /*6Fj*/int height); \
   VIRTUAL_METHOD_PROTO(onPostCreate, onPostCreate, c, Window, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(onRedraw, onRedraw, c, Window, \
      void, c & _ARG, , /*6Fj*/Surface & surface); \
   VIRTUAL_METHOD_PROTO(onResize, onResize, c, Window, \
      void, c & _ARG, , /*6Fj*/int width _ARG /*6Fj*/int height); \
   VIRTUAL_METHOD_PROTO(onResizing, onResizing, c, Window, \
      bool, c & _ARG, , /*6Fj*/int * width _ARG /*6Fj*/int * height); \
   VIRTUAL_METHOD_PROTO(onRightButtonDown, onRightButtonDown, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onRightButtonUp, onRightButtonUp, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onRightDoubleClick, onRightDoubleClick, c, Window, \
      bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onSaveFile, onSaveFile, c, Window, \
      bool, c & _ARG, , /*6Fj*/const char * fileName); \
   VIRTUAL_METHOD_PROTO(onStateChange, onStateChange, c, Window, \
      bool, c & _ARG, , /*6Fj*/WindowState state _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(onSysKeyDown, onSysKeyDown, c, Window, \
      bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(onSysKeyHit, onSysKeyHit, c, Window, \
      bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(onSysKeyUp, onSysKeyUp, c, Window, \
      bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(onUnloadGraphics, onUnloadGraphics, c, Window, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(onVScroll, onVScroll, c, Window, \
      void, c & _ARG, , /*6Fj*/ScrollBarAction action _ARG /*6Fj*/int position _ARG /*6Fj*/Key key); \
   VIRTUAL_METHOD_PROTO(preShowDecorations, preShowDecorations, c, Window, \
      void, c & _ARG, , /*6Fj*/Font captionFont _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/const char * name _ARG /*6Fj*/bool active _ARG /*6Fj*/bool moving); \
   VIRTUAL_METHOD_PROTO(setBox, setBox, c, Window, \
      void, c & _ARG, , /*6Fj*/Box & box); \
   VIRTUAL_METHOD_PROTO(setWindowArea, setWindowArea, c, Window, \
      void, c & _ARG, , /*6Fj*/int * x _ARG /*6Fj*/int * y _ARG /*6Fj*/MinMaxValue * w _ARG /*6Fj*/MinMaxValue * h _ARG /*6Fj*/MinMaxValue * cw _ARG /*6Fj*/MinMaxValue * ch); \
   VIRTUAL_METHOD_PROTO(setWindowMinimum, setWindowMinimum, c, Window, \
      void, c & _ARG, , /*6Fj*/MinMaxValue * mw _ARG /*6Fj*/MinMaxValue * mh); \
   VIRTUAL_METHOD_PROTO(showDecorations, showDecorations, c, Window, \
      void, c & _ARG, , /*6Fj*/Font captionFont _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/const char * name _ARG /*6Fj*/bool active _ARG /*6Fj*/bool moving); \
   VIRTUAL_METHOD_PROTO(updateNonClient, updateNonClient, c, Window, \
      void, c &, , );

#define WINDOW_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(getDecorationsSize, getDecorationsSize, c, Window, \
   void, c & _ARG, , /*6Fj*/MinMaxValue * w _ARG /*6Fj*/MinMaxValue * h, \
   Window_getDecorationsSize(self ? self->impl : (C(Window))null, /*7Al*/&w->impl, /*7Al*/&h->impl);); \
VIRTUAL_METHOD(isInside, isInside, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y, \
   return (bool)Window_isInside(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(isMouseMoving, isMouseMoving, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h, \
   return (bool)Window_isMouseMoving(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h);); \
VIRTUAL_METHOD(isMouseResizing, isMouseResizing, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Cj*/C(bool) * resizeX _ARG /*6Cj*/C(bool) * resizeY _ARG /*6Cj*/C(bool) * resizeEndX _ARG /*6Cj*/C(bool) * resizeEndY, \
   return (bool)Window_isMouseResizing(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h, /*7Al*/resizeX, /*7Al*/resizeY, /*7Al*/resizeEndX, /*7Al*/resizeEndY);); \
VIRTUAL_METHOD(isOpaque, isOpaque, c, Window, \
   bool, c &, , , \
   return (bool)Window_isOpaque(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(notifyActivate, notifyActivate, c, Window, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Window & window _ARG /*6Fj*/bool active _ARG /*6Fj*/Window & previous, \
   return (bool)Window_notifyActivate(self ? self->impl : (C(Window))null, o_.impl, /*7Al*/window.impl, /*7Al*/(C(bool))active, /*7Al*/previous.impl);); \
VIRTUAL_METHOD(notifyDestroyed, notifyDestroyed, c, Window, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Window & window _ARG /*6Fj*/DialogResult result, \
   Window_notifyDestroyed(self ? self->impl : (C(Window))null, self ? self->impl : (C(Window))null, /*7Al*/window.impl, /*7Al*/(C(DialogResult))result);); \
VIRTUAL_METHOD(notifySaved, notifySaved, c, Window, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Window & window _ARG /*6Fj*/const char * filePath, \
   Window_notifySaved(self ? self->impl : (C(Window))null, self ? self->impl : (C(Window))null, /*7Al*/window.impl, /*7Al*/filePath);); \
VIRTUAL_METHOD(onActivate, onActivate, c, Window, \
   bool, c & _ARG, , /*6Fj*/bool active _ARG /*6Fj*/Window & previous _ARG /*6Cj*/C(bool) * goOnWithActivation _ARG /*6Fj*/bool direct, \
   return (bool)Window_onActivate(self ? self->impl : (C(Window))null, /*7Al*/(C(bool))active, /*7Al*/previous.impl, /*7Al*/goOnWithActivation, /*7Al*/(C(bool))direct);); \
VIRTUAL_METHOD(onActivateClient, onActivateClient, c, Window, \
   void, c & _ARG, , /*6Fj*/Window & client _ARG /*6Fj*/Window & previous, \
   Window_onActivateClient(self ? self->impl : (C(Window))null, /*7Al*/client.impl, /*7Al*/previous.impl);); \
VIRTUAL_METHOD(onApplyGraphics, onApplyGraphics, c, Window, \
   void, c &, , , \
   Window_onApplyGraphics(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onChildAddedOrRemoved, onChildAddedOrRemoved, c, Window, \
   void, c & _ARG, , /*6Fj*/Window & child _ARG /*6Fj*/bool removed, \
   Window_onChildAddedOrRemoved(self ? self->impl : (C(Window))null, /*7Al*/child.impl, /*7Al*/(C(bool))removed);); \
VIRTUAL_METHOD(onChildResized, onChildResized, c, Window, \
   void, c & _ARG, , /*6Fj*/Window & child _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h, \
   Window_onChildResized(self ? self->impl : (C(Window))null, /*7Al*/child.impl, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h);); \
VIRTUAL_METHOD(onChildVisibilityToggled, onChildVisibilityToggled, c, Window, \
   void, c & _ARG, , /*6Fj*/Window & child _ARG /*6Fj*/bool visible, \
   Window_onChildVisibilityToggled(self ? self->impl : (C(Window))null, /*7Al*/child.impl, /*7Al*/(C(bool))visible);); \
VIRTUAL_METHOD(onClose, onClose, c, Window, \
   bool, c & _ARG, , /*6Fj*/bool parentClosing, \
   return (bool)Window_onClose(self ? self->impl : (C(Window))null, /*7Al*/(C(bool))parentClosing);); \
VIRTUAL_METHOD(onCreate, onCreate, c, Window, \
   bool, c &, , , \
   return (bool)Window_onCreate(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onDestroy, onDestroy, c, Window, \
   void, c &, , , \
   Window_onDestroy(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onDestroyed, onDestroyed, c, Window, \
   void, c &, , , \
   Window_onDestroyed(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onDrawOverChildren, onDrawOverChildren, c, Window, \
   void, c & _ARG, , /*6Fj*/Surface & surface, \
   Window_onDrawOverChildren(self ? self->impl : (C(Window))null, /*7Al*/surface.impl);); \
VIRTUAL_METHOD(onFileModified, onFileModified, c, Window, \
   bool, c & _ARG, , /*6Fj*/FileChange fileChange _ARG /*6Fj*/const char * param, \
   return (bool)Window_onFileModified(self ? self->impl : (C(Window))null, /*7Al*/(C(FileChange))fileChange, /*7Al*/param);); \
VIRTUAL_METHOD(onHScroll, onHScroll, c, Window, \
   void, c & _ARG, , /*6Fj*/ScrollBarAction action _ARG /*6Fj*/int position _ARG /*6Fj*/Key key, \
   Window_onHScroll(self ? self->impl : (C(Window))null, /*7Al*/(C(ScrollBarAction))action, /*7Al*/position, /*7Al*/(C(Key))key);); \
VIRTUAL_METHOD(onKeyDown, onKeyDown, c, Window, \
   bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)Window_onKeyDown(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(onKeyHit, onKeyHit, c, Window, \
   bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)Window_onKeyHit(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(onKeyUp, onKeyUp, c, Window, \
   bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)Window_onKeyUp(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(onLeftButtonDown, onLeftButtonDown, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onLeftButtonDown(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onLeftButtonUp, onLeftButtonUp, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onLeftButtonUp(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onLeftDoubleClick, onLeftDoubleClick, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onLeftDoubleClick(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onLoadGraphics, onLoadGraphics, c, Window, \
   bool, c &, , , \
   return (bool)Window_onLoadGraphics(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onMiddleButtonDown, onMiddleButtonDown, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onMiddleButtonDown(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onMiddleButtonUp, onMiddleButtonUp, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onMiddleButtonUp(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onMiddleDoubleClick, onMiddleDoubleClick, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onMiddleDoubleClick(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onMouseCaptureLost, onMouseCaptureLost, c, Window, \
   void, c &, , , \
   Window_onMouseCaptureLost(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onMouseLeave, onMouseLeave, c, Window, \
   bool, c & _ARG, , /*6Fj*/Modifiers mods, \
   return (bool)Window_onMouseLeave(self ? self->impl : (C(Window))null, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onMouseMove, onMouseMove, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onMouseMove(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onMouseOver, onMouseOver, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onMouseOver(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onMoving, onMoving, c, Window, \
   bool, c & _ARG, , /*6Fj*/int * x _ARG /*6Fj*/int * y _ARG /*6Fj*/int w _ARG /*6Fj*/int h, \
   return (bool)Window_onMoving(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h);); \
VIRTUAL_METHOD(onMultiTouch, onMultiTouch, c, Window, \
   bool, c & _ARG, , /*6Fj*/TouchPointerEvent event _ARG /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onMultiTouch(self ? self->impl : (C(Window))null, /*7Al*/(C(TouchPointerEvent))event, /*7Al*/((Instance&)infos).impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onPosition, onPosition, c, Window, \
   void, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int width _ARG /*6Fj*/int height, \
   Window_onPosition(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/width, /*7Al*/height);); \
VIRTUAL_METHOD(onPostCreate, onPostCreate, c, Window, \
   bool, c &, , , \
   return (bool)Window_onPostCreate(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onRedraw, onRedraw, c, Window, \
   void, c & _ARG, , /*6Fj*/Surface & surface, \
   Window_onRedraw(self ? self->impl : (C(Window))null, /*7Al*/surface.impl);); \
VIRTUAL_METHOD(onResize, onResize, c, Window, \
   void, c & _ARG, , /*6Fj*/int width _ARG /*6Fj*/int height, \
   Window_onResize(self ? self->impl : (C(Window))null, /*7Al*/width, /*7Al*/height);); \
VIRTUAL_METHOD(onResizing, onResizing, c, Window, \
   bool, c & _ARG, , /*6Fj*/int * width _ARG /*6Fj*/int * height, \
   return (bool)Window_onResizing(self ? self->impl : (C(Window))null, /*7Al*/width, /*7Al*/height);); \
VIRTUAL_METHOD(onRightButtonDown, onRightButtonDown, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onRightButtonDown(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onRightButtonUp, onRightButtonUp, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onRightButtonUp(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onRightDoubleClick, onRightDoubleClick, c, Window, \
   bool, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onRightDoubleClick(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onSaveFile, onSaveFile, c, Window, \
   bool, c & _ARG, , /*6Fj*/const char * fileName, \
   return (bool)Window_onSaveFile(self ? self->impl : (C(Window))null, /*7Al*/fileName);); \
VIRTUAL_METHOD(onStateChange, onStateChange, c, Window, \
   bool, c & _ARG, , /*6Fj*/WindowState state _ARG /*6Fj*/Modifiers mods, \
   return (bool)Window_onStateChange(self ? self->impl : (C(Window))null, /*7Al*/(C(WindowState))state, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(onSysKeyDown, onSysKeyDown, c, Window, \
   bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)Window_onSysKeyDown(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(onSysKeyHit, onSysKeyHit, c, Window, \
   bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)Window_onSysKeyHit(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(onSysKeyUp, onSysKeyUp, c, Window, \
   bool, c & _ARG, , /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)Window_onSysKeyUp(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(onUnloadGraphics, onUnloadGraphics, c, Window, \
   void, c &, , , \
   Window_onUnloadGraphics(self ? self->impl : (C(Window))null);); \
VIRTUAL_METHOD(onVScroll, onVScroll, c, Window, \
   void, c & _ARG, , /*6Fj*/ScrollBarAction action _ARG /*6Fj*/int position _ARG /*6Fj*/Key key, \
   Window_onVScroll(self ? self->impl : (C(Window))null, /*7Al*/(C(ScrollBarAction))action, /*7Al*/position, /*7Al*/(C(Key))key);); \
VIRTUAL_METHOD(preShowDecorations, preShowDecorations, c, Window, \
   void, c & _ARG, , /*6Fj*/Font captionFont _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/const char * name _ARG /*6Fj*/bool active _ARG /*6Fj*/bool moving, \
   Window_preShowDecorations(self ? self->impl : (C(Window))null, /*7Al*/captionFont.impl, /*7Al*/surface.impl, /*7Al*/name, /*7Al*/(C(bool))active, /*7Al*/(C(bool))moving);); \
VIRTUAL_METHOD(setBox, setBox, c, Window, \
   void, c & _ARG, , /*6Fj*/Box & box, \
   Window_setBox(self ? self->impl : (C(Window))null, /*7Al*/&box.impl);); \
VIRTUAL_METHOD(setWindowArea, setWindowArea, c, Window, \
   void, c & _ARG, , /*6Fj*/int * x _ARG /*6Fj*/int * y _ARG /*6Fj*/MinMaxValue * w _ARG /*6Fj*/MinMaxValue * h _ARG /*6Fj*/MinMaxValue * cw _ARG /*6Fj*/MinMaxValue * ch, \
   Window_setWindowArea(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/&w->impl, /*7Al*/&h->impl, /*7Al*/&cw->impl, /*7Al*/&ch->impl);); \
VIRTUAL_METHOD(setWindowMinimum, setWindowMinimum, c, Window, \
   void, c & _ARG, , /*6Fj*/MinMaxValue * mw _ARG /*6Fj*/MinMaxValue * mh, \
   Window_setWindowMinimum(self ? self->impl : (C(Window))null, /*7Al*/&mw->impl, /*7Al*/&mh->impl);); \
VIRTUAL_METHOD(showDecorations, showDecorations, c, Window, \
   void, c & _ARG, , /*6Fj*/Font captionFont _ARG /*6Fj*/Surface & surface _ARG /*6Fj*/const char * name _ARG /*6Fj*/bool active _ARG /*6Fj*/bool moving, \
   Window_showDecorations(self ? self->impl : (C(Window))null, /*7Al*/captionFont.impl, /*7Al*/surface.impl, /*7Al*/name, /*7Al*/(C(bool))active, /*7Al*/(C(bool))moving);); \
VIRTUAL_METHOD(updateNonClient, updateNonClient, c, Window, \
   void, c &, , , \
   Window_updateNonClient(self ? self->impl : (C(Window))null););

class Window : public Instance
{
public:
   inline Window(Window && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Window & operator= (Window && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Window() : Window((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Window> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Window * inst = new Window(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Window * inst = (Window *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Window & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Window(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) acquireInput(/*1Ab*/bool acquired); // Window_acquireInput
   inline void activate(); // Window_activate
   inline void addResource(/*1Ab*/Resource & resource); // Window_addResource
   inline C(bool) buttonCloseDialog(/*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods); // Window_buttonCloseDialog
   inline C(bool) capture(); // Window_capture
   inline C(bool) closeConfirmation(/*1Ab*/bool parentClosing); // Window_closeConfirmation
   inline C(bool) create(); // Window_create
   inline C(bool) cycleChildren(/*1Ab*/bool backward, /*1Ab*/bool clientOnly, /*1Ab*/bool tabCycleOnly, /*1Ab*/bool cycleParents); // Window_cycleChildren
   inline void deactivate(); // Window_deactivate
   inline C(bool) destroy(/*1Ab*/int64 code); // Window_destroy
   inline C(DialogResult) doModal(); // Window_doModal
   inline C(DialogResult) doModalEnd(); // Window_doModalEnd
   inline C(bool) doModalLoop(); // Window_doModalLoop
   inline void doModalStart(); // Window_doModalStart
   inline void externalPosition(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h); // Window_externalPosition
   inline void flash(); // Window_flash
   static inline void freeMouseRange(); // Window_freeMouseRange
   inline void getCaretPosition(/*1Ab*/Point & caretPos); // Window_getCaretPosition
   inline void getCaretPosition(/*1Ac*/Point * caretPos); // Window_getCaretPosition
   inline int getCaretSize(); // Window_getCaretSize
   inline BitmapResource getIcon(/*1Ab*/SkinBitmap iconID); // Window_getIcon
   inline void getMousePosition(/*1Ab*/int * x, /*1Ab*/int * y); // Window_getMousePosition
   inline void getNCMousePosition(/*1Ab*/int * x, /*1Ab*/int * y); // Window_getNCMousePosition
   inline C(bool) grab(/*1Ab*/Bitmap & bitmap, /*1Ab*/Box & box, /*1Ab*/bool decorations); // Window_grab
   inline C(bool) grab(/*1Ac*/Bitmap & bitmap, /*1Ac*/Box * box, /*1Ac*/bool decorations); // Window_grab
   inline void makeActive(); // Window_makeActive
   inline C(bool) menuFileClose(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuFileClose
   inline C(bool) menuFileExit(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuFileExit
   inline C(bool) menuFileSave(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuFileSave
   inline C(bool) menuFileSaveAll(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuFileSaveAll
   inline C(bool) menuFileSaveAs(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuFileSaveAs
   inline C(bool) menuWindowArrangeIcons(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowArrangeIcons
   inline C(bool) menuWindowCascade(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowCascade
   inline C(bool) menuWindowClose(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowClose
   inline C(bool) menuWindowCloseAll(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowCloseAll
   inline C(bool) menuWindowMaximize(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowMaximize
   inline C(bool) menuWindowMinimize(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowMinimize
   inline C(bool) menuWindowMove(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowMove
   inline C(bool) menuWindowNext(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowNext
   inline C(bool) menuWindowPrevious(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowPrevious
   inline C(bool) menuWindowRestore(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowRestore
   inline C(bool) menuWindowSelectWindow(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowSelectWindow
   inline C(bool) menuWindowSize(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowSize
   inline C(bool) menuWindowStayOnTop(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowStayOnTop
   inline C(bool) menuWindowTileHorz(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowTileHorz
   inline C(bool) menuWindowTileVert(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowTileVert
   inline C(bool) menuWindowWindows(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods); // Window_menuWindowWindows
   inline C(DialogResult) modal(); // Window_modal
   inline C(bool) mouseMessage(/*1Ab*/uint method, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers * mods, /*1Ab*/bool consequential, /*1Ab*/bool activate); // Window_mouseMessage
   inline void move(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h); // Window_move
   inline C(bool) multiTouchMessage(/*1Ab*/TouchPointerEvent event, /*1Ab*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Ab*/Modifiers * mods, /*1Ab*/bool consequential, /*1Ab*/bool activate); // Window_multiTouchMessage
   inline void releaseCapture(); // Window_releaseCapture
   inline void removeResource(/*1Ab*/Resource & resource); // Window_removeResource
   static inline void restoreCaret(); // Window_restoreCaret
   inline void _scroll(/*1Ab*/int x, /*1Ab*/int y); // Window_scroll
   template<typename... Args> inline void setCaption(/*1Ab*/const char * format, /*1Ab*/Args... args); // Window_setCaption
   inline void setCaret(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int size); // Window_setCaret
   inline void setMousePosition(/*1Ab*/int x, /*1Ab*/int y); // Window_setMousePosition
   inline void setMouseRange(/*1Ab*/Box & range); // Window_setMouseRange
   inline void setMouseRange(/*1Ac*/Box * range); // Window_setMouseRange
   inline void setMouseRangeToClient(); // Window_setMouseRangeToClient
   inline void setMouseRangeToWindow(); // Window_setMouseRangeToWindow
   inline void setScrollArea(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/bool snapToStep); // Window_setScrollArea
   inline void setScrollLineStep(/*1Ab*/int stepX, /*1Ab*/int stepY); // Window_setScrollLineStep
   inline void setScrollPosition(/*1Ab*/int x, /*1Ab*/int y); // Window_setScrollPosition
   inline void setState(/*1Ab*/WindowState newState, /*1Ab*/bool activate, /*1Ab*/Modifiers mods); // Window_setState
   template<typename... Args> inline void setText(/*1Ab*/const char * format, /*1Ab*/Args... args); // Window_setText
   inline void showSysMenu(/*1Ab*/int x, /*1Ab*/int y); // Window_showSysMenu
   inline void softActivate(); // Window_softActivate
   inline void update(/*1Ab*/const Box & region); // Window_update
   inline void update(/*1Ac*/const Box * region); // Window_update
   inline void updateDisplay(); // Window_updateDisplay
   inline void writeCaption(/*1Ab*/Surface & surface, /*1Ab*/int x, /*1Ab*/int y); // Window_writeCaption

   struct Window_getDecorationsSize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/MinMaxValue * w, /*6Fj*/MinMaxValue * h);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/MinMaxValue * w, /*6Fj*/MinMaxValue * h);
   } getDecorationsSize;
   // inline static void register_getDecorationsSize(CPPClass & cl, Window::Window_getDecorationsSize_Functor::FunctionType func)

   struct Window_isInside_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y);
   } isInside;
   // inline static void register_isInside(CPPClass & cl, Window::Window_isInside_Functor::FunctionType func)

   struct Window_isMouseMoving_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h);
   } isMouseMoving;
   // inline static void register_isMouseMoving(CPPClass & cl, Window::Window_isMouseMoving_Functor::FunctionType func)

   struct Window_isMouseResizing_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Cj*/C(bool) * resizeX, /*6Cj*/C(bool) * resizeY, /*6Cj*/C(bool) * resizeEndX, /*6Cj*/C(bool) * resizeEndY);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Cj*/C(bool) * resizeX, /*6Cj*/C(bool) * resizeY, /*6Cj*/C(bool) * resizeEndX, /*6Cj*/C(bool) * resizeEndY);
   } isMouseResizing;
   // inline static void register_isMouseResizing(CPPClass & cl, Window::Window_isMouseResizing_Functor::FunctionType func)

   struct Window_isOpaque_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } isOpaque;
   // inline static void register_isOpaque(CPPClass & cl, Window::Window_isOpaque_Functor::FunctionType func)

   struct Window_notifyActivate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Window & window, /*6Fj*/bool active, /*6Fj*/Window & previous);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Window & window, /*6Fj*/bool active, /*6Fj*/Window & previous);
   } notifyActivate;
   // inline static void register_notifyActivate(CPPClass & cl, Window::Window_notifyActivate_Functor::FunctionType func)

   struct Window_notifyDestroyed_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Window & window, /*6Fj*/DialogResult result);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/Window & window, /*6Fj*/DialogResult result);
   } notifyDestroyed;
   // inline static void register_notifyDestroyed(CPPClass & cl, Window::Window_notifyDestroyed_Functor::FunctionType func)

   struct Window_notifySaved_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Window & window, /*6Fj*/const char * filePath);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/Window & window, /*6Fj*/const char * filePath);
   } notifySaved;
   // inline static void register_notifySaved(CPPClass & cl, Window::Window_notifySaved_Functor::FunctionType func)

   struct Window_onActivate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/bool active, /*6Fj*/Window & previous, /*6Cj*/C(bool) * goOnWithActivation, /*6Fj*/bool direct);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/bool active, /*6Fj*/Window & previous, /*6Cj*/C(bool) * goOnWithActivation, /*6Fj*/bool direct);
   } onActivate;
   // inline static void register_onActivate(CPPClass & cl, Window::Window_onActivate_Functor::FunctionType func)

   struct Window_onActivateClient_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Window & client, /*6Fj*/Window & previous);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & client, /*6Fj*/Window & previous);
   } onActivateClient;
   // inline static void register_onActivateClient(CPPClass & cl, Window::Window_onActivateClient_Functor::FunctionType func)

   struct Window_onApplyGraphics_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onApplyGraphics;
   // inline static void register_onApplyGraphics(CPPClass & cl, Window::Window_onApplyGraphics_Functor::FunctionType func)

   struct Window_onChildAddedOrRemoved_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Window & child, /*6Fj*/bool removed);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & child, /*6Fj*/bool removed);
   } onChildAddedOrRemoved;
   // inline static void register_onChildAddedOrRemoved(CPPClass & cl, Window::Window_onChildAddedOrRemoved_Functor::FunctionType func)

   struct Window_onChildResized_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Window & child, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & child, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h);
   } onChildResized;
   // inline static void register_onChildResized(CPPClass & cl, Window::Window_onChildResized_Functor::FunctionType func)

   struct Window_onChildVisibilityToggled_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Window & child, /*6Fj*/bool visible);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & child, /*6Fj*/bool visible);
   } onChildVisibilityToggled;
   // inline static void register_onChildVisibilityToggled(CPPClass & cl, Window::Window_onChildVisibilityToggled_Functor::FunctionType func)

   struct Window_onClose_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/bool parentClosing);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/bool parentClosing);
   } onClose;
   // inline static void register_onClose(CPPClass & cl, Window::Window_onClose_Functor::FunctionType func)

   struct Window_onCreate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } onCreate;
   // inline static void register_onCreate(CPPClass & cl, Window::Window_onCreate_Functor::FunctionType func)

   struct Window_onDestroy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onDestroy;
   // inline static void register_onDestroy(CPPClass & cl, Window::Window_onDestroy_Functor::FunctionType func)

   struct Window_onDestroyed_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onDestroyed;
   // inline static void register_onDestroyed(CPPClass & cl, Window::Window_onDestroyed_Functor::FunctionType func)

   struct Window_onDrawOverChildren_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Surface & surface);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Surface & surface);
   } onDrawOverChildren;
   // inline static void register_onDrawOverChildren(CPPClass & cl, Window::Window_onDrawOverChildren_Functor::FunctionType func)

   struct Window_onFileModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/FileChange fileChange, /*6Fj*/const char * param);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/FileChange fileChange, /*6Fj*/const char * param);
   } onFileModified;
   // inline static void register_onFileModified(CPPClass & cl, Window::Window_onFileModified_Functor::FunctionType func)

   struct Window_onHScroll_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key);
   } onHScroll;
   // inline static void register_onHScroll(CPPClass & cl, Window::Window_onHScroll_Functor::FunctionType func)

   struct Window_onKeyDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onKeyDown;
   // inline static void register_onKeyDown(CPPClass & cl, Window::Window_onKeyDown_Functor::FunctionType func)

   struct Window_onKeyHit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onKeyHit;
   // inline static void register_onKeyHit(CPPClass & cl, Window::Window_onKeyHit_Functor::FunctionType func)

   struct Window_onKeyUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onKeyUp;
   // inline static void register_onKeyUp(CPPClass & cl, Window::Window_onKeyUp_Functor::FunctionType func)

   struct Window_onLeftButtonDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onLeftButtonDown;
   // inline static void register_onLeftButtonDown(CPPClass & cl, Window::Window_onLeftButtonDown_Functor::FunctionType func)

   struct Window_onLeftButtonUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onLeftButtonUp;
   // inline static void register_onLeftButtonUp(CPPClass & cl, Window::Window_onLeftButtonUp_Functor::FunctionType func)

   struct Window_onLeftDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onLeftDoubleClick;
   // inline static void register_onLeftDoubleClick(CPPClass & cl, Window::Window_onLeftDoubleClick_Functor::FunctionType func)

   struct Window_onLoadGraphics_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } onLoadGraphics;
   // inline static void register_onLoadGraphics(CPPClass & cl, Window::Window_onLoadGraphics_Functor::FunctionType func)

   struct Window_onMiddleButtonDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMiddleButtonDown;
   // inline static void register_onMiddleButtonDown(CPPClass & cl, Window::Window_onMiddleButtonDown_Functor::FunctionType func)

   struct Window_onMiddleButtonUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMiddleButtonUp;
   // inline static void register_onMiddleButtonUp(CPPClass & cl, Window::Window_onMiddleButtonUp_Functor::FunctionType func)

   struct Window_onMiddleDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMiddleDoubleClick;
   // inline static void register_onMiddleDoubleClick(CPPClass & cl, Window::Window_onMiddleDoubleClick_Functor::FunctionType func)

   struct Window_onMouseCaptureLost_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onMouseCaptureLost;
   // inline static void register_onMouseCaptureLost(CPPClass & cl, Window::Window_onMouseCaptureLost_Functor::FunctionType func)

   struct Window_onMouseLeave_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Modifiers mods);
   } onMouseLeave;
   // inline static void register_onMouseLeave(CPPClass & cl, Window::Window_onMouseLeave_Functor::FunctionType func)

   struct Window_onMouseMove_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMouseMove;
   // inline static void register_onMouseMove(CPPClass & cl, Window::Window_onMouseMove_Functor::FunctionType func)

   struct Window_onMouseOver_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMouseOver;
   // inline static void register_onMouseOver(CPPClass & cl, Window::Window_onMouseOver_Functor::FunctionType func)

   struct Window_onMoving_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int * x, /*6Fj*/int * y, /*6Fj*/int w, /*6Fj*/int h);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int * x, /*6Fj*/int * y, /*6Fj*/int w, /*6Fj*/int h);
   } onMoving;
   // inline static void register_onMoving(CPPClass & cl, Window::Window_onMoving_Functor::FunctionType func)

   struct Window_onMultiTouch_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/TouchPointerEvent event, /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TouchPointerEvent event, /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*6Fj*/Modifiers mods);
   } onMultiTouch;
   // inline static void register_onMultiTouch(CPPClass & cl, Window::Window_onMultiTouch_Functor::FunctionType func)

   struct Window_onPosition_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/int height);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/int height);
   } onPosition;
   // inline static void register_onPosition(CPPClass & cl, Window::Window_onPosition_Functor::FunctionType func)

   struct Window_onPostCreate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } onPostCreate;
   // inline static void register_onPostCreate(CPPClass & cl, Window::Window_onPostCreate_Functor::FunctionType func)

   struct Window_onRedraw_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Surface & surface);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Surface & surface);
   } onRedraw;
   // inline static void register_onRedraw(CPPClass & cl, Window::Window_onRedraw_Functor::FunctionType func)

   struct Window_onResize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/int width, /*6Fj*/int height);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int width, /*6Fj*/int height);
   } onResize;
   // inline static void register_onResize(CPPClass & cl, Window::Window_onResize_Functor::FunctionType func)

   struct Window_onResizing_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int * width, /*6Fj*/int * height);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int * width, /*6Fj*/int * height);
   } onResizing;
   // inline static void register_onResizing(CPPClass & cl, Window::Window_onResizing_Functor::FunctionType func)

   struct Window_onRightButtonDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onRightButtonDown;
   // inline static void register_onRightButtonDown(CPPClass & cl, Window::Window_onRightButtonDown_Functor::FunctionType func)

   struct Window_onRightButtonUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onRightButtonUp;
   // inline static void register_onRightButtonUp(CPPClass & cl, Window::Window_onRightButtonUp_Functor::FunctionType func)

   struct Window_onRightDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onRightDoubleClick;
   // inline static void register_onRightDoubleClick(CPPClass & cl, Window::Window_onRightDoubleClick_Functor::FunctionType func)

   struct Window_onSaveFile_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/const char * fileName);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/const char * fileName);
   } onSaveFile;
   // inline static void register_onSaveFile(CPPClass & cl, Window::Window_onSaveFile_Functor::FunctionType func)

   struct Window_onStateChange_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/WindowState state, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/WindowState state, /*6Fj*/Modifiers mods);
   } onStateChange;
   // inline static void register_onStateChange(CPPClass & cl, Window::Window_onStateChange_Functor::FunctionType func)

   struct Window_onSysKeyDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onSysKeyDown;
   // inline static void register_onSysKeyDown(CPPClass & cl, Window::Window_onSysKeyDown_Functor::FunctionType func)

   struct Window_onSysKeyHit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onSysKeyHit;
   // inline static void register_onSysKeyHit(CPPClass & cl, Window::Window_onSysKeyHit_Functor::FunctionType func)

   struct Window_onSysKeyUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onSysKeyUp;
   // inline static void register_onSysKeyUp(CPPClass & cl, Window::Window_onSysKeyUp_Functor::FunctionType func)

   struct Window_onUnloadGraphics_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onUnloadGraphics;
   // inline static void register_onUnloadGraphics(CPPClass & cl, Window::Window_onUnloadGraphics_Functor::FunctionType func)

   struct Window_onVScroll_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key);
   } onVScroll;
   // inline static void register_onVScroll(CPPClass & cl, Window::Window_onVScroll_Functor::FunctionType func)

   struct Window_preShowDecorations_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Font captionFont, /*6Fj*/Surface & surface, /*6Fj*/const char * name, /*6Fj*/bool active, /*6Fj*/bool moving);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Font captionFont, /*6Fj*/Surface & surface, /*6Fj*/const char * name, /*6Fj*/bool active, /*6Fj*/bool moving);
   } preShowDecorations;
   // inline static void register_preShowDecorations(CPPClass & cl, Window::Window_preShowDecorations_Functor::FunctionType func)

   struct Window_setBox_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Box & box);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Box & box);
   } setBox;
   // inline static void register_setBox(CPPClass & cl, Window::Window_setBox_Functor::FunctionType func)

   struct Window_setWindowArea_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/int * x, /*6Fj*/int * y, /*6Fj*/MinMaxValue * w, /*6Fj*/MinMaxValue * h, /*6Fj*/MinMaxValue * cw, /*6Fj*/MinMaxValue * ch);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int * x, /*6Fj*/int * y, /*6Fj*/MinMaxValue * w, /*6Fj*/MinMaxValue * h, /*6Fj*/MinMaxValue * cw, /*6Fj*/MinMaxValue * ch);
   } setWindowArea;
   // inline static void register_setWindowArea(CPPClass & cl, Window::Window_setWindowArea_Functor::FunctionType func)

   struct Window_setWindowMinimum_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/MinMaxValue * mw, /*6Fj*/MinMaxValue * mh);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/MinMaxValue * mw, /*6Fj*/MinMaxValue * mh);
   } setWindowMinimum;
   // inline static void register_setWindowMinimum(CPPClass & cl, Window::Window_setWindowMinimum_Functor::FunctionType func)

   struct Window_showDecorations_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/Font captionFont, /*6Fj*/Surface & surface, /*6Fj*/const char * name, /*6Fj*/bool active, /*6Fj*/bool moving);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Font captionFont, /*6Fj*/Surface & surface, /*6Fj*/const char * name, /*6Fj*/bool active, /*6Fj*/bool moving);
   } showDecorations;
   // inline static void register_showDecorations(CPPClass & cl, Window::Window_showDecorations_Functor::FunctionType func)

   struct Window_updateNonClient_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } updateNonClient;
   // inline static void register_updateNonClient(CPPClass & cl, Window::Window_updateNonClient_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct parent_Prop
   {
      constexpr parent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline Window::parent_Prop & operator= (Window::parent_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } parent;
   struct master_Prop
   {
      constexpr master_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline Window::master_Prop & operator= (Window::master_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } master;
   struct caption_Prop
   {
      constexpr caption_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline Window::caption_Prop & operator= (Window::caption_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } caption;
   struct hotKey_Prop
   {
      constexpr hotKey_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Key operator= (/*0H*/Key v);
      /*regSet*/inline Window::hotKey_Prop & operator= (Window::hotKey_Prop & prop);
      /*regGet*/inline operator /*0I*/Key () const;
   } hotKey;
   struct background_Prop
   {
      constexpr background_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline Window::background_Prop & operator= (Window::background_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } background;
   struct opacity_Prop
   {
      constexpr opacity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Percentage operator= (/*0H*/Percentage v);
      /*regSet*/inline Window::opacity_Prop & operator= (Window::opacity_Prop & prop);
      /*regGet*/inline operator /*0I*/Percentage () const;
      /*regGet*/inline operator /*0J*/C(Percentage) () const;
   } opacity;
   struct foreground_Prop
   {
      constexpr foreground_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline Window::foreground_Prop & operator= (Window::foreground_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } foreground;
   struct borderStyle_Prop
   {
      constexpr borderStyle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/BorderStyle operator= (/*0H*/BorderStyle v);
      /*regSet*/inline Window::borderStyle_Prop & operator= (Window::borderStyle_Prop & prop);
      /*regGet*/inline operator /*0I*/BorderStyle () const;
   } borderStyle;
   struct minClientSize_Prop
   {
      constexpr minClientSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Size operator= (/*0H*/Size v);
      /*regSet*/inline Window::minClientSize_Prop & operator= (Window::minClientSize_Prop & prop);
      /*regGet*/inline operator /*0I*/Size () const;
   } minClientSize;
   struct maxClientSize_Prop
   {
      constexpr maxClientSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Size operator= (/*0H*/Size v);
      /*regSet*/inline Window::maxClientSize_Prop & operator= (Window::maxClientSize_Prop & prop);
      /*regGet*/inline operator /*0I*/Size () const;
   } maxClientSize;
   struct hasMaximize_Prop
   {
      constexpr hasMaximize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::hasMaximize_Prop & operator= (Window::hasMaximize_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasMaximize;
   struct hasMinimize_Prop
   {
      constexpr hasMinimize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::hasMinimize_Prop & operator= (Window::hasMinimize_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasMinimize;
   struct hasClose_Prop
   {
      constexpr hasClose_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::hasClose_Prop & operator= (Window::hasClose_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasClose;
   struct nonClient_Prop
   {
      constexpr nonClient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::nonClient_Prop & operator= (Window::nonClient_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } nonClient;
   struct inactive_Prop
   {
      constexpr inactive_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::inactive_Prop & operator= (Window::inactive_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } inactive;
   struct clickThrough_Prop
   {
      constexpr clickThrough_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::clickThrough_Prop & operator= (Window::clickThrough_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } clickThrough;
   struct isRemote_Prop
   {
      constexpr isRemote_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::isRemote_Prop & operator= (Window::isRemote_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isRemote;
   struct noCycle_Prop
   {
      constexpr noCycle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::noCycle_Prop & operator= (Window::noCycle_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noCycle;
   struct isModal_Prop
   {
      constexpr isModal_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::isModal_Prop & operator= (Window::isModal_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isModal;
   struct interim_Prop
   {
      constexpr interim_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::interim_Prop & operator= (Window::interim_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } interim;
   struct tabCycle_Prop
   {
      constexpr tabCycle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::tabCycle_Prop & operator= (Window::tabCycle_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } tabCycle;
   struct isDefault_Prop
   {
      constexpr isDefault_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::isDefault_Prop & operator= (Window::isDefault_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isDefault;
   struct drawBehind_Prop
   {
      constexpr drawBehind_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::drawBehind_Prop & operator= (Window::drawBehind_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } drawBehind;
   struct hasMenuBar_Prop
   {
      constexpr hasMenuBar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::hasMenuBar_Prop & operator= (Window::hasMenuBar_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasMenuBar;
   struct hasStatusBar_Prop
   {
      constexpr hasStatusBar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::hasStatusBar_Prop & operator= (Window::hasStatusBar_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasStatusBar;
   struct stayOnTop_Prop
   {
      constexpr stayOnTop_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::stayOnTop_Prop & operator= (Window::stayOnTop_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } stayOnTop;
   struct menu_Prop
   {
      constexpr menu_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Menu & operator= (/*0A*/const Menu & v);
      /*regSet*/inline Window::menu_Prop & operator= (Window::menu_Prop & prop);
      /*nstSet*/inline /*0C*/const Menu * operator= (/*0C*/const Menu * v);
      /*regGet*/inline operator /*0B*/TIH<Menu> () const;
      /*regGet*/inline TIH<Menu> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Menu () const;
      /*regGet*/inline operator /*0F*/Menu* () const;
   } menu;
   struct font_Prop
   {
      constexpr font_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const FontResource & operator= (/*0A*/const FontResource & v);
      /*regSet*/inline Window::font_Prop & operator= (Window::font_Prop & prop);
      /*nstSet*/inline /*0C*/const FontResource * operator= (/*0C*/const FontResource * v);
      /*regGet*/inline operator /*0B*/TIH<FontResource> () const;
      /*regGet*/inline TIH<FontResource> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/FontResource () const;
      /*regGet*/inline operator /*0F*/FontResource* () const;
   } font;
   struct sizeAnchor_Prop
   {
      constexpr sizeAnchor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SizeAnchor operator= (/*0H*/SizeAnchor v);
      /*regSet*/inline Window::sizeAnchor_Prop & operator= (Window::sizeAnchor_Prop & prop);
      /*regGet*/inline operator /*0I*/SizeAnchor () const;
   } sizeAnchor;
   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Size operator= (/*0H*/Size v);
      /*regSet*/inline Window::size_Prop & operator= (Window::size_Prop & prop);
      /*regGet*/inline operator /*0I*/Size () const;
   } size;
   struct clientSize_Prop
   {
      constexpr clientSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Size operator= (/*0H*/Size v);
      /*regSet*/inline Window::clientSize_Prop & operator= (Window::clientSize_Prop & prop);
      /*regGet*/inline operator /*0I*/Size () const;
   } clientSize;
   struct initSize_Prop
   {
      constexpr initSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Size () const;
   } initSize;
   struct anchor_Prop
   {
      constexpr anchor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Anchor operator= (/*0H*/Anchor v);
      /*regSet*/inline Window::anchor_Prop & operator= (Window::anchor_Prop & prop);
      /*regGet*/inline operator /*0I*/Anchor () const;
   } anchor;
   struct position_Prop
   {
      constexpr position_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Point operator= (/*0H*/Point v);
      /*regSet*/inline Window::position_Prop & operator= (Window::position_Prop & prop);
      /*regGet*/inline operator /*0I*/Point () const;
   } position;
   struct disabled_Prop
   {
      constexpr disabled_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::disabled_Prop & operator= (Window::disabled_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } disabled;
   struct isEnabled_Prop
   {
      constexpr isEnabled_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } isEnabled;
   struct state_Prop
   {
      constexpr state_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/WindowState operator= (/*0H*/WindowState v);
      /*regSet*/inline Window::state_Prop & operator= (Window::state_Prop & prop);
      /*regGet*/inline operator /*0I*/WindowState () const;
   } state;
   struct visible_Prop
   {
      constexpr visible_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::visible_Prop & operator= (Window::visible_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } visible;
   struct isDocument_Prop
   {
      constexpr isDocument_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::isDocument_Prop & operator= (Window::isDocument_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isDocument;
   struct mergeMenus_Prop
   {
      constexpr mergeMenus_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::mergeMenus_Prop & operator= (Window::mergeMenus_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } mergeMenus;
   struct hasHorzScroll_Prop
   {
      constexpr hasHorzScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::hasHorzScroll_Prop & operator= (Window::hasHorzScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasHorzScroll;
   struct hasVertScroll_Prop
   {
      constexpr hasVertScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::hasVertScroll_Prop & operator= (Window::hasVertScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasVertScroll;
   struct dontHideScroll_Prop
   {
      constexpr dontHideScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::dontHideScroll_Prop & operator= (Window::dontHideScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } dontHideScroll;
   struct dontScrollVert_Prop
   {
      constexpr dontScrollVert_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::dontScrollVert_Prop & operator= (Window::dontScrollVert_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } dontScrollVert;
   struct dontScrollHorz_Prop
   {
      constexpr dontScrollHorz_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::dontScrollHorz_Prop & operator= (Window::dontScrollHorz_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } dontScrollHorz;
   struct snapVertScroll_Prop
   {
      constexpr snapVertScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::snapVertScroll_Prop & operator= (Window::snapVertScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } snapVertScroll;
   struct snapHorzScroll_Prop
   {
      constexpr snapHorzScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::snapHorzScroll_Prop & operator= (Window::snapHorzScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } snapHorzScroll;
   struct scroll_Prop
   {
      constexpr scroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Point operator= (/*0H*/Point v);
      /*regSet*/inline Window::scroll_Prop & operator= (Window::scroll_Prop & prop);
      /*regGet*/inline operator /*0I*/Point () const;
   } scroll;
   struct modifyVirtualArea_Prop
   {
      constexpr modifyVirtualArea_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::modifyVirtualArea_Prop & operator= (Window::modifyVirtualArea_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } modifyVirtualArea;
   struct dontAutoScrollArea_Prop
   {
      constexpr dontAutoScrollArea_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::dontAutoScrollArea_Prop & operator= (Window::dontAutoScrollArea_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } dontAutoScrollArea;
   struct fileName_Prop
   {
      constexpr fileName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline Window::fileName_Prop & operator= (Window::fileName_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } fileName;
   struct id_Prop
   {
      constexpr id_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int64 operator= (/*0H*/int64 v);
      /*regSet*/inline Window::id_Prop & operator= (Window::id_Prop & prop);
      /*regGet*/inline operator /*0I*/int64 () const;
   } id;
   struct modifiedDocument_Prop
   {
      constexpr modifiedDocument_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::modifiedDocument_Prop & operator= (Window::modifiedDocument_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } modifiedDocument;
   struct showInTaskBar_Prop
   {
      constexpr showInTaskBar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::showInTaskBar_Prop & operator= (Window::showInTaskBar_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } showInTaskBar;
   struct saveDialog_Prop
   {
      constexpr saveDialog_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const FileDialog & operator= (/*0A*/const FileDialog & v);
      /*nstSet*/inline /*0C*/const FileDialog * operator= (/*0C*/const FileDialog * v);
   } saveDialog;
   struct isActiveClient_Prop
   {
      constexpr isActiveClient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::isActiveClient_Prop & operator= (Window::isActiveClient_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isActiveClient;
   struct cursor_Prop
   {
      constexpr cursor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Cursor & operator= (/*0A*/const Cursor & v);
      /*regSet*/inline Window::cursor_Prop & operator= (Window::cursor_Prop & prop);
      /*nstSet*/inline /*0C*/const Cursor * operator= (/*0C*/const Cursor * v);
      /*regGet*/inline operator /*0B*/TIH<Cursor> () const;
      /*regGet*/inline TIH<Cursor> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Cursor () const;
      /*regGet*/inline operator /*0F*/Cursor* () const;
   } cursor;
   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline Window::name_Prop & operator= (Window::name_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } name;
   struct displayDriver_Prop
   {
      constexpr displayDriver_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline Window::displayDriver_Prop & operator= (Window::displayDriver_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } displayDriver;
   struct autoCreate_Prop
   {
      constexpr autoCreate_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::autoCreate_Prop & operator= (Window::autoCreate_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } autoCreate;
   struct scrollArea_Prop
   {
      constexpr scrollArea_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Size operator= (/*0H*/Size v);
      /*regSet*/inline Window::scrollArea_Prop & operator= (Window::scrollArea_Prop & prop);
      /*regGet*/inline operator /*0I*/Size () const;
   } scrollArea;
   struct is3D_Prop
   {
      constexpr is3D_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::is3D_Prop & operator= (Window::is3D_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } is3D;
   struct fontObject_Prop
   {
      constexpr fontObject_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Font () const;
   } fontObject;
   struct clientStart_Prop
   {
      constexpr clientStart_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Point () const;
   } clientStart;
   struct absPosition_Prop
   {
      constexpr absPosition_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Point () const;
   } absPosition;
   struct normalAnchor_Prop
   {
      constexpr normalAnchor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Anchor () const;
   } normalAnchor;
   struct normalSizeAnchor_Prop
   {
      constexpr normalSizeAnchor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/SizeAnchor () const;
   } normalSizeAnchor;
   struct active_Prop
   {
      constexpr active_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } active;
   struct created_Prop
   {
      constexpr created_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } created;
   struct destroyed_Prop
   {
      constexpr destroyed_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } destroyed;
   struct firstSlave_Prop
   {
      constexpr firstSlave_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } firstSlave;
   struct firstChild_Prop
   {
      constexpr firstChild_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } firstChild;
   struct lastChild_Prop
   {
      constexpr lastChild_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } lastChild;
   struct activeClient_Prop
   {
      constexpr activeClient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } activeClient;
   struct activeChild_Prop
   {
      constexpr activeChild_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } activeChild;
   struct display_Prop
   {
      constexpr display_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Display> () const;
      /*regGet*/inline TIH<Display> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Display () const;
      /*regGet*/inline operator /*0F*/Display* () const;
   } display;
   struct displaySystem_Prop
   {
      constexpr displaySystem_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DisplaySystem> () const;
      /*regGet*/inline TIH<DisplaySystem> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DisplaySystem () const;
      /*regGet*/inline operator /*0F*/DisplaySystem* () const;
   } displaySystem;
   struct horzScroll_Prop
   {
      constexpr horzScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<ScrollBar> () const;
      /*regGet*/inline TIH<ScrollBar> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/ScrollBar () const;
      /*regGet*/inline operator /*0F*/ScrollBar* () const;
   } horzScroll;
   struct vertScroll_Prop
   {
      constexpr vertScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<ScrollBar> () const;
      /*regGet*/inline TIH<ScrollBar> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/ScrollBar () const;
      /*regGet*/inline operator /*0F*/ScrollBar* () const;
   } vertScroll;
   struct statusBar_Prop
   {
      constexpr statusBar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<StatusBar> () const;
      /*regGet*/inline TIH<StatusBar> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/StatusBar () const;
      /*regGet*/inline operator /*0F*/StatusBar* () const;
   } statusBar;
   struct rootWindow_Prop
   {
      constexpr rootWindow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } rootWindow;
   struct closing_Prop
   {
      constexpr closing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::closing_Prop & operator= (Window::closing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } closing;
   struct documentID_Prop
   {
      constexpr documentID_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } documentID;
   struct previous_Prop
   {
      constexpr previous_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } previous;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } next;
   struct nextSlave_Prop
   {
      constexpr nextSlave_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } nextSlave;
   struct menuBar_Prop
   {
      constexpr menuBar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<PopupMenu> () const;
      /*regGet*/inline TIH<PopupMenu> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/PopupMenu () const;
      /*regGet*/inline operator /*0F*/PopupMenu* () const;
   } menuBar;
   struct sbv_Prop
   {
      constexpr sbv_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<ScrollBar> () const;
      /*regGet*/inline TIH<ScrollBar> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/ScrollBar () const;
      /*regGet*/inline operator /*0F*/ScrollBar* () const;
   } sbv;
   struct sbh_Prop
   {
      constexpr sbh_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<ScrollBar> () const;
      /*regGet*/inline TIH<ScrollBar> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/ScrollBar () const;
      /*regGet*/inline operator /*0F*/ScrollBar* () const;
   } sbh;
   struct fullRender_Prop
   {
      constexpr fullRender_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::fullRender_Prop & operator= (Window::fullRender_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fullRender;
   struct systemHandle_Prop
   {
      constexpr systemHandle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/void * () const;
   } systemHandle;
   struct minimizeButton_Prop
   {
      constexpr minimizeButton_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Button> () const;
      /*regGet*/inline TIH<Button> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Button () const;
      /*regGet*/inline operator /*0F*/Button* () const;
   } minimizeButton;
   struct maximizeButton_Prop
   {
      constexpr maximizeButton_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Button> () const;
      /*regGet*/inline TIH<Button> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Button () const;
      /*regGet*/inline operator /*0F*/Button* () const;
   } maximizeButton;
   struct closeButton_Prop
   {
      constexpr closeButton_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Button> () const;
      /*regGet*/inline TIH<Button> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Button () const;
      /*regGet*/inline operator /*0F*/Button* () const;
   } closeButton;
   struct icon_Prop
   {
      constexpr icon_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const BitmapResource & operator= (/*0A*/const BitmapResource & v);
      /*regSet*/inline Window::icon_Prop & operator= (Window::icon_Prop & prop);
      /*nstSet*/inline /*0C*/const BitmapResource * operator= (/*0C*/const BitmapResource * v);
      /*regGet*/inline operator /*0B*/TIH<BitmapResource> () const;
      /*regGet*/inline TIH<BitmapResource> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/BitmapResource () const;
      /*regGet*/inline operator /*0F*/BitmapResource* () const;
   } icon;
   struct moveable_Prop
   {
      constexpr moveable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::moveable_Prop & operator= (Window::moveable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } moveable;
   struct alphaBlend_Prop
   {
      constexpr alphaBlend_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::alphaBlend_Prop & operator= (Window::alphaBlend_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alphaBlend;
   struct useSharedMemory_Prop
   {
      constexpr useSharedMemory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::useSharedMemory_Prop & operator= (Window::useSharedMemory_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } useSharedMemory;
   struct glCapabilities_Prop
   {
      constexpr glCapabilities_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GLCapabilities operator= (/*0H*/GLCapabilities v);
      /*regSet*/inline Window::glCapabilities_Prop & operator= (Window::glCapabilities_Prop & prop);
      /*regGet*/inline operator /*0I*/GLCapabilities () const;
   } glCapabilities;
   struct creationActivation_Prop
   {
      constexpr creationActivation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/CreationActivationOption operator= (/*0H*/CreationActivationOption v);
      /*regSet*/inline Window::creationActivation_Prop & operator= (Window::creationActivation_Prop & prop);
      /*regGet*/inline operator /*0I*/CreationActivationOption () const;
   } creationActivation;
   struct nativeDecorations_Prop
   {
      constexpr nativeDecorations_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::nativeDecorations_Prop & operator= (Window::nativeDecorations_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } nativeDecorations;
   struct manageDisplay_Prop
   {
      constexpr manageDisplay_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::manageDisplay_Prop & operator= (Window::manageDisplay_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } manageDisplay;
   struct text_Prop
   {
      constexpr text_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline Window::text_Prop & operator= (Window::text_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } text;
   struct controller_Prop
   {
      constexpr controller_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const WindowController & operator= (/*0A*/const WindowController & v);
      /*regSet*/inline Window::controller_Prop & operator= (Window::controller_Prop & prop);
      /*nstSet*/inline /*0C*/const WindowController * operator= (/*0C*/const WindowController * v);
      /*regGet*/inline operator /*0F*/WindowController* () const;
   } controller;
   struct noConsequential_Prop
   {
      constexpr noConsequential_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Window::noConsequential_Prop & operator= (Window::noConsequential_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noConsequential;
};

struct Anchor : public TStruct<Anchor>
{
public:
   C(Anchor) impl;
   constexpr Anchor() : impl({}) { }
   constexpr Anchor(const C(Anchor) impl) : impl(impl) { }

   struct left_Prop
   {
      constexpr left_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/AnchorValue operator= (/*0H*/AnchorValue v);
      /*regSet*/inline Anchor::left_Prop & operator= (Anchor::left_Prop & prop);
      /*regGet*/inline operator /*0I*/AnchorValue () const;
   } left;
   struct horz_Prop
   {
      constexpr horz_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/MiddleAnchorValue operator= (/*0H*/MiddleAnchorValue v);
      /*regSet*/inline Anchor::horz_Prop & operator= (Anchor::horz_Prop & prop);
      /*regGet*/inline operator /*0I*/MiddleAnchorValue () const;
   } horz;
   struct top_Prop
   {
      constexpr top_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/AnchorValue operator= (/*0H*/AnchorValue v);
      /*regSet*/inline Anchor::top_Prop & operator= (Anchor::top_Prop & prop);
      /*regGet*/inline operator /*0I*/AnchorValue () const;
   } top;
   struct vert_Prop
   {
      constexpr vert_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/MiddleAnchorValue operator= (/*0H*/MiddleAnchorValue v);
      /*regSet*/inline Anchor::vert_Prop & operator= (Anchor::vert_Prop & prop);
      /*regGet*/inline operator /*0I*/MiddleAnchorValue () const;
   } vert;
   struct right_Prop
   {
      constexpr right_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/AnchorValue operator= (/*0H*/AnchorValue v);
      /*regSet*/inline Anchor::right_Prop & operator= (Anchor::right_Prop & prop);
      /*regGet*/inline operator /*0I*/AnchorValue () const;
   } right;
   struct bottom_Prop
   {
      constexpr bottom_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/AnchorValue operator= (/*0H*/AnchorValue v);
      /*regSet*/inline Anchor::bottom_Prop & operator= (Anchor::bottom_Prop & prop);
      /*regGet*/inline operator /*0I*/AnchorValue () const;
   } bottom;
};

struct AnchorValue : public TStruct<AnchorValue>
{
public:
   C(AnchorValue) impl;
   constexpr AnchorValue() : impl({}) { }
   constexpr AnchorValue(const C(AnchorValue) impl) : impl(impl) { }
   inline operator MinMaxValue() const;
   inline AnchorValue(const MinMaxValue & m);
   inline AnchorValue & operator =(const MinMaxValue & m);

   inline AnchorValue(AnchorValueType type, int distance, float percent);

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/AnchorValueType operator= (/*0H*/AnchorValueType v);
      /*regSet*/inline AnchorValue::type_Prop & operator= (AnchorValue::type_Prop & prop);
      /*regGet*/inline operator /*0I*/AnchorValueType () const;
   } type;
   struct distance_Prop
   {
      constexpr distance_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline AnchorValue::distance_Prop & operator= (AnchorValue::distance_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } distance;
   struct percent_Prop
   {
      constexpr percent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline AnchorValue::percent_Prop & operator= (AnchorValue::percent_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } percent;
};

enum class AnchorValueType : int
{
   none = AnchorValueType_none,
   offset = AnchorValueType_offset,
   relative = AnchorValueType_relative,
   middleRelative = AnchorValueType_middleRelative,
   cascade = AnchorValueType_cascade,
   vTiled = AnchorValueType_vTiled,
   hTiled = AnchorValueType_hTiled
};

enum class BorderStyle : uint
{
   none = BorderStyle_none,
   contour = BorderStyle_contour,
   fixed = BorderStyle_fixed,
   sizable = BorderStyle_sizable,
   thin = BorderStyle_thin,
   sizableThin = BorderStyle_sizableThin,
   deep = BorderStyle_deep,
   bevel = BorderStyle_bevel,
   sizableDeep = BorderStyle_sizableDeep,
   sizableBevel = BorderStyle_sizableBevel,
   fixedDeep = BorderStyle_fixedDeep,
   fixedBevel = BorderStyle_fixedBevel,
   deepContour = BorderStyle_deepContour
};

template <class TC, C(Class) ** TCO>
class TClipBoard : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline C(bool) allocate(/*1Ab*/uint size); // ClipBoard_allocate
   inline void clear(); // ClipBoard_clear
   inline C(bool) load(); // ClipBoard_load
   inline C(bool) save(); // ClipBoard_save
   inline void unload(); // ClipBoard_unload

   struct memory_Prop
   {
      constexpr memory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/char * () const;
   } memory;

   struct text_Prop
   {
      constexpr text_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/char * operator= (/*0H*/char * v);
      /*regSet*/inline typename TClipBoard<TC, TCO>::text_Prop & operator= (typename TClipBoard<TC, TCO>::text_Prop & prop);
      /*regGet*/inline operator /*0I*/char * () const;
   } text;
   struct handle_Prop
   {
      constexpr handle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline typename TClipBoard<TC, TCO>::handle_Prop & operator= (typename TClipBoard<TC, TCO>::handle_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } handle;
   ~TClipBoard()
   {
      this->impl = null; // How to know not to delete?
   }
};


#define REG_CommonControl(c) \
      CommonControl::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define COMMONCONTROL_VIRTUAL_METHODS_PROTO(c) \

#define COMMONCONTROL_VIRTUAL_METHODS(c) \

class CommonControl : public Window
{
public:
   inline CommonControl(CommonControl && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline CommonControl & operator= (CommonControl && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   CommonControl() : CommonControl((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<CommonControl> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         CommonControl * inst = new CommonControl(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      CommonControl * inst = (CommonControl *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(CommonControl & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline CommonControl(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline CommonControl(/*CT-D*/constString toolTip);

   struct toolTip_Prop
   {
      constexpr toolTip_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*//*CT-D*/constString operator= (/*0H*//*CT-D*/constString v);
      /*regSet*/inline CommonControl::toolTip_Prop & operator= (CommonControl::toolTip_Prop & prop);
      /*regGet*/inline operator /*0I*//*CT-D*/constString () const;
   } toolTip;
};


#define REG_ControllableWindow(c) \
      ControllableWindow::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define CONTROLLABLEWINDOW_VIRTUAL_METHODS_PROTO(c) \

#define CONTROLLABLEWINDOW_VIRTUAL_METHODS(c) \

class ControllableWindow : public Window
{
public:
   inline ControllableWindow(ControllableWindow && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ControllableWindow & operator= (ControllableWindow && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ControllableWindow() : ControllableWindow((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ControllableWindow> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ControllableWindow * inst = new ControllableWindow(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ControllableWindow * inst = (ControllableWindow *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ControllableWindow & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ControllableWindow(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

enum class CreationActivationOption : int
{
   activate = CreationActivationOption_activate,
   flash = CreationActivationOption_flash,
   doNothing = CreationActivationOption_doNothing
};


#define REG_Cursor(c) \
      Cursor::class_registration(_cpp_class);

#define CURSOR_VIRTUAL_METHODS_PROTO(c) \

#define CURSOR_VIRTUAL_METHODS(c) \

class Cursor : public Instance
{
public:
   inline Cursor(Cursor && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Cursor & operator= (Cursor && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Cursor() : Cursor((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Cursor> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Cursor * inst = new Cursor(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Cursor * inst = (Cursor *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Cursor & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Cursor(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void free(); // Cursor_free
   inline C(bool) load(/*1Ab*/const char * name, /*1Ab*/int hotSpotX, /*1Ab*/int hotSpotY, /*1Ab*/byte * paletteShades, /*1Ab*/DisplaySystem & ds); // Cursor_load

   static void class_registration(CPPClass & _cpp_class);

   inline Cursor(SystemCursor systemCursor);

   struct systemCursor_Prop
   {
      constexpr systemCursor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/SystemCursor operator= (/*0G*/SystemCursor v);
   } systemCursor;
};

enum class DialogResult : int64
{
   cancel = DialogResult_cancel,
   yes = DialogResult_yes,
   no = DialogResult_no,
   ok = DialogResult_ok
};

struct Extent : public TStruct<Extent>
{
public:
   C(Extent) impl;
   constexpr Extent() : impl({}) { }
   constexpr Extent(const C(Extent) impl) : impl(impl) { }

   inline void add(/*1Ab*/void * item); // OldList_add
   inline C(bool) addName(/*1Ab*/void * item); // OldList_addName
   inline void clear(); // OldList_clear
   inline void _delete(/*1Ab*/void * item); // OldList_delete
   inline C(OldLink) * findLink(/*1Ab*/void * data); // OldList_findLink
   inline void * findName(/*1Ab*/const char * name, /*1Ab*/bool warn); // OldList_findName
   inline void * findNamedLink(/*1Ab*/const char * name, /*1Ab*/bool warn); // OldList_findNamedLink
   inline void free(void (* freeFn)(void *)); // OldList_free
   inline C(bool) insert(/*1Ab*/void * prevItem, /*1Ab*/void * item); // OldList_insert
   inline void move(/*1Ab*/void * item, /*1Ab*/void * prevItem); // OldList_move
   inline C(bool) placeName(/*1Ab*/const char * name, /*1Ab*/void ** place); // OldList_placeName
   inline void remove(/*1Ab*/void * item); // OldList_remove
   inline void removeAll(void (* freeFn)(void *)); // OldList_removeAll
   inline void sort(int (* compare)(void *, void *, void *), /*1Ab*/void * data); // OldList_sort
   inline void swap(/*1Ab*/void * item1, /*1Ab*/void * item2); // OldList_swap
   inline void addBox(/*1Ab*/Box & box); // Extent_addBox
   inline void addBox(/*1Ac*/Box * box); // Extent_addBox
   inline void copy(/*1Ab*/Extent & source); // Extent_copy
   inline void copy(/*1Ac*/Extent * source); // Extent_copy
   inline void empty(); // Extent_empty
   inline void excludeBox(/*1Ab*/Box & box, /*1Ab*/Extent & temp); // Extent_excludeBox
   inline void excludeBox(/*1Ac*/Box * box, /*1Ac*/Extent * temp); // Extent_excludeBox
   inline void exclusion(/*1Ab*/Extent & b, /*1Ab*/Extent & temp); // Extent_exclusion
   inline void exclusion(/*1Ac*/Extent * b, /*1Ac*/Extent * temp); // Extent_exclusion
   inline void intersectBox(/*1Ab*/Box & box); // Extent_intersectBox
   inline void intersectBox(/*1Ac*/Box * box); // Extent_intersectBox
   inline void intersection(/*1Ab*/Extent & b, /*1Ab*/Extent & temp, /*1Ab*/Extent & temp2, /*1Ab*/Extent & temp3); // Extent_intersection
   inline void intersection(/*1Ac*/Extent * b, /*1Ac*/Extent * temp, /*1Ac*/Extent * temp2, /*1Ac*/Extent * temp3); // Extent_intersection
   inline void _offset(/*1Ab*/int x, /*1Ab*/int y); // Extent_offset
   inline void _union(/*1Ab*/Extent & b, /*1Ab*/Extent & temp); // Extent_union
   inline void _union(/*1Ac*/Extent * b, /*1Ac*/Extent * temp); // Extent_union
   inline void unionBox(/*1Ab*/Box & box, /*1Ab*/Extent & temp); // Extent_unionBox
   inline void unionBox(/*1Ac*/Box * box, /*1Ac*/Extent * temp); // Extent_unionBox

   inline Extent(void * first, void * last, int count, uint offset, bool circ);

   struct first_Prop
   {
      constexpr first_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline Extent::first_Prop & operator= (Extent::first_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } first;
   struct last_Prop
   {
      constexpr last_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline Extent::last_Prop & operator= (Extent::last_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } last;
   struct count_Prop
   {
      constexpr count_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Extent::count_Prop & operator= (Extent::count_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } count;
   struct offset_Prop
   {
      constexpr offset_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline Extent::offset_Prop & operator= (Extent::offset_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } offset;
   struct circ_Prop
   {
      constexpr circ_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Extent::circ_Prop & operator= (Extent::circ_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } circ;
};

#define REG_GuiApplication_cycle(m, c)     REGVMETHOD(GuiApplication, cycle,     c::m, (/*1Ab*/GuiApplication & self, /*1Ab*/bool idle), c, (/*4Hm*/(bool)idle))
#define REG_GuiApplication_init(m, c)      REGVMETHOD(GuiApplication, init,      c::m, (/*1Ab*/GuiApplication & self),                   c, ())
#define REG_GuiApplication_terminate(m, c) REGVMETHOD(GuiApplication, terminate, c::m, (/*1Ab*/GuiApplication & self),                   c, ())

#define REG_GuiApplication(c) \
      GuiApplication::class_registration(_cpp_class); \
      REG_Module_onLoad(onLoad, c); \
      REG_Module_onUnload(onUnload, c); \
      REG_Application_main(main, c); \
      REG_GuiApplication_cycle(cycle, c); \
      REG_GuiApplication_init(init, c); \
      REG_GuiApplication_terminate(terminate, c);

#define GUIAPPLICATION_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(cycle, cycle, c, GuiApplication, \
      bool, c & _ARG, , /*6Fj*/bool idle); \
   VIRTUAL_METHOD_PROTO(init, init, c, GuiApplication, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(terminate, terminate, c, GuiApplication, \
      void, c &, , );

#define GUIAPPLICATION_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(cycle, cycle, c, GuiApplication, \
   bool, c & _ARG, , /*6Fj*/bool idle, \
   return (bool)GuiApplication_cycle(self ? self->impl : (C(GuiApplication))null, /*7Al*/(C(bool))idle);); \
VIRTUAL_METHOD(init, init, c, GuiApplication, \
   bool, c &, , , \
   return (bool)GuiApplication_init(self ? self->impl : (C(GuiApplication))null);); \
VIRTUAL_METHOD(terminate, terminate, c, GuiApplication, \
   void, c &, , , \
   GuiApplication_terminate(self ? self->impl : (C(GuiApplication))null););

class GuiApplication : public Application
{
public:
   inline GuiApplication(GuiApplication && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GuiApplication & operator= (GuiApplication && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   inline GuiApplication() : GuiApplication(eC_init_CALL(__LINK_ECERE__)) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GuiApplication> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GuiApplication * inst = new GuiApplication(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GuiApplication * inst = (GuiApplication *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GuiApplication & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GuiApplication(C(Instance) _impl, CPPClass & cl = _cpp_class) : Application(_impl, cl)
   {
      EVOLVE_APP(GuiApplication, *this);
#ifdef MODULE_NAME
      loadTranslatedStrings(null, MODULE_NAME);
#endif
   }

   inline Cursor getCursor(/*1Ab*/SystemCursor cursor); // GuiApplication_getCursor
   inline C(bool) getKeyState(/*1Ab*/Key key); // GuiApplication_getKeyState
   inline C(bool) getMouseState(/*1Ab*/MouseButtons * buttons, /*1Ab*/int * x, /*1Ab*/int * y); // GuiApplication_getMouseState
   inline void lock(); // GuiApplication_lock
   inline void lockEx(/*1Ab*/int count); // GuiApplication_lockEx
   inline void pauseNetworkEvents(); // GuiApplication_pauseNetworkEvents
   inline C(bool) processFileNotifications(); // GuiApplication_processFileNotifications
   inline C(bool) processInput(/*1Ab*/bool useProcessAll); // GuiApplication_processInput
   inline C(bool) processNetworkEvents(); // GuiApplication_processNetworkEvents
   inline void resumeNetworkEvents(); // GuiApplication_resumeNetworkEvents
   inline C(bool) setDesktopPosition(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/bool moveChildren); // GuiApplication_setDesktopPosition
   inline void signalEvent(); // GuiApplication_signalEvent
   inline C(bool) switchMode(/*1Ab*/bool fullScreen, /*1Ab*/const char * driverName, /*1Ab*/Resolution resolution, /*1Ab*/PixelFormat colorDepth, /*1Ab*/int refreshRate, /*1Ab*/const char * skinName, /*1Ab*/bool fallBack); // GuiApplication_switchMode
   inline void unlock(); // GuiApplication_unlock
   inline int unlockEx(); // GuiApplication_unlockEx
   inline void updateDisplay(); // GuiApplication_updateDisplay
   inline void wait(); // GuiApplication_wait
   inline void waitEvent(); // GuiApplication_waitEvent
   inline void waitNetworkEvent(); // GuiApplication_waitNetworkEvent

   struct GuiApplication_cycle_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(GuiApplication & , /*6Fj*/bool idle);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/bool idle);
   } cycle;
   // inline static void register_cycle(CPPClass & cl, GuiApplication::GuiApplication_cycle_Functor::FunctionType func)

   struct GuiApplication_init_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(GuiApplication &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } init;
   // inline static void register_init(CPPClass & cl, GuiApplication::GuiApplication_init_Functor::FunctionType func)

   struct GuiApplication_terminate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(GuiApplication &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } terminate;
   // inline static void register_terminate(CPPClass & cl, GuiApplication::GuiApplication_terminate_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline GuiApplication(const char * appName, bool alwaysEmptyInput, bool fullScreen, const char * driver, Resolution resolution, PixelFormat pixelFormat, int refreshRate, const char * skin, bool textMode, uint timerResolution);

   struct appName_Prop
   {
      constexpr appName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GuiApplication::appName_Prop & operator= (GuiApplication::appName_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } appName;
   struct semaphore_Prop
   {
      constexpr semaphore_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/Semaphore () const;
   } semaphore;
   struct alwaysEmptyInput_Prop
   {
      constexpr alwaysEmptyInput_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GuiApplication::alwaysEmptyInput_Prop & operator= (GuiApplication::alwaysEmptyInput_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alwaysEmptyInput;
   struct fullScreen_Prop
   {
      constexpr fullScreen_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GuiApplication::fullScreen_Prop & operator= (GuiApplication::fullScreen_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fullScreen;
   struct driver_Prop
   {
      constexpr driver_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GuiApplication::driver_Prop & operator= (GuiApplication::driver_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } driver;
   struct resolution_Prop
   {
      constexpr resolution_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Resolution operator= (/*0H*/Resolution v);
      /*regSet*/inline GuiApplication::resolution_Prop & operator= (GuiApplication::resolution_Prop & prop);
      /*regGet*/inline operator /*0I*/Resolution () const;
   } resolution;
   struct pixelFormat_Prop
   {
      constexpr pixelFormat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/PixelFormat operator= (/*0H*/PixelFormat v);
      /*regSet*/inline GuiApplication::pixelFormat_Prop & operator= (GuiApplication::pixelFormat_Prop & prop);
      /*regGet*/inline operator /*0I*/PixelFormat () const;
   } pixelFormat;
   struct refreshRate_Prop
   {
      constexpr refreshRate_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GuiApplication::refreshRate_Prop & operator= (GuiApplication::refreshRate_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } refreshRate;
   struct skin_Prop
   {
      constexpr skin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GuiApplication::skin_Prop & operator= (GuiApplication::skin_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } skin;
   struct textMode_Prop
   {
      constexpr textMode_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GuiApplication::textMode_Prop & operator= (GuiApplication::textMode_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } textMode;
   struct desktop_Prop
   {
      constexpr desktop_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } desktop;
   struct drivers_Prop
   {
      constexpr drivers_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/const char ** () const;
   } drivers;
   struct skins_Prop
   {
      constexpr skins_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/const char ** () const;
   } skins;
   struct currentSkin_Prop
   {
      constexpr currentSkin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/C(Class) * () const;
   } currentSkin;
   struct numDrivers_Prop
   {
      constexpr numDrivers_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } numDrivers;
   struct numSkins_Prop
   {
      constexpr numSkins_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } numSkins;
   struct timerResolution_Prop
   {
      constexpr timerResolution_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/uint operator= (/*0G*/uint v);
   } timerResolution;
   struct acquiredWindow_Prop
   {
      constexpr acquiredWindow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } acquiredWindow;
};

#define REG_Interface_acquireInput(m, c)         REGVMETHOD(Interface, acquireInput,         c::m, (/*1Ab*/Window & window, /*1Ab*/bool state),                                                                                              c, (/*4Im*/window, /*4Hm*/(bool)state))
#define REG_Interface_activateRootWindow(m, c)   REGVMETHOD(Interface, activateRootWindow,   c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_allocateClipboard(m, c)    REGVMETHOD(Interface, allocateClipboard,    c::m, (/*1Ab*/ClipBoard clipBoard, /*1Ab*/uint size),                                                                                           c, (/*4Im*/clipBoard, /*4Im*/size))
#define REG_Interface_clearClipboard(m, c)       REGVMETHOD(Interface, clearClipboard,       c::m, (),                                                                                                                                       c, ())
#define REG_Interface_createRootWindow(m, c)     REGVMETHOD(Interface, createRootWindow,     c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_destroyRootWindow(m, c)    REGVMETHOD(Interface, destroyRootWindow,    c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_ensureFullScreen(m, c)     REGVMETHOD(Interface, ensureFullScreen,     c::m, (/*1Ab*/C(bool) * fullScreen),                                                                                                            c, (/*4Hm*/(C(bool) *)fullScreen))
#define REG_Interface_flashRootWindow(m, c)      REGVMETHOD(Interface, flashRootWindow,      c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_getCurrentMode(m, c)       REGVMETHOD(Interface, getCurrentMode,       c::m, (/*1Ab*/C(bool) * fullScreen, /*1Ab*/Resolution * resolution, /*1Ab*/PixelFormat * colorDepth, /*1Ab*/int * refreshRate),                 c, (/*4Hm*/(C(bool) *)fullScreen, /*4Hm*/(Resolution *)resolution, /*4Hm*/(PixelFormat *)colorDepth, /*4Im*/refreshRate))
#define REG_Interface_getJoystickState(m, c)     REGVMETHOD(Interface, getJoystickState,     c::m, (/*1Ab*/int device, /*1Ab*/Joystick & joystick),                                                                                          c, (/*4Im*/device, /*4Im*/joystick))
#define REG_Interface_getKeyState(m, c)          REGVMETHOD(Interface, getKeyState,          c::m, (/*1Ab*/Key key),                                                                                                                         c, (/*4Hm*/(Key)key))
#define REG_Interface_getMousePosition(m, c)     REGVMETHOD(Interface, getMousePosition,     c::m, (/*1Ab*/int * x, /*1Ab*/int * y),                                                                                                         c, (/*4Im*/x, /*4Im*/y))
#define REG_Interface_getMouseState(m, c)        REGVMETHOD(Interface, getMouseState,        c::m, (/*1Ab*/MouseButtons * buttons, /*1Ab*/int * x, /*1Ab*/int * y),                                                                          c, (/*4Hm*/(MouseButtons *)buttons, /*4Im*/x, /*4Im*/y))
#define REG_Interface_getScreenArea(m, c)        REGVMETHOD(Interface, getScreenArea,        c::m, (/*1Ab*/Window & window, /*1Ab*/Box & box),                                                                                               c, (/*4Im*/window, /*4Im*/box))
#define REG_Interface_graphicsDrivers(m, c)      REGVMETHOD(Interface, graphicsDrivers,      c::m, (/*1Ab*/int * numDrivers),                                                                                                                c, (/*4Im*/numDrivers))
#define REG_Interface_initialize(m, c)           REGVMETHOD(Interface, initialize,           c::m, (),                                                                                                                                       c, ())
#define REG_Interface_loadClipboard(m, c)        REGVMETHOD(Interface, loadClipboard,        c::m, (/*1Ab*/ClipBoard clipBoard),                                                                                                             c, (/*4Im*/clipBoard))
#define REG_Interface_lock(m, c)                 REGVMETHOD(Interface, lock,                 c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_offsetWindow(m, c)         REGVMETHOD(Interface, offsetWindow,         c::m, (/*1Ab*/Window & window, /*1Ab*/int * x, /*1Ab*/int * y),                                                                                 c, (/*4Im*/window, /*4Im*/x, /*4Im*/y))
#define REG_Interface_orderRootWindow(m, c)      REGVMETHOD(Interface, orderRootWindow,      c::m, (/*1Ab*/Window & window, /*1Ab*/bool topMost),                                                                                            c, (/*4Im*/window, /*4Hm*/(bool)topMost))
#define REG_Interface_positionRootWindow(m, c)   REGVMETHOD(Interface, positionRootWindow,   c::m, (/*1Ab*/Window & window, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/bool move, /*1Ab*/bool resize),                   c, (/*4Im*/window, /*4Im*/x, /*4Im*/y, /*4Im*/w, /*4Im*/h, /*4Hm*/(bool)move, /*4Hm*/(bool)resize))
#define REG_Interface_processInput(m, c)         REGVMETHOD(Interface, processInput,         c::m, (/*1Ab*/bool processAll),                                                                                                                 c, (/*4Hm*/(bool)processAll))
#define REG_Interface_saveClipboard(m, c)        REGVMETHOD(Interface, saveClipboard,        c::m, (/*1Ab*/ClipBoard clipBoard),                                                                                                             c, (/*4Im*/clipBoard))
#define REG_Interface_screenMode(m, c)           REGVMETHOD(Interface, screenMode,           c::m, (/*1Ab*/bool fullScreen, /*1Ab*/Resolution resolution, /*1Ab*/PixelFormat colorDepth, /*1Ab*/int refreshRate, /*1Ab*/C(bool) * textMode), c, (/*4Hm*/(bool)fullScreen, /*4Hm*/(Resolution)resolution, /*4Hm*/(PixelFormat)colorDepth, /*4Im*/refreshRate, /*4Hm*/(C(bool) *)textMode))
#define REG_Interface_setCaret(m, c)             REGVMETHOD(Interface, setCaret,             c::m, (/*1Ab*/int caretX, /*1Ab*/int caretY, /*1Ab*/int size),                                                                                  c, (/*4Im*/caretX, /*4Im*/caretY, /*4Im*/size))
#define REG_Interface_setIcon(m, c)              REGVMETHOD(Interface, setIcon,              c::m, (/*1Ab*/Window & window, /*1Ab*/BitmapResource & icon),                                                                                   c, (/*4Im*/window, /*4Im*/icon))
#define REG_Interface_setMouseCapture(m, c)      REGVMETHOD(Interface, setMouseCapture,      c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_setMouseCursor(m, c)       REGVMETHOD(Interface, setMouseCursor,       c::m, (/*1Ab*/Window & window, /*1Ab*/SystemCursor cursor),                                                                                     c, (/*4Im*/window, /*4Hm*/(SystemCursor)cursor))
#define REG_Interface_setMousePosition(m, c)     REGVMETHOD(Interface, setMousePosition,     c::m, (/*1Ab*/int x, /*1Ab*/int y),                                                                                                             c, (/*4Im*/x, /*4Im*/y))
#define REG_Interface_setMouseRange(m, c)        REGVMETHOD(Interface, setMouseRange,        c::m, (/*1Ab*/Window & window, /*1Ab*/Box & box),                                                                                               c, (/*4Im*/window, /*4Im*/box))
#define REG_Interface_setRootWindowCaption(m, c) REGVMETHOD(Interface, setRootWindowCaption, c::m, (/*1Ab*/Window & window, /*1Ab*/const char * name),                                                                                       c, (/*4Im*/window, /*4Im*/name))
#define REG_Interface_setRootWindowColor(m, c)   REGVMETHOD(Interface, setRootWindowColor,   c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_setRootWindowState(m, c)   REGVMETHOD(Interface, setRootWindowState,   c::m, (/*1Ab*/Window & window, /*1Ab*/WindowState state, /*1Ab*/bool visible),                                                                  c, (/*4Im*/window, /*4Hm*/(WindowState)state, /*4Hm*/(bool)visible))
#define REG_Interface_setTimerResolution(m, c)   REGVMETHOD(Interface, setTimerResolution,   c::m, (/*1Ab*/uint hertz),                                                                                                                      c, (/*4Im*/hertz))
#define REG_Interface_startMoving(m, c)          REGVMETHOD(Interface, startMoving,          c::m, (/*1Ab*/Window & window, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/bool fromKeyBoard),                                                           c, (/*4Im*/window, /*4Im*/x, /*4Im*/y, /*4Hm*/(bool)fromKeyBoard))
#define REG_Interface_stopMoving(m, c)           REGVMETHOD(Interface, stopMoving,           c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_terminate(m, c)            REGVMETHOD(Interface, terminate,            c::m, (),                                                                                                                                       c, ())
#define REG_Interface_unloadClipboard(m, c)      REGVMETHOD(Interface, unloadClipboard,      c::m, (/*1Ab*/ClipBoard clipBoard),                                                                                                             c, (/*4Im*/clipBoard))
#define REG_Interface_unlock(m, c)               REGVMETHOD(Interface, unlock,               c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_updateRootWindow(m, c)     REGVMETHOD(Interface, updateRootWindow,     c::m, (/*1Ab*/Window & window),                                                                                                                 c, (/*4Im*/window))
#define REG_Interface_wait(m, c)                 REGVMETHOD(Interface, wait,                 c::m, (),                                                                                                                                       c, ())

#define REG_Interface(c) \
      Interface::class_registration(_cpp_class); \
      REG_Interface_acquireInput(acquireInput, c); \
      REG_Interface_activateRootWindow(activateRootWindow, c); \
      REG_Interface_allocateClipboard(allocateClipboard, c); \
      REG_Interface_clearClipboard(clearClipboard, c); \
      REG_Interface_createRootWindow(createRootWindow, c); \
      REG_Interface_destroyRootWindow(destroyRootWindow, c); \
      REG_Interface_ensureFullScreen(ensureFullScreen, c); \
      REG_Interface_flashRootWindow(flashRootWindow, c); \
      REG_Interface_getCurrentMode(getCurrentMode, c); \
      REG_Interface_getJoystickState(getJoystickState, c); \
      REG_Interface_getKeyState(getKeyState, c); \
      REG_Interface_getMousePosition(getMousePosition, c); \
      REG_Interface_getMouseState(getMouseState, c); \
      REG_Interface_getScreenArea(getScreenArea, c); \
      REG_Interface_graphicsDrivers(graphicsDrivers, c); \
      REG_Interface_initialize(initialize, c); \
      REG_Interface_loadClipboard(loadClipboard, c); \
      REG_Interface_lock(lock, c); \
      REG_Interface_offsetWindow(offsetWindow, c); \
      REG_Interface_orderRootWindow(orderRootWindow, c); \
      REG_Interface_positionRootWindow(positionRootWindow, c); \
      REG_Interface_processInput(processInput, c); \
      REG_Interface_saveClipboard(saveClipboard, c); \
      REG_Interface_screenMode(screenMode, c); \
      REG_Interface_setCaret(setCaret, c); \
      REG_Interface_setIcon(setIcon, c); \
      REG_Interface_setMouseCapture(setMouseCapture, c); \
      REG_Interface_setMouseCursor(setMouseCursor, c); \
      REG_Interface_setMousePosition(setMousePosition, c); \
      REG_Interface_setMouseRange(setMouseRange, c); \
      REG_Interface_setRootWindowCaption(setRootWindowCaption, c); \
      REG_Interface_setRootWindowColor(setRootWindowColor, c); \
      REG_Interface_setRootWindowState(setRootWindowState, c); \
      REG_Interface_setTimerResolution(setTimerResolution, c); \
      REG_Interface_startMoving(startMoving, c); \
      REG_Interface_stopMoving(stopMoving, c); \
      REG_Interface_terminate(terminate, c); \
      REG_Interface_unloadClipboard(unloadClipboard, c); \
      REG_Interface_unlock(unlock, c); \
      REG_Interface_updateRootWindow(updateRootWindow, c); \
      REG_Interface_wait(wait, c);

#define INTERFACE_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(acquireInput, acquireInput, c, Interface, \
      bool, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/bool state); \
   VIRTUAL_METHOD_PROTO(activateRootWindow, activateRootWindow, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(allocateClipboard, allocateClipboard, c, Interface, \
      bool, c & _ARG, , /*6Fj*/ClipBoard clipBoard _ARG /*6Fj*/uint size); \
   VIRTUAL_METHOD_PROTO(clearClipboard, clearClipboard, c, Interface, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(createRootWindow, createRootWindow, c, Interface, \
      void *, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(destroyRootWindow, destroyRootWindow, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(ensureFullScreen, ensureFullScreen, c, Interface, \
      void, c & _ARG, , /*6Cj*/C(bool) * fullScreen); \
   VIRTUAL_METHOD_PROTO(flashRootWindow, flashRootWindow, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(getCurrentMode, getCurrentMode, c, Interface, \
      void, c & _ARG, , /*6Cj*/C(bool) * fullScreen _ARG /*6Fj*/Resolution * resolution _ARG /*6Fj*/PixelFormat * colorDepth _ARG /*6Fj*/int * refreshRate); \
   VIRTUAL_METHOD_PROTO(getJoystickState, getJoystickState, c, Interface, \
      bool, c & _ARG, , /*6Fj*/int device _ARG /*6Fj*/Joystick & joystick); \
   VIRTUAL_METHOD_PROTO(getKeyState, getKeyState, c, Interface, \
      bool, c & _ARG, , /*6Fj*/Key key); \
   VIRTUAL_METHOD_PROTO(getMousePosition, getMousePosition, c, Interface, \
      void, c & _ARG, , /*6Fj*/int * x _ARG /*6Fj*/int * y); \
   VIRTUAL_METHOD_PROTO(getMouseState, getMouseState, c, Interface, \
      bool, c & _ARG, , /*6Fj*/MouseButtons * buttons _ARG /*6Fj*/int * x _ARG /*6Fj*/int * y); \
   VIRTUAL_METHOD_PROTO(getScreenArea, getScreenArea, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/Box & box); \
   VIRTUAL_METHOD_PROTO(graphicsDrivers, graphicsDrivers, c, Interface, \
      const char **, c & _ARG, , /*6Fj*/int * numDrivers); \
   VIRTUAL_METHOD_PROTO(initialize, initialize, c, Interface, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(loadClipboard, loadClipboard, c, Interface, \
      bool, c & _ARG, , /*6Fj*/ClipBoard clipBoard); \
   VIRTUAL_METHOD_PROTO(lock, lock, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(offsetWindow, offsetWindow, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/int * x _ARG /*6Fj*/int * y); \
   VIRTUAL_METHOD_PROTO(orderRootWindow, orderRootWindow, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/bool topMost); \
   VIRTUAL_METHOD_PROTO(positionRootWindow, positionRootWindow, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/bool move _ARG /*6Fj*/bool resize); \
   VIRTUAL_METHOD_PROTO(processInput, processInput, c, Interface, \
      bool, c & _ARG, , /*6Fj*/bool processAll); \
   VIRTUAL_METHOD_PROTO(saveClipboard, saveClipboard, c, Interface, \
      bool, c & _ARG, , /*6Fj*/ClipBoard clipBoard); \
   VIRTUAL_METHOD_PROTO(screenMode, screenMode, c, Interface, \
      bool, c & _ARG, , /*6Fj*/bool fullScreen _ARG /*6Fj*/Resolution resolution _ARG /*6Fj*/PixelFormat colorDepth _ARG /*6Fj*/int refreshRate _ARG /*6Cj*/C(bool) * textMode); \
   VIRTUAL_METHOD_PROTO(setCaret, setCaret, c, Interface, \
      void, c & _ARG, , /*6Fj*/int caretX _ARG /*6Fj*/int caretY _ARG /*6Fj*/int size); \
   VIRTUAL_METHOD_PROTO(setIcon, setIcon, c, Interface, \
      bool, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/BitmapResource & icon); \
   VIRTUAL_METHOD_PROTO(setMouseCapture, setMouseCapture, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(setMouseCursor, setMouseCursor, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/SystemCursor cursor); \
   VIRTUAL_METHOD_PROTO(setMousePosition, setMousePosition, c, Interface, \
      void, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y); \
   VIRTUAL_METHOD_PROTO(setMouseRange, setMouseRange, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/Box & box); \
   VIRTUAL_METHOD_PROTO(setRootWindowCaption, setRootWindowCaption, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/const char * name); \
   VIRTUAL_METHOD_PROTO(setRootWindowColor, setRootWindowColor, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(setRootWindowState, setRootWindowState, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/WindowState state _ARG /*6Fj*/bool visible); \
   VIRTUAL_METHOD_PROTO(setTimerResolution, setTimerResolution, c, Interface, \
      void, c & _ARG, , /*6Fj*/uint hertz); \
   VIRTUAL_METHOD_PROTO(startMoving, startMoving, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/bool fromKeyBoard); \
   VIRTUAL_METHOD_PROTO(stopMoving, stopMoving, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(terminate, terminate, c, Interface, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(unloadClipboard, unloadClipboard, c, Interface, \
      void, c & _ARG, , /*6Fj*/ClipBoard clipBoard); \
   VIRTUAL_METHOD_PROTO(unlock, unlock, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(updateRootWindow, updateRootWindow, c, Interface, \
      void, c & _ARG, , /*6Fj*/Window & window); \
   VIRTUAL_METHOD_PROTO(wait, wait, c, Interface, \
      void, c &, , );

#define INTERFACE_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(acquireInput, acquireInput, c, Interface, \
   bool, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/bool state, \
   return (bool)Interface_acquireInput(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(bool))state);); \
VIRTUAL_METHOD(activateRootWindow, activateRootWindow, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_activateRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(allocateClipboard, allocateClipboard, c, Interface, \
   bool, c & _ARG, , /*6Fj*/ClipBoard clipBoard _ARG /*6Fj*/uint size, \
   return (bool)Interface_allocateClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl, /*7Al*/size);); \
VIRTUAL_METHOD(clearClipboard, clearClipboard, c, Interface, \
   void, c &, , , \
   Interface_clearClipboard(self ? self->impl : (C(Interface))null);); \
VIRTUAL_METHOD(createRootWindow, createRootWindow, c, Interface, \
   void *, c & _ARG, , /*6Fj*/Window & window, \
   return Interface_createRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(destroyRootWindow, destroyRootWindow, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_destroyRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(ensureFullScreen, ensureFullScreen, c, Interface, \
   void, c & _ARG, , /*6Cj*/C(bool) * fullScreen, \
   Interface_ensureFullScreen(self ? self->impl : (C(Interface))null, /*7Al*/fullScreen);); \
VIRTUAL_METHOD(flashRootWindow, flashRootWindow, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_flashRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(getCurrentMode, getCurrentMode, c, Interface, \
   void, c & _ARG, , /*6Cj*/C(bool) * fullScreen _ARG /*6Fj*/Resolution * resolution _ARG /*6Fj*/PixelFormat * colorDepth _ARG /*6Fj*/int * refreshRate, \
   Interface_getCurrentMode(self ? self->impl : (C(Interface))null, /*7Al*/fullScreen, /*7Al*/(C(Resolution) *)resolution, /*7Al*/(C(PixelFormat) *)colorDepth, /*7Al*/refreshRate);); \
VIRTUAL_METHOD(getJoystickState, getJoystickState, c, Interface, \
   bool, c & _ARG, , /*6Fj*/int device _ARG /*6Fj*/Joystick & joystick, \
   return (bool)Interface_getJoystickState(self ? self->impl : (C(Interface))null, /*7Al*/device, /*7Al*/&joystick.impl);); \
VIRTUAL_METHOD(getKeyState, getKeyState, c, Interface, \
   bool, c & _ARG, , /*6Fj*/Key key, \
   return (bool)Interface_getKeyState(self ? self->impl : (C(Interface))null, /*7Al*/(C(Key))key);); \
VIRTUAL_METHOD(getMousePosition, getMousePosition, c, Interface, \
   void, c & _ARG, , /*6Fj*/int * x _ARG /*6Fj*/int * y, \
   Interface_getMousePosition(self ? self->impl : (C(Interface))null, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(getMouseState, getMouseState, c, Interface, \
   bool, c & _ARG, , /*6Fj*/MouseButtons * buttons _ARG /*6Fj*/int * x _ARG /*6Fj*/int * y, \
   return (bool)Interface_getMouseState(self ? self->impl : (C(Interface))null, /*7Al*/(C(MouseButtons) *)buttons, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(getScreenArea, getScreenArea, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/Box & box, \
   Interface_getScreenArea(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/&box.impl);); \
VIRTUAL_METHOD(graphicsDrivers, graphicsDrivers, c, Interface, \
   const char **, c & _ARG, , /*6Fj*/int * numDrivers, \
   return Interface_graphicsDrivers(self ? self->impl : (C(Interface))null, /*7Al*/numDrivers);); \
VIRTUAL_METHOD(initialize, initialize, c, Interface, \
   bool, c &, , , \
   return (bool)Interface_initialize(self ? self->impl : (C(Interface))null);); \
VIRTUAL_METHOD(loadClipboard, loadClipboard, c, Interface, \
   bool, c & _ARG, , /*6Fj*/ClipBoard clipBoard, \
   return (bool)Interface_loadClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl);); \
VIRTUAL_METHOD(lock, lock, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_lock(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(offsetWindow, offsetWindow, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/int * x _ARG /*6Fj*/int * y, \
   Interface_offsetWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(orderRootWindow, orderRootWindow, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/bool topMost, \
   Interface_orderRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(bool))topMost);); \
VIRTUAL_METHOD(positionRootWindow, positionRootWindow, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/int w _ARG /*6Fj*/int h _ARG /*6Fj*/bool move _ARG /*6Fj*/bool resize, \
   Interface_positionRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h, /*7Al*/(C(bool))move, /*7Al*/(C(bool))resize);); \
VIRTUAL_METHOD(processInput, processInput, c, Interface, \
   bool, c & _ARG, , /*6Fj*/bool processAll, \
   return (bool)Interface_processInput(self ? self->impl : (C(Interface))null, /*7Al*/(C(bool))processAll);); \
VIRTUAL_METHOD(saveClipboard, saveClipboard, c, Interface, \
   bool, c & _ARG, , /*6Fj*/ClipBoard clipBoard, \
   return (bool)Interface_saveClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl);); \
VIRTUAL_METHOD(screenMode, screenMode, c, Interface, \
   bool, c & _ARG, , /*6Fj*/bool fullScreen _ARG /*6Fj*/Resolution resolution _ARG /*6Fj*/PixelFormat colorDepth _ARG /*6Fj*/int refreshRate _ARG /*6Cj*/C(bool) * textMode, \
   return (bool)Interface_screenMode(self ? self->impl : (C(Interface))null, /*7Al*/(C(bool))fullScreen, /*7Al*/(C(Resolution))resolution, /*7Al*/(C(PixelFormat))colorDepth, /*7Al*/refreshRate, /*7Al*/textMode);); \
VIRTUAL_METHOD(setCaret, setCaret, c, Interface, \
   void, c & _ARG, , /*6Fj*/int caretX _ARG /*6Fj*/int caretY _ARG /*6Fj*/int size, \
   Interface_setCaret(self ? self->impl : (C(Interface))null, /*7Al*/caretX, /*7Al*/caretY, /*7Al*/size);); \
VIRTUAL_METHOD(setIcon, setIcon, c, Interface, \
   bool, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/BitmapResource & icon, \
   return (bool)Interface_setIcon(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/icon.impl);); \
VIRTUAL_METHOD(setMouseCapture, setMouseCapture, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_setMouseCapture(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(setMouseCursor, setMouseCursor, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/SystemCursor cursor, \
   Interface_setMouseCursor(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(SystemCursor))cursor);); \
VIRTUAL_METHOD(setMousePosition, setMousePosition, c, Interface, \
   void, c & _ARG, , /*6Fj*/int x _ARG /*6Fj*/int y, \
   Interface_setMousePosition(self ? self->impl : (C(Interface))null, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(setMouseRange, setMouseRange, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/Box & box, \
   Interface_setMouseRange(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/&box.impl);); \
VIRTUAL_METHOD(setRootWindowCaption, setRootWindowCaption, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/const char * name, \
   Interface_setRootWindowCaption(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/name);); \
VIRTUAL_METHOD(setRootWindowColor, setRootWindowColor, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_setRootWindowColor(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(setRootWindowState, setRootWindowState, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/WindowState state _ARG /*6Fj*/bool visible, \
   Interface_setRootWindowState(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(WindowState))state, /*7Al*/(C(bool))visible);); \
VIRTUAL_METHOD(setTimerResolution, setTimerResolution, c, Interface, \
   void, c & _ARG, , /*6Fj*/uint hertz, \
   Interface_setTimerResolution(self ? self->impl : (C(Interface))null, /*7Al*/hertz);); \
VIRTUAL_METHOD(startMoving, startMoving, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/bool fromKeyBoard, \
   Interface_startMoving(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(bool))fromKeyBoard);); \
VIRTUAL_METHOD(stopMoving, stopMoving, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_stopMoving(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(terminate, terminate, c, Interface, \
   void, c &, , , \
   Interface_terminate(self ? self->impl : (C(Interface))null);); \
VIRTUAL_METHOD(unloadClipboard, unloadClipboard, c, Interface, \
   void, c & _ARG, , /*6Fj*/ClipBoard clipBoard, \
   Interface_unloadClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl);); \
VIRTUAL_METHOD(unlock, unlock, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_unlock(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(updateRootWindow, updateRootWindow, c, Interface, \
   void, c & _ARG, , /*6Fj*/Window & window, \
   Interface_updateRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);); \
VIRTUAL_METHOD(wait, wait, c, Interface, \
   void, c &, , , \
   Interface_wait(self ? self->impl : (C(Interface))null););

class Interface : public Instance
{
public:
   inline Interface(Interface && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Interface & operator= (Interface && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Interface() : Interface((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Interface> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Interface * inst = new Interface(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Interface * inst = (Interface *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Interface & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Interface(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   static inline C(Key) getExtendedKey(/*1Ab*/Key key); // Interface_getExtendedKey
   static inline char translateKey(/*1Ab*/Key key, /*1Ab*/bool shift); // Interface_translateKey
   static inline void writeKeyedText(/*1Ab*/Surface & surface, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/Key hotKey); // Interface_writeKeyedText
   static inline void writeKeyedTextDisabled(/*1Ab*/Surface & surface, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/Key hotKey, /*1Ab*/bool disabled); // Interface_writeKeyedTextDisabled

   struct Interface_acquireInput_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/bool state);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Window & window, /*6Fj*/bool state);
   } acquireInput;
   // inline static void register_acquireInput(CPPClass & cl, Interface::Interface_acquireInput_Functor::FunctionType func)

   struct Interface_activateRootWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } activateRootWindow;
   // inline static void register_activateRootWindow(CPPClass & cl, Interface::Interface_activateRootWindow_Functor::FunctionType func)

   struct Interface_allocateClipboard_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/ClipBoard clipBoard, /*6Fj*/uint size);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/ClipBoard clipBoard, /*6Fj*/uint size);
   } allocateClipboard;
   // inline static void register_allocateClipboard(CPPClass & cl, Interface::Interface_allocateClipboard_Functor::FunctionType func)

   struct Interface_clearClipboard_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } clearClipboard;
   // inline static void register_clearClipboard(CPPClass & cl, Interface::Interface_clearClipboard_Functor::FunctionType func)

   struct Interface_createRootWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void * (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void * operator()( /*6Fj*/Window & window);
   } createRootWindow;
   // inline static void register_createRootWindow(CPPClass & cl, Interface::Interface_createRootWindow_Functor::FunctionType func)

   struct Interface_destroyRootWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } destroyRootWindow;
   // inline static void register_destroyRootWindow(CPPClass & cl, Interface::Interface_destroyRootWindow_Functor::FunctionType func)

   struct Interface_ensureFullScreen_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Cj*/C(bool) * fullScreen);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Cj*/C(bool) * fullScreen);
   } ensureFullScreen;
   // inline static void register_ensureFullScreen(CPPClass & cl, Interface::Interface_ensureFullScreen_Functor::FunctionType func)

   struct Interface_flashRootWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } flashRootWindow;
   // inline static void register_flashRootWindow(CPPClass & cl, Interface::Interface_flashRootWindow_Functor::FunctionType func)

   struct Interface_getCurrentMode_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Cj*/C(bool) * fullScreen, /*6Fj*/Resolution * resolution, /*6Fj*/PixelFormat * colorDepth, /*6Fj*/int * refreshRate);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Cj*/C(bool) * fullScreen, /*6Fj*/Resolution * resolution, /*6Fj*/PixelFormat * colorDepth, /*6Fj*/int * refreshRate);
   } getCurrentMode;
   // inline static void register_getCurrentMode(CPPClass & cl, Interface::Interface_getCurrentMode_Functor::FunctionType func)

   struct Interface_getJoystickState_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/int device, /*6Fj*/Joystick & joystick);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int device, /*6Fj*/Joystick & joystick);
   } getJoystickState;
   // inline static void register_getJoystickState(CPPClass & cl, Interface::Interface_getJoystickState_Functor::FunctionType func)

   struct Interface_getKeyState_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/Key key);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Key key);
   } getKeyState;
   // inline static void register_getKeyState(CPPClass & cl, Interface::Interface_getKeyState_Functor::FunctionType func)

   struct Interface_getMousePosition_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/int * x, /*6Fj*/int * y);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int * x, /*6Fj*/int * y);
   } getMousePosition;
   // inline static void register_getMousePosition(CPPClass & cl, Interface::Interface_getMousePosition_Functor::FunctionType func)

   struct Interface_getMouseState_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/MouseButtons * buttons, /*6Fj*/int * x, /*6Fj*/int * y);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/MouseButtons * buttons, /*6Fj*/int * x, /*6Fj*/int * y);
   } getMouseState;
   // inline static void register_getMouseState(CPPClass & cl, Interface::Interface_getMouseState_Functor::FunctionType func)

   struct Interface_getScreenArea_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/Box & box);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/Box & box);
   } getScreenArea;
   // inline static void register_getScreenArea(CPPClass & cl, Interface::Interface_getScreenArea_Functor::FunctionType func)

   struct Interface_graphicsDrivers_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char ** (* FunctionType)(Interface & , /*6Fj*/int * numDrivers);
      inline FunctionType operator= (FunctionType func);
      inline const char ** operator()( /*6Fj*/int * numDrivers);
   } graphicsDrivers;
   // inline static void register_graphicsDrivers(CPPClass & cl, Interface::Interface_graphicsDrivers_Functor::FunctionType func)

   struct Interface_initialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } initialize;
   // inline static void register_initialize(CPPClass & cl, Interface::Interface_initialize_Functor::FunctionType func)

   struct Interface_loadClipboard_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/ClipBoard clipBoard);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/ClipBoard clipBoard);
   } loadClipboard;
   // inline static void register_loadClipboard(CPPClass & cl, Interface::Interface_loadClipboard_Functor::FunctionType func)

   struct Interface_lock_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } lock;
   // inline static void register_lock(CPPClass & cl, Interface::Interface_lock_Functor::FunctionType func)

   struct Interface_offsetWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/int * x, /*6Fj*/int * y);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/int * x, /*6Fj*/int * y);
   } offsetWindow;
   // inline static void register_offsetWindow(CPPClass & cl, Interface::Interface_offsetWindow_Functor::FunctionType func)

   struct Interface_orderRootWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/bool topMost);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/bool topMost);
   } orderRootWindow;
   // inline static void register_orderRootWindow(CPPClass & cl, Interface::Interface_orderRootWindow_Functor::FunctionType func)

   struct Interface_positionRootWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/bool move, /*6Fj*/bool resize);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/bool move, /*6Fj*/bool resize);
   } positionRootWindow;
   // inline static void register_positionRootWindow(CPPClass & cl, Interface::Interface_positionRootWindow_Functor::FunctionType func)

   struct Interface_processInput_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/bool processAll);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/bool processAll);
   } processInput;
   // inline static void register_processInput(CPPClass & cl, Interface::Interface_processInput_Functor::FunctionType func)

   struct Interface_saveClipboard_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/ClipBoard clipBoard);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/ClipBoard clipBoard);
   } saveClipboard;
   // inline static void register_saveClipboard(CPPClass & cl, Interface::Interface_saveClipboard_Functor::FunctionType func)

   struct Interface_screenMode_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/bool fullScreen, /*6Fj*/Resolution resolution, /*6Fj*/PixelFormat colorDepth, /*6Fj*/int refreshRate, /*6Cj*/C(bool) * textMode);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/bool fullScreen, /*6Fj*/Resolution resolution, /*6Fj*/PixelFormat colorDepth, /*6Fj*/int refreshRate, /*6Cj*/C(bool) * textMode);
   } screenMode;
   // inline static void register_screenMode(CPPClass & cl, Interface::Interface_screenMode_Functor::FunctionType func)

   struct Interface_setCaret_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/int caretX, /*6Fj*/int caretY, /*6Fj*/int size);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int caretX, /*6Fj*/int caretY, /*6Fj*/int size);
   } setCaret;
   // inline static void register_setCaret(CPPClass & cl, Interface::Interface_setCaret_Functor::FunctionType func)

   struct Interface_setIcon_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/BitmapResource & icon);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Window & window, /*6Fj*/BitmapResource & icon);
   } setIcon;
   // inline static void register_setIcon(CPPClass & cl, Interface::Interface_setIcon_Functor::FunctionType func)

   struct Interface_setMouseCapture_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } setMouseCapture;
   // inline static void register_setMouseCapture(CPPClass & cl, Interface::Interface_setMouseCapture_Functor::FunctionType func)

   struct Interface_setMouseCursor_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/SystemCursor cursor);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/SystemCursor cursor);
   } setMouseCursor;
   // inline static void register_setMouseCursor(CPPClass & cl, Interface::Interface_setMouseCursor_Functor::FunctionType func)

   struct Interface_setMousePosition_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/int x, /*6Fj*/int y);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int x, /*6Fj*/int y);
   } setMousePosition;
   // inline static void register_setMousePosition(CPPClass & cl, Interface::Interface_setMousePosition_Functor::FunctionType func)

   struct Interface_setMouseRange_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/Box & box);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/Box & box);
   } setMouseRange;
   // inline static void register_setMouseRange(CPPClass & cl, Interface::Interface_setMouseRange_Functor::FunctionType func)

   struct Interface_setRootWindowCaption_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/const char * name);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/const char * name);
   } setRootWindowCaption;
   // inline static void register_setRootWindowCaption(CPPClass & cl, Interface::Interface_setRootWindowCaption_Functor::FunctionType func)

   struct Interface_setRootWindowColor_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } setRootWindowColor;
   // inline static void register_setRootWindowColor(CPPClass & cl, Interface::Interface_setRootWindowColor_Functor::FunctionType func)

   struct Interface_setRootWindowState_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/WindowState state, /*6Fj*/bool visible);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/WindowState state, /*6Fj*/bool visible);
   } setRootWindowState;
   // inline static void register_setRootWindowState(CPPClass & cl, Interface::Interface_setRootWindowState_Functor::FunctionType func)

   struct Interface_setTimerResolution_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/uint hertz);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/uint hertz);
   } setTimerResolution;
   // inline static void register_setTimerResolution(CPPClass & cl, Interface::Interface_setTimerResolution_Functor::FunctionType func)

   struct Interface_startMoving_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/bool fromKeyBoard);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/bool fromKeyBoard);
   } startMoving;
   // inline static void register_startMoving(CPPClass & cl, Interface::Interface_startMoving_Functor::FunctionType func)

   struct Interface_stopMoving_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } stopMoving;
   // inline static void register_stopMoving(CPPClass & cl, Interface::Interface_stopMoving_Functor::FunctionType func)

   struct Interface_terminate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } terminate;
   // inline static void register_terminate(CPPClass & cl, Interface::Interface_terminate_Functor::FunctionType func)

   struct Interface_unloadClipboard_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/ClipBoard clipBoard);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/ClipBoard clipBoard);
   } unloadClipboard;
   // inline static void register_unloadClipboard(CPPClass & cl, Interface::Interface_unloadClipboard_Functor::FunctionType func)

   struct Interface_unlock_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } unlock;
   // inline static void register_unlock(CPPClass & cl, Interface::Interface_unlock_Functor::FunctionType func)

   struct Interface_updateRootWindow_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface & , /*6Fj*/Window & window);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & window);
   } updateRootWindow;
   // inline static void register_updateRootWindow(CPPClass & cl, Interface::Interface_updateRootWindow_Functor::FunctionType func)

   struct Interface_wait_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Interface &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } wait;
   // inline static void register_wait(CPPClass & cl, Interface::Interface_wait_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};

struct Joystick : public TStruct<Joystick>
{
public:
   C(Joystick) impl;
   constexpr Joystick() : impl({}) { }
   constexpr Joystick(const C(Joystick) impl) : impl(impl) { }

   inline Joystick(int x, int y, int z, int rx, int ry, int rz, uint buttons);

   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Joystick::x_Prop & operator= (Joystick::x_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Joystick::y_Prop & operator= (Joystick::y_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } y;
   struct z_Prop
   {
      constexpr z_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Joystick::z_Prop & operator= (Joystick::z_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } z;
   struct rx_Prop
   {
      constexpr rx_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Joystick::rx_Prop & operator= (Joystick::rx_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } rx;
   struct ry_Prop
   {
      constexpr ry_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Joystick::ry_Prop & operator= (Joystick::ry_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } ry;
   struct rz_Prop
   {
      constexpr rz_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Joystick::rz_Prop & operator= (Joystick::rz_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } rz;
   struct buttons_Prop
   {
      constexpr buttons_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline Joystick::buttons_Prop & operator= (Joystick::buttons_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } buttons;
};

enum class KeyCode : uint
{
   escape = KeyCode_escape,
   k1 = KeyCode_k1,
   bang = KeyCode_bang,
   k2 = KeyCode_k2,
   commercial = KeyCode_commercial,
   k3 = KeyCode_k3,
   pound = KeyCode_pound,
   k4 = KeyCode_k4,
   dollar = KeyCode_dollar,
   k5 = KeyCode_k5,
   percent = KeyCode_percent,
   k6 = KeyCode_k6,
   circumflex = KeyCode_circumflex,
   k7 = KeyCode_k7,
   ampersand = KeyCode_ampersand,
   k8 = KeyCode_k8,
   star = KeyCode_star,
   k9 = KeyCode_k9,
   leftParanthesis = KeyCode_leftParanthesis,
   k0 = KeyCode_k0,
   rightParanthesis = KeyCode_rightParanthesis,
   minus = KeyCode_minus,
   underscore = KeyCode_underscore,
   equal = KeyCode_equal,
   plus = KeyCode_plus,
   backSpace = KeyCode_backSpace,
   tab = KeyCode_tab,
   q = KeyCode_q,
   w = KeyCode_w,
   e = KeyCode_e,
   r = KeyCode_r,
   t = KeyCode_t,
   y = KeyCode_y,
   u = KeyCode_u,
   i = KeyCode_i,
   o = KeyCode_o,
   p = KeyCode_p,
   leftBracket = KeyCode_leftBracket,
   rightBracket = KeyCode_rightBracket,
   enter = KeyCode_enter,
   leftControl = KeyCode_leftControl,
   a = KeyCode_a,
   s = KeyCode_s,
   d = KeyCode_d,
   f = KeyCode_f,
   g = KeyCode_g,
   h = KeyCode_h,
   j = KeyCode_j,
   k = KeyCode_k,
   l = KeyCode_l,
   semicolon = KeyCode_semicolon,
   colon = KeyCode_colon,
   quote = KeyCode_quote,
   doubleQuote = KeyCode_doubleQuote,
   tilde = KeyCode_tilde,
   backQuote = KeyCode_backQuote,
   leftShift = KeyCode_leftShift,
   backSlash = KeyCode_backSlash,
   pipe = KeyCode_pipe,
   z = KeyCode_z,
   x = KeyCode_x,
   c = KeyCode_c,
   v = KeyCode_v,
   b = KeyCode_b,
   n = KeyCode_n,
   m = KeyCode_m,
   comma = KeyCode_comma,
   smallerThan = KeyCode_smallerThan,
   period = KeyCode_period,
   greaterThan = KeyCode_greaterThan,
   slash = KeyCode_slash,
   questionMark = KeyCode_questionMark,
   rightShift = KeyCode_rightShift,
   keyPadStar = KeyCode_keyPadStar,
   leftAlt = KeyCode_leftAlt,
   space = KeyCode_space,
   capsLock = KeyCode_capsLock,
   f1 = KeyCode_f1,
   f2 = KeyCode_f2,
   f3 = KeyCode_f3,
   f4 = KeyCode_f4,
   f5 = KeyCode_f5,
   f6 = KeyCode_f6,
   f7 = KeyCode_f7,
   f8 = KeyCode_f8,
   f9 = KeyCode_f9,
   f10 = KeyCode_f10,
   numLock = KeyCode_numLock,
   scrollLock = KeyCode_scrollLock,
   keyPadHome = KeyCode_keyPadHome,
   keyPad7 = KeyCode_keyPad7,
   keyPadUp = KeyCode_keyPadUp,
   keyPad8 = KeyCode_keyPad8,
   keyPadPageUp = KeyCode_keyPadPageUp,
   keyPad9 = KeyCode_keyPad9,
   keyPadMinus = KeyCode_keyPadMinus,
   keyPadLeft = KeyCode_keyPadLeft,
   keyPad4 = KeyCode_keyPad4,
   keyPad5 = KeyCode_keyPad5,
   keyPadRight = KeyCode_keyPadRight,
   keyPad6 = KeyCode_keyPad6,
   keyPadPlus = KeyCode_keyPadPlus,
   keyPadEnd = KeyCode_keyPadEnd,
   keyPad1 = KeyCode_keyPad1,
   keyPadDown = KeyCode_keyPadDown,
   keyPad2 = KeyCode_keyPad2,
   keyPadPageDown = KeyCode_keyPadPageDown,
   keyPad3 = KeyCode_keyPad3,
   keyPadInsert = KeyCode_keyPadInsert,
   keyPad0 = KeyCode_keyPad0,
   keyPadDelete = KeyCode_keyPadDelete,
   f11 = KeyCode_f11,
   f12 = KeyCode_f12,
   keyPadEnter = KeyCode_keyPadEnter,
   rightControl = KeyCode_rightControl,
   keyPadSlash = KeyCode_keyPadSlash,
   printScreen = KeyCode_printScreen,
   rightAlt = KeyCode_rightAlt,
   pauseBreak = KeyCode_pauseBreak,
   home = KeyCode_home,
   up = KeyCode_up,
   pageUp = KeyCode_pageUp,
   left = KeyCode_left,
   right = KeyCode_right,
   end = KeyCode_end,
   down = KeyCode_down,
   pageDown = KeyCode_pageDown,
   insert = KeyCode_insert,
   del = KeyCode_del,
   shift = KeyCode_shift,
   alt = KeyCode_alt,
   control = KeyCode_control,
   wheelUp = KeyCode_wheelUp,
   wheelDown = KeyCode_wheelDown,
   hotKey = KeyCode_hotKey,
   defaultKey = KeyCode_defaultKey,
   capsState = KeyCode_capsState,
   numState = KeyCode_numState,
   scrollState = KeyCode_scrollState,
   play = KeyCode_play,
   record = KeyCode_record,
   pause = KeyCode_pause,
   rewind = KeyCode_rewind,
   fastForward = KeyCode_fastForward,
   previousTrack = KeyCode_previousTrack,
   nextTrack = KeyCode_nextTrack,
   stop = KeyCode_stop,
   eject = KeyCode_eject,
   volumeUp = KeyCode_volumeUp,
   volumeDown = KeyCode_volumeDown,
   mute = KeyCode_mute,
   remoteHome = KeyCode_remoteHome,
   back = KeyCode_back,
   menu1 = KeyCode_menu1,
   menu2 = KeyCode_menu2,
   menu3 = KeyCode_menu3,
   menu4 = KeyCode_menu4,
   select = KeyCode_select,
   bassBoost = KeyCode_bassBoost,
   bassDown = KeyCode_bassDown,
   bassUp = KeyCode_bassUp,
   browserBackward = KeyCode_browserBackward,
   browserFavorites = KeyCode_browserFavorites,
   browserForward = KeyCode_browserForward,
   browserHome = KeyCode_browserHome,
   browserRefresh = KeyCode_browserRefresh,
   browserSearch = KeyCode_browserSearch,
   browserStop = KeyCode_browserStop,
   launchApp1 = KeyCode_launchApp1,
   launchApp2 = KeyCode_launchApp2,
   launchMail = KeyCode_launchMail,
   launchMediaSelect = KeyCode_launchMediaSelect,
   micVolumeDown = KeyCode_micVolumeDown,
   micMute = KeyCode_micMute,
   micVolumeUp = KeyCode_micVolumeUp,
   trebleDown = KeyCode_trebleDown,
   trebleUp = KeyCode_trebleUp
};

struct MiddleAnchorValue : public TStruct<MiddleAnchorValue>
{
public:
   C(MiddleAnchorValue) impl;
   constexpr MiddleAnchorValue() : impl({}) { }
   constexpr MiddleAnchorValue(const C(MiddleAnchorValue) impl) : impl(impl) { }
   inline operator MinMaxValue() const;
   inline MiddleAnchorValue(const MinMaxValue & m);
   inline MiddleAnchorValue & operator =(const MinMaxValue & m);

   inline MiddleAnchorValue(AnchorValueType type, int distance, float percent);

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/AnchorValueType operator= (/*0H*/AnchorValueType v);
      /*regSet*/inline MiddleAnchorValue::type_Prop & operator= (MiddleAnchorValue::type_Prop & prop);
      /*regGet*/inline operator /*0I*/AnchorValueType () const;
   } type;
   struct distance_Prop
   {
      constexpr distance_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline MiddleAnchorValue::distance_Prop & operator= (MiddleAnchorValue::distance_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } distance;
   struct percent_Prop
   {
      constexpr percent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline MiddleAnchorValue::percent_Prop & operator= (MiddleAnchorValue::percent_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } percent;
};

class Modifiers
{
public:
   C(Modifiers) impl;
   constexpr Modifiers() : impl(0) { }
   constexpr Modifiers(C(Modifiers) impl) : impl(impl) { }
   operator C(Modifiers)() { return impl; }
   Modifiers & operator =(C(Modifiers) impl) { impl = impl; return *this; }
   bool operator ==(const Modifiers & value) const { return impl == value.impl; }
   bool operator !=(const Modifiers & value) const { return impl != value.impl; }

   struct shift_Prop
   {
      constexpr shift_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::shift_Prop & operator= (Modifiers::shift_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } shift;
   struct ctrl_Prop
   {
      constexpr ctrl_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::ctrl_Prop & operator= (Modifiers::ctrl_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } ctrl;
   struct alt_Prop
   {
      constexpr alt_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::alt_Prop & operator= (Modifiers::alt_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alt;
   struct cmd_Prop
   {
      constexpr cmd_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::cmd_Prop & operator= (Modifiers::cmd_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } cmd;
   struct left_Prop
   {
      constexpr left_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::left_Prop & operator= (Modifiers::left_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } left;
   struct middle_Prop
   {
      constexpr middle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::middle_Prop & operator= (Modifiers::middle_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } middle;
   struct right_Prop
   {
      constexpr right_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::right_Prop & operator= (Modifiers::right_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } right;
   struct isActivate_Prop
   {
      constexpr isActivate_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::isActivate_Prop & operator= (Modifiers::isActivate_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isActivate;
   struct isSideEffect_Prop
   {
      constexpr isSideEffect_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::isSideEffect_Prop & operator= (Modifiers::isSideEffect_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isSideEffect;
   struct closingDropDown_Prop
   {
      constexpr closingDropDown_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Modifiers::closingDropDown_Prop & operator= (Modifiers::closingDropDown_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } closingDropDown;
};

class MouseButtons
{
public:
   C(MouseButtons) impl;
   constexpr MouseButtons() : impl(0) { }
   constexpr MouseButtons(C(MouseButtons) impl) : impl(impl) { }
   MouseButtons(bool left, bool right, bool middle);
   operator C(MouseButtons)() { return impl; }
   MouseButtons & operator =(C(MouseButtons) impl) { impl = impl; return *this; }
   bool operator ==(const MouseButtons & value) const { return impl == value.impl; }
   bool operator !=(const MouseButtons & value) const { return impl != value.impl; }

   struct left_Prop
   {
      constexpr left_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MouseButtons::left_Prop & operator= (MouseButtons::left_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } left;
   struct right_Prop
   {
      constexpr right_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MouseButtons::right_Prop & operator= (MouseButtons::right_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } right;
   struct middle_Prop
   {
      constexpr middle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MouseButtons::middle_Prop & operator= (MouseButtons::middle_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } middle;
};

class Percentage
{
public:
   C(Percentage) impl;
   constexpr Percentage() : impl(0) { }
   constexpr Percentage(C(Percentage) value) : impl(value) { }
   operator C(Percentage)() const { return impl; }
   constexpr Percentage(const Percentage & value) : impl(value.impl) { }
   Percentage & operator =(float value) { impl = value; return *this; }
   Percentage & operator +=(Percentage value) { impl += value.impl; return *this; }
   Percentage & operator -=(Percentage value) { impl -= value.impl; return *this; }
   Percentage operator +(const Percentage & b) const { return Percentage(impl + b.impl); }
   Percentage operator -(const Percentage & b) const { return Percentage(impl - b.impl); }
   bool operator ==(const Percentage & value) const { return impl == value.impl; }
   bool operator !=(const Percentage & value) const { return impl != value.impl; }
   bool operator <(const Percentage & value) const { return impl < value.impl; }
   bool operator >(const Percentage & value) const { return impl > value.impl; }
   bool operator <=(const Percentage & value) const { return impl <= value.impl; }
   bool operator >=(const Percentage & value) const { return impl >= value.impl; }
   bool operator ==(float value) const { return impl == Percentage(value).impl; }
   bool operator !=(float value) const { return impl != Percentage(value).impl; }
   bool operator <(float value) const { return impl < Percentage(value).impl; }
   bool operator >(float value) const { return impl > Percentage(value).impl; }
   bool operator <=(float value) const { return impl <= Percentage(value).impl; }
   bool operator >=(float value) const { return impl >= Percentage(value).impl; }
   bool operator ==(int value) const { return impl == Percentage(value).impl; }
   bool operator !=(int value) const { return impl != Percentage(value).impl; }
   bool operator <(int value) const { return impl < Percentage(value).impl; }
   bool operator >(int value) const { return impl > Percentage(value).impl; }
   bool operator <=(int value) const { return impl <= Percentage(value).impl; }
   bool operator >=(int value) const { return impl >= Percentage(value).impl; }
};

enum class PredefinedKey : uint
{
   alt0 = PredefinedKey_alt0,
   alt1 = PredefinedKey_alt1,
   alt2 = PredefinedKey_alt2,
   alt3 = PredefinedKey_alt3,
   alt4 = PredefinedKey_alt4,
   alt5 = PredefinedKey_alt5,
   alt6 = PredefinedKey_alt6,
   alt7 = PredefinedKey_alt7,
   alt8 = PredefinedKey_alt8,
   alt9 = PredefinedKey_alt9,
   altA = PredefinedKey_altA,
   altB = PredefinedKey_altB,
   altC = PredefinedKey_altC,
   altD = PredefinedKey_altD,
   altE = PredefinedKey_altE,
   altF = PredefinedKey_altF,
   altG = PredefinedKey_altG,
   altH = PredefinedKey_altH,
   altI = PredefinedKey_altI,
   altJ = PredefinedKey_altJ,
   altK = PredefinedKey_altK,
   altL = PredefinedKey_altL,
   altM = PredefinedKey_altM,
   altN = PredefinedKey_altN,
   altO = PredefinedKey_altO,
   altP = PredefinedKey_altP,
   altQ = PredefinedKey_altQ,
   altR = PredefinedKey_altR,
   altS = PredefinedKey_altS,
   altT = PredefinedKey_altT,
   altU = PredefinedKey_altU,
   altV = PredefinedKey_altV,
   altW = PredefinedKey_altW,
   altX = PredefinedKey_altX,
   altY = PredefinedKey_altY,
   altZ = PredefinedKey_altZ,
   altF1 = PredefinedKey_altF1,
   altF2 = PredefinedKey_altF2,
   altF3 = PredefinedKey_altF3,
   altF4 = PredefinedKey_altF4,
   altF5 = PredefinedKey_altF5,
   altF6 = PredefinedKey_altF6,
   altF7 = PredefinedKey_altF7,
   altF8 = PredefinedKey_altF8,
   altF9 = PredefinedKey_altF9,
   altF10 = PredefinedKey_altF10,
   altF11 = PredefinedKey_altF11,
   altF12 = PredefinedKey_altF12,
   altLeft = PredefinedKey_altLeft,
   altRight = PredefinedKey_altRight,
   altUp = PredefinedKey_altUp,
   altDown = PredefinedKey_altDown,
   altEnter = PredefinedKey_altEnter,
   altKeyPadEnter = PredefinedKey_altKeyPadEnter,
   altHome = PredefinedKey_altHome,
   altEnd = PredefinedKey_altEnd,
   altMinus = PredefinedKey_altMinus,
   altSpace = PredefinedKey_altSpace,
   ctrl0 = PredefinedKey_ctrl0,
   ctrl1 = PredefinedKey_ctrl1,
   ctrl2 = PredefinedKey_ctrl2,
   ctrl3 = PredefinedKey_ctrl3,
   ctrl4 = PredefinedKey_ctrl4,
   ctrl5 = PredefinedKey_ctrl5,
   ctrl6 = PredefinedKey_ctrl6,
   ctrl7 = PredefinedKey_ctrl7,
   ctrl8 = PredefinedKey_ctrl8,
   ctrl9 = PredefinedKey_ctrl9,
   ctrlA = PredefinedKey_ctrlA,
   ctrlB = PredefinedKey_ctrlB,
   ctrlC = PredefinedKey_ctrlC,
   ctrlD = PredefinedKey_ctrlD,
   ctrlE = PredefinedKey_ctrlE,
   ctrlF = PredefinedKey_ctrlF,
   ctrlG = PredefinedKey_ctrlG,
   ctrlH = PredefinedKey_ctrlH,
   ctrlI = PredefinedKey_ctrlI,
   ctrlJ = PredefinedKey_ctrlJ,
   ctrlK = PredefinedKey_ctrlK,
   ctrlL = PredefinedKey_ctrlL,
   ctrlM = PredefinedKey_ctrlM,
   ctrlN = PredefinedKey_ctrlN,
   ctrlO = PredefinedKey_ctrlO,
   ctrlP = PredefinedKey_ctrlP,
   ctrlQ = PredefinedKey_ctrlQ,
   ctrlR = PredefinedKey_ctrlR,
   ctrlS = PredefinedKey_ctrlS,
   ctrlT = PredefinedKey_ctrlT,
   ctrlU = PredefinedKey_ctrlU,
   ctrlV = PredefinedKey_ctrlV,
   ctrlW = PredefinedKey_ctrlW,
   ctrlX = PredefinedKey_ctrlX,
   ctrlY = PredefinedKey_ctrlY,
   ctrlZ = PredefinedKey_ctrlZ,
   ctrlF1 = PredefinedKey_ctrlF1,
   ctrlF2 = PredefinedKey_ctrlF2,
   ctrlF3 = PredefinedKey_ctrlF3,
   ctrlF4 = PredefinedKey_ctrlF4,
   ctrlF5 = PredefinedKey_ctrlF5,
   ctrlF6 = PredefinedKey_ctrlF6,
   ctrlF7 = PredefinedKey_ctrlF7,
   ctrlF8 = PredefinedKey_ctrlF8,
   ctrlF9 = PredefinedKey_ctrlF9,
   ctrlF10 = PredefinedKey_ctrlF10,
   ctrlF11 = PredefinedKey_ctrlF11,
   ctrlF12 = PredefinedKey_ctrlF12,
   ctrlLeft = PredefinedKey_ctrlLeft,
   ctrlRight = PredefinedKey_ctrlRight,
   ctrlUp = PredefinedKey_ctrlUp,
   ctrlDown = PredefinedKey_ctrlDown,
   ctrlEnter = PredefinedKey_ctrlEnter,
   ctrlHome = PredefinedKey_ctrlHome,
   ctrlEnd = PredefinedKey_ctrlEnd,
   ctrlPageUp = PredefinedKey_ctrlPageUp,
   ctrlPageDown = PredefinedKey_ctrlPageDown,
   ctrlInsert = PredefinedKey_ctrlInsert,
   ctrlSpace = PredefinedKey_ctrlSpace,
   shiftTab = PredefinedKey_shiftTab,
   shiftF1 = PredefinedKey_shiftF1,
   shiftF2 = PredefinedKey_shiftF2,
   shiftF3 = PredefinedKey_shiftF3,
   shiftF4 = PredefinedKey_shiftF4,
   shiftF5 = PredefinedKey_shiftF5,
   shiftF6 = PredefinedKey_shiftF6,
   shiftF7 = PredefinedKey_shiftF7,
   shiftF8 = PredefinedKey_shiftF8,
   shiftF9 = PredefinedKey_shiftF9,
   shiftF10 = PredefinedKey_shiftF10,
   shiftF11 = PredefinedKey_shiftF11,
   shiftF12 = PredefinedKey_shiftF12,
   shiftInsert = PredefinedKey_shiftInsert,
   shiftDel = PredefinedKey_shiftDel
};

struct SizeAnchor : public TStruct<SizeAnchor>
{
public:
   C(SizeAnchor) impl;
   constexpr SizeAnchor() : impl({}) { }
   constexpr SizeAnchor(const C(SizeAnchor) impl) : impl(impl) { }

   inline SizeAnchor(Size size, bool isClientW, bool isClientH);

   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Size operator= (/*0H*/Size v);
      /*regSet*/inline SizeAnchor::size_Prop & operator= (SizeAnchor::size_Prop & prop);
      /*regGet*/inline operator /*0I*/Size () const;
   } size;
   struct isClientW_Prop
   {
      constexpr isClientW_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline SizeAnchor::isClientW_Prop & operator= (SizeAnchor::isClientW_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isClientW;
   struct isClientH_Prop
   {
      constexpr isClientH_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline SizeAnchor::isClientH_Prop & operator= (SizeAnchor::isClientH_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isClientH;
};

#define REG_Skin_captionFont(m, c)        REGVMETHOD(Skin, captionFont,        c::m, (),                                                                                                                                                                            c, ())
#define REG_Skin_cursorsBitmaps(m, c)     REGVMETHOD(Skin, cursorsBitmaps,     c::m, (/*1Ab*/uint id, /*1Ab*/int * hotSpotX, /*1Ab*/int * hotSpotY, /*1Ab*/byte ** paletteShades),                                                                                  c, (/*4Im*/id, /*4Im*/hotSpotX, /*4Im*/hotSpotY, /*4Im*/paletteShades))
#define REG_Skin_getBitmap(m, c)          REGVMETHOD(Skin, getBitmap,          c::m, (/*1Ab*/SkinBitmap ap1),                                                                                                                                                       c, (/*4Hm*/(SkinBitmap)ap1))
#define REG_Skin_getDecorationsSize(m, c) REGVMETHOD(Skin, getDecorationsSize, c::m, (/*1Ab*/Window & ap1, /*1Ab*/MinMaxValue * ap2, /*1Ab*/MinMaxValue * ap3),                                                                                                     c, (/*4Im*/ap1, /*4Hm*/(MinMaxValue *)ap2, /*4Hm*/(MinMaxValue *)ap3))
#define REG_Skin_horizontalSBH(m, c)      REGVMETHOD(Skin, horizontalSBH,      c::m, (),                                                                                                                                                                            c, ())
#define REG_Skin_isMouseMoving(m, c)      REGVMETHOD(Skin, isMouseMoving,      c::m, (/*1Ab*/Window & ap1, /*1Ab*/int ap2, /*1Ab*/int ap3, /*1Ab*/int ap4, /*1Ab*/int ap5),                                                                                         c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/ap4, /*4Im*/ap5))
#define REG_Skin_isMouseResizing(m, c)    REGVMETHOD(Skin, isMouseResizing,    c::m, (/*1Ab*/Window & ap1, /*1Ab*/int ap2, /*1Ab*/int ap3, /*1Ab*/int ap4, /*1Ab*/int ap5, /*1Ab*/C(bool) * ap6, /*1Ab*/C(bool) * ap7, /*1Ab*/C(bool) * ap8, /*1Ab*/C(bool) * ap9), c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/ap4, /*4Im*/ap5, /*4Hm*/(C(bool) *)ap6, /*4Hm*/(C(bool) *)ap7, /*4Hm*/(C(bool) *)ap8, /*4Hm*/(C(bool) *)ap9))
#define REG_Skin_setWindowArea(m, c)      REGVMETHOD(Skin, setWindowArea,      c::m, (/*1Ab*/Window & ap1, /*1Ab*/int * ap2, /*1Ab*/int * ap3, /*1Ab*/MinMaxValue * ap4, /*1Ab*/MinMaxValue * ap5, /*1Ab*/MinMaxValue * ap6, /*1Ab*/MinMaxValue * ap7),             c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Hm*/(MinMaxValue *)ap4, /*4Hm*/(MinMaxValue *)ap5, /*4Hm*/(MinMaxValue *)ap6, /*4Hm*/(MinMaxValue *)ap7))
#define REG_Skin_setWindowMinimum(m, c)   REGVMETHOD(Skin, setWindowMinimum,   c::m, (/*1Ab*/Window & ap1, /*1Ab*/MinMaxValue * ap2, /*1Ab*/MinMaxValue * ap3),                                                                                                     c, (/*4Im*/ap1, /*4Hm*/(MinMaxValue *)ap2, /*4Hm*/(MinMaxValue *)ap3))
#define REG_Skin_showDecorations(m, c)    REGVMETHOD(Skin, showDecorations,    c::m, (/*1Ab*/void * ap1, /*1Ab*/Surface & ap2, /*1Ab*/Window & ap3, /*1Ab*/const char * ap4, /*1Ab*/bool ap5, /*1Ab*/bool ap6),                                                     c, (/*4Im*/ap1, /*4Im*/ap2, /*4Im*/ap3, /*4Im*/ap4, /*4Hm*/(bool)ap5, /*4Hm*/(bool)ap6))
#define REG_Skin_systemFont(m, c)         REGVMETHOD(Skin, systemFont,         c::m, (),                                                                                                                                                                            c, ())
#define REG_Skin_updateNonClient(m, c)    REGVMETHOD(Skin, updateNonClient,    c::m, (/*1Ab*/void * ap1),                                                                                                                                                           c, (/*4Im*/ap1))
#define REG_Skin_verticalSBW(m, c)        REGVMETHOD(Skin, verticalSBW,        c::m, (),                                                                                                                                                                            c, ())

#define REG_Skin(c) \
      Skin::class_registration(_cpp_class); \
      REG_Skin_captionFont(captionFont, c); \
      REG_Skin_cursorsBitmaps(cursorsBitmaps, c); \
      REG_Skin_getBitmap(getBitmap, c); \
      REG_Skin_getDecorationsSize(getDecorationsSize, c); \
      REG_Skin_horizontalSBH(horizontalSBH, c); \
      REG_Skin_isMouseMoving(isMouseMoving, c); \
      REG_Skin_isMouseResizing(isMouseResizing, c); \
      REG_Skin_setWindowArea(setWindowArea, c); \
      REG_Skin_setWindowMinimum(setWindowMinimum, c); \
      REG_Skin_showDecorations(showDecorations, c); \
      REG_Skin_systemFont(systemFont, c); \
      REG_Skin_updateNonClient(updateNonClient, c); \
      REG_Skin_verticalSBW(verticalSBW, c);

#define SKIN_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(captionFont, captionFont, c, Skin, \
      FontResource *, c &, , ); \
   VIRTUAL_METHOD_PROTO(cursorsBitmaps, cursorsBitmaps, c, Skin, \
      const char *, c & _ARG, , /*6Fj*/uint id _ARG /*6Fj*/int * hotSpotX _ARG /*6Fj*/int * hotSpotY _ARG /*6Fj*/unsigned char ** paletteShades); \
   VIRTUAL_METHOD_PROTO(getBitmap, getBitmap, c, Skin, \
      BitmapResource *, c & _ARG, , /*6Fj*/SkinBitmap ap1); \
   VIRTUAL_METHOD_PROTO(getDecorationsSize, getDecorationsSize, c, Skin, \
      void, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/MinMaxValue * ap2 _ARG /*6Fj*/MinMaxValue * ap3); \
   VIRTUAL_METHOD_PROTO(horizontalSBH, horizontalSBH, c, Skin, \
      int, c &, , ); \
   VIRTUAL_METHOD_PROTO(isMouseMoving, isMouseMoving, c, Skin, \
      bool, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/int ap5); \
   VIRTUAL_METHOD_PROTO(isMouseResizing, isMouseResizing, c, Skin, \
      bool, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/int ap5 _ARG /*6Cj*/C(bool) * ap6 _ARG /*6Cj*/C(bool) * ap7 _ARG /*6Cj*/C(bool) * ap8 _ARG /*6Cj*/C(bool) * ap9); \
   VIRTUAL_METHOD_PROTO(setWindowArea, setWindowArea, c, Skin, \
      void, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/int * ap2 _ARG /*6Fj*/int * ap3 _ARG /*6Fj*/MinMaxValue * ap4 _ARG /*6Fj*/MinMaxValue * ap5 _ARG /*6Fj*/MinMaxValue * ap6 _ARG /*6Fj*/MinMaxValue * ap7); \
   VIRTUAL_METHOD_PROTO(setWindowMinimum, setWindowMinimum, c, Skin, \
      void, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/MinMaxValue * ap2 _ARG /*6Fj*/MinMaxValue * ap3); \
   VIRTUAL_METHOD_PROTO(showDecorations, showDecorations, c, Skin, \
      void, c & _ARG, , /*6Fj*/void * ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Window & ap3 _ARG /*6Fj*/const char * ap4 _ARG /*6Fj*/bool ap5 _ARG /*6Fj*/bool ap6); \
   VIRTUAL_METHOD_PROTO(systemFont, systemFont, c, Skin, \
      FontResource *, c &, , ); \
   VIRTUAL_METHOD_PROTO(updateNonClient, updateNonClient, c, Skin, \
      void, c & _ARG, , /*6Fj*/void * ap1); \
   VIRTUAL_METHOD_PROTO(verticalSBW, verticalSBW, c, Skin, \
      int, c &, , );

#define SKIN_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(captionFont, captionFont, c, Skin, \
   FontResource *, c &, , , \
   C(FontResource) retFontResource = Skin_captionFont(self ? self->impl : (C(Skin))null); \
      return BINDINGS_CLASS(retFontResource) ? (FontResource *)INSTANCEL(retFontResource, retFontResource->_class) : (FontResource *)0;); \
VIRTUAL_METHOD(cursorsBitmaps, cursorsBitmaps, c, Skin, \
   const char *, c & _ARG, , /*6Fj*/uint id _ARG /*6Fj*/int * hotSpotX _ARG /*6Fj*/int * hotSpotY _ARG /*6Fj*/unsigned char ** paletteShades, \
   return Skin_cursorsBitmaps(self ? self->impl : (C(Skin))null, /*7Al*/id, /*7Al*/hotSpotX, /*7Al*/hotSpotY, /*7Al*/paletteShades);); \
VIRTUAL_METHOD(getBitmap, getBitmap, c, Skin, \
   BitmapResource *, c & _ARG, , /*6Fj*/SkinBitmap ap1, \
   C(BitmapResource) retBitmapResource = Skin_getBitmap(self ? self->impl : (C(Skin))null, /*7Al*/(C(SkinBitmap))ap1); \
      return BINDINGS_CLASS(retBitmapResource) ? (BitmapResource *)INSTANCEL(retBitmapResource, retBitmapResource->_class) : (BitmapResource *)0;); \
VIRTUAL_METHOD(getDecorationsSize, getDecorationsSize, c, Skin, \
   void, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/MinMaxValue * ap2 _ARG /*6Fj*/MinMaxValue * ap3, \
   Skin_getDecorationsSize(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/&ap2->impl, /*7Al*/&ap3->impl);); \
VIRTUAL_METHOD(horizontalSBH, horizontalSBH, c, Skin, \
   int, c &, , , \
   return Skin_horizontalSBH(self ? self->impl : (C(Skin))null);); \
VIRTUAL_METHOD(isMouseMoving, isMouseMoving, c, Skin, \
   bool, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/int ap5, \
   return (bool)Skin_isMouseMoving(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5);); \
VIRTUAL_METHOD(isMouseResizing, isMouseResizing, c, Skin, \
   bool, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/int ap2 _ARG /*6Fj*/int ap3 _ARG /*6Fj*/int ap4 _ARG /*6Fj*/int ap5 _ARG /*6Cj*/C(bool) * ap6 _ARG /*6Cj*/C(bool) * ap7 _ARG /*6Cj*/C(bool) * ap8 _ARG /*6Cj*/C(bool) * ap9, \
   return (bool)Skin_isMouseResizing(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5, /*7Al*/ap6, /*7Al*/ap7, /*7Al*/ap8, /*7Al*/ap9);); \
VIRTUAL_METHOD(setWindowArea, setWindowArea, c, Skin, \
   void, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/int * ap2 _ARG /*6Fj*/int * ap3 _ARG /*6Fj*/MinMaxValue * ap4 _ARG /*6Fj*/MinMaxValue * ap5 _ARG /*6Fj*/MinMaxValue * ap6 _ARG /*6Fj*/MinMaxValue * ap7, \
   Skin_setWindowArea(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/&ap4->impl, /*7Al*/&ap5->impl, /*7Al*/&ap6->impl, /*7Al*/&ap7->impl);); \
VIRTUAL_METHOD(setWindowMinimum, setWindowMinimum, c, Skin, \
   void, c & _ARG, , /*6Fj*/Window & ap1 _ARG /*6Fj*/MinMaxValue * ap2 _ARG /*6Fj*/MinMaxValue * ap3, \
   Skin_setWindowMinimum(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/&ap2->impl, /*7Al*/&ap3->impl);); \
VIRTUAL_METHOD(showDecorations, showDecorations, c, Skin, \
   void, c & _ARG, , /*6Fj*/void * ap1 _ARG /*6Fj*/Surface & ap2 _ARG /*6Fj*/Window & ap3 _ARG /*6Fj*/const char * ap4 _ARG /*6Fj*/bool ap5 _ARG /*6Fj*/bool ap6, \
   Skin_showDecorations(self ? self->impl : (C(Skin))null, /*7Al*/ap1, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/ap4, /*7Al*/(C(bool))ap5, /*7Al*/(C(bool))ap6);); \
VIRTUAL_METHOD(systemFont, systemFont, c, Skin, \
   FontResource *, c &, , , \
   C(FontResource) retFontResource = Skin_systemFont(self ? self->impl : (C(Skin))null); \
      return BINDINGS_CLASS(retFontResource) ? (FontResource *)INSTANCEL(retFontResource, retFontResource->_class) : (FontResource *)0;); \
VIRTUAL_METHOD(updateNonClient, updateNonClient, c, Skin, \
   void, c & _ARG, , /*6Fj*/void * ap1, \
   Skin_updateNonClient(self ? self->impl : (C(Skin))null, /*7Al*/ap1);); \
VIRTUAL_METHOD(verticalSBW, verticalSBW, c, Skin, \
   int, c &, , , \
   return Skin_verticalSBW(self ? self->impl : (C(Skin))null););

class Skin : public Instance
{
public:
   inline Skin(Skin && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Skin & operator= (Skin && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Skin() : Skin((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Skin> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Skin * inst = new Skin(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Skin * inst = (Skin *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Skin & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Skin(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct Skin_captionFont_Functor
   {
      [[no_unique_address]] int _[0];
      typedef FontResource * (* FunctionType)(Skin &);
      inline FunctionType operator= (FunctionType func);
      inline FontResource * operator()( );
   } captionFont;
   // inline static void register_captionFont(CPPClass & cl, Skin::Skin_captionFont_Functor::FunctionType func)

   struct Skin_cursorsBitmaps_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Skin & , /*6Fj*/uint id, /*6Fj*/int * hotSpotX, /*6Fj*/int * hotSpotY, /*6Fj*/unsigned char ** paletteShades);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()( /*6Fj*/uint id, /*6Fj*/int * hotSpotX, /*6Fj*/int * hotSpotY, /*6Fj*/unsigned char ** paletteShades);
   } cursorsBitmaps;
   // inline static void register_cursorsBitmaps(CPPClass & cl, Skin::Skin_cursorsBitmaps_Functor::FunctionType func)

   struct Skin_getBitmap_Functor
   {
      [[no_unique_address]] int _[0];
      typedef BitmapResource * (* FunctionType)(Skin & , /*6Fj*/SkinBitmap ap1);
      inline FunctionType operator= (FunctionType func);
      inline BitmapResource * operator()( /*6Fj*/SkinBitmap ap1);
   } getBitmap;
   // inline static void register_getBitmap(CPPClass & cl, Skin::Skin_getBitmap_Functor::FunctionType func)

   struct Skin_getDecorationsSize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Skin & , /*6Fj*/Window & ap1, /*6Fj*/MinMaxValue * ap2, /*6Fj*/MinMaxValue * ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & ap1, /*6Fj*/MinMaxValue * ap2, /*6Fj*/MinMaxValue * ap3);
   } getDecorationsSize;
   // inline static void register_getDecorationsSize(CPPClass & cl, Skin::Skin_getDecorationsSize_Functor::FunctionType func)

   struct Skin_horizontalSBH_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Skin &);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( );
   } horizontalSBH;
   // inline static void register_horizontalSBH(CPPClass & cl, Skin::Skin_horizontalSBH_Functor::FunctionType func)

   struct Skin_isMouseMoving_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Skin & , /*6Fj*/Window & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Window & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5);
   } isMouseMoving;
   // inline static void register_isMouseMoving(CPPClass & cl, Skin::Skin_isMouseMoving_Functor::FunctionType func)

   struct Skin_isMouseResizing_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Skin & , /*6Fj*/Window & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5, /*6Cj*/C(bool) * ap6, /*6Cj*/C(bool) * ap7, /*6Cj*/C(bool) * ap8, /*6Cj*/C(bool) * ap9);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/Window & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5, /*6Cj*/C(bool) * ap6, /*6Cj*/C(bool) * ap7, /*6Cj*/C(bool) * ap8, /*6Cj*/C(bool) * ap9);
   } isMouseResizing;
   // inline static void register_isMouseResizing(CPPClass & cl, Skin::Skin_isMouseResizing_Functor::FunctionType func)

   struct Skin_setWindowArea_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Skin & , /*6Fj*/Window & ap1, /*6Fj*/int * ap2, /*6Fj*/int * ap3, /*6Fj*/MinMaxValue * ap4, /*6Fj*/MinMaxValue * ap5, /*6Fj*/MinMaxValue * ap6, /*6Fj*/MinMaxValue * ap7);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & ap1, /*6Fj*/int * ap2, /*6Fj*/int * ap3, /*6Fj*/MinMaxValue * ap4, /*6Fj*/MinMaxValue * ap5, /*6Fj*/MinMaxValue * ap6, /*6Fj*/MinMaxValue * ap7);
   } setWindowArea;
   // inline static void register_setWindowArea(CPPClass & cl, Skin::Skin_setWindowArea_Functor::FunctionType func)

   struct Skin_setWindowMinimum_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Skin & , /*6Fj*/Window & ap1, /*6Fj*/MinMaxValue * ap2, /*6Fj*/MinMaxValue * ap3);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & ap1, /*6Fj*/MinMaxValue * ap2, /*6Fj*/MinMaxValue * ap3);
   } setWindowMinimum;
   // inline static void register_setWindowMinimum(CPPClass & cl, Skin::Skin_setWindowMinimum_Functor::FunctionType func)

   struct Skin_showDecorations_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Skin & , /*6Fj*/void * ap1, /*6Fj*/Surface & ap2, /*6Fj*/Window & ap3, /*6Fj*/const char * ap4, /*6Fj*/bool ap5, /*6Fj*/bool ap6);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/void * ap1, /*6Fj*/Surface & ap2, /*6Fj*/Window & ap3, /*6Fj*/const char * ap4, /*6Fj*/bool ap5, /*6Fj*/bool ap6);
   } showDecorations;
   // inline static void register_showDecorations(CPPClass & cl, Skin::Skin_showDecorations_Functor::FunctionType func)

   struct Skin_systemFont_Functor
   {
      [[no_unique_address]] int _[0];
      typedef FontResource * (* FunctionType)(Skin &);
      inline FunctionType operator= (FunctionType func);
      inline FontResource * operator()( );
   } systemFont;
   // inline static void register_systemFont(CPPClass & cl, Skin::Skin_systemFont_Functor::FunctionType func)

   struct Skin_updateNonClient_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Skin & , /*6Fj*/void * ap1);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/void * ap1);
   } updateNonClient;
   // inline static void register_updateNonClient(CPPClass & cl, Skin::Skin_updateNonClient_Functor::FunctionType func)

   struct Skin_verticalSBW_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Skin &);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( );
   } verticalSBW;
   // inline static void register_verticalSBW(CPPClass & cl, Skin::Skin_verticalSBW_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};

enum class SkinBitmap : int
{
   minimize = SkinBitmap_minimize,
   maximize = SkinBitmap_maximize,
   restore = SkinBitmap_restore,
   close = SkinBitmap_close
};

class SmartKey
{
public:
   C(SmartKey) impl;
   constexpr SmartKey() : impl(0) { }
   constexpr SmartKey(C(SmartKey) impl) : impl(impl) { }
   SmartKey(KeyCode code, bool shift, bool ctrl, bool alt, Modifiers & modifiers);
   operator C(SmartKey)() { return impl; }
   SmartKey & operator =(C(SmartKey) impl) { impl = impl; return *this; }
   bool operator ==(const SmartKey & value) const { return impl == value.impl; }
   bool operator !=(const SmartKey & value) const { return impl != value.impl; }
   inline SmartKey operator= (Key value);
   inline SmartKey(Key value);
   inline SmartKey operator= (KeyCode value);
   inline SmartKey(KeyCode value);
   inline SmartKey operator= (PredefinedKey value);
   inline SmartKey(PredefinedKey value);

   struct code_Prop
   {
      constexpr code_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/KeyCode operator= (/*0H*/KeyCode v);
      /*regSet*/inline SmartKey::code_Prop & operator= (SmartKey::code_Prop & prop);
      /*regGet*/inline operator /*0I*/KeyCode () const;
   } code;
   struct shift_Prop
   {
      constexpr shift_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline SmartKey::shift_Prop & operator= (SmartKey::shift_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } shift;
   struct ctrl_Prop
   {
      constexpr ctrl_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline SmartKey::ctrl_Prop & operator= (SmartKey::ctrl_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } ctrl;
   struct alt_Prop
   {
      constexpr alt_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline SmartKey::alt_Prop & operator= (SmartKey::alt_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alt;
   struct modifiers_Prop
   {
      constexpr modifiers_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Modifiers operator= (/*0H*/Modifiers v);
      /*regSet*/inline SmartKey::modifiers_Prop & operator= (SmartKey::modifiers_Prop & prop);
      /*regGet*/inline operator /*0I*/Modifiers () const;
   } modifiers;
};

enum class SystemCursor : int
{
   arrow = SystemCursor_arrow,
   iBeam = SystemCursor_iBeam,
   cross = SystemCursor_cross,
   moving = SystemCursor_moving,
   sizeNESW = SystemCursor_sizeNESW,
   sizeNS = SystemCursor_sizeNS,
   sizeNWSE = SystemCursor_sizeNWSE,
   sizeWE = SystemCursor_sizeWE,
   hand = SystemCursor_hand
};

#define REG_Timer_delayExpired(m, c) REGVMETHOD(Timer, delayExpired, c::m, (/*1Ab*/any_object self), c, (/*4Im*/self))

#define REG_Timer(c) \
      Timer::class_registration(_cpp_class); \
      REG_Timer_delayExpired(delayExpired, c);

#define TIMER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(delayExpired, delayExpired, c, Timer, \
      bool, any_object, /*6Fk*/any_object o_, );

#define TIMER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(delayExpired, delayExpired, c, Timer, \
   bool, any_object, /*6Fk*/any_object o_, , \
   return (bool)Timer_delayExpired(self ? self->impl : (C(Timer))null, o_););

class Timer : public Instance
{
public:
   inline Timer(Timer && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Timer & operator= (Timer && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Timer() : Timer((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { Timer_set_userData(this->impl, this); }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Timer> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Timer * inst = new Timer(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Timer * inst = (Timer *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Timer & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Timer(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void start(); // Timer_start
   inline void stop(); // Timer_stop

   struct Timer_delayExpired_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(any_object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/any_object o_ );
   } delayExpired;
   // inline static void register_delayExpired(CPPClass & cl, Timer::Timer_delayExpired_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline Timer(void * userData, Seconds delay, bool started, Seconds _delay);

private:
   void * _userData;
public:

   struct userData_Prop
   {
      constexpr userData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline Timer::userData_Prop & operator= (Timer::userData_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } userData;
   struct delay_Prop
   {
      constexpr delay_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Seconds operator= (/*0H*/Seconds v);
      /*regSet*/inline Timer::delay_Prop & operator= (Timer::delay_Prop & prop);
      /*regGet*/inline operator /*0I*/Seconds () const;
      /*regGet*/inline operator /*0J*/C(Time) () const;
   } delay;
   struct started_Prop
   {
      constexpr started_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Timer::started_Prop & operator= (Timer::started_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } started;

   struct _delay_Prop
   {
      constexpr _delay_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Seconds operator= (/*0H*/Seconds v);
      /*regSet*/inline Timer::_delay_Prop & operator= (Timer::_delay_Prop & prop);
      /*regGet*/inline operator /*0I*/Seconds () const;
      /*regGet*/inline operator /*0J*/C(Time) () const;
   } _delay;
};

enum class TouchPointerEvent : int
{
   move = TouchPointerEvent_move,
   up = TouchPointerEvent_up,
   down = TouchPointerEvent_down,
   pointerUp = TouchPointerEvent_pointerUp,
   pointerDown = TouchPointerEvent_pointerDown
};

struct TouchPointerInfo : public TStruct<TouchPointerInfo>
{
public:
   C(TouchPointerInfo) impl;
   constexpr TouchPointerInfo() : impl({}) { }
   constexpr TouchPointerInfo(const C(TouchPointerInfo) impl) : impl(impl) { }

   inline TouchPointerInfo(int id, Point point, float size, float pressure);

   struct id_Prop
   {
      constexpr id_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline TouchPointerInfo::id_Prop & operator= (TouchPointerInfo::id_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } id;
   struct point_Prop
   {
      constexpr point_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Point operator= (/*0H*/Point v);
      /*regSet*/inline TouchPointerInfo::point_Prop & operator= (TouchPointerInfo::point_Prop & prop);
      /*regGet*/inline operator /*0I*/Point () const;
   } point;
   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline TouchPointerInfo::size_Prop & operator= (TouchPointerInfo::size_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } size;
   struct pressure_Prop
   {
      constexpr pressure_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline TouchPointerInfo::pressure_Prop & operator= (TouchPointerInfo::pressure_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } pressure;
};

class WindowController
{
public:
   static TCPPClass<WindowController> _cpp_class;
   static void class_registration(CPPClass & _cpp_class);
};

#define REG_WindowController_onCreate(m, c, TP_V)            TREGVMETHOD(TWindowController<TP_V>, WindowController, onCreate,            c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller),                                                                                                                                c, (/*4Im*/v, /*4Im*/(c &)controller))
#define REG_WindowController_onKeyDown(m, c, TP_V)           TREGVMETHOD(TWindowController<TP_V>, WindowController, onKeyDown,           c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Hm*/(Key)key, /*4Im*/ch))
#define REG_WindowController_onKeyHit(m, c, TP_V)            TREGVMETHOD(TWindowController<TP_V>, WindowController, onKeyHit,            c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Hm*/(Key)key, /*4Im*/ch))
#define REG_WindowController_onKeyUp(m, c, TP_V)             TREGVMETHOD(TWindowController<TP_V>, WindowController, onKeyUp,             c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Hm*/(Key)key, /*4Im*/ch))
#define REG_WindowController_onLeftButtonDown(m, c, TP_V)    TREGVMETHOD(TWindowController<TP_V>, WindowController, onLeftButtonDown,    c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onLeftButtonUp(m, c, TP_V)      TREGVMETHOD(TWindowController<TP_V>, WindowController, onLeftButtonUp,      c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onLeftDoubleClick(m, c, TP_V)   TREGVMETHOD(TWindowController<TP_V>, WindowController, onLeftDoubleClick,   c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onLoadGraphics(m, c, TP_V)      TREGVMETHOD(TWindowController<TP_V>, WindowController, onLoadGraphics,      c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller),                                                                                                                                c, (/*4Im*/v, /*4Im*/(c &)controller))
#define REG_WindowController_onMiddleButtonDown(m, c, TP_V)  TREGVMETHOD(TWindowController<TP_V>, WindowController, onMiddleButtonDown,  c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onMiddleButtonUp(m, c, TP_V)    TREGVMETHOD(TWindowController<TP_V>, WindowController, onMiddleButtonUp,    c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onMiddleDoubleClick(m, c, TP_V) TREGVMETHOD(TWindowController<TP_V>, WindowController, onMiddleDoubleClick, c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onMouseMove(m, c, TP_V)         TREGVMETHOD(TWindowController<TP_V>, WindowController, onMouseMove,         c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onMultiTouch(m, c, TP_V)        TREGVMETHOD(TWindowController<TP_V>, WindowController, onMultiTouch,        c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/TouchPointerEvent event, /*1Ab*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Ab*/Modifiers mods), c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Hm*/(TouchPointerEvent)event, /*4Im*/infos, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onRedraw(m, c, TP_V)            TREGVMETHOD(TWindowController<TP_V>, WindowController, onRedraw,            c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/Surface & surface),                                                                                                      c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/surface))
#define REG_WindowController_onResize(m, c, TP_V)            TREGVMETHOD(TWindowController<TP_V>, WindowController, onResize,            c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int width, /*1Ab*/int height),                                                                                           c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/width, /*4Im*/height))
#define REG_WindowController_onRightButtonDown(m, c, TP_V)   TREGVMETHOD(TWindowController<TP_V>, WindowController, onRightButtonDown,   c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onRightButtonUp(m, c, TP_V)     TREGVMETHOD(TWindowController<TP_V>, WindowController, onRightButtonUp,     c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onRightDoubleClick(m, c, TP_V)  TREGVMETHOD(TWindowController<TP_V>, WindowController, onRightDoubleClick,  c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),                                                                             c, (/*4Im*/v, /*4Im*/(c &)controller, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_WindowController_onUnloadGraphics(m, c, TP_V)    TREGVMETHOD(TWindowController<TP_V>, WindowController, onUnloadGraphics,    c::m, (/*1Ab*/TWindowController<TP_V> & self, /*1Ab*/TP_V & v, /*1Ab*/TWindowController<TP_V> & controller),                                                                                                                                c, (/*4Im*/v, /*4Im*/(c &)controller))

#define TREG_WindowController(c, TP_V) \
      TWindowController::class_registration(_cpp_class); \
      REG_WindowController_onCreate(onCreate, c, TP_V); \
      REG_WindowController_onKeyDown(onKeyDown, c, TP_V); \
      REG_WindowController_onKeyHit(onKeyHit, c, TP_V); \
      REG_WindowController_onKeyUp(onKeyUp, c, TP_V); \
      REG_WindowController_onLeftButtonDown(onLeftButtonDown, c, TP_V); \
      REG_WindowController_onLeftButtonUp(onLeftButtonUp, c, TP_V); \
      REG_WindowController_onLeftDoubleClick(onLeftDoubleClick, c, TP_V); \
      REG_WindowController_onLoadGraphics(onLoadGraphics, c, TP_V); \
      REG_WindowController_onMiddleButtonDown(onMiddleButtonDown, c, TP_V); \
      REG_WindowController_onMiddleButtonUp(onMiddleButtonUp, c, TP_V); \
      REG_WindowController_onMiddleDoubleClick(onMiddleDoubleClick, c, TP_V); \
      REG_WindowController_onMouseMove(onMouseMove, c, TP_V); \
      REG_WindowController_onMultiTouch(onMultiTouch, c, TP_V); \
      REG_WindowController_onRedraw(onRedraw, c, TP_V); \
      REG_WindowController_onResize(onResize, c, TP_V); \
      REG_WindowController_onRightButtonDown(onRightButtonDown, c, TP_V); \
      REG_WindowController_onRightButtonUp(onRightButtonUp, c, TP_V); \
      REG_WindowController_onRightDoubleClick(onRightDoubleClick, c, TP_V); \
      REG_WindowController_onUnloadGraphics(onUnloadGraphics, c, TP_V);

#define WINDOWCONTROLLER_VIRTUAL_METHODS_PROTO(c) \
   TVIRTUAL_METHOD_PROTO(onCreate, onCreate, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller); \
   TVIRTUAL_METHOD_PROTO(onKeyDown, onKeyDown, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   TVIRTUAL_METHOD_PROTO(onKeyHit, onKeyHit, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   TVIRTUAL_METHOD_PROTO(onKeyUp, onKeyUp, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   TVIRTUAL_METHOD_PROTO(onLeftButtonDown, onLeftButtonDown, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onLeftButtonUp, onLeftButtonUp, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onLeftDoubleClick, onLeftDoubleClick, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onLoadGraphics, onLoadGraphics, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller); \
   TVIRTUAL_METHOD_PROTO(onMiddleButtonDown, onMiddleButtonDown, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onMiddleButtonUp, onMiddleButtonUp, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onMiddleDoubleClick, onMiddleDoubleClick, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onMouseMove, onMouseMove, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onMultiTouch, onMultiTouch, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/TouchPointerEvent event _ARG /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onRedraw, onRedraw, WindowController, TWindowController, \
      void, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Surface & surface); \
   TVIRTUAL_METHOD_PROTO(onResize, onResize, WindowController, TWindowController, \
      void, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int width _ARG /*6Fj*/int height); \
   TVIRTUAL_METHOD_PROTO(onRightButtonDown, onRightButtonDown, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onRightButtonUp, onRightButtonUp, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onRightDoubleClick, onRightDoubleClick, WindowController, TWindowController, \
      bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   TVIRTUAL_METHOD_PROTO(onUnloadGraphics, onUnloadGraphics, WindowController, TWindowController, \
      void, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller);

#define WINDOWCONTROLLER_VIRTUAL_METHODS(c) \
TVIRTUAL_METHOD(onCreate, onCreate, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller, \
   return (bool)WindowController_onCreate(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl);); \
TVIRTUAL_METHOD(onKeyDown, onKeyDown, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)WindowController_onKeyDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(Key))key, /*7Al*/ch);); \
TVIRTUAL_METHOD(onKeyHit, onKeyHit, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)WindowController_onKeyHit(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(Key))key, /*7Al*/ch);); \
TVIRTUAL_METHOD(onKeyUp, onKeyUp, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)WindowController_onKeyUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(Key))key, /*7Al*/ch);); \
TVIRTUAL_METHOD(onLeftButtonDown, onLeftButtonDown, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onLeftButtonDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onLeftButtonUp, onLeftButtonUp, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onLeftButtonUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onLeftDoubleClick, onLeftDoubleClick, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onLeftDoubleClick(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onLoadGraphics, onLoadGraphics, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller, \
   return (bool)WindowController_onLoadGraphics(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl);); \
TVIRTUAL_METHOD(onMiddleButtonDown, onMiddleButtonDown, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onMiddleButtonDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onMiddleButtonUp, onMiddleButtonUp, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onMiddleButtonUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onMiddleDoubleClick, onMiddleDoubleClick, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onMiddleDoubleClick(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onMouseMove, onMouseMove, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onMouseMove(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onMultiTouch, onMultiTouch, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/TouchPointerEvent event _ARG /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onMultiTouch(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(TouchPointerEvent))event, /*7Al*/((Instance&)infos).impl, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onRedraw, onRedraw, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   void, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/Surface & surface, \
   WindowController_onRedraw(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/surface.impl);); \
TVIRTUAL_METHOD(onResize, onResize, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   void, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int width _ARG /*6Fj*/int height, \
   WindowController_onResize(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/width, /*7Al*/height);); \
TVIRTUAL_METHOD(onRightButtonDown, onRightButtonDown, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onRightButtonDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onRightButtonUp, onRightButtonUp, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onRightButtonUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onRightDoubleClick, onRightDoubleClick, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   bool, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)WindowController_onRightDoubleClick(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
TVIRTUAL_METHOD(onUnloadGraphics, onUnloadGraphics, WindowController, <TP_V>, template <typename TP_V>, WindowController, \
   void, c & _ARG, , /*6Fj*/TP_V & v _ARG /*6Fj*/TWindowController & controller, \
   WindowController_onUnloadGraphics(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl););

template <typename TP_V>
class TWindowController : public Instance, public WindowController
{
public:
   inline TWindowController/*<TP_V>*/(TWindowController<TP_V> && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline TWindowController<TP_V> & operator= (TWindowController<TP_V> && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   TWindowController() : TWindowController((C(Instance))Instance_newEx(ensureTemplatized <TP_V>(_cpp_class, "WindowController").impl, false), ensureTemplatized <TP_V>(_cpp_class, "WindowController")) { }
   INSTANCE_VIRTUAL_METHODS_PROTO(TWindowController)
   static TCPPClass<TWindowController> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         TWindowController <TP_V> * inst = new TWindowController <TP_V>(i, _cpp_class);
         if(inst)
         {
            /*printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      TWindowController <TP_V>* inst = (TWindowController <TP_V>*)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor) ((void (*)(TWindowController <TP_V> & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree) delete inst;
      }
   }
   explicit inline TWindowController /*<TP_V>*/(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl)
 { }

   struct WindowController_onCreate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller);
   } onCreate;
   // inline static void register_onCreate(CPPClass & cl, WindowController::WindowController_onCreate_Functor::FunctionType func)

   struct WindowController_onKeyDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onKeyDown;
   // inline static void register_onKeyDown(CPPClass & cl, WindowController::WindowController_onKeyDown_Functor::FunctionType func)

   struct WindowController_onKeyHit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onKeyHit;
   // inline static void register_onKeyHit(CPPClass & cl, WindowController::WindowController_onKeyHit_Functor::FunctionType func)

   struct WindowController_onKeyUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch);
   } onKeyUp;
   // inline static void register_onKeyUp(CPPClass & cl, WindowController::WindowController_onKeyUp_Functor::FunctionType func)

   struct WindowController_onLeftButtonDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onLeftButtonDown;
   // inline static void register_onLeftButtonDown(CPPClass & cl, WindowController::WindowController_onLeftButtonDown_Functor::FunctionType func)

   struct WindowController_onLeftButtonUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onLeftButtonUp;
   // inline static void register_onLeftButtonUp(CPPClass & cl, WindowController::WindowController_onLeftButtonUp_Functor::FunctionType func)

   struct WindowController_onLeftDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onLeftDoubleClick;
   // inline static void register_onLeftDoubleClick(CPPClass & cl, WindowController::WindowController_onLeftDoubleClick_Functor::FunctionType func)

   struct WindowController_onLoadGraphics_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller);
   } onLoadGraphics;
   // inline static void register_onLoadGraphics(CPPClass & cl, WindowController::WindowController_onLoadGraphics_Functor::FunctionType func)

   struct WindowController_onMiddleButtonDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMiddleButtonDown;
   // inline static void register_onMiddleButtonDown(CPPClass & cl, WindowController::WindowController_onMiddleButtonDown_Functor::FunctionType func)

   struct WindowController_onMiddleButtonUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMiddleButtonUp;
   // inline static void register_onMiddleButtonUp(CPPClass & cl, WindowController::WindowController_onMiddleButtonUp_Functor::FunctionType func)

   struct WindowController_onMiddleDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMiddleDoubleClick;
   // inline static void register_onMiddleDoubleClick(CPPClass & cl, WindowController::WindowController_onMiddleDoubleClick_Functor::FunctionType func)

   struct WindowController_onMouseMove_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onMouseMove;
   // inline static void register_onMouseMove(CPPClass & cl, WindowController::WindowController_onMouseMove_Functor::FunctionType func)

   struct WindowController_onMultiTouch_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/TouchPointerEvent event, /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/TouchPointerEvent event, /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*6Fj*/Modifiers mods);
   } onMultiTouch;
   // inline static void register_onMultiTouch(CPPClass & cl, WindowController::WindowController_onMultiTouch_Functor::FunctionType func)

   struct WindowController_onRedraw_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Surface & surface);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Surface & surface);
   } onRedraw;
   // inline static void register_onRedraw(CPPClass & cl, WindowController::WindowController_onRedraw_Functor::FunctionType func)

   struct WindowController_onResize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int width, /*6Fj*/int height);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int width, /*6Fj*/int height);
   } onResize;
   // inline static void register_onResize(CPPClass & cl, WindowController::WindowController_onResize_Functor::FunctionType func)

   struct WindowController_onRightButtonDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onRightButtonDown;
   // inline static void register_onRightButtonDown(CPPClass & cl, WindowController::WindowController_onRightButtonDown_Functor::FunctionType func)

   struct WindowController_onRightButtonUp_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onRightButtonUp;
   // inline static void register_onRightButtonUp(CPPClass & cl, WindowController::WindowController_onRightButtonUp_Functor::FunctionType func)

   struct WindowController_onRightDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } onRightDoubleClick;
   // inline static void register_onRightDoubleClick(CPPClass & cl, WindowController::WindowController_onRightDoubleClick_Functor::FunctionType func)

   struct WindowController_onUnloadGraphics_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(TWindowController & , /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller);
   } onUnloadGraphics;
   // inline static void register_onUnloadGraphics(CPPClass & cl, WindowController::WindowController_onUnloadGraphics_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct window_Prop
   {
      constexpr window_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } window;
   struct controlled_Prop
   {
      constexpr controlled_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const TP_V & operator= (/*0A*/const TP_V & v);
      /*regSet*/inline TWindowController<TP_V>::controlled_Prop & operator= (TWindowController<TP_V>::controlled_Prop & prop);
      /*nstSet*/inline /*0C*/const TP_V * operator= (/*0C*/const TP_V * v);
      /*regGet*/inline operator /*0B*/TIH<TP_V> () const;
      /*regGet*/inline TIH<TP_V> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/TP_V () const;
      /*regGet*/inline operator /*0F*/TP_V* () const;
   } controlled;
};

enum class WindowState : int
{
   normal = WindowState_normal,
   minimized = WindowState_minimized,
   maximized = WindowState_maximized
};

#define REG_Button_notifyClicked(m, c)     REGVMETHOD(Button, notifyClicked,     c::m, (/*1Ab*/Window & self, /*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods), c, (/*4Im*/self, /*4Im*/button, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Button_notifyDoubleClick(m, c) REGVMETHOD(Button, notifyDoubleClick, c::m, (/*1Ab*/Window & self, /*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods), c, (/*4Im*/self, /*4Im*/button, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Button_notifyMouseLeave(m, c)  REGVMETHOD(Button, notifyMouseLeave,  c::m, (/*1Ab*/Window & self, /*1Ab*/Button & button, /*1Ab*/Modifiers mods),                             c, (/*4Im*/self, /*4Im*/button, /*4Hm*/(Modifiers)mods))
#define REG_Button_notifyMouseMove(m, c)   REGVMETHOD(Button, notifyMouseMove,   c::m, (/*1Ab*/Window & self, /*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods), c, (/*4Im*/self, /*4Im*/button, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Button_notifyMouseOver(m, c)   REGVMETHOD(Button, notifyMouseOver,   c::m, (/*1Ab*/Window & self, /*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods), c, (/*4Im*/self, /*4Im*/button, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Button_notifyPushed(m, c)      REGVMETHOD(Button, notifyPushed,      c::m, (/*1Ab*/Window & self, /*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods), c, (/*4Im*/self, /*4Im*/button, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_Button_notifyReleased(m, c)    REGVMETHOD(Button, notifyReleased,    c::m, (/*1Ab*/Window & self, /*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods), c, (/*4Im*/self, /*4Im*/button, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))

#define REG_Button(c) \
      Button::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_Button_notifyClicked(notifyClicked, c); \
      REG_Button_notifyDoubleClick(notifyDoubleClick, c); \
      REG_Button_notifyMouseLeave(notifyMouseLeave, c); \
      REG_Button_notifyMouseMove(notifyMouseMove, c); \
      REG_Button_notifyMouseOver(notifyMouseOver, c); \
      REG_Button_notifyPushed(notifyPushed, c); \
      REG_Button_notifyReleased(notifyReleased, c);

#define BUTTON_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyClicked, notifyClicked, c, Button, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyDoubleClick, notifyDoubleClick, c, Button, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyMouseLeave, notifyMouseLeave, c, Button, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyMouseMove, notifyMouseMove, c, Button, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyMouseOver, notifyMouseOver, c, Button, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyPushed, notifyPushed, c, Button, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyReleased, notifyReleased, c, Button, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods);

#define BUTTON_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyClicked, notifyClicked, c, Button, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Button_notifyClicked(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyDoubleClick, notifyDoubleClick, c, Button, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Button_notifyDoubleClick(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyMouseLeave, notifyMouseLeave, c, Button, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/Modifiers mods, \
   return (bool)Button_notifyMouseLeave(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyMouseMove, notifyMouseMove, c, Button, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Button_notifyMouseMove(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyMouseOver, notifyMouseOver, c, Button, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Button_notifyMouseOver(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyPushed, notifyPushed, c, Button, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Button_notifyPushed(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyReleased, notifyReleased, c, Button, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/Button & button _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)Button_notifyReleased(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods););

class Button : public CommonControl
{
public:
   inline Button(Button && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Button & operator= (Button && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Button() : Button((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Button> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Button * inst = new Button(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Button * inst = (Button *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Button & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Button(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   inline void removeRadio(); // Button_removeRadio
   inline void setColor(/*1Ab*/ButtonState state, /*1Ab*/Color value); // Button_setColor
   inline void setTextColor(/*1Ab*/ButtonState state, /*1Ab*/Color value); // Button_setTextColor

   struct Button_notifyClicked_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyClicked;
   // inline static void register_notifyClicked(CPPClass & cl, Button::Button_notifyClicked_Functor::FunctionType func)

   struct Button_notifyDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyDoubleClick;
   // inline static void register_notifyDoubleClick(CPPClass & cl, Button::Button_notifyDoubleClick_Functor::FunctionType func)

   struct Button_notifyMouseLeave_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Button & button, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/Modifiers mods);
   } notifyMouseLeave;
   // inline static void register_notifyMouseLeave(CPPClass & cl, Button::Button_notifyMouseLeave_Functor::FunctionType func)

   struct Button_notifyMouseMove_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyMouseMove;
   // inline static void register_notifyMouseMove(CPPClass & cl, Button::Button_notifyMouseMove_Functor::FunctionType func)

   struct Button_notifyMouseOver_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyMouseOver;
   // inline static void register_notifyMouseOver(CPPClass & cl, Button::Button_notifyMouseOver_Functor::FunctionType func)

   struct Button_notifyPushed_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyPushed;
   // inline static void register_notifyPushed(CPPClass & cl, Button::Button_notifyPushed_Functor::FunctionType func)

   struct Button_notifyReleased_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyReleased;
   // inline static void register_notifyReleased(CPPClass & cl, Button::Button_notifyReleased_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline Button(Percentage opacity, bool drawBehind, bool isRadio, bool isCheckbox, bool bevel, bool bevelOver, bool toggle, bool checked, Alignment alignment);

   struct opacity_Prop
   {
      constexpr opacity_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Percentage operator= (/*0H*/Percentage v);
      /*regSet*/inline Button::opacity_Prop & operator= (Button::opacity_Prop & prop);
      /*regGet*/inline operator /*0I*/Percentage () const;
      /*regGet*/inline operator /*0J*/C(Percentage) () const;
   } opacity;
   struct drawBehind_Prop
   {
      constexpr drawBehind_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::drawBehind_Prop & operator= (Button::drawBehind_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } drawBehind;
   struct isRadio_Prop
   {
      constexpr isRadio_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::isRadio_Prop & operator= (Button::isRadio_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isRadio;
   struct isCheckbox_Prop
   {
      constexpr isCheckbox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::isCheckbox_Prop & operator= (Button::isCheckbox_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isCheckbox;
   struct bevel_Prop
   {
      constexpr bevel_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::bevel_Prop & operator= (Button::bevel_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bevel;
   struct bevelOver_Prop
   {
      constexpr bevelOver_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::bevelOver_Prop & operator= (Button::bevelOver_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bevelOver;
   struct toggle_Prop
   {
      constexpr toggle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::toggle_Prop & operator= (Button::toggle_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } toggle;
   struct checked_Prop
   {
      constexpr checked_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::checked_Prop & operator= (Button::checked_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } checked;
   struct alignment_Prop
   {
      constexpr alignment_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Alignment operator= (/*0H*/Alignment v);
      /*regSet*/inline Button::alignment_Prop & operator= (Button::alignment_Prop & prop);
      /*regGet*/inline operator /*0I*/Alignment () const;
   } alignment;
   struct bitmap_Prop
   {
      constexpr bitmap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const BitmapResource & operator= (/*0A*/const BitmapResource & v);
      /*regSet*/inline Button::bitmap_Prop & operator= (Button::bitmap_Prop & prop);
      /*nstSet*/inline /*0C*/const BitmapResource * operator= (/*0C*/const BitmapResource * v);
      /*regGet*/inline operator /*0B*/TIH<BitmapResource> () const;
      /*regGet*/inline TIH<BitmapResource> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/BitmapResource () const;
      /*regGet*/inline operator /*0F*/BitmapResource* () const;
   } bitmap;
   struct stayUp_Prop
   {
      constexpr stayUp_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::stayUp_Prop & operator= (Button::stayUp_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } stayUp;
   struct scaleBitmap_Prop
   {
      constexpr scaleBitmap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::scaleBitmap_Prop & operator= (Button::scaleBitmap_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } scaleBitmap;
   struct keyRepeat_Prop
   {
      constexpr keyRepeat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::keyRepeat_Prop & operator= (Button::keyRepeat_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } keyRepeat;
   struct symbol_Prop
   {
      constexpr symbol_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unichar operator= (/*0H*/unichar v);
      /*regSet*/inline Button::symbol_Prop & operator= (Button::symbol_Prop & prop);
      /*regGet*/inline operator /*0I*/unichar () const;
   } symbol;
   struct ellipsis_Prop
   {
      constexpr ellipsis_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::ellipsis_Prop & operator= (Button::ellipsis_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } ellipsis;
   struct stayDown_Prop
   {
      constexpr stayDown_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::stayDown_Prop & operator= (Button::stayDown_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } stayDown;
   struct offset_Prop
   {
      constexpr offset_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Button::offset_Prop & operator= (Button::offset_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } offset;
   struct buttonState_Prop
   {
      constexpr buttonState_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ButtonState operator= (/*0H*/ButtonState v);
      /*regSet*/inline Button::buttonState_Prop & operator= (Button::buttonState_Prop & prop);
      /*regGet*/inline operator /*0I*/ButtonState () const;
   } buttonState;
   struct bitmapAlignment_Prop
   {
      constexpr bitmapAlignment_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/BoxAlignment operator= (/*0H*/BoxAlignment v);
      /*regSet*/inline Button::bitmapAlignment_Prop & operator= (Button::bitmapAlignment_Prop & prop);
      /*regGet*/inline operator /*0I*/BoxAlignment () const;
   } bitmapAlignment;
};

#define REG_DataBox_notifyChanged(m, c)  REGVMETHOD(DataBox, notifyChanged,  c::m, (/*1Ab*/Window & self, /*1Ab*/DataBox & dataBox, /*1Ab*/bool closingDropDown),   c, (/*4Im*/self, /*4Im*/dataBox, /*4Hm*/(bool)closingDropDown))
#define REG_DataBox_notifyModified(m, c) REGVMETHOD(DataBox, notifyModified, c::m, (/*1Ab*/Window & self),                                                          c, (/*4Im*/self))
#define REG_DataBox_onConfigure(m, c)    REGVMETHOD(DataBox, onConfigure,    c::m, (/*1Ab*/DataBox & self, /*1Ab*/Window & editor),                                 c, (/*4Im*/editor))
#define REG_DataBox_setData(m, c)        REGVMETHOD(DataBox, setData,        c::m, (/*1Ab*/DataBox & self, /*1Ab*/any_object newData, /*1Ab*/bool closingDropDown), c, (/*4Im*/newData, /*4Hm*/(bool)closingDropDown))

#define REG_DataBox(c) \
      DataBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_DataBox_notifyChanged(notifyChanged, c); \
      REG_DataBox_notifyModified(notifyModified, c); \
      REG_DataBox_onConfigure(onConfigure, c); \
      REG_DataBox_setData(setData, c);

#define DATABOX_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyChanged, notifyChanged, c, DataBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DataBox & dataBox _ARG /*6Fj*/bool closingDropDown); \
   VIRTUAL_METHOD_PROTO(notifyModified, notifyModified, c, DataBox, \
      bool, Window &, /*6Fk*/Window & o_, ); \
   VIRTUAL_METHOD_PROTO(onConfigure, onConfigure, c, DataBox, \
      void, c & _ARG, , /*6Fj*/Window & editor); \
   VIRTUAL_METHOD_PROTO(setData, setData, c, DataBox, \
      void, c & _ARG, , /*6Fj*/any_object newData _ARG /*6Fj*/bool closingDropDown);

#define DATABOX_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyChanged, notifyChanged, c, DataBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DataBox & dataBox _ARG /*6Fj*/bool closingDropDown, \
   return (bool)DataBox_notifyChanged(self ? self->impl : (C(DataBox))null, o_.impl, /*7Al*/dataBox.impl, /*7Al*/(C(bool))closingDropDown);); \
VIRTUAL_METHOD(notifyModified, notifyModified, c, DataBox, \
   bool, Window &, /*6Fk*/Window & o_, , \
   return (bool)DataBox_notifyModified(self ? self->impl : (C(DataBox))null, o_.impl);); \
VIRTUAL_METHOD(onConfigure, onConfigure, c, DataBox, \
   void, c & _ARG, , /*6Fj*/Window & editor, \
   DataBox_onConfigure(self ? self->impl : (C(DataBox))null, /*7Al*/editor.impl);); \
VIRTUAL_METHOD(setData, setData, c, DataBox, \
   void, c & _ARG, , /*6Fj*/any_object newData _ARG /*6Fj*/bool closingDropDown, \
   DataBox_setData(self ? self->impl : (C(DataBox))null, /*7Al*/newData, /*7Al*/(C(bool))closingDropDown););

class DataBox : public CommonControl
{
public:
   inline DataBox(DataBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DataBox & operator= (DataBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DataBox() : DataBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DataBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DataBox * inst = new DataBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DataBox * inst = (DataBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DataBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DataBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   inline void modified(); // DataBox_modified
   inline void refresh(); // DataBox_refresh
   inline C(bool) saveData(); // DataBox_saveData

   struct DataBox_notifyChanged_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/DataBox & dataBox, /*6Fj*/bool closingDropDown);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/bool closingDropDown);
   } notifyChanged;
   // inline static void register_notifyChanged(CPPClass & cl, DataBox::DataBox_notifyChanged_Functor::FunctionType func)

   struct DataBox_notifyModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ );
   } notifyModified;
   // inline static void register_notifyModified(CPPClass & cl, DataBox::DataBox_notifyModified_Functor::FunctionType func)

   struct DataBox_onConfigure_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DataBox & , /*6Fj*/Window & editor);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & editor);
   } onConfigure;
   // inline static void register_onConfigure(CPPClass & cl, DataBox::DataBox_onConfigure_Functor::FunctionType func)

   struct DataBox_setData_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DataBox & , /*6Fj*/any_object newData, /*6Fj*/bool closingDropDown);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/any_object newData, /*6Fj*/bool closingDropDown);
   } setData;
   // inline static void register_setData(CPPClass & cl, DataBox::DataBox_setData_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Class operator= (/*0H*/Class & v);
      /*regSet*/inline DataBox::type_Prop & operator= (DataBox::type_Prop & prop);
      /*regGet*/inline operator /*0I*/Class () const;
   } type;
   struct data_Prop
   {
      constexpr data_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline DataBox::data_Prop & operator= (DataBox::data_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } data;
   struct fieldData_Prop
   {
      constexpr fieldData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline DataBox::fieldData_Prop & operator= (DataBox::fieldData_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } fieldData;
   struct editor_Prop
   {
      constexpr editor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Window operator= (/*0H*/Window v);
      /*regSet*/inline DataBox::editor_Prop & operator= (DataBox::editor_Prop & prop);
      /*regGet*/inline operator /*0I*/Window () const;
   } editor;
   struct readOnly_Prop
   {
      constexpr readOnly_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataBox::readOnly_Prop & operator= (DataBox::readOnly_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } readOnly;
   struct keepEditor_Prop
   {
      constexpr keepEditor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataBox::keepEditor_Prop & operator= (DataBox::keepEditor_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } keepEditor;
   struct autoSize_Prop
   {
      constexpr autoSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataBox::autoSize_Prop & operator= (DataBox::autoSize_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } autoSize;
   struct needUpdate_Prop
   {
      constexpr needUpdate_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataBox::needUpdate_Prop & operator= (DataBox::needUpdate_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } needUpdate;
   struct stringValue_Prop
   {
      constexpr stringValue_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/char * operator= (/*0H*/char * v);
      /*regSet*/inline DataBox::stringValue_Prop & operator= (DataBox::stringValue_Prop & prop);
      /*regGet*/inline operator /*0I*/char * () const;
   } stringValue;
};

#define REG_File_close(m, c)       REGVMETHOD(File, close,       c::m, (/*1Ab*/File & self),                                                                                    c, ())
#define REG_File_closeInput(m, c)  REGVMETHOD(File, closeInput,  c::m, (/*1Ab*/File & self),                                                                                    c, ())
#define REG_File_closeOutput(m, c) REGVMETHOD(File, closeOutput, c::m, (/*1Ab*/File & self),                                                                                    c, ())
#define REG_File_eof(m, c)         REGVMETHOD(File, eof,         c::m, (/*1Ab*/File & self),                                                                                    c, ())
#define REG_File_getSize(m, c)     REGVMETHOD(File, getSize,     c::m, (/*1Ab*/File & self),                                                                                    c, ())
#define REG_File_getc(m, c)        REGVMETHOD(File, getc,        c::m, (/*1Ab*/File & self, /*1Ab*/char * ch),                                                                  c, (/*4Im*/ch))
#define REG_File_lock(m, c)        REGVMETHOD(File, lock,        c::m, (/*1Ab*/File & self, /*1Ab*/FileLock type, /*1Ab*/uint64 start, /*1Ab*/uint64 length, /*1Ab*/bool wait), c, (/*4Hm*/(FileLock)type, /*4Im*/start, /*4Im*/length, /*4Hm*/(bool)wait))
#define REG_File_putc(m, c)        REGVMETHOD(File, putc,        c::m, (/*1Ab*/File & self, /*1Ab*/char ch),                                                                    c, (/*4Im*/ch))
#define REG_File_puts(m, c)        REGVMETHOD(File, puts,        c::m, (/*1Ab*/File & self, /*1Ab*/const char * string),                                                        c, (/*4Im*/string))
#define REG_File_read(m, c)        REGVMETHOD(File, read,        c::m, (/*1Ab*/File & self, /*1Ab*/void * buffer, /*1Ab*/uintsize size, /*1Ab*/uintsize count),                 c, (/*4Im*/buffer, /*4Im*/size, /*4Im*/count))
#define REG_File_seek(m, c)        REGVMETHOD(File, seek,        c::m, (/*1Ab*/File & self, /*1Ab*/int64 pos, /*1Ab*/FileSeekMode mode),                                        c, (/*4Im*/pos, /*4Hm*/(FileSeekMode)mode))
#define REG_File_tell(m, c)        REGVMETHOD(File, tell,        c::m, (/*1Ab*/File & self),                                                                                    c, ())
#define REG_File_truncate(m, c)    REGVMETHOD(File, truncate,    c::m, (/*1Ab*/File & self, /*1Ab*/uint64 size),                                                                c, (/*4Im*/size))
#define REG_File_unlock(m, c)      REGVMETHOD(File, unlock,      c::m, (/*1Ab*/File & self, /*1Ab*/uint64 start, /*1Ab*/uint64 length, /*1Ab*/bool wait),                       c, (/*4Im*/start, /*4Im*/length, /*4Hm*/(bool)wait))
#define REG_File_write(m, c)       REGVMETHOD(File, write,       c::m, (/*1Ab*/File & self, /*1Ab*/const void * buffer, /*1Ab*/uintsize size, /*1Ab*/uintsize count),           c, (/*4Im*/buffer, /*4Im*/size, /*4Im*/count))

#define REG_File(c) \
      File::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define FILE_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(close, close, c, File, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(closeInput, closeInput, c, File, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(closeOutput, closeOutput, c, File, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(eof, eof_, c, File, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(getSize, getSize, c, File, \
      uint64, c &, , ); \
   VIRTUAL_METHOD_PROTO(getc, getc, c, File, \
      bool, c & _ARG, , /*6Fj*/char * ch); \
   VIRTUAL_METHOD_PROTO(lock, lock, c, File, \
      bool, c & _ARG, , /*6Fj*/FileLock type _ARG /*6Fj*/uint64 start _ARG /*6Fj*/uint64 length _ARG /*6Fj*/bool wait); \
   VIRTUAL_METHOD_PROTO(putc, putc, c, File, \
      bool, c & _ARG, , /*6Fj*/char ch); \
   VIRTUAL_METHOD_PROTO(puts, puts, c, File, \
      bool, c & _ARG, , /*6Fj*/const char * string); \
   VIRTUAL_METHOD_PROTO(read, read, c, File, \
      uintsize, c & _ARG, , /*6Fj*/void * buffer _ARG /*6Fj*/uintsize size _ARG /*6Fj*/uintsize count); \
   VIRTUAL_METHOD_PROTO(seek, seek, c, File, \
      bool, c & _ARG, , /*6Fj*/int64 pos _ARG /*6Fj*/FileSeekMode mode); \
   VIRTUAL_METHOD_PROTO(tell, tell, c, File, \
      uint64, c &, , ); \
   VIRTUAL_METHOD_PROTO(truncate, truncate, c, File, \
      bool, c & _ARG, , /*6Fj*/uint64 size); \
   VIRTUAL_METHOD_PROTO(unlock, unlock, c, File, \
      bool, c & _ARG, , /*6Fj*/uint64 start _ARG /*6Fj*/uint64 length _ARG /*6Fj*/bool wait); \
   VIRTUAL_METHOD_PROTO(write, write, c, File, \
      uintsize, c & _ARG, , /*6Fj*/const void * buffer _ARG /*6Fj*/uintsize size _ARG /*6Fj*/uintsize count);

#define FILE_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(close, close, c, File, \
   void, c &, , , \
   File_close(self ? self->impl : (C(File))null);); \
VIRTUAL_METHOD(closeInput, closeInput, c, File, \
   void, c &, , , \
   File_closeInput(self ? self->impl : (C(File))null);); \
VIRTUAL_METHOD(closeOutput, closeOutput, c, File, \
   void, c &, , , \
   File_closeOutput(self ? self->impl : (C(File))null);); \
VIRTUAL_METHOD(eof, eof_, c, File, \
   bool, c &, , , \
   return (bool)File_eof(self ? self->impl : (C(File))null);); \
VIRTUAL_METHOD(getSize, getSize, c, File, \
   uint64, c &, , , \
   return File_getSize(self ? self->impl : (C(File))null);); \
VIRTUAL_METHOD(getc, getc, c, File, \
   bool, c & _ARG, , /*6Fj*/char * ch, \
   return (bool)File_getc(self ? self->impl : (C(File))null, /*7Al*/ch);); \
VIRTUAL_METHOD(lock, lock, c, File, \
   bool, c & _ARG, , /*6Fj*/FileLock type _ARG /*6Fj*/uint64 start _ARG /*6Fj*/uint64 length _ARG /*6Fj*/bool wait, \
   return (bool)File_lock(self ? self->impl : (C(File))null, /*7Al*/(C(FileLock))type, /*7Al*/start, /*7Al*/length, /*7Al*/(C(bool))wait);); \
VIRTUAL_METHOD(putc, putc, c, File, \
   bool, c & _ARG, , /*6Fj*/char ch, \
   return (bool)File_putc(self ? self->impl : (C(File))null, /*7Al*/ch);); \
VIRTUAL_METHOD(puts, puts, c, File, \
   bool, c & _ARG, , /*6Fj*/const char * string, \
   return (bool)File_puts(self ? self->impl : (C(File))null, /*7Al*/string);); \
VIRTUAL_METHOD(read, read, c, File, \
   uintsize, c & _ARG, , /*6Fj*/void * buffer _ARG /*6Fj*/uintsize size _ARG /*6Fj*/uintsize count, \
   return File_read(self ? self->impl : (C(File))null, /*7Al*/buffer, /*7Al*/size, /*7Al*/count);); \
VIRTUAL_METHOD(seek, seek, c, File, \
   bool, c & _ARG, , /*6Fj*/int64 pos _ARG /*6Fj*/FileSeekMode mode, \
   return (bool)File_seek(self ? self->impl : (C(File))null, /*7Al*/pos, /*7Al*/(C(FileSeekMode))mode);); \
VIRTUAL_METHOD(tell, tell, c, File, \
   uint64, c &, , , \
   return File_tell(self ? self->impl : (C(File))null);); \
VIRTUAL_METHOD(truncate, truncate, c, File, \
   bool, c & _ARG, , /*6Fj*/uint64 size, \
   return (bool)File_truncate(self ? self->impl : (C(File))null, /*7Al*/size);); \
VIRTUAL_METHOD(unlock, unlock, c, File, \
   bool, c & _ARG, , /*6Fj*/uint64 start _ARG /*6Fj*/uint64 length _ARG /*6Fj*/bool wait, \
   return (bool)File_unlock(self ? self->impl : (C(File))null, /*7Al*/start, /*7Al*/length, /*7Al*/(C(bool))wait);); \
VIRTUAL_METHOD(write, write, c, File, \
   uintsize, c & _ARG, , /*6Fj*/const void * buffer _ARG /*6Fj*/uintsize size _ARG /*6Fj*/uintsize count, \
   return File_write(self ? self->impl : (C(File))null, /*7Al*/buffer, /*7Al*/size, /*7Al*/count););

class File : public IOChannel
{
public:
   inline File(File && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline File & operator= (File && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   File() : File((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<File> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         File * inst = new File(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      File * inst = (File *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(File & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline File(C(Instance) _impl, CPPClass & cl = _cpp_class) : IOChannel(_impl, cl) { }

   inline C(bool) copyTo(/*1Ab*/const char * outputFileName); // File_copyTo
   inline C(bool) copyToFile(/*1Ab*/File & f); // File_copyToFile
   inline C(bool) flush(); // File_flush
   inline double getDouble(); // File_getDouble
   inline float getFloat(); // File_getFloat
   inline uint getHexValue(); // File_getHexValue
   inline C(bool) getLine(/*1Ab*/char * s, /*1Ab*/int max); // File_getLine
   inline int getLineEx(/*1Ab*/char * s, /*1Ab*/int max, /*1Ab*/C(bool) * hasNewLineChar); // File_getLineEx
   inline C(bool) getString(/*1Ab*/char * string, /*1Ab*/int max); // File_getString
   inline int getValue(); // File_getValue
   template <typename ...Ts> inline void print(/*1Ab*/const Ts&... ts); // File_print
   template <typename ...Ts> inline void printLn(/*1Ab*/const Ts&... ts); // File_printLn
   template<typename... Args> inline int _printf(/*1Ab*/const char * format, /*1Ab*/Args... args); // File_printf

   struct File_close_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(File &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } close;
   // inline static void register_close(CPPClass & cl, File::File_close_Functor::FunctionType func)

   struct File_closeInput_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(File &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } closeInput;
   // inline static void register_closeInput(CPPClass & cl, File::File_closeInput_Functor::FunctionType func)

   struct File_closeOutput_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(File &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } closeOutput;
   // inline static void register_closeOutput(CPPClass & cl, File::File_closeOutput_Functor::FunctionType func)

   struct File_eof_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } eof_;
   // inline static void register_eof(CPPClass & cl, File::File_eof_Functor::FunctionType func)

   struct File_getSize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uint64 (* FunctionType)(File &);
      inline FunctionType operator= (FunctionType func);
      inline uint64 operator()( );
   } getSize;
   // inline static void register_getSize(CPPClass & cl, File::File_getSize_Functor::FunctionType func)

   struct File_getc_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File & , /*6Fj*/char * ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/char * ch);
   } getc;
   // inline static void register_getc(CPPClass & cl, File::File_getc_Functor::FunctionType func)

   struct File_lock_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File & , /*6Fj*/FileLock type, /*6Fj*/uint64 start, /*6Fj*/uint64 length, /*6Fj*/bool wait);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/FileLock type, /*6Fj*/uint64 start, /*6Fj*/uint64 length, /*6Fj*/bool wait);
   } lock;
   // inline static void register_lock(CPPClass & cl, File::File_lock_Functor::FunctionType func)

   struct File_putc_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File & , /*6Fj*/char ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/char ch);
   } putc;
   // inline static void register_putc(CPPClass & cl, File::File_putc_Functor::FunctionType func)

   struct File_puts_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/const char * string);
   } puts;
   // inline static void register_puts(CPPClass & cl, File::File_puts_Functor::FunctionType func)

   struct File_read_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uintsize (* FunctionType)(File & , /*6Fj*/void * buffer, /*6Fj*/uintsize size, /*6Fj*/uintsize count);
      inline FunctionType operator= (FunctionType func);
      inline uintsize operator()( /*6Fj*/void * buffer, /*6Fj*/uintsize size, /*6Fj*/uintsize count);
   } read;
   // inline static void register_read(CPPClass & cl, File::File_read_Functor::FunctionType func)

   struct File_seek_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File & , /*6Fj*/int64 pos, /*6Fj*/FileSeekMode mode);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int64 pos, /*6Fj*/FileSeekMode mode);
   } seek;
   // inline static void register_seek(CPPClass & cl, File::File_seek_Functor::FunctionType func)

   struct File_tell_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uint64 (* FunctionType)(File &);
      inline FunctionType operator= (FunctionType func);
      inline uint64 operator()( );
   } tell;
   // inline static void register_tell(CPPClass & cl, File::File_tell_Functor::FunctionType func)

   struct File_truncate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File & , /*6Fj*/uint64 size);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/uint64 size);
   } truncate;
   // inline static void register_truncate(CPPClass & cl, File::File_truncate_Functor::FunctionType func)

   struct File_unlock_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(File & , /*6Fj*/uint64 start, /*6Fj*/uint64 length, /*6Fj*/bool wait);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/uint64 start, /*6Fj*/uint64 length, /*6Fj*/bool wait);
   } unlock;
   // inline static void register_unlock(CPPClass & cl, File::File_unlock_Functor::FunctionType func)

   struct File_write_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uintsize (* FunctionType)(File & , /*6Fj*/const void * buffer, /*6Fj*/uintsize size, /*6Fj*/uintsize count);
      inline FunctionType operator= (FunctionType func);
      inline uintsize operator()( /*6Fj*/const void * buffer, /*6Fj*/uintsize size, /*6Fj*/uintsize count);
   } write;
   // inline static void register_write(CPPClass & cl, File::File_write_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline File(void * input, void * output, bool buffered);

   struct input_Prop
   {
      constexpr input_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline File::input_Prop & operator= (File::input_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } input;
   struct output_Prop
   {
      constexpr output_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline File::output_Prop & operator= (File::output_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } output;
   struct buffered_Prop
   {
      constexpr buffered_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } buffered;
   struct eof_Prop
   {
      constexpr eof_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } eof;
};

#define REG_MenuItem_notifySelect(m, c) REGVMETHOD(MenuItem, notifySelect, c::m, (/*1Ab*/Window & self, /*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods), c, (/*4Im*/self, /*4Im*/selection, /*4Hm*/(Modifiers)mods))

#define REG_MenuItem(c) \
      MenuItem::class_registration(_cpp_class); \
      REG_MenuItem_notifySelect(notifySelect, c);

#define MENUITEM_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifySelect, notifySelect, c, MenuItem, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/MenuItem & selection _ARG /*6Fj*/Modifiers mods);

#define MENUITEM_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifySelect, notifySelect, c, MenuItem, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/MenuItem & selection _ARG /*6Fj*/Modifiers mods, \
   return (bool)MenuItem_notifySelect(self ? self->impl : (C(MenuItem))null, o_.impl, /*7Al*/selection.impl, /*7Al*/(C(Modifiers))mods););

class MenuItem : public Instance
{
public:
   inline MenuItem(MenuItem && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline MenuItem & operator= (MenuItem && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   MenuItem() : MenuItem((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<MenuItem> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         MenuItem * inst = new MenuItem(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      MenuItem * inst = (MenuItem *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(MenuItem & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline MenuItem(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct MenuItem_notifySelect_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/MenuItem & selection, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/MenuItem & selection, /*6Fj*/Modifiers mods);
   } notifySelect;
   // inline static void register_notifySelect(CPPClass & cl, MenuItem::MenuItem_notifySelect_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct parent_Prop
   {
      constexpr parent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Menu & operator= (/*0A*/const Menu & v);
      /*nstSet*/inline /*0C*/const Menu * operator= (/*0C*/const Menu * v);
   } parent;
   struct text_Prop
   {
      constexpr text_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/const char * operator= (/*0G*/const char * v);
   } text;
   struct hotKey_Prop
   {
      constexpr hotKey_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Key operator= (/*0G*/Key v);
   } hotKey;
   struct accelerator_Prop
   {
      constexpr accelerator_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Key operator= (/*0G*/Key v);
   } accelerator;
   struct checked_Prop
   {
      constexpr checked_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MenuItem::checked_Prop & operator= (MenuItem::checked_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } checked;
   struct disabled_Prop
   {
      constexpr disabled_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } disabled;
   struct checkable_Prop
   {
      constexpr checkable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } checkable;
   struct isRadio_Prop
   {
      constexpr isRadio_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } isRadio;
   struct id_Prop
   {
      constexpr id_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint64 operator= (/*0H*/uint64 v);
      /*regSet*/inline MenuItem::id_Prop & operator= (MenuItem::id_Prop & prop);
      /*regGet*/inline operator /*0I*/uint64 () const;
   } id;
   struct bitmap_Prop
   {
      constexpr bitmap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const BitmapResource & operator= (/*0A*/const BitmapResource & v);
      /*regSet*/inline MenuItem::bitmap_Prop & operator= (MenuItem::bitmap_Prop & prop);
      /*nstSet*/inline /*0C*/const BitmapResource * operator= (/*0C*/const BitmapResource * v);
      /*regGet*/inline operator /*0B*/TIH<BitmapResource> () const;
      /*regGet*/inline TIH<BitmapResource> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/BitmapResource () const;
      /*regGet*/inline operator /*0F*/BitmapResource* () const;
   } bitmap;
   struct copyText_Prop
   {
      constexpr copyText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } copyText;
   struct bold_Prop
   {
      constexpr bold_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MenuItem::bold_Prop & operator= (MenuItem::bold_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } bold;
};


#define REG_SelectorButton(c) \
      SelectorButton::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_Button_notifyClicked(notifyClicked, c); \
      REG_Button_notifyDoubleClick(notifyDoubleClick, c); \
      REG_Button_notifyMouseLeave(notifyMouseLeave, c); \
      REG_Button_notifyMouseMove(notifyMouseMove, c); \
      REG_Button_notifyMouseOver(notifyMouseOver, c); \
      REG_Button_notifyPushed(notifyPushed, c); \
      REG_Button_notifyReleased(notifyReleased, c);

#define SELECTORBUTTON_VIRTUAL_METHODS_PROTO(c) \

#define SELECTORBUTTON_VIRTUAL_METHODS(c) \

class SelectorButton : public Button
{
public:
   inline SelectorButton(SelectorButton && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline SelectorButton & operator= (SelectorButton && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   SelectorButton() : SelectorButton((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<SelectorButton> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         SelectorButton * inst = new SelectorButton(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      SelectorButton * inst = (SelectorButton *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(SelectorButton & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline SelectorButton(C(Instance) _impl, CPPClass & cl = _cpp_class) : Button(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct focusHolder_Prop
   {
      constexpr focusHolder_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Window operator= (/*0H*/Window v);
      /*regSet*/inline SelectorButton::focusHolder_Prop & operator= (SelectorButton::focusHolder_Prop & prop);
      /*regGet*/inline operator /*0I*/Window () const;
   } focusHolder;
};


#define REG_Stacker(c) \
      Stacker::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define STACKER_VIRTUAL_METHODS_PROTO(c) \

#define STACKER_VIRTUAL_METHODS(c) \

class Stacker : public Window
{
public:
   inline Stacker(Stacker && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Stacker & operator= (Stacker && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Stacker() : Stacker((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Stacker> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Stacker * inst = new Stacker(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Stacker * inst = (Stacker *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Stacker & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Stacker(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   inline void destroyChildren(); // Stacker_destroyChildren
   inline Window getNextStackedItem(/*1Ab*/Window & current, /*1Ab*/bool previous, /*1Ab*/Class filter); // Stacker_getNextStackedItem
   inline void makeControlVisible(/*1Ab*/Window & control); // Stacker_makeControlVisible
   inline void moveControl(/*1Ab*/IteratorPointer ctrl, /*1Ab*/IteratorPointer after, /*1Ab*/bool fixCycle); // Stacker_moveControl

   static void class_registration(CPPClass & _cpp_class);

   inline Stacker(ScrollDirection direction, int gap, bool reverse, bool scrollable);

   struct direction_Prop
   {
      constexpr direction_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ScrollDirection operator= (/*0H*/ScrollDirection v);
      /*regSet*/inline Stacker::direction_Prop & operator= (Stacker::direction_Prop & prop);
      /*regGet*/inline operator /*0I*/ScrollDirection () const;
   } direction;
   struct gap_Prop
   {
      constexpr gap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Stacker::gap_Prop & operator= (Stacker::gap_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } gap;
   struct reverse_Prop
   {
      constexpr reverse_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Stacker::reverse_Prop & operator= (Stacker::reverse_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } reverse;
   struct scrollable_Prop
   {
      constexpr scrollable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Stacker::scrollable_Prop & operator= (Stacker::scrollable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } scrollable;
   struct controls_Prop
   {
      constexpr controls_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<TArray<C(Window) _ARG int _ARG C(Window)>> () const;
      /*regGet*/inline TIH<TArray<C(Window) _ARG int _ARG C(Window)>> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/TArray<C(Window) _ARG int _ARG C(Window)> () const;
      /*regGet*/inline operator /*0F*/TArray<C(Window) _ARG int _ARG C(Window)>* () const;
   } controls;
   struct flipper_Prop
   {
      constexpr flipper_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline Stacker::flipper_Prop & operator= (Stacker::flipper_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } flipper;
   struct flipSpring_Prop
   {
      constexpr flipSpring_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Stacker::flipSpring_Prop & operator= (Stacker::flipSpring_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } flipSpring;
   struct autoSize_Prop
   {
      constexpr autoSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Stacker::autoSize_Prop & operator= (Stacker::autoSize_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } autoSize;
   struct margin_Prop
   {
      constexpr margin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Stacker::margin_Prop & operator= (Stacker::margin_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } margin;
   struct endButtons_Prop
   {
      constexpr endButtons_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Stacker::endButtons_Prop & operator= (Stacker::endButtons_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } endButtons;
   struct hoverScroll_Prop
   {
      constexpr hoverScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Stacker::hoverScroll_Prop & operator= (Stacker::hoverScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hoverScroll;
};

enum class BoxAlignment : int
{
   center = BoxAlignment_center,
   left = BoxAlignment_left,
   right = BoxAlignment_right,
   top = BoxAlignment_top,
   bottom = BoxAlignment_bottom
};

struct BufferLocation : public TStruct<BufferLocation>
{
public:
   C(BufferLocation) impl;
   constexpr BufferLocation() : impl({}) { }
   constexpr BufferLocation(const C(BufferLocation) impl) : impl(impl) { }

   inline void adjustAdd(/*1Ab*/BufferLocation & start, /*1Ab*/BufferLocation & end); // BufferLocation_adjustAdd
   inline void adjustAdd(/*1Ac*/BufferLocation * start, /*1Ac*/BufferLocation * end); // BufferLocation_adjustAdd
   inline void adjustDelete(/*1Ab*/BufferLocation & start, /*1Ab*/BufferLocation & end); // BufferLocation_adjustDelete
   inline void adjustDelete(/*1Ac*/BufferLocation * start, /*1Ac*/BufferLocation * end); // BufferLocation_adjustDelete

   struct line_Prop
   {
      constexpr line_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/EditLine operator= (/*0H*/EditLine & v);
      /*regSet*/inline BufferLocation::line_Prop & operator= (BufferLocation::line_Prop & prop);
      /*regGet*/inline operator /*0I*/EditLine () const;
   } line;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline BufferLocation::y_Prop & operator= (BufferLocation::y_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } y;
   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline BufferLocation::x_Prop & operator= (BufferLocation::x_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } x;
};

enum class ButtonState : int
{
   up = ButtonState_up,
   down = ButtonState_down,
   over = ButtonState_over,
   disabled = ButtonState_disabled,
   upChecked = ButtonState_upChecked,
   downChecked = ButtonState_downChecked,
   overChecked = ButtonState_overChecked,
   disabledChecked = ButtonState_disabledChecked
};

#define REG_CalendarControl_notifyChanged(m, c) REGVMETHOD(CalendarControl, notifyChanged, c::m, (/*1Ab*/Window & self, /*1Ab*/CalendarControl & calendarControl, /*1Ab*/bool close), c, (/*4Im*/self, /*4Im*/calendarControl, /*4Hm*/(bool)close))

#define REG_CalendarControl(c) \
      CalendarControl::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_CalendarControl_notifyChanged(notifyChanged, c);

#define CALENDARCONTROL_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyChanged, notifyChanged, c, CalendarControl, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/CalendarControl & calendarControl _ARG /*6Fj*/bool close);

#define CALENDARCONTROL_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyChanged, notifyChanged, c, CalendarControl, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/CalendarControl & calendarControl _ARG /*6Fj*/bool close, \
   CalendarControl_notifyChanged(self ? self->impl : (C(CalendarControl))null, self ? self->impl : (C(CalendarControl))null, /*7Al*/calendarControl.impl, /*7Al*/(C(bool))close););

class CalendarControl : public CommonControl
{
public:
   inline CalendarControl(CalendarControl && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline CalendarControl & operator= (CalendarControl && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   CalendarControl() : CalendarControl((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<CalendarControl> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         CalendarControl * inst = new CalendarControl(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      CalendarControl * inst = (CalendarControl *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(CalendarControl & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline CalendarControl(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   struct CalendarControl_notifyChanged_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/CalendarControl & calendarControl, /*6Fj*/bool close);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/CalendarControl & calendarControl, /*6Fj*/bool close);
   } notifyChanged;
   // inline static void register_notifyChanged(CPPClass & cl, CalendarControl::CalendarControl_notifyChanged_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline CalendarControl(Date dateValue, Month shownMonth, int shownYear);

   struct dateValue_Prop
   {
      constexpr dateValue_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Date operator= (/*0H*/Date v);
      /*regSet*/inline CalendarControl::dateValue_Prop & operator= (CalendarControl::dateValue_Prop & prop);
      /*regGet*/inline operator /*0I*/Date () const;
   } dateValue;
   struct shownMonth_Prop
   {
      constexpr shownMonth_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Month operator= (/*0H*/Month v);
      /*regSet*/inline CalendarControl::shownMonth_Prop & operator= (CalendarControl::shownMonth_Prop & prop);
      /*regGet*/inline operator /*0I*/Month () const;
   } shownMonth;
   struct shownYear_Prop
   {
      constexpr shownYear_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline CalendarControl::shownYear_Prop & operator= (CalendarControl::shownYear_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } shownYear;
};


#define REG_DataField(c) \
      DataField::class_registration(_cpp_class);

#define DATAFIELD_VIRTUAL_METHODS_PROTO(c) \

#define DATAFIELD_VIRTUAL_METHODS(c) \

class DataField : public Instance
{
public:
   inline DataField(DataField && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DataField & operator= (DataField && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DataField() : DataField((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DataField> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DataField * inst = new DataField(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DataField * inst = (DataField *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DataField & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DataField(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void autoSize(); // DataField_autoSize
   inline void move(/*1Ab*/DataField & after); // DataField_move

   static void class_registration(CPPClass & _cpp_class);

   struct dataType_Prop
   {
      constexpr dataType_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Class operator= (/*0H*/Class & v);
      /*regSet*/inline DataField::dataType_Prop & operator= (DataField::dataType_Prop & prop);
      /*regGet*/inline operator /*0I*/Class () const;
   } dataType;
   struct editable_Prop
   {
      constexpr editable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } editable;
   struct fixed_Prop
   {
      constexpr fixed_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataField::fixed_Prop & operator= (DataField::fixed_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fixed;
   struct alignment_Prop
   {
      constexpr alignment_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Alignment operator= (/*0H*/Alignment v);
      /*regSet*/inline DataField::alignment_Prop & operator= (DataField::alignment_Prop & prop);
      /*regGet*/inline operator /*0I*/Alignment () const;
   } alignment;
   struct width_Prop
   {
      constexpr width_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DataField::width_Prop & operator= (DataField::width_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } width;
   struct index_Prop
   {
      constexpr index_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } index;
   struct position_Prop
   {
      constexpr position_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DataField::position_Prop & operator= (DataField::position_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } position;
   struct sortOrder_Prop
   {
      constexpr sortOrder_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } sortOrder;
   struct header_Prop
   {
      constexpr header_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/const char * operator= (/*0G*/const char * v);
   } header;
   struct userData_Prop
   {
      constexpr userData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline DataField::userData_Prop & operator= (DataField::userData_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } userData;
   struct freeData_Prop
   {
      constexpr freeData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataField::freeData_Prop & operator= (DataField::freeData_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } freeData;
   struct prev_Prop
   {
      constexpr prev_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataField> () const;
      /*regGet*/inline TIH<DataField> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataField () const;
      /*regGet*/inline operator /*0F*/DataField* () const;
   } prev;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataField> () const;
      /*regGet*/inline TIH<DataField> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataField () const;
      /*regGet*/inline operator /*0F*/DataField* () const;
   } next;
};

struct DataFieldSort : public TStruct<DataFieldSort>
{
public:
   C(DataFieldSort) impl;
   constexpr DataFieldSort() : impl({}) { }
   constexpr DataFieldSort(const C(DataFieldSort) impl) : impl(impl) { }

   struct field_Prop
   {
      constexpr field_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DataField operator= (/*0H*/DataField v);
      /*regSet*/inline DataFieldSort::field_Prop & operator= (DataFieldSort::field_Prop & prop);
      /*regGet*/inline operator /*0I*/DataField () const;
   } field;
   struct order_Prop
   {
      constexpr order_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DataFieldSort::order_Prop & operator= (DataFieldSort::order_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } order;
};


#define REG_DataRow(c) \
      DataRow::class_registration(_cpp_class);

#define DATAROW_VIRTUAL_METHODS_PROTO(c) \

#define DATAROW_VIRTUAL_METHODS(c) \

class DataRow : public Instance
{
public:
   inline DataRow(DataRow && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DataRow & operator= (DataRow && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DataRow() : DataRow((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DataRow> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DataRow * inst = new DataRow(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DataRow * inst = (DataRow *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DataRow & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DataRow(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline DataRow addRow(); // DataRow_addRow
   inline DataRow addRowAfter(/*1Ab*/DataRow & after); // DataRow_addRowAfter
   inline DataRow addString(/*1Ab*/const char * string); // DataRow_addString
   template<typename... Args> inline DataRow addStringf(/*1Ab*/const char * format, /*1Ab*/Args... args); // DataRow_addStringf
   inline void edit(/*1Ab*/DataField & field); // DataRow_edit
   inline DataRow findRow(/*1Ab*/int64 tag); // DataRow_findRow
   inline DataRow findSubRow(/*1Ab*/int64 tag); // DataRow_findSubRow
   inline any_object getData(/*1Ab*/DataField & field); // DataRow_getData
   inline DataRow getNextRow(); // DataRow_getNextRow
   inline DataRow getPrevRow(); // DataRow_getPrevRow
   inline void move(/*1Ab*/DataRow & after); // DataRow_move
   inline void * setData(/*1Ab*/DataField & field, /*1Ab*/any_object newData); // DataRow_setData
   inline void sortSubRows(/*1Ab*/bool scrollToCurrent); // DataRow_sortSubRows
   inline void unsetData(/*1Ab*/DataField & field); // DataRow_unsetData

   static void class_registration(CPPClass & _cpp_class);

   inline DataRow(int64 tag, const char * string, bool isHeader);

   struct tag_Prop
   {
      constexpr tag_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int64 operator= (/*0H*/int64 v);
      /*regSet*/inline DataRow::tag_Prop & operator= (DataRow::tag_Prop & prop);
      /*regGet*/inline operator /*0I*/int64 () const;
   } tag;
   struct previous_Prop
   {
      constexpr previous_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } previous;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } next;
   struct index_Prop
   {
      constexpr index_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } index;
   struct string_Prop
   {
      constexpr string_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline DataRow::string_Prop & operator= (DataRow::string_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } string;
   struct isHeader_Prop
   {
      constexpr isHeader_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataRow::isHeader_Prop & operator= (DataRow::isHeader_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isHeader;
   struct icon_Prop
   {
      constexpr icon_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const BitmapResource & operator= (/*0A*/const BitmapResource & v);
      /*regSet*/inline DataRow::icon_Prop & operator= (DataRow::icon_Prop & prop);
      /*nstSet*/inline /*0C*/const BitmapResource * operator= (/*0C*/const BitmapResource * v);
      /*regGet*/inline operator /*0B*/TIH<BitmapResource> () const;
      /*regGet*/inline TIH<BitmapResource> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/BitmapResource () const;
      /*regGet*/inline operator /*0F*/BitmapResource* () const;
   } icon;
   struct collapsed_Prop
   {
      constexpr collapsed_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataRow::collapsed_Prop & operator= (DataRow::collapsed_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } collapsed;
   struct selected_Prop
   {
      constexpr selected_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DataRow::selected_Prop & operator= (DataRow::selected_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } selected;
   struct parent_Prop
   {
      constexpr parent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const DataRow & operator= (/*0A*/const DataRow & v);
      /*regSet*/inline DataRow::parent_Prop & operator= (DataRow::parent_Prop & prop);
      /*nstSet*/inline /*0C*/const DataRow * operator= (/*0C*/const DataRow * v);
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } parent;
   struct lastRow_Prop
   {
      constexpr lastRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } lastRow;
   struct firstRow_Prop
   {
      constexpr firstRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } firstRow;
};

#define REG_DirectoriesBox_notifyModified(m, c)        REGVMETHOD(DirectoriesBox, notifyModified,        c::m, (/*1Ab*/Window & self, /*1Ab*/DirectoriesBox & dirsBox),                           c, (/*4Im*/self, /*4Im*/dirsBox))
#define REG_DirectoriesBox_notifyPathBoxModified(m, c) REGVMETHOD(DirectoriesBox, notifyPathBoxModified, c::m, (/*1Ab*/Window & self, /*1Ab*/DirectoriesBox & dirsBox, /*1Ab*/PathBox & pathBox), c, (/*4Im*/self, /*4Im*/dirsBox, /*4Im*/pathBox))
#define REG_DirectoriesBox_onBrowsedDir(m, c)          REGVMETHOD(DirectoriesBox, onBrowsedDir,          c::m, (/*1Ab*/DirectoriesBox & self, /*1Ab*/char ** directory),                          c, (/*4Im*/directory))
#define REG_DirectoriesBox_onChangedDir(m, c)          REGVMETHOD(DirectoriesBox, onChangedDir,          c::m, (/*1Ab*/DirectoriesBox & self, /*1Ab*/char ** directory),                          c, (/*4Im*/directory))
#define REG_DirectoriesBox_onPrepareBrowseDir(m, c)    REGVMETHOD(DirectoriesBox, onPrepareBrowseDir,    c::m, (/*1Ab*/DirectoriesBox & self, /*1Ab*/char ** directory),                          c, (/*4Im*/directory))

#define REG_DirectoriesBox(c) \
      DirectoriesBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_DirectoriesBox_notifyModified(notifyModified, c); \
      REG_DirectoriesBox_notifyPathBoxModified(notifyPathBoxModified, c); \
      REG_DirectoriesBox_onBrowsedDir(onBrowsedDir, c); \
      REG_DirectoriesBox_onChangedDir(onChangedDir, c); \
      REG_DirectoriesBox_onPrepareBrowseDir(onPrepareBrowseDir, c);

#define DIRECTORIESBOX_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyModified, notifyModified, c, DirectoriesBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DirectoriesBox & dirsBox); \
   VIRTUAL_METHOD_PROTO(notifyPathBoxModified, notifyPathBoxModified, c, DirectoriesBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DirectoriesBox & dirsBox _ARG /*6Fj*/PathBox & pathBox); \
   VIRTUAL_METHOD_PROTO(onBrowsedDir, onBrowsedDir, c, DirectoriesBox, \
      bool, c & _ARG, , /*6Fj*/char ** directory); \
   VIRTUAL_METHOD_PROTO(onChangedDir, onChangedDir, c, DirectoriesBox, \
      bool, c & _ARG, , /*6Fj*/char ** directory); \
   VIRTUAL_METHOD_PROTO(onPrepareBrowseDir, onPrepareBrowseDir, c, DirectoriesBox, \
      bool, c & _ARG, , /*6Fj*/char ** directory);

#define DIRECTORIESBOX_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyModified, notifyModified, c, DirectoriesBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DirectoriesBox & dirsBox, \
   return (bool)DirectoriesBox_notifyModified(self ? self->impl : (C(DirectoriesBox))null, o_.impl, /*7Al*/dirsBox.impl);); \
VIRTUAL_METHOD(notifyPathBoxModified, notifyPathBoxModified, c, DirectoriesBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DirectoriesBox & dirsBox _ARG /*6Fj*/PathBox & pathBox, \
   return (bool)DirectoriesBox_notifyPathBoxModified(self ? self->impl : (C(DirectoriesBox))null, o_.impl, /*7Al*/dirsBox.impl, /*7Al*/pathBox.impl);); \
VIRTUAL_METHOD(onBrowsedDir, onBrowsedDir, c, DirectoriesBox, \
   bool, c & _ARG, , /*6Fj*/char ** directory, \
   return (bool)DirectoriesBox_onBrowsedDir(self ? self->impl : (C(DirectoriesBox))null, /*7Al*/directory);); \
VIRTUAL_METHOD(onChangedDir, onChangedDir, c, DirectoriesBox, \
   bool, c & _ARG, , /*6Fj*/char ** directory, \
   return (bool)DirectoriesBox_onChangedDir(self ? self->impl : (C(DirectoriesBox))null, /*7Al*/directory);); \
VIRTUAL_METHOD(onPrepareBrowseDir, onPrepareBrowseDir, c, DirectoriesBox, \
   bool, c & _ARG, , /*6Fj*/char ** directory, \
   return (bool)DirectoriesBox_onPrepareBrowseDir(self ? self->impl : (C(DirectoriesBox))null, /*7Al*/directory););

class DirectoriesBox : public CommonControl
{
public:
   inline DirectoriesBox(DirectoriesBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DirectoriesBox & operator= (DirectoriesBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DirectoriesBox() : DirectoriesBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DirectoriesBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DirectoriesBox * inst = new DirectoriesBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DirectoriesBox * inst = (DirectoriesBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DirectoriesBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DirectoriesBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   struct DirectoriesBox_notifyModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/DirectoriesBox & dirsBox);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/DirectoriesBox & dirsBox);
   } notifyModified;
   // inline static void register_notifyModified(CPPClass & cl, DirectoriesBox::DirectoriesBox_notifyModified_Functor::FunctionType func)

   struct DirectoriesBox_notifyPathBoxModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/DirectoriesBox & dirsBox, /*6Fj*/PathBox & pathBox);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/DirectoriesBox & dirsBox, /*6Fj*/PathBox & pathBox);
   } notifyPathBoxModified;
   // inline static void register_notifyPathBoxModified(CPPClass & cl, DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::FunctionType func)

   struct DirectoriesBox_onBrowsedDir_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DirectoriesBox & , /*6Fj*/char ** directory);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/char ** directory);
   } onBrowsedDir;
   // inline static void register_onBrowsedDir(CPPClass & cl, DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::FunctionType func)

   struct DirectoriesBox_onChangedDir_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DirectoriesBox & , /*6Fj*/char ** directory);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/char ** directory);
   } onChangedDir;
   // inline static void register_onChangedDir(CPPClass & cl, DirectoriesBox::DirectoriesBox_onChangedDir_Functor::FunctionType func)

   struct DirectoriesBox_onPrepareBrowseDir_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(DirectoriesBox & , /*6Fj*/char ** directory);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/char ** directory);
   } onPrepareBrowseDir;
   // inline static void register_onPrepareBrowseDir(CPPClass & cl, DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline DirectoriesBox(bool browsing);

   struct strings_Prop
   {
      constexpr strings_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const TArray<C(String) _ARG int _ARG C(String)> & operator= (/*0A*/const TArray<C(String) _ARG int _ARG C(String)> & v);
      /*regSet*/inline DirectoriesBox::strings_Prop & operator= (DirectoriesBox::strings_Prop & prop);
      /*nstSet*/inline /*0C*/const TArray<C(String) _ARG int _ARG C(String)> * operator= (/*0C*/const TArray<C(String) _ARG int _ARG C(String)> * v);
      /*regGet*/inline operator /*0B*/TIH<TArray<C(String) _ARG int _ARG C(String)>> () const;
      /*regGet*/inline TIH<TArray<C(String) _ARG int _ARG C(String)>> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/TArray<C(String) _ARG int _ARG C(String)> () const;
      /*regGet*/inline operator /*0F*/TArray<C(String) _ARG int _ARG C(String)>* () const;
   } strings;
   struct browseDialog_Prop
   {
      constexpr browseDialog_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const FileDialog & operator= (/*0A*/const FileDialog & v);
      /*regSet*/inline DirectoriesBox::browseDialog_Prop & operator= (DirectoriesBox::browseDialog_Prop & prop);
      /*nstSet*/inline /*0C*/const FileDialog * operator= (/*0C*/const FileDialog * v);
      /*regGet*/inline operator /*0B*/TIH<FileDialog> () const;
      /*regGet*/inline TIH<FileDialog> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/FileDialog () const;
      /*regGet*/inline operator /*0F*/FileDialog* () const;
   } browseDialog;
   struct baseBrowsePath_Prop
   {
      constexpr baseBrowsePath_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/char * operator= (/*0H*/char * v);
      /*regSet*/inline DirectoriesBox::baseBrowsePath_Prop & operator= (DirectoriesBox::baseBrowsePath_Prop & prop);
      /*regGet*/inline operator /*0I*/char * () const;
   } baseBrowsePath;

   struct browsing_Prop
   {
      constexpr browsing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DirectoriesBox::browsing_Prop & operator= (DirectoriesBox::browsing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } browsing;
   struct add_Prop
   {
      constexpr add_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Button operator= (/*0H*/Button v);
      /*regSet*/inline DirectoriesBox::add_Prop & operator= (DirectoriesBox::add_Prop & prop);
      /*regGet*/inline operator /*0I*/Button () const;
   } add;
   struct remove_Prop
   {
      constexpr remove_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Button operator= (/*0H*/Button v);
      /*regSet*/inline DirectoriesBox::remove_Prop & operator= (DirectoriesBox::remove_Prop & prop);
      /*regGet*/inline operator /*0I*/Button () const;
   } remove;
   struct up_Prop
   {
      constexpr up_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/RepButton operator= (/*0H*/RepButton v);
      /*regSet*/inline DirectoriesBox::up_Prop & operator= (DirectoriesBox::up_Prop & prop);
      /*regGet*/inline operator /*0I*/RepButton () const;
   } up;
   struct down_Prop
   {
      constexpr down_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/RepButton operator= (/*0H*/RepButton v);
      /*regSet*/inline DirectoriesBox::down_Prop & operator= (DirectoriesBox::down_Prop & prop);
      /*regGet*/inline operator /*0I*/RepButton () const;
   } down;
   struct list_Prop
   {
      constexpr list_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ListBox operator= (/*0H*/ListBox v);
      /*regSet*/inline DirectoriesBox::list_Prop & operator= (DirectoriesBox::list_Prop & prop);
      /*regGet*/inline operator /*0I*/ListBox () const;
   } list;
   struct dirField_Prop
   {
      constexpr dirField_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DataField operator= (/*0H*/DataField v);
      /*regSet*/inline DirectoriesBox::dirField_Prop & operator= (DirectoriesBox::dirField_Prop & prop);
      /*regGet*/inline operator /*0I*/DataField () const;
   } dirField;
};

#define REG_DropBox_notifyClose(m, c)     REGVMETHOD(DropBox, notifyClose,     c::m, (/*1Ab*/Window & self, /*1Ab*/DropBox & dropBox),                                                    c, (/*4Im*/self, /*4Im*/dropBox))
#define REG_DropBox_notifyHighlight(m, c) REGVMETHOD(DropBox, notifyHighlight, c::m, (/*1Ab*/Window & self, /*1Ab*/DropBox & dropBox, /*1Ab*/DataRow & row, /*1Ab*/Modifiers mods),       c, (/*4Im*/self, /*4Im*/dropBox, /*4Im*/row, /*4Hm*/(Modifiers)mods))
#define REG_DropBox_notifySelect(m, c)    REGVMETHOD(DropBox, notifySelect,    c::m, (/*1Ab*/Window & self, /*1Ab*/DropBox & dropBox, /*1Ab*/DataRow & row, /*1Ab*/Modifiers mods),       c, (/*4Im*/self, /*4Im*/dropBox, /*4Im*/row, /*4Hm*/(Modifiers)mods))
#define REG_DropBox_notifyTextEntry(m, c) REGVMETHOD(DropBox, notifyTextEntry, c::m, (/*1Ab*/Window & self, /*1Ab*/DropBox & dropBox, /*1Ab*/const char * string, /*1Ab*/bool confirmed), c, (/*4Im*/self, /*4Im*/dropBox, /*4Im*/string, /*4Hm*/(bool)confirmed))
#define REG_DropBox_onCloseDropDown(m, c) REGVMETHOD(DropBox, onCloseDropDown, c::m, (/*1Ab*/DropBox & self, /*1Ab*/Window & pullDown),                                                   c, (/*4Im*/pullDown))
#define REG_DropBox_onDropDown(m, c)      REGVMETHOD(DropBox, onDropDown,      c::m, (/*1Ab*/DropBox & self),                                                                             c, ())

#define REG_DropBox(c) \
      DropBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_DropBox_notifyClose(notifyClose, c); \
      REG_DropBox_notifyHighlight(notifyHighlight, c); \
      REG_DropBox_notifySelect(notifySelect, c); \
      REG_DropBox_notifyTextEntry(notifyTextEntry, c); \
      REG_DropBox_onCloseDropDown(onCloseDropDown, c); \
      REG_DropBox_onDropDown(onDropDown, c);

#define DROPBOX_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyClose, notifyClose, c, DropBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox); \
   VIRTUAL_METHOD_PROTO(notifyHighlight, notifyHighlight, c, DropBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifySelect, notifySelect, c, DropBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyTextEntry, notifyTextEntry, c, DropBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox _ARG /*6Fj*/const char * string _ARG /*6Fj*/bool confirmed); \
   VIRTUAL_METHOD_PROTO(onCloseDropDown, onCloseDropDown, c, DropBox, \
      void, c & _ARG, , /*6Fj*/Window & pullDown); \
   VIRTUAL_METHOD_PROTO(onDropDown, onDropDown, c, DropBox, \
      Window *, c &, , );

#define DROPBOX_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyClose, notifyClose, c, DropBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox, \
   return (bool)DropBox_notifyClose(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl);); \
VIRTUAL_METHOD(notifyHighlight, notifyHighlight, c, DropBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods, \
   return (bool)DropBox_notifyHighlight(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifySelect, notifySelect, c, DropBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods, \
   return (bool)DropBox_notifySelect(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyTextEntry, notifyTextEntry, c, DropBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/DropBox & dropBox _ARG /*6Fj*/const char * string _ARG /*6Fj*/bool confirmed, \
   return (bool)DropBox_notifyTextEntry(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl, /*7Al*/string, /*7Al*/(C(bool))confirmed);); \
VIRTUAL_METHOD(onCloseDropDown, onCloseDropDown, c, DropBox, \
   void, c & _ARG, , /*6Fj*/Window & pullDown, \
   DropBox_onCloseDropDown(self ? self->impl : (C(DropBox))null, /*7Al*/pullDown.impl);); \
VIRTUAL_METHOD(onDropDown, onDropDown, c, DropBox, \
   Window *, c &, , , \
   C(Window) retWindow = DropBox_onDropDown(self ? self->impl : (C(DropBox))null); \
      return BINDINGS_CLASS(retWindow) ? (Window *)INSTANCEL(retWindow, retWindow->_class) : (Window *)0;);

class DropBox : public CommonControl
{
public:
   inline DropBox(DropBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DropBox & operator= (DropBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DropBox() : DropBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DropBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DropBox * inst = new DropBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DropBox * inst = (DropBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DropBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DropBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   inline void addField(/*1Ab*/DataField & field); // DropBox_addField
   inline DataRow addRow(); // DropBox_addRow
   inline DataRow addRowAfter(/*1Ab*/DataRow & after); // DropBox_addRowAfter
   inline DataRow addString(/*1Ab*/const char * string); // DropBox_addString
   template<typename... Args> inline DataRow addStringf(/*1Ab*/const char * format, /*1Ab*/Args... args); // DropBox_addStringf
   inline void clear(); // DropBox_clear
   inline void deleteRow(/*1Ab*/DataRow & row); // DropBox_deleteRow
   inline DataRow findRow(/*1Ab*/int64 tag); // DropBox_findRow
   inline DataRow findSubRow(/*1Ab*/int64 tag); // DropBox_findSubRow
   inline any_object getData(/*1Ab*/DataField & field); // DropBox_getData
   inline int getRowCount(); // DropBox_getRowCount
   inline int64 getTag(); // DropBox_getTag
   inline C(bool) save(); // DropBox_save
   inline void selectRow(/*1Ab*/DataRow & row); // DropBox_selectRow
   inline void * setData(/*1Ab*/DataField & field, /*1Ab*/any_object data); // DropBox_setData
   inline void sort(/*1Ab*/DataField & field, /*1Ab*/int order); // DropBox_sort

   struct DropBox_notifyClose_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/DropBox & dropBox);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox);
   } notifyClose;
   // inline static void register_notifyClose(CPPClass & cl, DropBox::DropBox_notifyClose_Functor::FunctionType func)

   struct DropBox_notifyHighlight_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/DropBox & dropBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
   } notifyHighlight;
   // inline static void register_notifyHighlight(CPPClass & cl, DropBox::DropBox_notifyHighlight_Functor::FunctionType func)

   struct DropBox_notifySelect_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/DropBox & dropBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
   } notifySelect;
   // inline static void register_notifySelect(CPPClass & cl, DropBox::DropBox_notifySelect_Functor::FunctionType func)

   struct DropBox_notifyTextEntry_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/DropBox & dropBox, /*6Fj*/const char * string, /*6Fj*/bool confirmed);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox, /*6Fj*/const char * string, /*6Fj*/bool confirmed);
   } notifyTextEntry;
   // inline static void register_notifyTextEntry(CPPClass & cl, DropBox::DropBox_notifyTextEntry_Functor::FunctionType func)

   struct DropBox_onCloseDropDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DropBox & , /*6Fj*/Window & pullDown);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Window & pullDown);
   } onCloseDropDown;
   // inline static void register_onCloseDropDown(CPPClass & cl, DropBox::DropBox_onCloseDropDown_Functor::FunctionType func)

   struct DropBox_onDropDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Window * (* FunctionType)(DropBox &);
      inline FunctionType operator= (FunctionType func);
      inline Window * operator()( );
   } onDropDown;
   // inline static void register_onDropDown(CPPClass & cl, DropBox::DropBox_onDropDown_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline DropBox(bool activeStipple, bool showButton, Alignment alignment, bool noHighlight, bool activeColor);

   struct activeStipple_Prop
   {
      constexpr activeStipple_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DropBox::activeStipple_Prop & operator= (DropBox::activeStipple_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } activeStipple;
   struct showButton_Prop
   {
      constexpr showButton_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DropBox::showButton_Prop & operator= (DropBox::showButton_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } showButton;
   struct alignment_Prop
   {
      constexpr alignment_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Alignment operator= (/*0H*/Alignment v);
      /*regSet*/inline DropBox::alignment_Prop & operator= (DropBox::alignment_Prop & prop);
      /*regGet*/inline operator /*0I*/Alignment () const;
   } alignment;
   struct noHighlight_Prop
   {
      constexpr noHighlight_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DropBox::noHighlight_Prop & operator= (DropBox::noHighlight_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noHighlight;
   struct activeColor_Prop
   {
      constexpr activeColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DropBox::activeColor_Prop & operator= (DropBox::activeColor_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } activeColor;
   struct currentRow_Prop
   {
      constexpr currentRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const DataRow & operator= (/*0A*/const DataRow & v);
      /*regSet*/inline DropBox::currentRow_Prop & operator= (DropBox::currentRow_Prop & prop);
      /*nstSet*/inline /*0C*/const DataRow * operator= (/*0C*/const DataRow * v);
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } currentRow;
   struct firstRow_Prop
   {
      constexpr firstRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } firstRow;
   struct lastRow_Prop
   {
      constexpr lastRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } lastRow;
   struct contents_Prop
   {
      constexpr contents_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline DropBox::contents_Prop & operator= (DropBox::contents_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } contents;
   struct editText_Prop
   {
      constexpr editText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DropBox::editText_Prop & operator= (DropBox::editText_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } editText;
   struct editBox_Prop
   {
      constexpr editBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<EditBox> () const;
      /*regGet*/inline TIH<EditBox> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/EditBox () const;
      /*regGet*/inline operator /*0F*/EditBox* () const;
   } editBox;
   struct typingTimeout_Prop
   {
      constexpr typingTimeout_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Seconds operator= (/*0H*/Seconds v);
      /*regSet*/inline DropBox::typingTimeout_Prop & operator= (DropBox::typingTimeout_Prop & prop);
      /*regGet*/inline operator /*0I*/Seconds () const;
      /*regGet*/inline operator /*0J*/C(Time) () const;
   } typingTimeout;
   struct rowHeight_Prop
   {
      constexpr rowHeight_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DropBox::rowHeight_Prop & operator= (DropBox::rowHeight_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } rowHeight;
   struct maxShown_Prop
   {
      constexpr maxShown_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DropBox::maxShown_Prop & operator= (DropBox::maxShown_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } maxShown;
   struct pullDown_Prop
   {
      constexpr pullDown_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } pullDown;
   struct showNone_Prop
   {
      constexpr showNone_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DropBox::showNone_Prop & operator= (DropBox::showNone_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } showNone;
   struct selectionColor_Prop
   {
      constexpr selectionColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline DropBox::selectionColor_Prop & operator= (DropBox::selectionColor_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionColor;
   struct selectionText_Prop
   {
      constexpr selectionText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline DropBox::selectionText_Prop & operator= (DropBox::selectionText_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionText;
   struct changeContents_Prop
   {
      constexpr changeContents_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DropBox::changeContents_Prop & operator= (DropBox::changeContents_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } changeContents;
   struct listBox_Prop
   {
      constexpr listBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<ListBox> () const;
      /*regGet*/inline TIH<ListBox> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/ListBox () const;
      /*regGet*/inline operator /*0F*/ListBox* () const;
   } listBox;
   struct rowCount_Prop
   {
      constexpr rowCount_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } rowCount;

   struct button_Prop
   {
      constexpr button_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Button operator= (/*0H*/Button v);
      /*regSet*/inline DropBox::button_Prop & operator= (DropBox::button_Prop & prop);
      /*regGet*/inline operator /*0I*/Button () const;
   } button;
};

#define REG_EditBox_notifyCaretMove(m, c)     REGVMETHOD(EditBox, notifyCaretMove,     c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox, /*1Ab*/int line, /*1Ab*/int charPos),                                                          c, (/*4Im*/self, /*4Im*/editBox, /*4Im*/line, /*4Im*/charPos))
#define REG_EditBox_notifyCharsAdded(m, c)    REGVMETHOD(EditBox, notifyCharsAdded,    c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox, /*1Ab*/BufferLocation & before, /*1Ab*/BufferLocation & after, /*1Ab*/bool pasteOperation),    c, (/*4Im*/self, /*4Im*/editBox, /*4Im*/before, /*4Im*/after, /*4Hm*/(bool)pasteOperation))
#define REG_EditBox_notifyCharsDeleted(m, c)  REGVMETHOD(EditBox, notifyCharsDeleted,  c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox, /*1Ab*/BufferLocation & beforeLoc, /*1Ab*/BufferLocation & after, /*1Ab*/bool pasteOperation), c, (/*4Im*/self, /*4Im*/editBox, /*4Im*/beforeLoc, /*4Im*/after, /*4Hm*/(bool)pasteOperation))
#define REG_EditBox_notifyDoubleClick(m, c)   REGVMETHOD(EditBox, notifyDoubleClick,   c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox, /*1Ab*/EditLine line, /*1Ab*/Modifiers mods),                                                  c, (/*4Im*/self, /*4Im*/editBox, /*4Im*/line, /*4Hm*/(Modifiers)mods))
#define REG_EditBox_notifyDropped(m, c)       REGVMETHOD(EditBox, notifyDropped,       c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox, /*1Ab*/int x, /*1Ab*/int y),                                                                   c, (/*4Im*/self, /*4Im*/editBox, /*4Im*/x, /*4Im*/y))
#define REG_EditBox_notifyKeyDown(m, c)       REGVMETHOD(EditBox, notifyKeyDown,       c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox, /*1Ab*/Key key, /*1Ab*/unichar ch),                                                            c, (/*4Im*/self, /*4Im*/editBox, /*4Hm*/(Key)key, /*4Im*/ch))
#define REG_EditBox_notifyModified(m, c)      REGVMETHOD(EditBox, notifyModified,      c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox),                                                                                               c, (/*4Im*/self, /*4Im*/editBox))
#define REG_EditBox_notifyOvrToggle(m, c)     REGVMETHOD(EditBox, notifyOvrToggle,     c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox, /*1Ab*/bool overwrite),                                                                        c, (/*4Im*/self, /*4Im*/editBox, /*4Hm*/(bool)overwrite))
#define REG_EditBox_notifyUnsetModified(m, c) REGVMETHOD(EditBox, notifyUnsetModified, c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox),                                                                                               c, (/*4Im*/self, /*4Im*/editBox))
#define REG_EditBox_notifyUpdate(m, c)        REGVMETHOD(EditBox, notifyUpdate,        c::m, (/*1Ab*/Window & self, /*1Ab*/EditBox & editBox),                                                                                               c, (/*4Im*/self, /*4Im*/editBox))

#define REG_EditBox(c) \
      EditBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_EditBox_notifyCaretMove(notifyCaretMove, c); \
      REG_EditBox_notifyCharsAdded(notifyCharsAdded, c); \
      REG_EditBox_notifyCharsDeleted(notifyCharsDeleted, c); \
      REG_EditBox_notifyDoubleClick(notifyDoubleClick, c); \
      REG_EditBox_notifyDropped(notifyDropped, c); \
      REG_EditBox_notifyKeyDown(notifyKeyDown, c); \
      REG_EditBox_notifyModified(notifyModified, c); \
      REG_EditBox_notifyOvrToggle(notifyOvrToggle, c); \
      REG_EditBox_notifyUnsetModified(notifyUnsetModified, c); \
      REG_EditBox_notifyUpdate(notifyUpdate, c);

#define EDITBOX_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyCaretMove, notifyCaretMove, c, EditBox, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/int line _ARG /*6Fj*/int charPos); \
   VIRTUAL_METHOD_PROTO(notifyCharsAdded, notifyCharsAdded, c, EditBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/BufferLocation & before _ARG /*6Fj*/BufferLocation & after _ARG /*6Fj*/bool pasteOperation); \
   VIRTUAL_METHOD_PROTO(notifyCharsDeleted, notifyCharsDeleted, c, EditBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/BufferLocation & beforeLoc _ARG /*6Fj*/BufferLocation & after _ARG /*6Fj*/bool pasteOperation); \
   VIRTUAL_METHOD_PROTO(notifyDoubleClick, notifyDoubleClick, c, EditBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/EditLine line _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyDropped, notifyDropped, c, EditBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/int x _ARG /*6Fj*/int y); \
   VIRTUAL_METHOD_PROTO(notifyKeyDown, notifyKeyDown, c, EditBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(notifyModified, notifyModified, c, EditBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox); \
   VIRTUAL_METHOD_PROTO(notifyOvrToggle, notifyOvrToggle, c, EditBox, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/bool overwrite); \
   VIRTUAL_METHOD_PROTO(notifyUnsetModified, notifyUnsetModified, c, EditBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox); \
   VIRTUAL_METHOD_PROTO(notifyUpdate, notifyUpdate, c, EditBox, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox);

#define EDITBOX_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyCaretMove, notifyCaretMove, c, EditBox, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/int line _ARG /*6Fj*/int charPos, \
   EditBox_notifyCaretMove(self ? self->impl : (C(EditBox))null, self ? self->impl : (C(EditBox))null, /*7Al*/editBox.impl, /*7Al*/line, /*7Al*/charPos);); \
VIRTUAL_METHOD(notifyCharsAdded, notifyCharsAdded, c, EditBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/BufferLocation & before _ARG /*6Fj*/BufferLocation & after _ARG /*6Fj*/bool pasteOperation, \
   return (bool)EditBox_notifyCharsAdded(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/&before.impl, /*7Al*/&after.impl, /*7Al*/(C(bool))pasteOperation);); \
VIRTUAL_METHOD(notifyCharsDeleted, notifyCharsDeleted, c, EditBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/BufferLocation & beforeLoc _ARG /*6Fj*/BufferLocation & after _ARG /*6Fj*/bool pasteOperation, \
   return (bool)EditBox_notifyCharsDeleted(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/&beforeLoc.impl, /*7Al*/&after.impl, /*7Al*/(C(bool))pasteOperation);); \
VIRTUAL_METHOD(notifyDoubleClick, notifyDoubleClick, c, EditBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/EditLine line _ARG /*6Fj*/Modifiers mods, \
   return (bool)EditBox_notifyDoubleClick(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/line.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyDropped, notifyDropped, c, EditBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/int x _ARG /*6Fj*/int y, \
   return (bool)EditBox_notifyDropped(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/x, /*7Al*/y);); \
VIRTUAL_METHOD(notifyKeyDown, notifyKeyDown, c, EditBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)EditBox_notifyKeyDown(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(notifyModified, notifyModified, c, EditBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox, \
   return (bool)EditBox_notifyModified(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl);); \
VIRTUAL_METHOD(notifyOvrToggle, notifyOvrToggle, c, EditBox, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox _ARG /*6Fj*/bool overwrite, \
   EditBox_notifyOvrToggle(self ? self->impl : (C(EditBox))null, self ? self->impl : (C(EditBox))null, /*7Al*/editBox.impl, /*7Al*/(C(bool))overwrite);); \
VIRTUAL_METHOD(notifyUnsetModified, notifyUnsetModified, c, EditBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox, \
   return (bool)EditBox_notifyUnsetModified(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl);); \
VIRTUAL_METHOD(notifyUpdate, notifyUpdate, c, EditBox, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditBox & editBox, \
   EditBox_notifyUpdate(self ? self->impl : (C(EditBox))null, self ? self->impl : (C(EditBox))null, /*7Al*/editBox.impl););

class EditBox : public CommonControl
{
public:
   inline EditBox(EditBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline EditBox & operator= (EditBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   EditBox() : EditBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<EditBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         EditBox * inst = new EditBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      EditBox * inst = (EditBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(EditBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline EditBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   inline C(bool) addCh(/*1Ab*/unichar ch); // EditBox_addCh
   inline C(bool) addS(/*1Ab*/const char * string); // EditBox_addS
   inline void backSpace(); // EditBox_backSpace
   inline void centerOnCursor(); // EditBox_centerOnCursor
   inline void clear(); // EditBox_clear
   inline void clearLine(); // EditBox_clearLine
   inline void copy(); // EditBox_copy
   inline void cut(); // EditBox_cut
   inline void _delete(/*1Ab*/EditLine line1, /*1Ab*/int y1, /*1Ab*/int x1, /*1Ab*/EditLine line2, /*1Ab*/int y2, /*1Ab*/int x2); // EditBox_delete
   inline void deleteSelection(); // EditBox_deleteSelection
   inline void deselect(); // EditBox_deselect
   inline void end(); // EditBox_end
   inline C(EditBoxFindResult) find(/*1Ab*/const char * text, /*1Ab*/bool matchWord, /*1Ab*/bool matchCase, /*1Ab*/bool isSearchDown); // EditBox_find
   inline C(EditBoxFindResult) findInSelection(/*1Ab*/const char * text, /*1Ab*/bool matchWord, /*1Ab*/bool matchCase, /*1Ab*/EditLine l2, /*1Ab*/int y2, /*1Ab*/int x2); // EditBox_findInSelection
   inline void getSel(/*1Ab*/char * text, /*1Ab*/bool addCr); // EditBox_getSel
   inline void getSelPos(/*1Ab*/EditLine * l1, /*1Ab*/int * y1, /*1Ab*/int * x1, /*1Ab*/EditLine * l2, /*1Ab*/int * y2, /*1Ab*/int * x2, /*1Ab*/bool reorder); // EditBox_getSelPos
   inline int getText(/*1Ab*/char * text, /*1Ab*/EditLine _l1, /*1Ab*/int _y1, /*1Ab*/int _x1, /*1Ab*/EditLine _l2, /*1Ab*/int _y2, /*1Ab*/int _x2, /*1Ab*/bool addCr, /*1Ab*/bool addSpaces); // EditBox_getText
   inline C(bool) goToLineNum(/*1Ab*/int lineNum); // EditBox_goToLineNum
   inline C(bool) goToPosition(/*1Ab*/EditLine line, /*1Ab*/int y, /*1Ab*/int x); // EditBox_goToPosition
   inline void home(); // EditBox_home
   inline void lineDown(); // EditBox_lineDown
   inline void lineUp(); // EditBox_lineUp
   inline void load(/*1Ab*/File & f); // EditBox_load
   inline void modified(); // EditBox_modified
   inline void pageDown(); // EditBox_pageDown
   inline void pageUp(); // EditBox_pageUp
   inline void paste(); // EditBox_paste
   template<typename... Args> inline void _printf(/*1Ab*/const char * format, /*1Ab*/Args... args); // EditBox_printf
   inline void putCh(/*1Ab*/unichar ch); // EditBox_putCh
   inline void putS(/*1Ab*/const char * string); // EditBox_putS
   inline void record(/*1Ab*/UndoAction action); // EditBox_record
   inline void redo(); // EditBox_redo
   inline void save(/*1Ab*/File & f, /*1Ab*/bool cr); // EditBox_save
   inline uint selSize(); // EditBox_selSize
   inline void select(/*1Ab*/EditLine line1, /*1Ab*/int y1, /*1Ab*/int x1, /*1Ab*/EditLine line2, /*1Ab*/int y2, /*1Ab*/int x2); // EditBox_select
   inline void selectAll(); // EditBox_selectAll
   template<typename... Args> inline void setContents(/*1Ab*/const char * format, /*1Ab*/Args... args); // EditBox_setContents
   inline void setCursorToView(); // EditBox_setCursorToView
   inline void setModified(/*1Ab*/bool flag); // EditBox_setModified
   inline void setSelPos(/*1Ab*/EditLine l1, /*1Ab*/int y1, /*1Ab*/int x1, /*1Ab*/EditLine l2, /*1Ab*/int y2, /*1Ab*/int x2); // EditBox_setSelPos
   inline void setViewToCursor(/*1Ab*/bool setCaret); // EditBox_setViewToCursor
   inline void undo(); // EditBox_undo

   struct EditBox_notifyCaretMove_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/EditBox & editBox, /*6Fj*/int line, /*6Fj*/int charPos);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/int line, /*6Fj*/int charPos);
   } notifyCaretMove;
   // inline static void register_notifyCaretMove(CPPClass & cl, EditBox::EditBox_notifyCaretMove_Functor::FunctionType func)

   struct EditBox_notifyCharsAdded_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditBox & editBox, /*6Fj*/BufferLocation & before, /*6Fj*/BufferLocation & after, /*6Fj*/bool pasteOperation);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/BufferLocation & before, /*6Fj*/BufferLocation & after, /*6Fj*/bool pasteOperation);
   } notifyCharsAdded;
   // inline static void register_notifyCharsAdded(CPPClass & cl, EditBox::EditBox_notifyCharsAdded_Functor::FunctionType func)

   struct EditBox_notifyCharsDeleted_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditBox & editBox, /*6Fj*/BufferLocation & beforeLoc, /*6Fj*/BufferLocation & after, /*6Fj*/bool pasteOperation);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/BufferLocation & beforeLoc, /*6Fj*/BufferLocation & after, /*6Fj*/bool pasteOperation);
   } notifyCharsDeleted;
   // inline static void register_notifyCharsDeleted(CPPClass & cl, EditBox::EditBox_notifyCharsDeleted_Functor::FunctionType func)

   struct EditBox_notifyDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditBox & editBox, /*6Fj*/EditLine line, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/EditLine line, /*6Fj*/Modifiers mods);
   } notifyDoubleClick;
   // inline static void register_notifyDoubleClick(CPPClass & cl, EditBox::EditBox_notifyDoubleClick_Functor::FunctionType func)

   struct EditBox_notifyDropped_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditBox & editBox, /*6Fj*/int x, /*6Fj*/int y);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/int x, /*6Fj*/int y);
   } notifyDropped;
   // inline static void register_notifyDropped(CPPClass & cl, EditBox::EditBox_notifyDropped_Functor::FunctionType func)

   struct EditBox_notifyKeyDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditBox & editBox, /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/Key key, /*6Fj*/unichar ch);
   } notifyKeyDown;
   // inline static void register_notifyKeyDown(CPPClass & cl, EditBox::EditBox_notifyKeyDown_Functor::FunctionType func)

   struct EditBox_notifyModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditBox & editBox);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox);
   } notifyModified;
   // inline static void register_notifyModified(CPPClass & cl, EditBox::EditBox_notifyModified_Functor::FunctionType func)

   struct EditBox_notifyOvrToggle_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/EditBox & editBox, /*6Fj*/bool overwrite);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/bool overwrite);
   } notifyOvrToggle;
   // inline static void register_notifyOvrToggle(CPPClass & cl, EditBox::EditBox_notifyOvrToggle_Functor::FunctionType func)

   struct EditBox_notifyUnsetModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditBox & editBox);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox);
   } notifyUnsetModified;
   // inline static void register_notifyUnsetModified(CPPClass & cl, EditBox::EditBox_notifyUnsetModified_Functor::FunctionType func)

   struct EditBox_notifyUpdate_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/EditBox & editBox);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox);
   } notifyUpdate;
   // inline static void register_notifyUpdate(CPPClass & cl, EditBox::EditBox_notifyUpdate_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline EditBox(bool textHorzScroll, bool textVertScroll, bool readOnly, bool multiLine, bool freeCaret, bool tabKey, int tabSize, bool tabSelection, bool smartHome, bool autoEmpty, bool noCaret, int maxLineSize, int maxNumLines, bool useTab);

   struct textHorzScroll_Prop
   {
      constexpr textHorzScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::textHorzScroll_Prop & operator= (EditBox::textHorzScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } textHorzScroll;
   struct textVertScroll_Prop
   {
      constexpr textVertScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::textVertScroll_Prop & operator= (EditBox::textVertScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } textVertScroll;
   struct readOnly_Prop
   {
      constexpr readOnly_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::readOnly_Prop & operator= (EditBox::readOnly_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } readOnly;
   struct multiLine_Prop
   {
      constexpr multiLine_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::multiLine_Prop & operator= (EditBox::multiLine_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } multiLine;
   struct freeCaret_Prop
   {
      constexpr freeCaret_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::freeCaret_Prop & operator= (EditBox::freeCaret_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } freeCaret;
   struct tabKey_Prop
   {
      constexpr tabKey_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::tabKey_Prop & operator= (EditBox::tabKey_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } tabKey;
   struct tabSize_Prop
   {
      constexpr tabSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline EditBox::tabSize_Prop & operator= (EditBox::tabSize_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } tabSize;
   struct tabSelection_Prop
   {
      constexpr tabSelection_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::tabSelection_Prop & operator= (EditBox::tabSelection_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } tabSelection;
   struct smartHome_Prop
   {
      constexpr smartHome_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::smartHome_Prop & operator= (EditBox::smartHome_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } smartHome;
   struct autoEmpty_Prop
   {
      constexpr autoEmpty_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::autoEmpty_Prop & operator= (EditBox::autoEmpty_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } autoEmpty;
   struct noCaret_Prop
   {
      constexpr noCaret_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::noCaret_Prop & operator= (EditBox::noCaret_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noCaret;
   struct maxLineSize_Prop
   {
      constexpr maxLineSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline EditBox::maxLineSize_Prop & operator= (EditBox::maxLineSize_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } maxLineSize;
   struct maxNumLines_Prop
   {
      constexpr maxNumLines_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline EditBox::maxNumLines_Prop & operator= (EditBox::maxNumLines_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } maxNumLines;
   struct useTab_Prop
   {
      constexpr useTab_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::useTab_Prop & operator= (EditBox::useTab_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } useTab;
   struct syntaxHighlighting_Prop
   {
      constexpr syntaxHighlighting_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const EditSyntaxHL & operator= (/*0A*/const EditSyntaxHL & v);
      /*regSet*/inline EditBox::syntaxHighlighting_Prop & operator= (EditBox::syntaxHighlighting_Prop & prop);
      /*nstSet*/inline /*0C*/const EditSyntaxHL * operator= (/*0C*/const EditSyntaxHL * v);
      /*regGet*/inline operator /*0B*/TIH<EditSyntaxHL> () const;
      /*regGet*/inline TIH<EditSyntaxHL> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/EditSyntaxHL () const;
      /*regGet*/inline operator /*0F*/EditSyntaxHL* () const;
   } syntaxHighlighting;
   struct noSelect_Prop
   {
      constexpr noSelect_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::noSelect_Prop & operator= (EditBox::noSelect_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noSelect;
   struct allCaps_Prop
   {
      constexpr allCaps_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::allCaps_Prop & operator= (EditBox::allCaps_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } allCaps;
   struct autoSize_Prop
   {
      constexpr autoSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::autoSize_Prop & operator= (EditBox::autoSize_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } autoSize;
   struct wrap_Prop
   {
      constexpr wrap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::wrap_Prop & operator= (EditBox::wrap_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } wrap;
   struct numLines_Prop
   {
      constexpr numLines_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } numLines;
   struct lineNumber_Prop
   {
      constexpr lineNumber_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } lineNumber;
   struct column_Prop
   {
      constexpr column_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } column;
   struct charPos_Prop
   {
      constexpr charPos_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } charPos;
   struct firstLine_Prop
   {
      constexpr firstLine_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/EditLine () const;
   } firstLine;
   struct lastLine_Prop
   {
      constexpr lastLine_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/EditLine () const;
   } lastLine;
   struct line_Prop
   {
      constexpr line_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/EditLine () const;
   } line;
   struct contents_Prop
   {
      constexpr contents_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline EditBox::contents_Prop & operator= (EditBox::contents_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } contents;
   struct overwrite_Prop
   {
      constexpr overwrite_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } overwrite;
   struct caretFollowsScrolling_Prop
   {
      constexpr caretFollowsScrolling_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::caretFollowsScrolling_Prop & operator= (EditBox::caretFollowsScrolling_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } caretFollowsScrolling;
   struct multiLineContents_Prop
   {
      constexpr multiLineContents_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/char * () const;
   } multiLineContents;
   struct selectionColor_Prop
   {
      constexpr selectionColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline EditBox::selectionColor_Prop & operator= (EditBox::selectionColor_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionColor;
   struct selectionText_Prop
   {
      constexpr selectionText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline EditBox::selectionText_Prop & operator= (EditBox::selectionText_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionText;
   struct recordUndoEvent_Prop
   {
      constexpr recordUndoEvent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditBox::recordUndoEvent_Prop & operator= (EditBox::recordUndoEvent_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } recordUndoEvent;
};

enum class EditBoxFindResult : int
{
   notFound = EditBoxFindResult_notFound,
   found = EditBoxFindResult_found,
   wrapped = EditBoxFindResult_wrapped
};


#define REG_EditBoxStream(c) \
      EditBoxStream::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define EDITBOXSTREAM_VIRTUAL_METHODS_PROTO(c) \

#define EDITBOXSTREAM_VIRTUAL_METHODS(c) \

class EditBoxStream : public File
{
public:
   inline EditBoxStream(EditBoxStream && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline EditBoxStream & operator= (EditBoxStream && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   EditBoxStream() : EditBoxStream((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<EditBoxStream> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         EditBoxStream * inst = new EditBoxStream(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      EditBoxStream * inst = (EditBoxStream *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(EditBoxStream & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline EditBoxStream(C(Instance) _impl, CPPClass & cl = _cpp_class) : File(_impl, cl) { }

   inline void deleteBytes(/*1Ab*/uint count); // EditBoxStream_deleteBytes

   static void class_registration(CPPClass & _cpp_class);

   struct editBox_Prop
   {
      constexpr editBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const EditBox & operator= (/*0A*/const EditBox & v);
      /*regSet*/inline EditBoxStream::editBox_Prop & operator= (EditBoxStream::editBox_Prop & prop);
      /*nstSet*/inline /*0C*/const EditBox * operator= (/*0C*/const EditBox * v);
      /*regGet*/inline operator /*0B*/TIH<EditBox> () const;
      /*regGet*/inline TIH<EditBox> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/EditBox () const;
      /*regGet*/inline operator /*0F*/EditBox* () const;
   } editBox;
};

template <class TC, C(Class) ** TCO>
class TEditLine : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct text_Prop
   {
      constexpr text_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline typename TEditLine<TC, TCO>::text_Prop & operator= (typename TEditLine<TC, TCO>::text_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } text;
   struct prev_Prop
   {
      constexpr prev_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/EditLine () const;
   } prev;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/EditLine () const;
   } next;
   struct count_Prop
   {
      constexpr count_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } count;
   ~TEditLine()
   {
      this->impl = null; // How to know not to delete?
   }
};

#define REG_EditSyntaxHL_canImpactOtherLines(m, c)     REGVMETHOD(EditSyntaxHL, canImpactOtherLines,     c::m, (/*1Ab*/EditSyntaxHL & self, /*1Ab*/EditLine line),                                                                                                                               c, (/*4Im*/line))
#define REG_EditSyntaxHL_figureStartSyntaxStates(m, c) REGVMETHOD(EditSyntaxHL, figureStartSyntaxStates, c::m, (/*1Ab*/EditSyntaxHL & self, /*1Ab*/EditLine firstLine, /*1Ab*/bool reset, /*1Ab*/EditLine viewLine),                                                                             c, (/*4Im*/firstLine, /*4Hm*/(bool)reset, /*4Im*/viewLine))
#define REG_EditSyntaxHL_gotSpace(m, c)                REGVMETHOD(EditSyntaxHL, gotSpace,                c::m, (/*1Ab*/EditSyntaxHL & self, /*1Ab*/bool beforeEnd),                                                                                                                              c, (/*4Hm*/(bool)beforeEnd))
#define REG_EditSyntaxHL_initDraw(m, c)                REGVMETHOD(EditSyntaxHL, initDraw,                c::m, (/*1Ab*/EditSyntaxHL & self),                                                                                                                                                     c, ())
#define REG_EditSyntaxHL_nextLine(m, c)                REGVMETHOD(EditSyntaxHL, nextLine,                c::m, (/*1Ab*/EditSyntaxHL & self, /*1Ab*/char * buffer, /*1Ab*/int count),                                                                                                             c, (/*4Im*/buffer, /*4Im*/count))
#define REG_EditSyntaxHL_parseWord(m, c)               REGVMETHOD(EditSyntaxHL, parseWord,               c::m, (/*1Ab*/EditSyntaxHL & self, /*1Ab*/char * buffer, /*1Ab*/int count, /*1Ab*/int wordLen),                                                                                         c, (/*4Im*/buffer, /*4Im*/count, /*4Im*/wordLen))
#define REG_EditSyntaxHL_process(m, c)                 REGVMETHOD(EditSyntaxHL, process,                 c::m, (/*1Ab*/EditSyntaxHL & self, /*1Ab*/char * word, /*1Ab*/int * wordLen, /*1Ab*/bool beforeEndOfLine, /*1Ab*/Color defaultTextColor, /*1Ab*/const char * buffer, /*1Ab*/int * ap1), c, (/*4Im*/word, /*4Im*/wordLen, /*4Hm*/(bool)beforeEndOfLine, /*4Hm*/(Color)defaultTextColor, /*4Im*/buffer, /*4Im*/ap1))
#define REG_EditSyntaxHL_resetState(m, c)              REGVMETHOD(EditSyntaxHL, resetState,              c::m, (/*1Ab*/EditSyntaxHL & self),                                                                                                                                                     c, ())
#define REG_EditSyntaxHL_startLine(m, c)               REGVMETHOD(EditSyntaxHL, startLine,               c::m, (/*1Ab*/EditSyntaxHL & self),                                                                                                                                                     c, ())

#define REG_EditSyntaxHL(c) \
      EditSyntaxHL::class_registration(_cpp_class); \
      REG_EditSyntaxHL_canImpactOtherLines(canImpactOtherLines, c); \
      REG_EditSyntaxHL_figureStartSyntaxStates(figureStartSyntaxStates, c); \
      REG_EditSyntaxHL_gotSpace(gotSpace, c); \
      REG_EditSyntaxHL_initDraw(initDraw, c); \
      REG_EditSyntaxHL_nextLine(nextLine, c); \
      REG_EditSyntaxHL_parseWord(parseWord, c); \
      REG_EditSyntaxHL_process(process, c); \
      REG_EditSyntaxHL_resetState(resetState, c); \
      REG_EditSyntaxHL_startLine(startLine, c);

#define EDITSYNTAXHL_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(canImpactOtherLines, canImpactOtherLines, c, EditSyntaxHL, \
      bool, c & _ARG, , /*6Fj*/EditLine line); \
   VIRTUAL_METHOD_PROTO(figureStartSyntaxStates, figureStartSyntaxStates, c, EditSyntaxHL, \
      void, c & _ARG, , /*6Fj*/EditLine firstLine _ARG /*6Fj*/bool reset _ARG /*6Fj*/EditLine viewLine); \
   VIRTUAL_METHOD_PROTO(gotSpace, gotSpace, c, EditSyntaxHL, \
      void, c & _ARG, , /*6Fj*/bool beforeEnd); \
   VIRTUAL_METHOD_PROTO(initDraw, initDraw, c, EditSyntaxHL, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(nextLine, nextLine, c, EditSyntaxHL, \
      void, c & _ARG, , /*6Fj*/char * buffer _ARG /*6Fj*/int count); \
   VIRTUAL_METHOD_PROTO(parseWord, parseWord, c, EditSyntaxHL, \
      int, c & _ARG, , /*6Fj*/char * buffer _ARG /*6Fj*/int count _ARG /*6Fj*/int wordLen); \
   VIRTUAL_METHOD_PROTO(process, process, c, EditSyntaxHL, \
      Color, c & _ARG, , /*6Fj*/char * word _ARG /*6Fj*/int * wordLen _ARG /*6Fj*/bool beforeEndOfLine _ARG /*6Fj*/Color defaultTextColor _ARG /*6Fj*/const char * buffer _ARG /*6Fj*/int * ap1); \
   VIRTUAL_METHOD_PROTO(resetState, resetState, c, EditSyntaxHL, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(startLine, startLine, c, EditSyntaxHL, \
      void, c &, , );

#define EDITSYNTAXHL_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(canImpactOtherLines, canImpactOtherLines, c, EditSyntaxHL, \
   bool, c & _ARG, , /*6Fj*/EditLine line, \
   return (bool)EditSyntaxHL_canImpactOtherLines(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/line.impl);); \
VIRTUAL_METHOD(figureStartSyntaxStates, figureStartSyntaxStates, c, EditSyntaxHL, \
   void, c & _ARG, , /*6Fj*/EditLine firstLine _ARG /*6Fj*/bool reset _ARG /*6Fj*/EditLine viewLine, \
   EditSyntaxHL_figureStartSyntaxStates(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/firstLine.impl, /*7Al*/(C(bool))reset, /*7Al*/viewLine.impl);); \
VIRTUAL_METHOD(gotSpace, gotSpace, c, EditSyntaxHL, \
   void, c & _ARG, , /*6Fj*/bool beforeEnd, \
   EditSyntaxHL_gotSpace(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/(C(bool))beforeEnd);); \
VIRTUAL_METHOD(initDraw, initDraw, c, EditSyntaxHL, \
   void, c &, , , \
   EditSyntaxHL_initDraw(self ? self->impl : (C(EditSyntaxHL))null);); \
VIRTUAL_METHOD(nextLine, nextLine, c, EditSyntaxHL, \
   void, c & _ARG, , /*6Fj*/char * buffer _ARG /*6Fj*/int count, \
   EditSyntaxHL_nextLine(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/buffer, /*7Al*/count);); \
VIRTUAL_METHOD(parseWord, parseWord, c, EditSyntaxHL, \
   int, c & _ARG, , /*6Fj*/char * buffer _ARG /*6Fj*/int count _ARG /*6Fj*/int wordLen, \
   return EditSyntaxHL_parseWord(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/buffer, /*7Al*/count, /*7Al*/wordLen);); \
VIRTUAL_METHOD(process, process, c, EditSyntaxHL, \
   Color, c & _ARG, , /*6Fj*/char * word _ARG /*6Fj*/int * wordLen _ARG /*6Fj*/bool beforeEndOfLine _ARG /*6Fj*/Color defaultTextColor _ARG /*6Fj*/const char * buffer _ARG /*6Fj*/int * ap1, \
   return EditSyntaxHL_process(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/word, /*7Al*/wordLen, /*7Al*/(C(bool))beforeEndOfLine, /*7Al*/(C(Color))defaultTextColor, /*7Al*/buffer, /*7Al*/ap1);); \
VIRTUAL_METHOD(resetState, resetState, c, EditSyntaxHL, \
   void, c &, , , \
   EditSyntaxHL_resetState(self ? self->impl : (C(EditSyntaxHL))null);); \
VIRTUAL_METHOD(startLine, startLine, c, EditSyntaxHL, \
   void, c &, , , \
   EditSyntaxHL_startLine(self ? self->impl : (C(EditSyntaxHL))null););

class EditSyntaxHL : public Instance
{
public:
   inline EditSyntaxHL(EditSyntaxHL && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline EditSyntaxHL & operator= (EditSyntaxHL && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   EditSyntaxHL() : EditSyntaxHL((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<EditSyntaxHL> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         EditSyntaxHL * inst = new EditSyntaxHL(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      EditSyntaxHL * inst = (EditSyntaxHL *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(EditSyntaxHL & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline EditSyntaxHL(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct EditSyntaxHL_canImpactOtherLines_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(EditSyntaxHL & , /*6Fj*/EditLine line);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/EditLine line);
   } canImpactOtherLines;
   // inline static void register_canImpactOtherLines(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::FunctionType func)

   struct EditSyntaxHL_figureStartSyntaxStates_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(EditSyntaxHL & , /*6Fj*/EditLine firstLine, /*6Fj*/bool reset, /*6Fj*/EditLine viewLine);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/EditLine firstLine, /*6Fj*/bool reset, /*6Fj*/EditLine viewLine);
   } figureStartSyntaxStates;
   // inline static void register_figureStartSyntaxStates(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType func)

   struct EditSyntaxHL_gotSpace_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(EditSyntaxHL & , /*6Fj*/bool beforeEnd);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/bool beforeEnd);
   } gotSpace;
   // inline static void register_gotSpace(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::FunctionType func)

   struct EditSyntaxHL_initDraw_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(EditSyntaxHL &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } initDraw;
   // inline static void register_initDraw(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_initDraw_Functor::FunctionType func)

   struct EditSyntaxHL_nextLine_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(EditSyntaxHL & , /*6Fj*/char * buffer, /*6Fj*/int count);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/char * buffer, /*6Fj*/int count);
   } nextLine;
   // inline static void register_nextLine(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_nextLine_Functor::FunctionType func)

   struct EditSyntaxHL_parseWord_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(EditSyntaxHL & , /*6Fj*/char * buffer, /*6Fj*/int count, /*6Fj*/int wordLen);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( /*6Fj*/char * buffer, /*6Fj*/int count, /*6Fj*/int wordLen);
   } parseWord;
   // inline static void register_parseWord(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_parseWord_Functor::FunctionType func)

   struct EditSyntaxHL_process_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Color (* FunctionType)(EditSyntaxHL & , /*6Fj*/char * word, /*6Fj*/int * wordLen, /*6Fj*/bool beforeEndOfLine, /*6Fj*/Color defaultTextColor, /*6Fj*/const char * buffer, /*6Fj*/int * ap1);
      inline FunctionType operator= (FunctionType func);
      inline Color operator()( /*6Fj*/char * word, /*6Fj*/int * wordLen, /*6Fj*/bool beforeEndOfLine, /*6Fj*/Color defaultTextColor, /*6Fj*/const char * buffer, /*6Fj*/int * ap1);
   } process;
   // inline static void register_process(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_process_Functor::FunctionType func)

   struct EditSyntaxHL_resetState_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(EditSyntaxHL &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } resetState;
   // inline static void register_resetState(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_resetState_Functor::FunctionType func)

   struct EditSyntaxHL_startLine_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(EditSyntaxHL &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } startLine;
   // inline static void register_startLine(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_startLine_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};

#define REG_EditableSelectorButton_onRename(m, c) REGVMETHOD(EditableSelectorButton, onRename, c::m, (/*1Ab*/Window & self, /*1Ab*/EditableSelectorButton & button, /*1Ab*/char ** oldName, /*1Ab*/char ** newName), c, (/*4Im*/self, /*4Im*/button, /*4Im*/oldName, /*4Im*/newName))

#define REG_EditableSelectorButton(c) \
      EditableSelectorButton::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_Button_notifyClicked(notifyClicked, c); \
      REG_Button_notifyDoubleClick(notifyDoubleClick, c); \
      REG_Button_notifyMouseLeave(notifyMouseLeave, c); \
      REG_Button_notifyMouseMove(notifyMouseMove, c); \
      REG_Button_notifyMouseOver(notifyMouseOver, c); \
      REG_Button_notifyPushed(notifyPushed, c); \
      REG_Button_notifyReleased(notifyReleased, c); \
      REG_EditableSelectorButton_onRename(onRename, c);

#define EDITABLESELECTORBUTTON_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(onRename, onRename, c, EditableSelectorButton, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditableSelectorButton & button _ARG /*6Fj*/char ** oldName _ARG /*6Fj*/char ** newName);

#define EDITABLESELECTORBUTTON_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(onRename, onRename, c, EditableSelectorButton, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/EditableSelectorButton & button _ARG /*6Fj*/char ** oldName _ARG /*6Fj*/char ** newName, \
   return (bool)EditableSelectorButton_onRename(self ? self->impl : (C(EditableSelectorButton))null, o_.impl, /*7Al*/button.impl, /*7Al*/oldName, /*7Al*/newName););

class EditableSelectorButton : public SelectorButton
{
public:
   inline EditableSelectorButton(EditableSelectorButton && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline EditableSelectorButton & operator= (EditableSelectorButton && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   EditableSelectorButton() : EditableSelectorButton((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<EditableSelectorButton> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         EditableSelectorButton * inst = new EditableSelectorButton(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      EditableSelectorButton * inst = (EditableSelectorButton *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(EditableSelectorButton & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline EditableSelectorButton(C(Instance) _impl, CPPClass & cl = _cpp_class) : SelectorButton(_impl, cl) { }

   struct EditableSelectorButton_onRename_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/EditableSelectorButton & button, /*6Fj*/char ** oldName, /*6Fj*/char ** newName);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/EditableSelectorButton & button, /*6Fj*/char ** oldName, /*6Fj*/char ** newName);
   } onRename;
   // inline static void register_onRename(CPPClass & cl, EditableSelectorButton::EditableSelectorButton_onRename_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline EditableSelectorButton(bool renameable);

   struct renameable_Prop
   {
      constexpr renameable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline EditableSelectorButton::renameable_Prop & operator= (EditableSelectorButton::renameable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } renameable;
   struct editBox_Prop
   {
      constexpr editBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<EditBox> () const;
      /*regGet*/inline TIH<EditBox> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/EditBox () const;
      /*regGet*/inline operator /*0F*/EditBox* () const;
   } editBox;
};


#define REG_Label(c) \
      Label::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define LABEL_VIRTUAL_METHODS_PROTO(c) \

#define LABEL_VIRTUAL_METHODS(c) \

class Label : public CommonControl
{
public:
   inline Label(Label && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Label & operator= (Label && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Label() : Label((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Label> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Label * inst = new Label(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Label * inst = (Label *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Label & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Label(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct labeledWindow_Prop
   {
      constexpr labeledWindow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline Label::labeledWindow_Prop & operator= (Label::labeledWindow_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } labeledWindow;
   struct isGroupBox_Prop
   {
      constexpr isGroupBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Label::isGroupBox_Prop & operator= (Label::isGroupBox_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isGroupBox;
};

#define REG_ListBox_notifyChanged(m, c)     REGVMETHOD(ListBox, notifyChanged,     c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row),                                    c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row))
#define REG_ListBox_notifyCollapse(m, c)    REGVMETHOD(ListBox, notifyCollapse,    c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/bool collapsed),             c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(bool)collapsed))
#define REG_ListBox_notifyDoubleClick(m, c) REGVMETHOD(ListBox, notifyDoubleClick, c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),       c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifyEditDone(m, c)    REGVMETHOD(ListBox, notifyEditDone,    c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row),                                    c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row))
#define REG_ListBox_notifyEdited(m, c)      REGVMETHOD(ListBox, notifyEdited,      c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row),                                    c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row))
#define REG_ListBox_notifyEditing(m, c)     REGVMETHOD(ListBox, notifyEditing,     c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row),                                    c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row))
#define REG_ListBox_notifyHighlight(m, c)   REGVMETHOD(ListBox, notifyHighlight,   c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/Modifiers mods),             c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifyKeyDown(m, c)     REGVMETHOD(ListBox, notifyKeyDown,     c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/Key key, /*1Ab*/unichar ch), c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(Key)key, /*4Im*/ch))
#define REG_ListBox_notifyKeyHit(m, c)      REGVMETHOD(ListBox, notifyKeyHit,      c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/Key key, /*1Ab*/unichar ch), c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(Key)key, /*4Im*/ch))
#define REG_ListBox_notifyModified(m, c)    REGVMETHOD(ListBox, notifyModified,    c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row),                                    c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row))
#define REG_ListBox_notifyMove(m, c)        REGVMETHOD(ListBox, notifyMove,        c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/Modifiers mods),             c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifyMoved(m, c)       REGVMETHOD(ListBox, notifyMoved,       c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/Modifiers mods),             c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifyMovedField(m, c)  REGVMETHOD(ListBox, notifyMovedField,  c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataField & field, /*1Ab*/Modifiers mods),         c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/field, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifyReclick(m, c)     REGVMETHOD(ListBox, notifyReclick,     c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/Modifiers mods),             c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifyResized(m, c)     REGVMETHOD(ListBox, notifyResized,     c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataField & field, /*1Ab*/Modifiers mods),         c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/field, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifyRightClick(m, c)  REGVMETHOD(ListBox, notifyRightClick,  c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods),       c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/x, /*4Im*/y, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifySelect(m, c)      REGVMETHOD(ListBox, notifySelect,      c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataRow & row, /*1Ab*/Modifiers mods),             c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/row, /*4Hm*/(Modifiers)mods))
#define REG_ListBox_notifySort(m, c)        REGVMETHOD(ListBox, notifySort,        c::m, (/*1Ab*/Window & self, /*1Ab*/ListBox & listBox, /*1Ab*/DataField & field, /*1Ab*/Modifiers mods),         c, (/*4Im*/self, /*4Im*/listBox, /*4Im*/field, /*4Hm*/(Modifiers)mods))

#define REG_ListBox(c) \
      ListBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_ListBox_notifyChanged(notifyChanged, c); \
      REG_ListBox_notifyCollapse(notifyCollapse, c); \
      REG_ListBox_notifyDoubleClick(notifyDoubleClick, c); \
      REG_ListBox_notifyEditDone(notifyEditDone, c); \
      REG_ListBox_notifyEdited(notifyEdited, c); \
      REG_ListBox_notifyEditing(notifyEditing, c); \
      REG_ListBox_notifyHighlight(notifyHighlight, c); \
      REG_ListBox_notifyKeyDown(notifyKeyDown, c); \
      REG_ListBox_notifyKeyHit(notifyKeyHit, c); \
      REG_ListBox_notifyModified(notifyModified, c); \
      REG_ListBox_notifyMove(notifyMove, c); \
      REG_ListBox_notifyMoved(notifyMoved, c); \
      REG_ListBox_notifyMovedField(notifyMovedField, c); \
      REG_ListBox_notifyReclick(notifyReclick, c); \
      REG_ListBox_notifyResized(notifyResized, c); \
      REG_ListBox_notifyRightClick(notifyRightClick, c); \
      REG_ListBox_notifySelect(notifySelect, c); \
      REG_ListBox_notifySort(notifySort, c);

#define LISTBOX_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyChanged, notifyChanged, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row); \
   VIRTUAL_METHOD_PROTO(notifyCollapse, notifyCollapse, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/bool collapsed); \
   VIRTUAL_METHOD_PROTO(notifyDoubleClick, notifyDoubleClick, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyEditDone, notifyEditDone, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row); \
   VIRTUAL_METHOD_PROTO(notifyEdited, notifyEdited, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row); \
   VIRTUAL_METHOD_PROTO(notifyEditing, notifyEditing, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row); \
   VIRTUAL_METHOD_PROTO(notifyHighlight, notifyHighlight, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyKeyDown, notifyKeyDown, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(notifyKeyHit, notifyKeyHit, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch); \
   VIRTUAL_METHOD_PROTO(notifyModified, notifyModified, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row); \
   VIRTUAL_METHOD_PROTO(notifyMove, notifyMove, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyMoved, notifyMoved, c, ListBox, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyMovedField, notifyMovedField, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataField & field _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyReclick, notifyReclick, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyResized, notifyResized, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataField & field _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifyRightClick, notifyRightClick, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifySelect, notifySelect, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods); \
   VIRTUAL_METHOD_PROTO(notifySort, notifySort, c, ListBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataField & field _ARG /*6Fj*/Modifiers mods);

#define LISTBOX_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyChanged, notifyChanged, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row, \
   return (bool)ListBox_notifyChanged(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);); \
VIRTUAL_METHOD(notifyCollapse, notifyCollapse, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/bool collapsed, \
   return (bool)ListBox_notifyCollapse(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(bool))collapsed);); \
VIRTUAL_METHOD(notifyDoubleClick, notifyDoubleClick, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifyDoubleClick(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyEditDone, notifyEditDone, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row, \
   return (bool)ListBox_notifyEditDone(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);); \
VIRTUAL_METHOD(notifyEdited, notifyEdited, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row, \
   return (bool)ListBox_notifyEdited(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);); \
VIRTUAL_METHOD(notifyEditing, notifyEditing, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row, \
   return (bool)ListBox_notifyEditing(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);); \
VIRTUAL_METHOD(notifyHighlight, notifyHighlight, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifyHighlight(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyKeyDown, notifyKeyDown, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)ListBox_notifyKeyDown(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(notifyKeyHit, notifyKeyHit, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Key key _ARG /*6Fj*/unichar ch, \
   return (bool)ListBox_notifyKeyHit(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Key))key, /*7Al*/ch);); \
VIRTUAL_METHOD(notifyModified, notifyModified, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row, \
   return (bool)ListBox_notifyModified(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);); \
VIRTUAL_METHOD(notifyMove, notifyMove, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifyMove(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyMoved, notifyMoved, c, ListBox, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods, \
   ListBox_notifyMoved(self ? self->impl : (C(ListBox))null, self ? self->impl : (C(ListBox))null, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyMovedField, notifyMovedField, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataField & field _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifyMovedField(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/field.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyReclick, notifyReclick, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifyReclick(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyResized, notifyResized, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataField & field _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifyResized(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/field.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifyRightClick, notifyRightClick, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/int x _ARG /*6Fj*/int y _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifyRightClick(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifySelect, notifySelect, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataRow & row _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifySelect(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);); \
VIRTUAL_METHOD(notifySort, notifySort, c, ListBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ListBox & listBox _ARG /*6Fj*/DataField & field _ARG /*6Fj*/Modifiers mods, \
   return (bool)ListBox_notifySort(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/field.impl, /*7Al*/(C(Modifiers))mods););

class ListBox : public CommonControl
{
public:
   inline ListBox(ListBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ListBox & operator= (ListBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ListBox() : ListBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ListBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ListBox * inst = new ListBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ListBox * inst = (ListBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ListBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ListBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   inline void addField(/*1Ab*/DataField & addedField); // ListBox_addField
   inline DataRow addRow(); // ListBox_addRow
   inline DataRow addRowAfter(/*1Ab*/DataRow & after); // ListBox_addRowAfter
   inline DataRow addRowNone(); // ListBox_addRowNone
   inline DataRow addString(/*1Ab*/const char * string); // ListBox_addString
   template<typename... Args> inline DataRow addStringf(/*1Ab*/const char * format, /*1Ab*/Args... args); // ListBox_addStringf
   inline void clear(); // ListBox_clear
   inline void clearFields(); // ListBox_clearFields
   inline void deleteRow(/*1Ab*/DataRow & row); // ListBox_deleteRow
   inline DataRow findRow(/*1Ab*/int64 tag); // ListBox_findRow
   inline DataRow findString(/*1Ab*/const char * searchedString); // ListBox_findString
   inline DataRow findSubRow(/*1Ab*/int64 tag); // ListBox_findSubRow
   inline DataRow findSubString(/*1Ab*/const char * subString); // ListBox_findSubString
   inline DataRow findSubStringAfter(/*1Ab*/DataRow & after, /*1Ab*/const char * subString); // ListBox_findSubStringAfter
   inline DataRow findSubStringi(/*1Ab*/const char * subString); // ListBox_findSubStringi
   inline any_object getData(/*1Ab*/DataField & field); // ListBox_getData
   inline void getMultiSelection(/*1Ab*/OldList & list); // ListBox_getMultiSelection
   inline void getMultiSelection(/*1Ac*/OldList * list); // ListBox_getMultiSelection
   inline int64 getTag(); // ListBox_getTag
   inline void multiSort(/*1Ab*/TArray<DataFieldSort _ARG int _ARG DataFieldSort> & fields); // ListBox_multiSort
   inline void removeField(/*1Ab*/DataField & field); // ListBox_removeField
   inline void selectRow(/*1Ab*/DataRow & row); // ListBox_selectRow
   inline void * setData(/*1Ab*/DataField & field, /*1Ab*/any_object data); // ListBox_setData
   inline void sort(/*1Ab*/DataField & field, /*1Ab*/int order); // ListBox_sort
   inline void sortAlsoBy(/*1Ab*/DataField & field, /*1Ab*/int order); // ListBox_sortAlsoBy
   inline void stopEditing(/*1Ab*/bool save); // ListBox_stopEditing

   struct ListBox_notifyChanged_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
   } notifyChanged;
   // inline static void register_notifyChanged(CPPClass & cl, ListBox::ListBox_notifyChanged_Functor::FunctionType func)

   struct ListBox_notifyCollapse_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/bool collapsed);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/bool collapsed);
   } notifyCollapse;
   // inline static void register_notifyCollapse(CPPClass & cl, ListBox::ListBox_notifyCollapse_Functor::FunctionType func)

   struct ListBox_notifyDoubleClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyDoubleClick;
   // inline static void register_notifyDoubleClick(CPPClass & cl, ListBox::ListBox_notifyDoubleClick_Functor::FunctionType func)

   struct ListBox_notifyEditDone_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
   } notifyEditDone;
   // inline static void register_notifyEditDone(CPPClass & cl, ListBox::ListBox_notifyEditDone_Functor::FunctionType func)

   struct ListBox_notifyEdited_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
   } notifyEdited;
   // inline static void register_notifyEdited(CPPClass & cl, ListBox::ListBox_notifyEdited_Functor::FunctionType func)

   struct ListBox_notifyEditing_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
   } notifyEditing;
   // inline static void register_notifyEditing(CPPClass & cl, ListBox::ListBox_notifyEditing_Functor::FunctionType func)

   struct ListBox_notifyHighlight_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
   } notifyHighlight;
   // inline static void register_notifyHighlight(CPPClass & cl, ListBox::ListBox_notifyHighlight_Functor::FunctionType func)

   struct ListBox_notifyKeyDown_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Key key, /*6Fj*/unichar ch);
   } notifyKeyDown;
   // inline static void register_notifyKeyDown(CPPClass & cl, ListBox::ListBox_notifyKeyDown_Functor::FunctionType func)

   struct ListBox_notifyKeyHit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Key key, /*6Fj*/unichar ch);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Key key, /*6Fj*/unichar ch);
   } notifyKeyHit;
   // inline static void register_notifyKeyHit(CPPClass & cl, ListBox::ListBox_notifyKeyHit_Functor::FunctionType func)

   struct ListBox_notifyModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row);
   } notifyModified;
   // inline static void register_notifyModified(CPPClass & cl, ListBox::ListBox_notifyModified_Functor::FunctionType func)

   struct ListBox_notifyMove_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
   } notifyMove;
   // inline static void register_notifyMove(CPPClass & cl, ListBox::ListBox_notifyMove_Functor::FunctionType func)

   struct ListBox_notifyMoved_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
   } notifyMoved;
   // inline static void register_notifyMoved(CPPClass & cl, ListBox::ListBox_notifyMoved_Functor::FunctionType func)

   struct ListBox_notifyMovedField_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods);
   } notifyMovedField;
   // inline static void register_notifyMovedField(CPPClass & cl, ListBox::ListBox_notifyMovedField_Functor::FunctionType func)

   struct ListBox_notifyReclick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
   } notifyReclick;
   // inline static void register_notifyReclick(CPPClass & cl, ListBox::ListBox_notifyReclick_Functor::FunctionType func)

   struct ListBox_notifyResized_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods);
   } notifyResized;
   // inline static void register_notifyResized(CPPClass & cl, ListBox::ListBox_notifyResized_Functor::FunctionType func)

   struct ListBox_notifyRightClick_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods);
   } notifyRightClick;
   // inline static void register_notifyRightClick(CPPClass & cl, ListBox::ListBox_notifyRightClick_Functor::FunctionType func)

   struct ListBox_notifySelect_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods);
   } notifySelect;
   // inline static void register_notifySelect(CPPClass & cl, ListBox::ListBox_notifySelect_Functor::FunctionType func)

   struct ListBox_notifySort_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods);
   } notifySort;
   // inline static void register_notifySort(CPPClass & cl, ListBox::ListBox_notifySort_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline ListBox(bool freeSelect);

   struct freeSelect_Prop
   {
      constexpr freeSelect_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::freeSelect_Prop & operator= (ListBox::freeSelect_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } freeSelect;
   struct currentRow_Prop
   {
      constexpr currentRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const DataRow & operator= (/*0A*/const DataRow & v);
      /*regSet*/inline ListBox::currentRow_Prop & operator= (ListBox::currentRow_Prop & prop);
      /*nstSet*/inline /*0C*/const DataRow * operator= (/*0C*/const DataRow * v);
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } currentRow;
   struct currentField_Prop
   {
      constexpr currentField_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const DataField & operator= (/*0A*/const DataField & v);
      /*regSet*/inline ListBox::currentField_Prop & operator= (ListBox::currentField_Prop & prop);
      /*nstSet*/inline /*0C*/const DataField * operator= (/*0C*/const DataField * v);
      /*regGet*/inline operator /*0B*/TIH<DataField> () const;
      /*regGet*/inline TIH<DataField> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataField () const;
      /*regGet*/inline operator /*0F*/DataField* () const;
   } currentField;
   struct rowHeight_Prop
   {
      constexpr rowHeight_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ListBox::rowHeight_Prop & operator= (ListBox::rowHeight_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } rowHeight;
   struct typingTimeout_Prop
   {
      constexpr typingTimeout_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Seconds operator= (/*0H*/Seconds v);
      /*regSet*/inline ListBox::typingTimeout_Prop & operator= (ListBox::typingTimeout_Prop & prop);
      /*regGet*/inline operator /*0I*/Seconds () const;
      /*regGet*/inline operator /*0J*/C(Time) () const;
   } typingTimeout;
   struct moveRows_Prop
   {
      constexpr moveRows_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::moveRows_Prop & operator= (ListBox::moveRows_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } moveRows;
   struct moveFields_Prop
   {
      constexpr moveFields_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::moveFields_Prop & operator= (ListBox::moveFields_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } moveFields;
   struct resizable_Prop
   {
      constexpr resizable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::resizable_Prop & operator= (ListBox::resizable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } resizable;
   struct autoScroll_Prop
   {
      constexpr autoScroll_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::autoScroll_Prop & operator= (ListBox::autoScroll_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } autoScroll;
   struct alwaysHighLight_Prop
   {
      constexpr alwaysHighLight_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::alwaysHighLight_Prop & operator= (ListBox::alwaysHighLight_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alwaysHighLight;
   struct hasClearHeader_Prop
   {
      constexpr hasClearHeader_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::hasClearHeader_Prop & operator= (ListBox::hasClearHeader_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasClearHeader;
   struct hasHeader_Prop
   {
      constexpr hasHeader_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::hasHeader_Prop & operator= (ListBox::hasHeader_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasHeader;
   struct multiSelect_Prop
   {
      constexpr multiSelect_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::multiSelect_Prop & operator= (ListBox::multiSelect_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } multiSelect;
   struct alwaysEdit_Prop
   {
      constexpr alwaysEdit_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::alwaysEdit_Prop & operator= (ListBox::alwaysEdit_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } alwaysEdit;
   struct fullRowSelect_Prop
   {
      constexpr fullRowSelect_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::fullRowSelect_Prop & operator= (ListBox::fullRowSelect_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fullRowSelect;
   struct collapseControl_Prop
   {
      constexpr collapseControl_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::collapseControl_Prop & operator= (ListBox::collapseControl_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } collapseControl;
   struct treeBranches_Prop
   {
      constexpr treeBranches_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::treeBranches_Prop & operator= (ListBox::treeBranches_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } treeBranches;
   struct rootCollapseButton_Prop
   {
      constexpr rootCollapseButton_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::rootCollapseButton_Prop & operator= (ListBox::rootCollapseButton_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } rootCollapseButton;
   struct sortable_Prop
   {
      constexpr sortable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::sortable_Prop & operator= (ListBox::sortable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } sortable;
   struct noDragging_Prop
   {
      constexpr noDragging_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::noDragging_Prop & operator= (ListBox::noDragging_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noDragging;
   struct fillLastField_Prop
   {
      constexpr fillLastField_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::fillLastField_Prop & operator= (ListBox::fillLastField_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fillLastField;
   struct numSelections_Prop
   {
      constexpr numSelections_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } numSelections;
   struct currentIndex_Prop
   {
      constexpr currentIndex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } currentIndex;
   struct lastRow_Prop
   {
      constexpr lastRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } lastRow;
   struct firstRow_Prop
   {
      constexpr firstRow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataRow> () const;
      /*regGet*/inline TIH<DataRow> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataRow () const;
      /*regGet*/inline operator /*0F*/DataRow* () const;
   } firstRow;
   struct rowCount_Prop
   {
      constexpr rowCount_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } rowCount;
   struct firstField_Prop
   {
      constexpr firstField_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<DataField> () const;
      /*regGet*/inline TIH<DataField> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/DataField () const;
      /*regGet*/inline operator /*0F*/DataField* () const;
   } firstField;
   struct selectionColor_Prop
   {
      constexpr selectionColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline ListBox::selectionColor_Prop & operator= (ListBox::selectionColor_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionColor;
   struct selectionText_Prop
   {
      constexpr selectionText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline ListBox::selectionText_Prop & operator= (ListBox::selectionText_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionText;
   struct stippleColor_Prop
   {
      constexpr stippleColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline ListBox::stippleColor_Prop & operator= (ListBox::stippleColor_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } stippleColor;
   struct expandOnAdd_Prop
   {
      constexpr expandOnAdd_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ListBox::expandOnAdd_Prop & operator= (ListBox::expandOnAdd_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } expandOnAdd;

   struct typingTimeOut_Prop
   {
      constexpr typingTimeOut_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline ListBox::typingTimeOut_Prop & operator= (ListBox::typingTimeOut_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } typingTimeOut;
};


#define REG_Menu(c) \
      Menu::class_registration(_cpp_class);

#define MENU_VIRTUAL_METHODS_PROTO(c) \

#define MENU_VIRTUAL_METHODS(c) \

class Menu : public Instance
{
public:
   inline Menu(Menu && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Menu & operator= (Menu && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Menu() : Menu((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Menu> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Menu * inst = new Menu(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Menu * inst = (Menu *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Menu & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Menu(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void addDynamic(/*1Ab*/MenuItem & addedItem, /*1Ab*/Window & master, /*1Ab*/bool persistent); // Menu_addDynamic
   inline void addItem(/*1Ab*/MenuItem & item); // Menu_addItem
   inline void addSubMenu(/*1Ab*/Menu & subMenu); // Menu_addSubMenu
   inline void clean(/*1Ab*/Window & window); // Menu_clean
   inline void clear(); // Menu_clear
   inline MenuItem findItem(C(bool) (* notifySelect)(C(Window) __this, C(MenuItem) selection, C(Modifiers) mods), /*1Ab*/uint64 id); // Menu_findItem
   inline Menu findMenu(/*1Ab*/const char * name); // Menu_findMenu
   inline void merge(/*1Ab*/Menu & menuBeingMerged, /*1Ab*/bool menuBar, /*1Ab*/Window & window); // Menu_merge
   inline void removeItem(/*1Ab*/MenuItem & item); // Menu_removeItem

   static void class_registration(CPPClass & _cpp_class);

   struct parent_Prop
   {
      constexpr parent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Menu & operator= (/*0A*/const Menu & v);
      /*nstSet*/inline /*0C*/const Menu * operator= (/*0C*/const Menu * v);
   } parent;
   struct text_Prop
   {
      constexpr text_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/const char * operator= (/*0G*/const char * v);
   } text;
   struct hotKey_Prop
   {
      constexpr hotKey_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Key operator= (/*0G*/Key v);
   } hotKey;
   struct hasMargin_Prop
   {
      constexpr hasMargin_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } hasMargin;
   struct copyText_Prop
   {
      constexpr copyText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } copyText;
};


#define REG_MenuDivider(c) \
      MenuDivider::class_registration(_cpp_class); \
      REG_MenuItem_notifySelect(notifySelect, c);

#define MENUDIVIDER_VIRTUAL_METHODS_PROTO(c) \

#define MENUDIVIDER_VIRTUAL_METHODS(c) \

class MenuDivider : public MenuItem
{
public:
   inline MenuDivider(MenuDivider && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline MenuDivider & operator= (MenuDivider && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   MenuDivider() : MenuDivider((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<MenuDivider> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         MenuDivider * inst = new MenuDivider(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      MenuDivider * inst = (MenuDivider *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(MenuDivider & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline MenuDivider(C(Instance) _impl, CPPClass & cl = _cpp_class) : MenuItem(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_MenuPlacement(c) \
      MenuPlacement::class_registration(_cpp_class); \
      REG_MenuItem_notifySelect(notifySelect, c);

#define MENUPLACEMENT_VIRTUAL_METHODS_PROTO(c) \

#define MENUPLACEMENT_VIRTUAL_METHODS(c) \

class MenuPlacement : public MenuItem
{
public:
   inline MenuPlacement(MenuPlacement && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline MenuPlacement & operator= (MenuPlacement && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   MenuPlacement() : MenuPlacement((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<MenuPlacement> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         MenuPlacement * inst = new MenuPlacement(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      MenuPlacement * inst = (MenuPlacement *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(MenuPlacement & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline MenuPlacement(C(Instance) _impl, CPPClass & cl = _cpp_class) : MenuItem(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_OldArray(c) \
      OldArray::class_registration(_cpp_class);

#define OLDARRAY_VIRTUAL_METHODS_PROTO(c) \

#define OLDARRAY_VIRTUAL_METHODS(c) \

class OldArray : public Instance
{
public:
   inline OldArray(OldArray && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline OldArray & operator= (OldArray && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   OldArray() : OldArray((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<OldArray> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         OldArray * inst = new OldArray(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      OldArray * inst = (OldArray *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(OldArray & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline OldArray(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline OldArray::size_Prop & operator= (OldArray::size_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } size;
   struct data_Prop
   {
      constexpr data_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/void * operator= (/*0G*/void * v);
   } data;

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Class operator= (/*0H*/Class & v);
      /*regSet*/inline OldArray::type_Prop & operator= (OldArray::type_Prop & prop);
      /*regGet*/inline operator /*0I*/Class () const;
   } type;
};

#define REG_PaneSplitter_notifyResized(m, c) REGVMETHOD(PaneSplitter, notifyResized, c::m, (/*1Ab*/Window & self, /*1Ab*/PaneSplitter & splitter), c, (/*4Im*/self, /*4Im*/splitter))

#define REG_PaneSplitter(c) \
      PaneSplitter::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_PaneSplitter_notifyResized(notifyResized, c);

#define PANESPLITTER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyResized, notifyResized, c, PaneSplitter, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/PaneSplitter & splitter);

#define PANESPLITTER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyResized, notifyResized, c, PaneSplitter, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/PaneSplitter & splitter, \
   return (bool)PaneSplitter_notifyResized(self ? self->impl : (C(PaneSplitter))null, o_.impl, /*7Al*/splitter.impl););

class PaneSplitter : public Window
{
public:
   inline PaneSplitter(PaneSplitter && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline PaneSplitter & operator= (PaneSplitter && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   PaneSplitter() : PaneSplitter((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<PaneSplitter> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         PaneSplitter * inst = new PaneSplitter(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      PaneSplitter * inst = (PaneSplitter *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(PaneSplitter & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline PaneSplitter(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   struct PaneSplitter_notifyResized_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/PaneSplitter & splitter);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/PaneSplitter & splitter);
   } notifyResized;
   // inline static void register_notifyResized(CPPClass & cl, PaneSplitter::PaneSplitter_notifyResized_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline PaneSplitter(int toolSize, int toolGap);

   struct toolSize_Prop
   {
      constexpr toolSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PaneSplitter::toolSize_Prop & operator= (PaneSplitter::toolSize_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } toolSize;
   struct toolGap_Prop
   {
      constexpr toolGap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PaneSplitter::toolGap_Prop & operator= (PaneSplitter::toolGap_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } toolGap;
   struct leftPane_Prop
   {
      constexpr leftPane_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline PaneSplitter::leftPane_Prop & operator= (PaneSplitter::leftPane_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } leftPane;
   struct rightPane_Prop
   {
      constexpr rightPane_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline PaneSplitter::rightPane_Prop & operator= (PaneSplitter::rightPane_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } rightPane;
   struct topPane_Prop
   {
      constexpr topPane_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline PaneSplitter::topPane_Prop & operator= (PaneSplitter::topPane_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } topPane;
   struct bottomPane_Prop
   {
      constexpr bottomPane_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Window & operator= (/*0A*/const Window & v);
      /*regSet*/inline PaneSplitter::bottomPane_Prop & operator= (PaneSplitter::bottomPane_Prop & prop);
      /*nstSet*/inline /*0C*/const Window * operator= (/*0C*/const Window * v);
      /*regGet*/inline operator /*0B*/TIH<Window> () const;
      /*regGet*/inline TIH<Window> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Window () const;
      /*regGet*/inline operator /*0F*/Window* () const;
   } bottomPane;
   struct scaleSplit_Prop
   {
      constexpr scaleSplit_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline PaneSplitter::scaleSplit_Prop & operator= (PaneSplitter::scaleSplit_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } scaleSplit;
   struct orientation_Prop
   {
      constexpr orientation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ScrollDirection operator= (/*0H*/ScrollDirection v);
      /*regSet*/inline PaneSplitter::orientation_Prop & operator= (PaneSplitter::orientation_Prop & prop);
      /*regGet*/inline operator /*0I*/ScrollDirection () const;
   } orientation;
   struct split_Prop
   {
      constexpr split_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline PaneSplitter::split_Prop & operator= (PaneSplitter::split_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } split;
};

#define REG_PathBox_notifyModified(m, c) REGVMETHOD(PathBox, notifyModified, c::m, (/*1Ab*/Window & self, /*1Ab*/PathBox & pathBox), c, (/*4Im*/self, /*4Im*/pathBox))

#define REG_PathBox(c) \
      PathBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_PathBox_notifyModified(notifyModified, c);

#define PATHBOX_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyModified, notifyModified, c, PathBox, \
      bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/PathBox & pathBox);

#define PATHBOX_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyModified, notifyModified, c, PathBox, \
   bool, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/PathBox & pathBox, \
   return (bool)PathBox_notifyModified(self ? self->impl : (C(PathBox))null, o_.impl, /*7Al*/pathBox.impl););

class PathBox : public CommonControl
{
public:
   inline PathBox(PathBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline PathBox & operator= (PathBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   PathBox() : PathBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<PathBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         PathBox * inst = new PathBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      PathBox * inst = (PathBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(PathBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline PathBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   inline void deselect(); // PathBox_deselect
   inline void end(); // PathBox_end
   inline void home(); // PathBox_home
   inline void selectAll(); // PathBox_selectAll

   struct PathBox_notifyModified_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Window & , /*6Fj*/PathBox & pathBox);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/Window & o_ , /*6Fj*/PathBox & pathBox);
   } notifyModified;
   // inline static void register_notifyModified(CPPClass & cl, PathBox::PathBox_notifyModified_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline PathBox(PathTypeExpected typeExpected);

   struct editBox_Prop
   {
      constexpr editBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<EditBox> () const;
      /*regGet*/inline TIH<EditBox> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/EditBox () const;
      /*regGet*/inline operator /*0F*/EditBox* () const;
   } editBox;
   struct typeExpected_Prop
   {
      constexpr typeExpected_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/PathTypeExpected operator= (/*0G*/PathTypeExpected v);
   } typeExpected;
   struct browseDialog_Prop
   {
      constexpr browseDialog_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const FileDialog & operator= (/*0A*/const FileDialog & v);
      /*regSet*/inline PathBox::browseDialog_Prop & operator= (PathBox::browseDialog_Prop & prop);
      /*nstSet*/inline /*0C*/const FileDialog * operator= (/*0C*/const FileDialog * v);
      /*regGet*/inline operator /*0B*/TIH<FileDialog> () const;
      /*regGet*/inline TIH<FileDialog> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/FileDialog () const;
      /*regGet*/inline operator /*0F*/FileDialog* () const;
   } browseDialog;
   struct path_Prop
   {
      constexpr path_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*//*CT-D*/constString operator= (/*0H*//*CT-D*/constString v);
      /*regSet*/inline PathBox::path_Prop & operator= (PathBox::path_Prop & prop);
      /*regGet*/inline operator /*0I*//*CT-D*/constString () const;
   } path;
   struct slashPath_Prop
   {
      constexpr slashPath_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/char * () const;
   } slashPath;
   struct systemPath_Prop
   {
      constexpr systemPath_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/char * () const;
   } systemPath;
   struct selectionColor_Prop
   {
      constexpr selectionColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline PathBox::selectionColor_Prop & operator= (PathBox::selectionColor_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionColor;
   struct selectionText_Prop
   {
      constexpr selectionText_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline PathBox::selectionText_Prop & operator= (PathBox::selectionText_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } selectionText;
};

enum class PathTypeExpected : int
{
   none = PathTypeExpected_none,
   any = PathTypeExpected_any,
   directory = PathTypeExpected_directory,
   file = PathTypeExpected_file
};


#define REG_Picture(c) \
      Picture::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define PICTURE_VIRTUAL_METHODS_PROTO(c) \

#define PICTURE_VIRTUAL_METHODS(c) \

class Picture : public CommonControl
{
public:
   inline Picture(Picture && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Picture & operator= (Picture && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Picture() : Picture((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Picture> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Picture * inst = new Picture(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Picture * inst = (Picture *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Picture & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Picture(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline Picture(Color tint);

   struct tint_Prop
   {
      constexpr tint_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Color operator= (/*0G*/Color v);
   } tint;
   struct image_Prop
   {
      constexpr image_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const BitmapResource & operator= (/*0A*/const BitmapResource & v);
      /*regSet*/inline Picture::image_Prop & operator= (Picture::image_Prop & prop);
      /*nstSet*/inline /*0C*/const BitmapResource * operator= (/*0C*/const BitmapResource * v);
      /*regGet*/inline operator /*0B*/TIH<BitmapResource> () const;
      /*regGet*/inline TIH<BitmapResource> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/BitmapResource () const;
      /*regGet*/inline operator /*0F*/BitmapResource* () const;
   } image;
   struct filter_Prop
   {
      constexpr filter_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Picture::filter_Prop & operator= (Picture::filter_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } filter;
   struct bitmapImage_Prop
   {
      constexpr bitmapImage_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Bitmap & operator= (/*0A*/const Bitmap & v);
      /*nstSet*/inline /*0C*/const Bitmap * operator= (/*0C*/const Bitmap * v);
   } bitmapImage;
};


#define REG_PopupMenu(c) \
      PopupMenu::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define POPUPMENU_VIRTUAL_METHODS_PROTO(c) \

#define POPUPMENU_VIRTUAL_METHODS(c) \

class PopupMenu : public Window
{
public:
   inline PopupMenu(PopupMenu && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline PopupMenu & operator= (PopupMenu && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   PopupMenu() : PopupMenu((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<PopupMenu> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         PopupMenu * inst = new PopupMenu(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      PopupMenu * inst = (PopupMenu *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(PopupMenu & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline PopupMenu(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct menu_Prop
   {
      constexpr menu_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Menu & operator= (/*0A*/const Menu & v);
      /*regSet*/inline PopupMenu::menu_Prop & operator= (PopupMenu::menu_Prop & prop);
      /*nstSet*/inline /*0C*/const Menu * operator= (/*0C*/const Menu * v);
      /*regGet*/inline operator /*0B*/TIH<Menu> () const;
      /*regGet*/inline TIH<Menu> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Menu () const;
      /*regGet*/inline operator /*0F*/Menu* () const;
   } menu;
   struct isMenuBar_Prop
   {
      constexpr isMenuBar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } isMenuBar;
   struct focus_Prop
   {
      constexpr focus_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } focus;
};


#define REG_ProgressBar(c) \
      ProgressBar::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define PROGRESSBAR_VIRTUAL_METHODS_PROTO(c) \

#define PROGRESSBAR_VIRTUAL_METHODS(c) \

class ProgressBar : public CommonControl
{
public:
   inline ProgressBar(ProgressBar && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ProgressBar & operator= (ProgressBar && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ProgressBar() : ProgressBar((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ProgressBar> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ProgressBar * inst = new ProgressBar(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ProgressBar * inst = (ProgressBar *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ProgressBar & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ProgressBar(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline ProgressBar(uint progress, uint range);

   struct progress_Prop
   {
      constexpr progress_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline ProgressBar::progress_Prop & operator= (ProgressBar::progress_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } progress;
   struct range_Prop
   {
      constexpr range_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline ProgressBar::range_Prop & operator= (ProgressBar::range_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } range;
};


#define REG_SavingDataBox(c) \
      SavingDataBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_DataBox_notifyChanged(notifyChanged, c); \
      REG_DataBox_notifyModified(notifyModified, c); \
      REG_DataBox_onConfigure(onConfigure, c); \
      REG_DataBox_setData(setData, c);

#define SAVINGDATABOX_VIRTUAL_METHODS_PROTO(c) \

#define SAVINGDATABOX_VIRTUAL_METHODS(c) \

class SavingDataBox : public DataBox
{
public:
   inline SavingDataBox(SavingDataBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline SavingDataBox & operator= (SavingDataBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   SavingDataBox() : SavingDataBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<SavingDataBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         SavingDataBox * inst = new SavingDataBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      SavingDataBox * inst = (SavingDataBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(SavingDataBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline SavingDataBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : DataBox(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

#define REG_ScrollBar_notifyScrolling(m, c) REGVMETHOD(ScrollBar, notifyScrolling, c::m, (/*1Ab*/Window & self, /*1Ab*/ScrollBar & scrollBar, /*1Ab*/ScrollBarAction action, /*1Ab*/int position, /*1Ab*/Key key), c, (/*4Im*/self, /*4Im*/scrollBar, /*4Hm*/(ScrollBarAction)action, /*4Im*/position, /*4Hm*/(Key)key))

#define REG_ScrollBar(c) \
      ScrollBar::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_ScrollBar_notifyScrolling(notifyScrolling, c);

#define SCROLLBAR_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(notifyScrolling, notifyScrolling, c, ScrollBar, \
      void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ScrollBar & scrollBar _ARG /*6Fj*/ScrollBarAction action _ARG /*6Fj*/int position _ARG /*6Fj*/Key key);

#define SCROLLBAR_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(notifyScrolling, notifyScrolling, c, ScrollBar, \
   void, Window & _ARG, /*6Fk*/Window & o_ _ARG, /*6Fj*/ScrollBar & scrollBar _ARG /*6Fj*/ScrollBarAction action _ARG /*6Fj*/int position _ARG /*6Fj*/Key key, \
   ScrollBar_notifyScrolling(self ? self->impl : (C(ScrollBar))null, self ? self->impl : (C(ScrollBar))null, /*7Al*/scrollBar.impl, /*7Al*/(C(ScrollBarAction))action, /*7Al*/position, /*7Al*/(C(Key))key););

class ScrollBar : public CommonControl
{
public:
   inline ScrollBar(ScrollBar && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ScrollBar & operator= (ScrollBar && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ScrollBar() : ScrollBar((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ScrollBar> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ScrollBar * inst = new ScrollBar(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ScrollBar * inst = (ScrollBar *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ScrollBar & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ScrollBar(C(Instance) _impl, CPPClass & cl = _cpp_class) : CommonControl(_impl, cl) { }

   inline C(bool) action(/*1Ab*/ScrollBarAction action, /*1Ab*/int newPosition, /*1Ab*/Key key); // ScrollBar_action

   struct ScrollBar_notifyScrolling_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Window & , /*6Fj*/ScrollBar & scrollBar, /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Fk*/Window & o_ , /*6Fj*/ScrollBar & scrollBar, /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key);
   } notifyScrolling;
   // inline static void register_notifyScrolling(CPPClass & cl, ScrollBar::ScrollBar_notifyScrolling_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline ScrollBar(ScrollDirection direction, bool windowOwned, bool snap, int range, int seen, int total, int lineStep, int pageStep, int thumbPosition);

   struct direction_Prop
   {
      constexpr direction_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ScrollDirection operator= (/*0H*/ScrollDirection v);
      /*regSet*/inline ScrollBar::direction_Prop & operator= (ScrollBar::direction_Prop & prop);
      /*regGet*/inline operator /*0I*/ScrollDirection () const;
   } direction;
   struct windowOwned_Prop
   {
      constexpr windowOwned_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } windowOwned;
   struct snap_Prop
   {
      constexpr snap_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ScrollBar::snap_Prop & operator= (ScrollBar::snap_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } snap;
   struct range_Prop
   {
      constexpr range_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ScrollBar::range_Prop & operator= (ScrollBar::range_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } range;
   struct seen_Prop
   {
      constexpr seen_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ScrollBar::seen_Prop & operator= (ScrollBar::seen_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } seen;
   struct total_Prop
   {
      constexpr total_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ScrollBar::total_Prop & operator= (ScrollBar::total_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } total;
   struct lineStep_Prop
   {
      constexpr lineStep_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ScrollBar::lineStep_Prop & operator= (ScrollBar::lineStep_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } lineStep;
   struct pageStep_Prop
   {
      constexpr pageStep_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ScrollBar::pageStep_Prop & operator= (ScrollBar::pageStep_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } pageStep;
   struct thumbPosition_Prop
   {
      constexpr thumbPosition_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ScrollBar::thumbPosition_Prop & operator= (ScrollBar::thumbPosition_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } thumbPosition;

   struct downBtn_Prop
   {
      constexpr downBtn_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Button operator= (/*0H*/Button v);
      /*regSet*/inline ScrollBar::downBtn_Prop & operator= (ScrollBar::downBtn_Prop & prop);
      /*regGet*/inline operator /*0I*/Button () const;
   } downBtn;
   struct upBtn_Prop
   {
      constexpr upBtn_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Button operator= (/*0H*/Button v);
      /*regSet*/inline ScrollBar::upBtn_Prop & operator= (ScrollBar::upBtn_Prop & prop);
      /*regGet*/inline operator /*0I*/Button () const;
   } upBtn;
   struct thumb_Prop
   {
      constexpr thumb_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Button operator= (/*0H*/Button v);
      /*regSet*/inline ScrollBar::thumb_Prop & operator= (ScrollBar::thumb_Prop & prop);
      /*regGet*/inline operator /*0I*/Button () const;
   } thumb;
   struct thumbSize_Prop
   {
      constexpr thumbSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline ScrollBar::thumbSize_Prop & operator= (ScrollBar::thumbSize_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } thumbSize;
};

enum class ScrollBarAction : int
{
   none = ScrollBarAction_none,
   up = ScrollBarAction_up,
   down = ScrollBarAction_down,
   pageDown = ScrollBarAction_pageDown,
   pageUp = ScrollBarAction_pageUp,
   setPosition = ScrollBarAction_setPosition,
   home = ScrollBarAction_home,
   end = ScrollBarAction_end,
   setRange = ScrollBarAction_setRange,
   wheelUp = ScrollBarAction_wheelUp,
   wheelDown = ScrollBarAction_wheelDown
};

enum class ScrollDirection : int
{
   horizontal = ScrollDirection_horizontal,
   vertical = ScrollDirection_vertical
};


#define REG_SelectorBar(c) \
      SelectorBar::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define SELECTORBAR_VIRTUAL_METHODS_PROTO(c) \

#define SELECTORBAR_VIRTUAL_METHODS(c) \

class SelectorBar : public Stacker
{
public:
   inline SelectorBar(SelectorBar && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline SelectorBar & operator= (SelectorBar && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   SelectorBar() : SelectorBar((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<SelectorBar> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         SelectorBar * inst = new SelectorBar(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      SelectorBar * inst = (SelectorBar *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(SelectorBar & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline SelectorBar(C(Instance) _impl, CPPClass & cl = _cpp_class) : Stacker(_impl, cl) { }

   inline void addButton(/*1Ab*/SelectorButton & button); // SelectorBar_addButton
   inline void clear(); // SelectorBar_clear
   inline SelectorButton findButtonByID(/*1Ab*/int64 id); // SelectorBar_findButtonByID
   inline void removeButton(/*1Ab*/SelectorButton & button); // SelectorBar_removeButton
   inline void select(/*1Ab*/SelectorButton & button); // SelectorBar_select

   static void class_registration(CPPClass & _cpp_class);

   struct selectedButton_Prop
   {
      constexpr selectedButton_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<SelectorButton> () const;
      /*regGet*/inline TIH<SelectorButton> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/SelectorButton () const;
      /*regGet*/inline operator /*0F*/SelectorButton* () const;
   } selectedButton;
};


#define REG_StatusBar(c) \
      StatusBar::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define STATUSBAR_VIRTUAL_METHODS_PROTO(c) \

#define STATUSBAR_VIRTUAL_METHODS(c) \

class StatusBar : public Window
{
public:
   inline StatusBar(StatusBar && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline StatusBar & operator= (StatusBar && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   StatusBar() : StatusBar((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<StatusBar> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         StatusBar * inst = new StatusBar(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      StatusBar * inst = (StatusBar *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(StatusBar & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline StatusBar(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   inline void addField(/*1Ab*/StatusField & field); // StatusBar_addField
   inline void clear(); // StatusBar_clear
   inline void removeField(/*1Ab*/StatusField & field); // StatusBar_removeField

   static void class_registration(CPPClass & _cpp_class);

   inline StatusBar(int minInfoWidth);

   struct minInfoWidth_Prop
   {
      constexpr minInfoWidth_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline StatusBar::minInfoWidth_Prop & operator= (StatusBar::minInfoWidth_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } minInfoWidth;
};


#define REG_StatusField(c) \
      StatusField::class_registration(_cpp_class);

#define STATUSFIELD_VIRTUAL_METHODS_PROTO(c) \

#define STATUSFIELD_VIRTUAL_METHODS(c) \

class StatusField : public Instance
{
public:
   inline StatusField(StatusField && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline StatusField & operator= (StatusField && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   StatusField() : StatusField((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<StatusField> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         StatusField * inst = new StatusField(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      StatusField * inst = (StatusField *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(StatusField & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline StatusField(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   template<typename... Args> inline void setTextf(/*1Ab*/const char * format, /*1Ab*/Args... args); // StatusField_setTextf

   static void class_registration(CPPClass & _cpp_class);

   struct statusBar_Prop
   {
      constexpr statusBar_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const StatusBar & operator= (/*0A*/const StatusBar & v);
      /*nstSet*/inline /*0C*/const StatusBar * operator= (/*0C*/const StatusBar * v);
   } statusBar;
   struct color_Prop
   {
      constexpr color_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Color operator= (/*0G*/Color v);
   } color;
   struct backColor_Prop
   {
      constexpr backColor_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/ColorAlpha operator= (/*0G*/ColorAlpha v);
   } backColor;
   struct bold_Prop
   {
      constexpr bold_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/bool operator= (/*0G*/bool v);
   } bold;
   struct text_Prop
   {
      constexpr text_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/const char * operator= (/*0G*/const char * v);
   } text;
   struct width_Prop
   {
      constexpr width_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/int operator= (/*0G*/int v);
   } width;
};


#define REG_Tab(c) \
      Tab::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define TAB_VIRTUAL_METHODS_PROTO(c) \

#define TAB_VIRTUAL_METHODS(c) \

class Tab : public Window
{
public:
   inline Tab(Tab && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Tab & operator= (Tab && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Tab() : Tab((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Tab> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Tab * inst = new Tab(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Tab * inst = (Tab *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Tab & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Tab(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   inline void selectTab(); // Tab_selectTab

   static void class_registration(CPPClass & _cpp_class);

   struct tabControl_Prop
   {
      constexpr tabControl_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const TabControl & operator= (/*0A*/const TabControl & v);
      /*regSet*/inline Tab::tabControl_Prop & operator= (Tab::tabControl_Prop & prop);
      /*nstSet*/inline /*0C*/const TabControl * operator= (/*0C*/const TabControl * v);
      /*regGet*/inline operator /*0B*/TIH<TabControl> () const;
      /*regGet*/inline TIH<TabControl> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/TabControl () const;
      /*regGet*/inline operator /*0F*/TabControl* () const;
   } tabControl;
   struct isAdded_Prop
   {
      constexpr isAdded_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } isAdded;
};


#define REG_TabControl(c) \
      TabControl::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define TABCONTROL_VIRTUAL_METHODS_PROTO(c) \

#define TABCONTROL_VIRTUAL_METHODS(c) \

class TabControl : public Window
{
public:
   inline TabControl(TabControl && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline TabControl & operator= (TabControl && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   TabControl() : TabControl((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<TabControl> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         TabControl * inst = new TabControl(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      TabControl * inst = (TabControl *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(TabControl & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline TabControl(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   inline void addTab(/*1Ab*/Tab & tab); // TabControl_addTab
   inline void removeTab(/*1Ab*/Tab & tab); // TabControl_removeTab

   static void class_registration(CPPClass & _cpp_class);

   inline TabControl(TabsPlacement placement, int buttonsOffset);

   struct placement_Prop
   {
      constexpr placement_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/TabsPlacement operator= (/*0H*/TabsPlacement v);
      /*regSet*/inline TabControl::placement_Prop & operator= (TabControl::placement_Prop & prop);
      /*regGet*/inline operator /*0I*/TabsPlacement () const;
   } placement;
   struct buttonsOffset_Prop
   {
      constexpr buttonsOffset_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline TabControl::buttonsOffset_Prop & operator= (TabControl::buttonsOffset_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } buttonsOffset;
   struct curTab_Prop
   {
      constexpr curTab_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Tab & operator= (/*0A*/const Tab & v);
      /*regSet*/inline TabControl::curTab_Prop & operator= (TabControl::curTab_Prop & prop);
      /*nstSet*/inline /*0C*/const Tab * operator= (/*0C*/const Tab * v);
      /*regGet*/inline operator /*0B*/TIH<Tab> () const;
      /*regGet*/inline TIH<Tab> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Tab () const;
      /*regGet*/inline operator /*0F*/Tab* () const;
   } curTab;
};

enum class TabsPlacement : int
{
   top = TabsPlacement_top,
   bottom = TabsPlacement_bottom,
   left = TabsPlacement_left,
   right = TabsPlacement_right
};


#define REG_ToolBar(c) \
      ToolBar::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define TOOLBAR_VIRTUAL_METHODS_PROTO(c) \

#define TOOLBAR_VIRTUAL_METHODS(c) \

class ToolBar : public Stacker
{
public:
   inline ToolBar(ToolBar && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ToolBar & operator= (ToolBar && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ToolBar() : ToolBar((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ToolBar> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ToolBar * inst = new ToolBar(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ToolBar * inst = (ToolBar *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ToolBar & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ToolBar(C(Instance) _impl, CPPClass & cl = _cpp_class) : Stacker(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_ToolButton(c) \
      ToolButton::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_Button_notifyClicked(notifyClicked, c); \
      REG_Button_notifyDoubleClick(notifyDoubleClick, c); \
      REG_Button_notifyMouseLeave(notifyMouseLeave, c); \
      REG_Button_notifyMouseMove(notifyMouseMove, c); \
      REG_Button_notifyMouseOver(notifyMouseOver, c); \
      REG_Button_notifyPushed(notifyPushed, c); \
      REG_Button_notifyReleased(notifyReleased, c);

#define TOOLBUTTON_VIRTUAL_METHODS_PROTO(c) \

#define TOOLBUTTON_VIRTUAL_METHODS(c) \

class ToolButton : public Button
{
public:
   inline ToolButton(ToolButton && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ToolButton & operator= (ToolButton && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ToolButton() : ToolButton((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ToolButton> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ToolButton * inst = new ToolButton(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ToolButton * inst = (ToolButton *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ToolButton & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ToolButton(C(Instance) _impl, CPPClass & cl = _cpp_class) : Button(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct menuItemPtr_Prop
   {
      constexpr menuItemPtr_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/C(MenuItem)* operator= (/*0G*/C(MenuItem)* v);
   } menuItemPtr;
   struct menuItem_Prop
   {
      constexpr menuItem_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<MenuItem> () const;
      /*regGet*/inline TIH<MenuItem> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/MenuItem () const;
      /*regGet*/inline operator /*0F*/MenuItem* () const;
   } menuItem;
};


#define REG_ToolSeparator(c) \
      ToolSeparator::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define TOOLSEPARATOR_VIRTUAL_METHODS_PROTO(c) \

#define TOOLSEPARATOR_VIRTUAL_METHODS(c) \

class ToolSeparator : public Window
{
public:
   inline ToolSeparator(ToolSeparator && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ToolSeparator & operator= (ToolSeparator && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ToolSeparator() : ToolSeparator((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ToolSeparator> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ToolSeparator * inst = new ToolSeparator(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ToolSeparator * inst = (ToolSeparator *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ToolSeparator & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ToolSeparator(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_ToolTip(c) \
      ToolTip::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define TOOLTIP_VIRTUAL_METHODS_PROTO(c) \

#define TOOLTIP_VIRTUAL_METHODS(c) \

class ToolTip : public Window
{
public:
   inline ToolTip(ToolTip && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ToolTip & operator= (ToolTip && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ToolTip() : ToolTip((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ToolTip> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ToolTip * inst = new ToolTip(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ToolTip * inst = (ToolTip *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ToolTip & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ToolTip(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline ToolTip(/*CT-D*/constString tip);

   struct tip_Prop
   {
      constexpr tip_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*//*CT-D*/constString operator= (/*0H*//*CT-D*/constString v);
      /*regSet*/inline ToolTip::tip_Prop & operator= (ToolTip::tip_Prop & prop);
      /*regGet*/inline operator /*0I*//*CT-D*/constString () const;
   } tip;
};

template <class TC, C(Class) ** TCO>
class TUndoAction : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct continued_Prop
   {
      constexpr continued_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline typename TUndoAction<TC, TCO>::continued_Prop & operator= (typename TUndoAction<TC, TCO>::continued_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } continued;
   ~TUndoAction()
   {
      this->impl = null; // How to know not to delete?
   }
};


#define REG_UndoBuffer(c) \
      UndoBuffer::class_registration(_cpp_class);

#define UNDOBUFFER_VIRTUAL_METHODS_PROTO(c) \

#define UNDOBUFFER_VIRTUAL_METHODS(c) \

class UndoBuffer : public Instance
{
public:
   inline UndoBuffer(UndoBuffer && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline UndoBuffer & operator= (UndoBuffer && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   UndoBuffer() : UndoBuffer((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<UndoBuffer> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         UndoBuffer * inst = new UndoBuffer(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      UndoBuffer * inst = (UndoBuffer *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(UndoBuffer & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline UndoBuffer(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void clear(); // UndoBuffer_clear
   inline void record(/*1Ab*/UndoAction action); // UndoBuffer_record
   inline void redo(); // UndoBuffer_redo
   inline void undo(); // UndoBuffer_undo

   static void class_registration(CPPClass & _cpp_class);

   inline UndoBuffer(int count, int curAction, void * data, int dontRecord, bool insideRedo, bool recordAsOne, bool firstEvent);

   struct count_Prop
   {
      constexpr count_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline UndoBuffer::count_Prop & operator= (UndoBuffer::count_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } count;
   struct curAction_Prop
   {
      constexpr curAction_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline UndoBuffer::curAction_Prop & operator= (UndoBuffer::curAction_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } curAction;
   struct data_Prop
   {
      constexpr data_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/void * operator= (/*0H*/void * v);
      /*regSet*/inline UndoBuffer::data_Prop & operator= (UndoBuffer::data_Prop & prop);
      /*regGet*/inline operator /*0I*/void * () const;
   } data;
   struct dontRecord_Prop
   {
      constexpr dontRecord_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline UndoBuffer::dontRecord_Prop & operator= (UndoBuffer::dontRecord_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } dontRecord;
   struct insideRedo_Prop
   {
      constexpr insideRedo_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UndoBuffer::insideRedo_Prop & operator= (UndoBuffer::insideRedo_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } insideRedo;
   struct recordAsOne_Prop
   {
      constexpr recordAsOne_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UndoBuffer::recordAsOne_Prop & operator= (UndoBuffer::recordAsOne_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } recordAsOne;
   struct firstEvent_Prop
   {
      constexpr firstEvent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UndoBuffer::firstEvent_Prop & operator= (UndoBuffer::firstEvent_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } firstEvent;
};


#define REG_ColorPicker(c) \
      ColorPicker::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define COLORPICKER_VIRTUAL_METHODS_PROTO(c) \

#define COLORPICKER_VIRTUAL_METHODS(c) \

class ColorPicker : public Window
{
public:
   inline ColorPicker(ColorPicker && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ColorPicker & operator= (ColorPicker && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ColorPicker() : ColorPicker((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ColorPicker> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ColorPicker * inst = new ColorPicker(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ColorPicker * inst = (ColorPicker *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ColorPicker & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ColorPicker(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline ColorPicker(Color color, bool hasAlpha);

   struct color_Prop
   {
      constexpr color_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Color operator= (/*0H*/Color v);
      /*regSet*/inline ColorPicker::color_Prop & operator= (ColorPicker::color_Prop & prop);
      /*regGet*/inline operator /*0I*/Color () const;
   } color;
   struct hasAlpha_Prop
   {
      constexpr hasAlpha_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ColorPicker::hasAlpha_Prop & operator= (ColorPicker::hasAlpha_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } hasAlpha;
};


#define REG_CreateDirectoryDialog(c) \
      CreateDirectoryDialog::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define CREATEDIRECTORYDIALOG_VIRTUAL_METHODS_PROTO(c) \

#define CREATEDIRECTORYDIALOG_VIRTUAL_METHODS(c) \

class CreateDirectoryDialog : public Window
{
public:
   inline CreateDirectoryDialog(CreateDirectoryDialog && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline CreateDirectoryDialog & operator= (CreateDirectoryDialog && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   CreateDirectoryDialog() : CreateDirectoryDialog((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<CreateDirectoryDialog> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         CreateDirectoryDialog * inst = new CreateDirectoryDialog(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      CreateDirectoryDialog * inst = (CreateDirectoryDialog *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(CreateDirectoryDialog & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline CreateDirectoryDialog(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline CreateDirectoryDialog(const char * currentDirectory);

   struct currentDirectory_Prop
   {
      constexpr currentDirectory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline CreateDirectoryDialog::currentDirectory_Prop & operator= (CreateDirectoryDialog::currentDirectory_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } currentDirectory;
};


#define REG_FileDialog(c) \
      FileDialog::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define FILEDIALOG_VIRTUAL_METHODS_PROTO(c) \

#define FILEDIALOG_VIRTUAL_METHODS(c) \

class FileDialog : public Window
{
public:
   inline FileDialog(FileDialog && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FileDialog & operator= (FileDialog && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FileDialog() : FileDialog((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FileDialog> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FileDialog * inst = new FileDialog(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FileDialog * inst = (FileDialog *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FileDialog & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FileDialog(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline FileDialog(FileDialogType type, const char * filePath, const char * currentDirectory, int sizeFilters, int sizeTypes, int filter, int fileType, bool mayNotExist);

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FileDialogType operator= (/*0H*/FileDialogType v);
      /*regSet*/inline FileDialog::type_Prop & operator= (FileDialog::type_Prop & prop);
      /*regGet*/inline operator /*0I*/FileDialogType () const;
   } type;
   struct filePath_Prop
   {
      constexpr filePath_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileDialog::filePath_Prop & operator= (FileDialog::filePath_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } filePath;
   struct currentDirectory_Prop
   {
      constexpr currentDirectory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileDialog::currentDirectory_Prop & operator= (FileDialog::currentDirectory_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } currentDirectory;
   struct sizeFilters_Prop
   {
      constexpr sizeFilters_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FileDialog::sizeFilters_Prop & operator= (FileDialog::sizeFilters_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } sizeFilters;
   struct sizeTypes_Prop
   {
      constexpr sizeTypes_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FileDialog::sizeTypes_Prop & operator= (FileDialog::sizeTypes_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } sizeTypes;
   struct filter_Prop
   {
      constexpr filter_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FileDialog::filter_Prop & operator= (FileDialog::filter_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } filter;
   struct fileType_Prop
   {
      constexpr fileType_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FileDialog::fileType_Prop & operator= (FileDialog::fileType_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } fileType;
   struct mayNotExist_Prop
   {
      constexpr mayNotExist_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileDialog::mayNotExist_Prop & operator= (FileDialog::mayNotExist_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } mayNotExist;
   struct numSelections_Prop
   {
      constexpr numSelections_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } numSelections;
   struct multiFilePaths_Prop
   {
      constexpr multiFilePaths_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/const char ** () const;
   } multiFilePaths;
};

enum class FileDialogType : int
{
   open = FileDialogType_open,
   save = FileDialogType_save,
   selectDir = FileDialogType_selectDir,
   multiOpen = FileDialogType_multiOpen
};

struct FileFilter : public TStruct<FileFilter>
{
public:
   C(FileFilter) impl;
   constexpr FileFilter() : impl({}) { }
   constexpr FileFilter(const C(FileFilter) impl) : impl(impl) { }

   inline C(bool) validateFileName(/*1Ab*/const char * name); // FileFilter_validateFileName

   inline FileFilter(const char * name, const char * extensions);

   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileFilter::name_Prop & operator= (FileFilter::name_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } name;
   struct extensions_Prop
   {
      constexpr extensions_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileFilter::extensions_Prop & operator= (FileFilter::extensions_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } extensions;
};

enum class FileForceExtension : int
{
   never = FileForceExtension_never,
   always = FileForceExtension_always,
   whenNoneGiven = FileForceExtension_whenNoneGiven
};

struct FileName : public TStruct<FileName>
{
public:
   C(FileName) impl;
   constexpr FileName() : impl({}) { }
   constexpr FileName(const C(FileName) impl) : impl(impl) { }

   inline FileName(const char * name, FileNameType type, int indent);

   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileName::name_Prop & operator= (FileName::name_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } name;
   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FileNameType operator= (/*0H*/FileNameType v);
      /*regSet*/inline FileName::type_Prop & operator= (FileName::type_Prop & prop);
      /*regGet*/inline operator /*0I*/FileNameType () const;
   } type;
   struct indent_Prop
   {
      constexpr indent_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline FileName::indent_Prop & operator= (FileName::indent_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } indent;
};

enum class FileNameType : int
{
   folder = FileNameType_folder,
   folderOpen = FileNameType_folderOpen,
   computer = FileNameType_computer,
   drive = FileNameType_drive,
   netDrive = FileNameType_netDrive,
   cdrom = FileNameType_cdrom,
   removable = FileNameType_removable,
   floppy = FileNameType_floppy,
   network = FileNameType_network,
   server = FileNameType_server,
   share = FileNameType_share,
   normalFile = FileNameType_normalFile,
   ewsFile = FileNameType_ewsFile,
   epjFile = FileNameType_epjFile,
   ecFile = FileNameType_ecFile,
   ehFile = FileNameType_ehFile,
   cFile = FileNameType_cFile,
   hFile = FileNameType_hFile,
   cppFile = FileNameType_cppFile,
   hppFile = FileNameType_hppFile,
   textFile = FileNameType_textFile,
   webFile = FileNameType_webFile,
   pictureFile = FileNameType_pictureFile,
   soundFile = FileNameType_soundFile,
   archiveFile = FileNameType_archiveFile,
   packageFile = FileNameType_packageFile,
   opticalMediaImageFile = FileNameType_opticalMediaImageFile
};

struct FileType : public TStruct<FileType>
{
public:
   C(FileType) impl;
   constexpr FileType() : impl({}) { }
   constexpr FileType(const C(FileType) impl) : impl(impl) { }

   inline FileType(const char * name, const char * typeExtension, FileForceExtension forceExtension);

   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileType::name_Prop & operator= (FileType::name_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } name;
   struct typeExtension_Prop
   {
      constexpr typeExtension_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileType::typeExtension_Prop & operator= (FileType::typeExtension_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } typeExtension;
   struct forceExtension_Prop
   {
      constexpr forceExtension_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FileForceExtension operator= (/*0H*/FileForceExtension v);
      /*regSet*/inline FileType::forceExtension_Prop & operator= (FileType::forceExtension_Prop & prop);
      /*regGet*/inline operator /*0I*/FileForceExtension () const;
   } forceExtension;
};


#define REG_FindDialog(c) \
      FindDialog::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define FINDDIALOG_VIRTUAL_METHODS_PROTO(c) \

#define FINDDIALOG_VIRTUAL_METHODS(c) \

class FindDialog : public Window
{
public:
   inline FindDialog(FindDialog && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FindDialog & operator= (FindDialog && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FindDialog() : FindDialog((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FindDialog> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FindDialog * inst = new FindDialog(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FindDialog * inst = (FindDialog *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FindDialog & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FindDialog(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct editBox_Prop
   {
      constexpr editBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const EditBox & operator= (/*0A*/const EditBox & v);
      /*nstSet*/inline /*0C*/const EditBox * operator= (/*0C*/const EditBox * v);
   } editBox;
   struct searchString_Prop
   {
      constexpr searchString_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FindDialog::searchString_Prop & operator= (FindDialog::searchString_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } searchString;
   struct wholeWord_Prop
   {
      constexpr wholeWord_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FindDialog::wholeWord_Prop & operator= (FindDialog::wholeWord_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } wholeWord;
   struct matchCase_Prop
   {
      constexpr matchCase_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FindDialog::matchCase_Prop & operator= (FindDialog::matchCase_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } matchCase;
   struct searchUp_Prop
   {
      constexpr searchUp_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FindDialog::searchUp_Prop & operator= (FindDialog::searchUp_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } searchUp;
};


#define REG_GoToDialog(c) \
      GoToDialog::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define GOTODIALOG_VIRTUAL_METHODS_PROTO(c) \

#define GOTODIALOG_VIRTUAL_METHODS(c) \

class GoToDialog : public Window
{
public:
   inline GoToDialog(GoToDialog && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GoToDialog & operator= (GoToDialog && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   GoToDialog() : GoToDialog((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GoToDialog> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GoToDialog * inst = new GoToDialog(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GoToDialog * inst = (GoToDialog *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GoToDialog & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GoToDialog(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline GoToDialog(int line);

   struct line_Prop
   {
      constexpr line_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline GoToDialog::line_Prop & operator= (GoToDialog::line_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } line;
   struct editBox_Prop
   {
      constexpr editBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const EditBox & operator= (/*0A*/const EditBox & v);
      /*regSet*/inline GoToDialog::editBox_Prop & operator= (GoToDialog::editBox_Prop & prop);
      /*nstSet*/inline /*0C*/const EditBox * operator= (/*0C*/const EditBox * v);
      /*regGet*/inline operator /*0B*/TIH<EditBox> () const;
      /*regGet*/inline TIH<EditBox> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/EditBox () const;
      /*regGet*/inline operator /*0F*/EditBox* () const;
   } editBox;
};


#define REG_MessageBox(c) \
      MessageBox::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define MESSAGEBOX_VIRTUAL_METHODS_PROTO(c) \

#define MESSAGEBOX_VIRTUAL_METHODS(c) \

class MessageBox : public Window
{
public:
   inline MessageBox(MessageBox && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline MessageBox & operator= (MessageBox && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   MessageBox() : MessageBox((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<MessageBox> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         MessageBox * inst = new MessageBox(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      MessageBox * inst = (MessageBox *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(MessageBox & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline MessageBox(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline MessageBox(MessageBoxType type, const char * contents);

   struct type_Prop
   {
      constexpr type_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/MessageBoxType operator= (/*0G*/MessageBoxType v);
   } type;
   struct contents_Prop
   {
      constexpr contents_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/const char * operator= (/*0G*/const char * v);
   } contents;
};

enum class MessageBoxType : int
{
   ok = MessageBoxType_ok,
   yesNo = MessageBoxType_yesNo,
   okCancel = MessageBoxType_okCancel,
   yesNoCancel = MessageBoxType_yesNoCancel
};


#define REG_ReplaceDialog(c) \
      ReplaceDialog::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define REPLACEDIALOG_VIRTUAL_METHODS_PROTO(c) \

#define REPLACEDIALOG_VIRTUAL_METHODS(c) \

class ReplaceDialog : public Window
{
public:
   inline ReplaceDialog(ReplaceDialog && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ReplaceDialog & operator= (ReplaceDialog && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ReplaceDialog() : ReplaceDialog((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ReplaceDialog> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ReplaceDialog * inst = new ReplaceDialog(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ReplaceDialog * inst = (ReplaceDialog *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ReplaceDialog & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ReplaceDialog(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct editBox_Prop
   {
      constexpr editBox_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const EditBox & operator= (/*0A*/const EditBox & v);
      /*nstSet*/inline /*0C*/const EditBox * operator= (/*0C*/const EditBox * v);
   } editBox;
   struct searchString_Prop
   {
      constexpr searchString_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline ReplaceDialog::searchString_Prop & operator= (ReplaceDialog::searchString_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } searchString;
   struct replaceString_Prop
   {
      constexpr replaceString_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline ReplaceDialog::replaceString_Prop & operator= (ReplaceDialog::replaceString_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } replaceString;
   struct wholeWord_Prop
   {
      constexpr wholeWord_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ReplaceDialog::wholeWord_Prop & operator= (ReplaceDialog::wholeWord_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } wholeWord;
   struct matchCase_Prop
   {
      constexpr matchCase_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ReplaceDialog::matchCase_Prop & operator= (ReplaceDialog::matchCase_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } matchCase;
};


#define REG_WindowList(c) \
      WindowList::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define WINDOWLIST_VIRTUAL_METHODS_PROTO(c) \

#define WINDOWLIST_VIRTUAL_METHODS(c) \

class WindowList : public Window
{
public:
   inline WindowList(WindowList && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline WindowList & operator= (WindowList && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   WindowList() : WindowList((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<WindowList> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         WindowList * inst = new WindowList(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      WindowList * inst = (WindowList *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(WindowList & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline WindowList(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_TVisionSkin_Window(c) \
      TVisionSkin_Window::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define TVISIONSKIN_WINDOW_VIRTUAL_METHODS_PROTO(c) \

#define TVISIONSKIN_WINDOW_VIRTUAL_METHODS(c) \

class TVisionSkin_Window : public Window
{
public:
   inline TVisionSkin_Window(TVisionSkin_Window && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline TVisionSkin_Window & operator= (TVisionSkin_Window && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   TVisionSkin_Window() : TVisionSkin_Window((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<TVisionSkin_Window> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         TVisionSkin_Window * inst = new TVisionSkin_Window(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      TVisionSkin_Window * inst = (TVisionSkin_Window *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(TVisionSkin_Window & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline TVisionSkin_Window(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_WindowsSkin_Button(c) \
      WindowsSkin_Button::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_Button_notifyClicked(notifyClicked, c); \
      REG_Button_notifyDoubleClick(notifyDoubleClick, c); \
      REG_Button_notifyMouseLeave(notifyMouseLeave, c); \
      REG_Button_notifyMouseMove(notifyMouseMove, c); \
      REG_Button_notifyMouseOver(notifyMouseOver, c); \
      REG_Button_notifyPushed(notifyPushed, c); \
      REG_Button_notifyReleased(notifyReleased, c);

#define WINDOWSSKIN_BUTTON_VIRTUAL_METHODS_PROTO(c) \

#define WINDOWSSKIN_BUTTON_VIRTUAL_METHODS(c) \

class WindowsSkin_Button : public Button
{
public:
   inline WindowsSkin_Button(WindowsSkin_Button && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline WindowsSkin_Button & operator= (WindowsSkin_Button && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   WindowsSkin_Button() : WindowsSkin_Button((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<WindowsSkin_Button> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         WindowsSkin_Button * inst = new WindowsSkin_Button(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      WindowsSkin_Button * inst = (WindowsSkin_Button *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(WindowsSkin_Button & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline WindowsSkin_Button(C(Instance) _impl, CPPClass & cl = _cpp_class) : Button(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_WindowsSkin_Window(c) \
      WindowsSkin_Window::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c);

#define WINDOWSSKIN_WINDOW_VIRTUAL_METHODS_PROTO(c) \

#define WINDOWSSKIN_WINDOW_VIRTUAL_METHODS(c) \

class WindowsSkin_Window : public Window
{
public:
   inline WindowsSkin_Window(WindowsSkin_Window && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline WindowsSkin_Window & operator= (WindowsSkin_Window && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   WindowsSkin_Window() : WindowsSkin_Window((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<WindowsSkin_Window> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         WindowsSkin_Window * inst = new WindowsSkin_Window(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      WindowsSkin_Window * inst = (WindowsSkin_Window *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(WindowsSkin_Window & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline WindowsSkin_Window(C(Instance) _impl, CPPClass & cl = _cpp_class) : Window(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

#define REG_Service_onAccept(m, c) REGVMETHOD(Service, onAccept, c::m, (/*1Ab*/Service & self), c, ())

#define REG_Service(c) \
      Service::class_registration(_cpp_class); \
      REG_Service_onAccept(onAccept, c);

#define SERVICE_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(onAccept, onAccept, c, Service, \
      void, c &, , );

#define SERVICE_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(onAccept, onAccept, c, Service, \
   void, c &, , , \
   Service_onAccept(self ? self->impl : (C(Service))null););

class Service : public Instance
{
public:
   inline Service(Service && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Service & operator= (Service && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Service() : Service((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Service> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Service * inst = new Service(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Service * inst = (Service *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Service & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Service(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) process(); // Service_process
   inline C(bool) processTimeOut(/*1Ab*/Time timeOut); // Service_processTimeOut
   inline C(bool) start(); // Service_start
   inline C(bool) stop(); // Service_stop

   struct Service_onAccept_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Service &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onAccept;
   // inline static void register_onAccept(CPPClass & cl, Service::Service_onAccept_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline Service(int port, bool processAlone);

   struct port_Prop
   {
      constexpr port_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Service::port_Prop & operator= (Service::port_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } port;
   struct firstClient_Prop
   {
      constexpr firstClient_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Socket> () const;
      /*regGet*/inline TIH<Socket> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Socket () const;
      /*regGet*/inline operator /*0F*/Socket* () const;
   } firstClient;
   struct processAlone_Prop
   {
      constexpr processAlone_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Service::processAlone_Prop & operator= (Service::processAlone_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } processAlone;
   struct started_Prop
   {
      constexpr started_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } started;
};

#define REG_Socket_onConnect(m, c)             REGVMETHOD(Socket, onConnect,             c::m, (/*1Ab*/Socket & self),                                                                  c, ())
#define REG_Socket_onDisconnect(m, c)          REGVMETHOD(Socket, onDisconnect,          c::m, (/*1Ab*/Socket & self, /*1Ab*/int code),                                                 c, (/*4Im*/code))
#define REG_Socket_onEstablishConnection(m, c) REGVMETHOD(Socket, onEstablishConnection, c::m, (/*1Ab*/Socket & self, /*1Ab*/int s),                                                    c, (/*4Im*/s))
#define REG_Socket_onReceive(m, c)             REGVMETHOD(Socket, onReceive,             c::m, (/*1Ab*/Socket & self, /*1Ab*/const byte * buffer, /*1Ab*/uint count),                   c, (/*4Im*/buffer, /*4Im*/count))
#define REG_Socket_onReceivePacket(m, c)       REGVMETHOD(Socket, onReceivePacket,       c::m, (/*1Ab*/Socket & self, /*1Ab*/Packet packet),                                            c, (/*4Im*/packet))
#define REG_Socket_receiveData(m, c)           REGVMETHOD(Socket, receiveData,           c::m, (/*1Ab*/Socket & self, /*1Ab*/byte * buffer, /*1Ab*/int count, /*1Ab*/uint flags),       c, (/*4Im*/buffer, /*4Im*/count, /*4Im*/flags))
#define REG_Socket_sendData(m, c)              REGVMETHOD(Socket, sendData,              c::m, (/*1Ab*/Socket & self, /*1Ab*/const byte * buffer, /*1Ab*/int count, /*1Ab*/uint flags), c, (/*4Im*/buffer, /*4Im*/count, /*4Im*/flags))

#define REG_Socket(c) \
      Socket::class_registration(_cpp_class); \
      REG_Socket_onConnect(onConnect, c); \
      REG_Socket_onDisconnect(onDisconnect, c); \
      REG_Socket_onEstablishConnection(onEstablishConnection, c); \
      REG_Socket_onReceive(onReceive, c); \
      REG_Socket_onReceivePacket(onReceivePacket, c); \
      REG_Socket_receiveData(receiveData, c); \
      REG_Socket_sendData(sendData, c);

#define SOCKET_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(onConnect, onConnect, c, Socket, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(onDisconnect, onDisconnect, c, Socket, \
      void, c & _ARG, , /*6Fj*/int code); \
   VIRTUAL_METHOD_PROTO(onEstablishConnection, onEstablishConnection, c, Socket, \
      bool, c & _ARG, , /*6Fj*/int s); \
   VIRTUAL_METHOD_PROTO(onReceive, onReceive, c, Socket, \
      uint, c & _ARG, , /*6Fj*/const unsigned char * buffer _ARG /*6Fj*/uint count); \
   VIRTUAL_METHOD_PROTO(onReceivePacket, onReceivePacket, c, Socket, \
      void, c & _ARG, , /*6Fj*/Packet packet); \
   VIRTUAL_METHOD_PROTO(receiveData, receiveData, c, Socket, \
      int, c & _ARG, , /*6Fj*/unsigned char * buffer _ARG /*6Fj*/int count _ARG /*6Fj*/uint flags); \
   VIRTUAL_METHOD_PROTO(sendData, sendData, c, Socket, \
      int, c & _ARG, , /*6Fj*/const unsigned char * buffer _ARG /*6Fj*/int count _ARG /*6Fj*/uint flags);

#define SOCKET_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(onConnect, onConnect, c, Socket, \
   void, c &, , , \
   Socket_onConnect(self ? self->impl : (C(Socket))null);); \
VIRTUAL_METHOD(onDisconnect, onDisconnect, c, Socket, \
   void, c & _ARG, , /*6Fj*/int code, \
   Socket_onDisconnect(self ? self->impl : (C(Socket))null, /*7Al*/code);); \
VIRTUAL_METHOD(onEstablishConnection, onEstablishConnection, c, Socket, \
   bool, c & _ARG, , /*6Fj*/int s, \
   return (bool)Socket_onEstablishConnection(self ? self->impl : (C(Socket))null, /*7Al*/s);); \
VIRTUAL_METHOD(onReceive, onReceive, c, Socket, \
   uint, c & _ARG, , /*6Fj*/const unsigned char * buffer _ARG /*6Fj*/uint count, \
   return Socket_onReceive(self ? self->impl : (C(Socket))null, /*7Al*/buffer, /*7Al*/count);); \
VIRTUAL_METHOD(onReceivePacket, onReceivePacket, c, Socket, \
   void, c & _ARG, , /*6Fj*/Packet packet, \
   Socket_onReceivePacket(self ? self->impl : (C(Socket))null, /*7Al*/packet.impl);); \
VIRTUAL_METHOD(receiveData, receiveData, c, Socket, \
   int, c & _ARG, , /*6Fj*/unsigned char * buffer _ARG /*6Fj*/int count _ARG /*6Fj*/uint flags, \
   return Socket_receiveData(self ? self->impl : (C(Socket))null, /*7Al*/buffer, /*7Al*/count, /*7Al*/flags);); \
VIRTUAL_METHOD(sendData, sendData, c, Socket, \
   int, c & _ARG, , /*6Fj*/const unsigned char * buffer _ARG /*6Fj*/int count _ARG /*6Fj*/uint flags, \
   return Socket_sendData(self ? self->impl : (C(Socket))null, /*7Al*/buffer, /*7Al*/count, /*7Al*/flags););

class Socket : public Instance
{
public:
   inline Socket(Socket && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Socket & operator= (Socket && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Socket() : Socket((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Socket> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Socket * inst = new Socket(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Socket * inst = (Socket *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Socket & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Socket(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) connect(/*1Ab*/const char * address, /*1Ab*/int port); // Socket_connect
   inline C(bool) datagramConnect(/*1Ab*/const char * sendAddress, /*1Ab*/int port); // Socket_datagramConnect
   inline C(bool) datagramHost(/*1Ab*/int port); // Socket_datagramHost
   inline void disconnect(/*1Ab*/DisconnectCode code); // Socket_disconnect
   inline C(bool) process(); // Socket_process
   inline C(bool) processTimeOut(/*1Ab*/Time timeOut); // Socket_processTimeOut
   inline C(bool) send(/*1Ab*/const void * buffer, /*1Ab*/int size); // Socket_send
   inline C(bool) sendPacket(/*1Ab*/Packet packet); // Socket_sendPacket
   inline C(bool) sendString(/*1Ab*/const char * string); // Socket_sendString
   template<typename... Args> inline C(bool) sendf(/*1Ab*/const char * format, /*1Ab*/Args... args); // Socket_sendf
   inline void safeDecRef(); // Socket_safeDecRef
   inline void safeIncRef(); // Socket_safeIncRef

   struct Socket_onConnect_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Socket &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onConnect;
   // inline static void register_onConnect(CPPClass & cl, Socket::Socket_onConnect_Functor::FunctionType func)

   struct Socket_onDisconnect_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Socket & , /*6Fj*/int code);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/int code);
   } onDisconnect;
   // inline static void register_onDisconnect(CPPClass & cl, Socket::Socket_onDisconnect_Functor::FunctionType func)

   struct Socket_onEstablishConnection_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Socket & , /*6Fj*/int s);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/int s);
   } onEstablishConnection;
   // inline static void register_onEstablishConnection(CPPClass & cl, Socket::Socket_onEstablishConnection_Functor::FunctionType func)

   struct Socket_onReceive_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uint (* FunctionType)(Socket & , /*6Fj*/const unsigned char * buffer, /*6Fj*/uint count);
      inline FunctionType operator= (FunctionType func);
      inline uint operator()( /*6Fj*/const unsigned char * buffer, /*6Fj*/uint count);
   } onReceive;
   // inline static void register_onReceive(CPPClass & cl, Socket::Socket_onReceive_Functor::FunctionType func)

   struct Socket_onReceivePacket_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Socket & , /*6Fj*/Packet packet);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/Packet packet);
   } onReceivePacket;
   // inline static void register_onReceivePacket(CPPClass & cl, Socket::Socket_onReceivePacket_Functor::FunctionType func)

   struct Socket_receiveData_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Socket & , /*6Fj*/unsigned char * buffer, /*6Fj*/int count, /*6Fj*/uint flags);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( /*6Fj*/unsigned char * buffer, /*6Fj*/int count, /*6Fj*/uint flags);
   } receiveData;
   // inline static void register_receiveData(CPPClass & cl, Socket::Socket_receiveData_Functor::FunctionType func)

   struct Socket_sendData_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Socket & , /*6Fj*/const unsigned char * buffer, /*6Fj*/int count, /*6Fj*/uint flags);
      inline FunctionType operator= (FunctionType func);
      inline int operator()( /*6Fj*/const unsigned char * buffer, /*6Fj*/int count, /*6Fj*/uint flags);
   } sendData;
   // inline static void register_sendData(CPPClass & cl, Socket::Socket_sendData_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct service_Prop
   {
      constexpr service_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const Service & operator= (/*0A*/const Service & v);
      /*regSet*/inline Socket::service_Prop & operator= (Socket::service_Prop & prop);
      /*nstSet*/inline /*0C*/const Service * operator= (/*0C*/const Service * v);
      /*regGet*/inline operator /*0B*/TIH<Service> () const;
      /*regGet*/inline TIH<Service> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Service () const;
      /*regGet*/inline operator /*0F*/Service* () const;
   } service;
   struct inetAddress_Prop
   {
      constexpr inetAddress_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/const char * () const;
   } inetAddress;
   struct inetPort_Prop
   {
      constexpr inetPort_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } inetPort;
   struct next_Prop
   {
      constexpr next_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0B*/TIH<Socket> () const;
      /*regGet*/inline TIH<Socket> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/Socket () const;
      /*regGet*/inline operator /*0F*/Socket* () const;
   } next;
   struct connected_Prop
   {
      constexpr connected_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } connected;
   struct processAlone_Prop
   {
      constexpr processAlone_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline Socket::processAlone_Prop & operator= (Socket::processAlone_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } processAlone;
};

#define REG_DCOMClientObject_callVirtualMethod(m, c) REGVMETHOD(DCOMClientObject, callVirtualMethod, c::m, (/*1Ab*/DCOMClientObject & self, /*1Ab*/uint __ecereMethodID, /*1Ab*/SerialBuffer & __ecereBuffer), c, (/*4Im*/__ecereMethodID, /*4Im*/__ecereBuffer))

#define REG_DCOMClientObject(c) \
      DCOMClientObject::class_registration(_cpp_class); \
      REG_Socket_onConnect(onConnect, c); \
      REG_Socket_onDisconnect(onDisconnect, c); \
      REG_Socket_onEstablishConnection(onEstablishConnection, c); \
      REG_Socket_onReceive(onReceive, c); \
      REG_Socket_onReceivePacket(onReceivePacket, c); \
      REG_Socket_receiveData(receiveData, c); \
      REG_Socket_sendData(sendData, c); \
      REG_DCOMClientObject_callVirtualMethod(callVirtualMethod, c);

#define DCOMCLIENTOBJECT_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(callVirtualMethod, callVirtualMethod, c, DCOMClientObject, \
      void, c & _ARG, , /*6Fj*/uint __ecereMethodID _ARG /*6Fj*/SerialBuffer & __ecereBuffer);

#define DCOMCLIENTOBJECT_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(callVirtualMethod, callVirtualMethod, c, DCOMClientObject, \
   void, c & _ARG, , /*6Fj*/uint __ecereMethodID _ARG /*6Fj*/SerialBuffer & __ecereBuffer, \
   DCOMClientObject_callVirtualMethod(self ? self->impl : (C(DCOMClientObject))null, /*7Al*/__ecereMethodID, /*7Al*/__ecereBuffer.impl););

class DCOMClientObject : public Socket
{
public:
   inline DCOMClientObject(DCOMClientObject && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DCOMClientObject & operator= (DCOMClientObject && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DCOMClientObject() : DCOMClientObject((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DCOMClientObject> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DCOMClientObject * inst = new DCOMClientObject(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DCOMClientObject * inst = (DCOMClientObject *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DCOMClientObject & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DCOMClientObject(C(Instance) _impl, CPPClass & cl = _cpp_class) : Socket(_impl, cl) { }

   inline C(bool) callMethod(/*1Ab*/uint methodID, /*1Ab*/bool hasReturnValue); // DCOMClientObject_callMethod
   inline C(bool) connect(/*1Ab*/const char * server, /*1Ab*/int port); // DCOMClientObject_connect

   struct DCOMClientObject_callVirtualMethod_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DCOMClientObject & , /*6Fj*/uint __ecereMethodID, /*6Fj*/SerialBuffer & __ecereBuffer);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/uint __ecereMethodID, /*6Fj*/SerialBuffer & __ecereBuffer);
   } callVirtualMethod;
   // inline static void register_callVirtualMethod(CPPClass & cl, DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline DCOMClientObject(uint objectID, bool answered);

   struct objectID_Prop
   {
      constexpr objectID_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline DCOMClientObject::objectID_Prop & operator= (DCOMClientObject::objectID_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } objectID;
   struct answered_Prop
   {
      constexpr answered_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline DCOMClientObject::answered_Prop & operator= (DCOMClientObject::answered_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } answered;
   struct __ecereBuffer_Prop
   {
      constexpr __ecereBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SerialBuffer operator= (/*0H*/SerialBuffer v);
      /*regSet*/inline DCOMClientObject::__ecereBuffer_Prop & operator= (DCOMClientObject::__ecereBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/SerialBuffer () const;
   } __ecereBuffer;
   struct nextCallID_Prop
   {
      constexpr nextCallID_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DCOMClientObject::nextCallID_Prop & operator= (DCOMClientObject::nextCallID_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nextCallID;
};


#define REG_DCOMSendControl(c) \
      DCOMSendControl::class_registration(_cpp_class);

#define DCOMSENDCONTROL_VIRTUAL_METHODS_PROTO(c) \

#define DCOMSENDCONTROL_VIRTUAL_METHODS(c) \

class DCOMSendControl : public Instance
{
public:
   inline DCOMSendControl(DCOMSendControl && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DCOMSendControl & operator= (DCOMSendControl && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DCOMSendControl() : DCOMSendControl((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DCOMSendControl> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DCOMSendControl * inst = new DCOMSendControl(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DCOMSendControl * inst = (DCOMSendControl *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DCOMSendControl & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DCOMSendControl(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void resume(); // DCOMSendControl_resume
   inline void stop(); // DCOMSendControl_stop

   static void class_registration(CPPClass & _cpp_class);
};

#define REG_DCOMServerObject_callMethod(m, c) REGVMETHOD(DCOMServerObject, callMethod, c::m, (/*1Ab*/DCOMServerObject & self, /*1Ab*/uint __ecereMethodID, /*1Ab*/SerialBuffer & __ecereBuffer), c, (/*4Im*/__ecereMethodID, /*4Im*/__ecereBuffer))

#define REG_DCOMServerObject(c) \
      DCOMServerObject::class_registration(_cpp_class); \
      REG_DCOMServerObject_callMethod(callMethod, c);

#define DCOMSERVEROBJECT_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(callMethod, callMethod, c, DCOMServerObject, \
      void, c & _ARG, , /*6Fj*/uint __ecereMethodID _ARG /*6Fj*/SerialBuffer & __ecereBuffer);

#define DCOMSERVEROBJECT_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(callMethod, callMethod, c, DCOMServerObject, \
   void, c & _ARG, , /*6Fj*/uint __ecereMethodID _ARG /*6Fj*/SerialBuffer & __ecereBuffer, \
   DCOMServerObject_callMethod(self ? self->impl : (C(DCOMServerObject))null, /*7Al*/__ecereMethodID, /*7Al*/__ecereBuffer.impl););

class DCOMServerObject : public Instance
{
public:
   inline DCOMServerObject(DCOMServerObject && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DCOMServerObject & operator= (DCOMServerObject && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DCOMServerObject() : DCOMServerObject((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DCOMServerObject> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DCOMServerObject * inst = new DCOMServerObject(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DCOMServerObject * inst = (DCOMServerObject *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DCOMServerObject & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DCOMServerObject(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) callVirtualMethod(/*1Ab*/uint methodID, /*1Ab*/bool hasReturnValue); // DCOMServerObject_callVirtualMethod

   struct DCOMServerObject_callMethod_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(DCOMServerObject & , /*6Fj*/uint __ecereMethodID, /*6Fj*/SerialBuffer & __ecereBuffer);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/uint __ecereMethodID, /*6Fj*/SerialBuffer & __ecereBuffer);
   } callMethod;
   // inline static void register_callMethod(CPPClass & cl, DCOMServerObject::DCOMServerObject_callMethod_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct instance_Prop
   {
      constexpr instance_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Instance operator= (/*0H*/Instance v);
      /*regSet*/inline DCOMServerObject::instance_Prop & operator= (DCOMServerObject::instance_Prop & prop);
      /*regGet*/inline operator /*0I*/Instance () const;
   } instance;
   struct serverSocket_Prop
   {
      constexpr serverSocket_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DCOMServerSocket operator= (/*0H*/DCOMServerSocket v);
      /*regSet*/inline DCOMServerObject::serverSocket_Prop & operator= (DCOMServerObject::serverSocket_Prop & prop);
      /*regGet*/inline operator /*0I*/DCOMServerSocket () const;
   } serverSocket;
   struct id_Prop
   {
      constexpr id_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline DCOMServerObject::id_Prop & operator= (DCOMServerObject::id_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } id;
   struct argsBuffer_Prop
   {
      constexpr argsBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SerialBuffer operator= (/*0H*/SerialBuffer v);
      /*regSet*/inline DCOMServerObject::argsBuffer_Prop & operator= (DCOMServerObject::argsBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/SerialBuffer () const;
   } argsBuffer;
   struct returnBuffer_Prop
   {
      constexpr returnBuffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SerialBuffer operator= (/*0H*/SerialBuffer v);
      /*regSet*/inline DCOMServerObject::returnBuffer_Prop & operator= (DCOMServerObject::returnBuffer_Prop & prop);
      /*regGet*/inline operator /*0I*/SerialBuffer () const;
   } returnBuffer;
   struct mutex_Prop
   {
      constexpr mutex_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Mutex operator= (/*0H*/Mutex & v);
      /*regSet*/inline DCOMServerObject::mutex_Prop & operator= (DCOMServerObject::mutex_Prop & prop);
      /*regGet*/inline operator /*0I*/Mutex () const;
   } mutex;
   struct nextCallID_Prop
   {
      constexpr nextCallID_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DCOMServerObject::nextCallID_Prop & operator= (DCOMServerObject::nextCallID_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } nextCallID;
};


#define REG_DCOMServerSocket(c) \
      DCOMServerSocket::class_registration(_cpp_class); \
      REG_Socket_onConnect(onConnect, c); \
      REG_Socket_onDisconnect(onDisconnect, c); \
      REG_Socket_onEstablishConnection(onEstablishConnection, c); \
      REG_Socket_onReceive(onReceive, c); \
      REG_Socket_onReceivePacket(onReceivePacket, c); \
      REG_Socket_receiveData(receiveData, c); \
      REG_Socket_sendData(sendData, c);

#define DCOMSERVERSOCKET_VIRTUAL_METHODS_PROTO(c) \

#define DCOMSERVERSOCKET_VIRTUAL_METHODS(c) \

class DCOMServerSocket : public Socket
{
public:
   inline DCOMServerSocket(DCOMServerSocket && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DCOMServerSocket & operator= (DCOMServerSocket && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DCOMServerSocket() : DCOMServerSocket((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DCOMServerSocket> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DCOMServerSocket * inst = new DCOMServerSocket(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DCOMServerSocket * inst = (DCOMServerSocket *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DCOMServerSocket & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DCOMServerSocket(C(Instance) _impl, CPPClass & cl = _cpp_class) : Socket(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_DCOMService(c) \
      DCOMService::class_registration(_cpp_class); \
      REG_Service_onAccept(onAccept, c);

#define DCOMSERVICE_VIRTUAL_METHODS_PROTO(c) \

#define DCOMSERVICE_VIRTUAL_METHODS(c) \

class DCOMService : public Service
{
public:
   inline DCOMService(DCOMService && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DCOMService & operator= (DCOMService && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DCOMService() : DCOMService((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DCOMService> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DCOMService * inst = new DCOMService(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DCOMService * inst = (DCOMService *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DCOMService & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DCOMService(C(Instance) _impl, CPPClass & cl = _cpp_class) : Service(_impl, cl) { }

   inline C(bool) start(); // DCOMService_start
   inline C(bool) stop(); // DCOMService_stop

   static void class_registration(CPPClass & _cpp_class);
};

enum class DisconnectCode : int
{
   remoteLost = DisconnectCode_remoteLost,
   remoteClosed = DisconnectCode_remoteClosed,
   resolveFailed = DisconnectCode_resolveFailed,
   connectFailed = DisconnectCode_connectFailed
};


#define REG_FileServerConnection(c) \
      FileServerConnection::class_registration(_cpp_class); \
      REG_Socket_onConnect(onConnect, c); \
      REG_Socket_onDisconnect(onDisconnect, c); \
      REG_Socket_onEstablishConnection(onEstablishConnection, c); \
      REG_Socket_onReceive(onReceive, c); \
      REG_Socket_onReceivePacket(onReceivePacket, c); \
      REG_Socket_receiveData(receiveData, c); \
      REG_Socket_sendData(sendData, c);

#define FILESERVERCONNECTION_VIRTUAL_METHODS_PROTO(c) \

#define FILESERVERCONNECTION_VIRTUAL_METHODS(c) \

class FileServerConnection : public Socket
{
public:
   inline FileServerConnection(FileServerConnection && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FileServerConnection & operator= (FileServerConnection && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FileServerConnection() : FileServerConnection((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FileServerConnection> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FileServerConnection * inst = new FileServerConnection(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FileServerConnection * inst = (FileServerConnection *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FileServerConnection & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FileServerConnection(C(Instance) _impl, CPPClass & cl = _cpp_class) : Socket(_impl, cl) { }

   inline NetworkClientFile open(/*1Ab*/const char * fileName, /*1Ab*/FileOpenMode mode); // FileServerConnection_open

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_HTTPFile(c) \
      HTTPFile::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define HTTPFILE_VIRTUAL_METHODS_PROTO(c) \

#define HTTPFILE_VIRTUAL_METHODS(c) \

class HTTPFile : public File
{
public:
   inline HTTPFile(HTTPFile && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline HTTPFile & operator= (HTTPFile && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   HTTPFile() : HTTPFile((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<HTTPFile> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         HTTPFile * inst = new HTTPFile(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      HTTPFile * inst = (HTTPFile *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(HTTPFile & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline HTTPFile(C(Instance) _impl, CPPClass & cl = _cpp_class) : File(_impl, cl) { }

   inline C(bool) openURL(/*1Ab*/const char * name, /*1Ab*/const char * referer, /*1Ab*/char * relocation); // HTTPFile_openURL
   inline C(bool) openURLEx(/*1Ab*/const char * name, /*1Ab*/const char * referer, /*1Ab*/char * relocation, /*1Ab*/const char * acceptHeader); // HTTPFile_openURLEx

   static void class_registration(CPPClass & _cpp_class);

   inline HTTPFile(bool reuseConnection);

   struct reuseConnection_Prop
   {
      constexpr reuseConnection_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline HTTPFile::reuseConnection_Prop & operator= (HTTPFile::reuseConnection_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } reuseConnection;
   struct contentType_Prop
   {
      constexpr contentType_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/char * () const;
   } contentType;
   struct contentDisposition_Prop
   {
      constexpr contentDisposition_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/char * () const;
   } contentDisposition;
   struct httpCode_Prop
   {
      constexpr httpCode_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int () const;
   } httpCode;
};


#define REG_NetworkClientFile(c) \
      NetworkClientFile::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define NETWORKCLIENTFILE_VIRTUAL_METHODS_PROTO(c) \

#define NETWORKCLIENTFILE_VIRTUAL_METHODS(c) \

class NetworkClientFile : public File
{
public:
   inline NetworkClientFile(NetworkClientFile && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline NetworkClientFile & operator= (NetworkClientFile && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   NetworkClientFile() : NetworkClientFile((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<NetworkClientFile> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         NetworkClientFile * inst = new NetworkClientFile(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      NetworkClientFile * inst = (NetworkClientFile *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(NetworkClientFile & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline NetworkClientFile(C(Instance) _impl, CPPClass & cl = _cpp_class) : File(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

template <class TC, C(Class) ** TCO>
class TPacket : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline typename TPacket<TC, TCO>::size_Prop & operator= (typename TPacket<TC, TCO>::size_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } size;
   ~TPacket()
   {
      this->impl = null; // How to know not to delete?
   }
};


#define REG_SSLSocket(c) \
      SSLSocket::class_registration(_cpp_class); \
      REG_Socket_onConnect(onConnect, c); \
      REG_Socket_onDisconnect(onDisconnect, c); \
      REG_Socket_onEstablishConnection(onEstablishConnection, c); \
      REG_Socket_onReceive(onReceive, c); \
      REG_Socket_onReceivePacket(onReceivePacket, c); \
      REG_Socket_receiveData(receiveData, c); \
      REG_Socket_sendData(sendData, c);

#define SSLSOCKET_VIRTUAL_METHODS_PROTO(c) \

#define SSLSOCKET_VIRTUAL_METHODS(c) \

class SSLSocket : public Socket
{
public:
   inline SSLSocket(SSLSocket && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline SSLSocket & operator= (SSLSocket && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   SSLSocket() : SSLSocket((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<SSLSocket> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         SSLSocket * inst = new SSLSocket(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      SSLSocket * inst = (SSLSocket *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(SSLSocket & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline SSLSocket(C(Instance) _impl, CPPClass & cl = _cpp_class) : Socket(_impl, cl) { }

   inline C(bool) establishConnection(); // SSLSocket_establishConnection

   static void class_registration(CPPClass & _cpp_class);

   inline SSLSocket(bool autoEstablish);

   struct autoEstablish_Prop
   {
      constexpr autoEstablish_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline SSLSocket::autoEstablish_Prop & operator= (SSLSocket::autoEstablish_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } autoEstablish;
};

enum class SocketType : int
{
   tcp = SocketType_tcp,
   udp = SocketType_udp
};

class FileAttribs
{
public:
   C(FileAttribs) impl;
   constexpr FileAttribs() : impl(0) { }
   constexpr FileAttribs(C(FileAttribs) impl) : impl(impl) { }
   operator C(FileAttribs)() { return impl; }
   FileAttribs & operator =(C(FileAttribs) impl) { impl = impl; return *this; }
   bool operator ==(const FileAttribs & value) const { return impl == value.impl; }
   bool operator !=(const FileAttribs & value) const { return impl != value.impl; }

   struct isFile_Prop
   {
      constexpr isFile_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isFile_Prop & operator= (FileAttribs::isFile_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isFile;
   struct isArchive_Prop
   {
      constexpr isArchive_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isArchive_Prop & operator= (FileAttribs::isArchive_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isArchive;
   struct isHidden_Prop
   {
      constexpr isHidden_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isHidden_Prop & operator= (FileAttribs::isHidden_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isHidden;
   struct isReadOnly_Prop
   {
      constexpr isReadOnly_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isReadOnly_Prop & operator= (FileAttribs::isReadOnly_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isReadOnly;
   struct isSystem_Prop
   {
      constexpr isSystem_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isSystem_Prop & operator= (FileAttribs::isSystem_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isSystem;
   struct isTemporary_Prop
   {
      constexpr isTemporary_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isTemporary_Prop & operator= (FileAttribs::isTemporary_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isTemporary;
   struct isDirectory_Prop
   {
      constexpr isDirectory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isDirectory_Prop & operator= (FileAttribs::isDirectory_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isDirectory;
   struct isDrive_Prop
   {
      constexpr isDrive_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isDrive_Prop & operator= (FileAttribs::isDrive_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isDrive;
   struct isCDROM_Prop
   {
      constexpr isCDROM_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isCDROM_Prop & operator= (FileAttribs::isCDROM_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isCDROM;
   struct isRemote_Prop
   {
      constexpr isRemote_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isRemote_Prop & operator= (FileAttribs::isRemote_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isRemote;
   struct isRemovable_Prop
   {
      constexpr isRemovable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isRemovable_Prop & operator= (FileAttribs::isRemovable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isRemovable;
   struct isServer_Prop
   {
      constexpr isServer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isServer_Prop & operator= (FileAttribs::isServer_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isServer;
   struct isShare_Prop
   {
      constexpr isShare_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileAttribs::isShare_Prop & operator= (FileAttribs::isShare_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isShare;
};

#define REG_ArchiveDir_addFromFile(m, c)           REGVMETHOD(ArchiveDir, addFromFile,           c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/const char * name, /*1Ab*/File & input, /*1Ab*/FileStats & stats, /*1Ab*/ArchiveAddMode addMode, /*1Ab*/int compression, /*1Ab*/int * ratio, /*1Ab*/uint * newPosition),                       c, (/*4Im*/name, /*4Im*/input, /*4Im*/stats, /*4Hm*/(ArchiveAddMode)addMode, /*4Im*/compression, /*4Im*/ratio, /*4Im*/newPosition))
#define REG_ArchiveDir_addFromFileAtPosition(m, c) REGVMETHOD(ArchiveDir, addFromFileAtPosition, c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/uint position, /*1Ab*/const char * name, /*1Ab*/File & input, /*1Ab*/FileStats & stats, /*1Ab*/ArchiveAddMode addMode, /*1Ab*/int compression, /*1Ab*/int * ratio, /*1Ab*/uint * newPosition), c, (/*4Im*/position, /*4Im*/name, /*4Im*/input, /*4Im*/stats, /*4Hm*/(ArchiveAddMode)addMode, /*4Im*/compression, /*4Im*/ratio, /*4Im*/newPosition))
#define REG_ArchiveDir_delete(m, c)                REGVMETHOD(ArchiveDir, delete,                c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/const char * fileName),                                                                                                                                                                        c, (/*4Im*/fileName))
#define REG_ArchiveDir_fileExists(m, c)            REGVMETHOD(ArchiveDir, fileExists,            c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/const char * fileName),                                                                                                                                                                        c, (/*4Im*/fileName))
#define REG_ArchiveDir_fileOpen(m, c)              REGVMETHOD(ArchiveDir, fileOpen,              c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/const char * fileName),                                                                                                                                                                        c, (/*4Im*/fileName))
#define REG_ArchiveDir_move(m, c)                  REGVMETHOD(ArchiveDir, move,                  c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/const char * name, /*1Ab*/ArchiveDir & to),                                                                                                                                                    c, (/*4Im*/name, /*4Im*/to))
#define REG_ArchiveDir_openDirectory(m, c)         REGVMETHOD(ArchiveDir, openDirectory,         c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/const char * name, /*1Ab*/FileStats & stats, /*1Ab*/ArchiveAddMode addMode),                                                                                                                   c, (/*4Im*/name, /*4Im*/stats, /*4Hm*/(ArchiveAddMode)addMode))
#define REG_ArchiveDir_rename(m, c)                REGVMETHOD(ArchiveDir, rename,                c::m, (/*1Ab*/ArchiveDir & self, /*1Ab*/const char * name, /*1Ab*/const char * newName),                                                                                                                                               c, (/*4Im*/name, /*4Im*/newName))

#define REG_ArchiveDir(c) \
      ArchiveDir::class_registration(_cpp_class); \
      REG_ArchiveDir_addFromFile(addFromFile, c); \
      REG_ArchiveDir_addFromFileAtPosition(addFromFileAtPosition, c); \
      REG_ArchiveDir_delete(delete, c); \
      REG_ArchiveDir_fileExists(fileExists, c); \
      REG_ArchiveDir_fileOpen(fileOpen, c); \
      REG_ArchiveDir_move(move, c); \
      REG_ArchiveDir_openDirectory(openDirectory, c); \
      REG_ArchiveDir_rename(rename, c);

#define ARCHIVEDIR_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(addFromFile, addFromFile, c, ArchiveDir, \
      bool, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/File & input _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode _ARG /*6Fj*/int compression _ARG /*6Fj*/int * ratio _ARG /*6Fj*/uint * newPosition); \
   VIRTUAL_METHOD_PROTO(addFromFileAtPosition, addFromFileAtPosition, c, ArchiveDir, \
      bool, c & _ARG, , /*6Fj*/uint position _ARG /*6Fj*/const char * name _ARG /*6Fj*/File & input _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode _ARG /*6Fj*/int compression _ARG /*6Fj*/int * ratio _ARG /*6Fj*/uint * newPosition); \
   VIRTUAL_METHOD_PROTO(delete, delete_, c, ArchiveDir, \
      bool, c & _ARG, , /*6Fj*/const char * fileName); \
   VIRTUAL_METHOD_PROTO(fileExists, fileExists, c, ArchiveDir, \
      FileAttribs, c & _ARG, , /*6Fj*/const char * fileName); \
   VIRTUAL_METHOD_PROTO(fileOpen, fileOpen, c, ArchiveDir, \
      File *, c & _ARG, , /*6Fj*/const char * fileName); \
   VIRTUAL_METHOD_PROTO(move, move, c, ArchiveDir, \
      bool, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/ArchiveDir & to); \
   VIRTUAL_METHOD_PROTO(openDirectory, openDirectory, c, ArchiveDir, \
      ArchiveDir *, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode); \
   VIRTUAL_METHOD_PROTO(rename, rename, c, ArchiveDir, \
      bool, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/const char * newName);

#define ARCHIVEDIR_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(addFromFile, addFromFile, c, ArchiveDir, \
   bool, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/File & input _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode _ARG /*6Fj*/int compression _ARG /*6Fj*/int * ratio _ARG /*6Fj*/uint * newPosition, \
   return (bool)ArchiveDir_addFromFile(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/input.impl, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode, /*7Al*/compression, /*7Al*/ratio, /*7Al*/newPosition);); \
VIRTUAL_METHOD(addFromFileAtPosition, addFromFileAtPosition, c, ArchiveDir, \
   bool, c & _ARG, , /*6Fj*/uint position _ARG /*6Fj*/const char * name _ARG /*6Fj*/File & input _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode _ARG /*6Fj*/int compression _ARG /*6Fj*/int * ratio _ARG /*6Fj*/uint * newPosition, \
   return (bool)ArchiveDir_addFromFileAtPosition(self ? self->impl : (C(ArchiveDir))null, /*7Al*/position, /*7Al*/name, /*7Al*/input.impl, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode, /*7Al*/compression, /*7Al*/ratio, /*7Al*/newPosition);); \
VIRTUAL_METHOD(delete, delete_, c, ArchiveDir, \
   bool, c & _ARG, , /*6Fj*/const char * fileName, \
   return (bool)ArchiveDir_delete(self ? self->impl : (C(ArchiveDir))null, /*7Al*/fileName);); \
VIRTUAL_METHOD(fileExists, fileExists, c, ArchiveDir, \
   FileAttribs, c & _ARG, , /*6Fj*/const char * fileName, \
   return ArchiveDir_fileExists(self ? self->impl : (C(ArchiveDir))null, /*7Al*/fileName);); \
VIRTUAL_METHOD(fileOpen, fileOpen, c, ArchiveDir, \
   File *, c & _ARG, , /*6Fj*/const char * fileName, \
   C(File) retFile = ArchiveDir_fileOpen(self ? self->impl : (C(ArchiveDir))null, /*7Al*/fileName); \
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;); \
VIRTUAL_METHOD(move, move, c, ArchiveDir, \
   bool, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/ArchiveDir & to, \
   return (bool)ArchiveDir_move(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/to.impl);); \
VIRTUAL_METHOD(openDirectory, openDirectory, c, ArchiveDir, \
   ArchiveDir *, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode, \
   C(ArchiveDir) retArchiveDir = ArchiveDir_openDirectory(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode); \
      return BINDINGS_CLASS(retArchiveDir) ? (ArchiveDir *)INSTANCEL(retArchiveDir, retArchiveDir->_class) : (ArchiveDir *)0;); \
VIRTUAL_METHOD(rename, rename, c, ArchiveDir, \
   bool, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/const char * newName, \
   return (bool)ArchiveDir_rename(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/newName););

class ArchiveDir : public Instance
{
public:
   inline ArchiveDir(ArchiveDir && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ArchiveDir & operator= (ArchiveDir && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ArchiveDir() : ArchiveDir((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ArchiveDir> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ArchiveDir * inst = new ArchiveDir(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ArchiveDir * inst = (ArchiveDir *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ArchiveDir & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ArchiveDir(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(bool) add(/*1Ab*/const char * name, /*1Ab*/const char * path, /*1Ab*/ArchiveAddMode addMode, /*1Ab*/int compression, /*1Ab*/int * ratio, /*1Ab*/uint * newPosition); // ArchiveDir_add

   struct ArchiveDir_addFromFile_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(ArchiveDir & , /*6Fj*/const char * name, /*6Fj*/File & input, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode, /*6Fj*/int compression, /*6Fj*/int * ratio, /*6Fj*/uint * newPosition);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/const char * name, /*6Fj*/File & input, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode, /*6Fj*/int compression, /*6Fj*/int * ratio, /*6Fj*/uint * newPosition);
   } addFromFile;
   // inline static void register_addFromFile(CPPClass & cl, ArchiveDir::ArchiveDir_addFromFile_Functor::FunctionType func)

   struct ArchiveDir_addFromFileAtPosition_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(ArchiveDir & , /*6Fj*/uint position, /*6Fj*/const char * name, /*6Fj*/File & input, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode, /*6Fj*/int compression, /*6Fj*/int * ratio, /*6Fj*/uint * newPosition);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/uint position, /*6Fj*/const char * name, /*6Fj*/File & input, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode, /*6Fj*/int compression, /*6Fj*/int * ratio, /*6Fj*/uint * newPosition);
   } addFromFileAtPosition;
   // inline static void register_addFromFileAtPosition(CPPClass & cl, ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::FunctionType func)

   struct ArchiveDir_delete_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(ArchiveDir & , /*6Fj*/const char * fileName);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/const char * fileName);
   } delete_;
   // inline static void register_delete(CPPClass & cl, ArchiveDir::ArchiveDir_delete_Functor::FunctionType func)

   struct ArchiveDir_fileExists_Functor
   {
      [[no_unique_address]] int _[0];
      typedef FileAttribs (* FunctionType)(ArchiveDir & , /*6Fj*/const char * fileName);
      inline FunctionType operator= (FunctionType func);
      inline FileAttribs operator()( /*6Fj*/const char * fileName);
   } fileExists;
   // inline static void register_fileExists(CPPClass & cl, ArchiveDir::ArchiveDir_fileExists_Functor::FunctionType func)

   struct ArchiveDir_fileOpen_Functor
   {
      [[no_unique_address]] int _[0];
      typedef File * (* FunctionType)(ArchiveDir & , /*6Fj*/const char * fileName);
      inline FunctionType operator= (FunctionType func);
      inline File * operator()( /*6Fj*/const char * fileName);
   } fileOpen;
   // inline static void register_fileOpen(CPPClass & cl, ArchiveDir::ArchiveDir_fileOpen_Functor::FunctionType func)

   struct ArchiveDir_move_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(ArchiveDir & , /*6Fj*/const char * name, /*6Fj*/ArchiveDir & to);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/const char * name, /*6Fj*/ArchiveDir & to);
   } move;
   // inline static void register_move(CPPClass & cl, ArchiveDir::ArchiveDir_move_Functor::FunctionType func)

   struct ArchiveDir_openDirectory_Functor
   {
      [[no_unique_address]] int _[0];
      typedef ArchiveDir * (* FunctionType)(ArchiveDir & , /*6Fj*/const char * name, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode);
      inline FunctionType operator= (FunctionType func);
      inline ArchiveDir * operator()( /*6Fj*/const char * name, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode);
   } openDirectory;
   // inline static void register_openDirectory(CPPClass & cl, ArchiveDir::ArchiveDir_openDirectory_Functor::FunctionType func)

   struct ArchiveDir_rename_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(ArchiveDir & , /*6Fj*/const char * name, /*6Fj*/const char * newName);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( /*6Fj*/const char * name, /*6Fj*/const char * newName);
   } rename;
   // inline static void register_rename(CPPClass & cl, ArchiveDir::ArchiveDir_rename_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};

class CharCategories
{
public:
   C(CharCategories) impl;
   constexpr CharCategories() : impl(0) { }

   CharCategories(PredefinedCharCategories impl) : impl((C(CharCategories))impl) { }
   CharCategories & operator =(PredefinedCharCategories impl) { this->impl = (C(CharCategories))impl; return *this; }

   constexpr CharCategories(C(CharCategories) impl) : impl(impl) { }
   operator C(CharCategories)() { return impl; }
   CharCategories & operator =(C(CharCategories) impl) { impl = impl; return *this; }
   bool operator ==(const CharCategories & value) const { return impl == value.impl; }
   bool operator !=(const CharCategories & value) const { return impl != value.impl; }

   struct none_Prop
   {
      constexpr none_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::none_Prop & operator= (CharCategories::none_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } none;
   struct markNonSpacing_Prop
   {
      constexpr markNonSpacing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::markNonSpacing_Prop & operator= (CharCategories::markNonSpacing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } markNonSpacing;
   struct markSpacing_Prop
   {
      constexpr markSpacing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::markSpacing_Prop & operator= (CharCategories::markSpacing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } markSpacing;
   struct markEnclosing_Prop
   {
      constexpr markEnclosing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::markEnclosing_Prop & operator= (CharCategories::markEnclosing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } markEnclosing;
   struct numberDecimalDigit_Prop
   {
      constexpr numberDecimalDigit_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::numberDecimalDigit_Prop & operator= (CharCategories::numberDecimalDigit_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } numberDecimalDigit;
   struct numberLetter_Prop
   {
      constexpr numberLetter_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::numberLetter_Prop & operator= (CharCategories::numberLetter_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } numberLetter;
   struct numberOther_Prop
   {
      constexpr numberOther_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::numberOther_Prop & operator= (CharCategories::numberOther_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } numberOther;
   struct separatorSpace_Prop
   {
      constexpr separatorSpace_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::separatorSpace_Prop & operator= (CharCategories::separatorSpace_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } separatorSpace;
   struct separatorLine_Prop
   {
      constexpr separatorLine_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::separatorLine_Prop & operator= (CharCategories::separatorLine_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } separatorLine;
   struct separatorParagraph_Prop
   {
      constexpr separatorParagraph_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::separatorParagraph_Prop & operator= (CharCategories::separatorParagraph_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } separatorParagraph;
   struct otherControl_Prop
   {
      constexpr otherControl_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::otherControl_Prop & operator= (CharCategories::otherControl_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } otherControl;
   struct otherFormat_Prop
   {
      constexpr otherFormat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::otherFormat_Prop & operator= (CharCategories::otherFormat_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } otherFormat;
   struct otherSurrogate_Prop
   {
      constexpr otherSurrogate_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::otherSurrogate_Prop & operator= (CharCategories::otherSurrogate_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } otherSurrogate;
   struct otherPrivateUse_Prop
   {
      constexpr otherPrivateUse_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::otherPrivateUse_Prop & operator= (CharCategories::otherPrivateUse_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } otherPrivateUse;
   struct otherNotAssigned_Prop
   {
      constexpr otherNotAssigned_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::otherNotAssigned_Prop & operator= (CharCategories::otherNotAssigned_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } otherNotAssigned;
   struct letterUpperCase_Prop
   {
      constexpr letterUpperCase_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::letterUpperCase_Prop & operator= (CharCategories::letterUpperCase_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } letterUpperCase;
   struct letterLowerCase_Prop
   {
      constexpr letterLowerCase_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::letterLowerCase_Prop & operator= (CharCategories::letterLowerCase_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } letterLowerCase;
   struct letterTitleCase_Prop
   {
      constexpr letterTitleCase_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::letterTitleCase_Prop & operator= (CharCategories::letterTitleCase_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } letterTitleCase;
   struct letterModifier_Prop
   {
      constexpr letterModifier_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::letterModifier_Prop & operator= (CharCategories::letterModifier_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } letterModifier;
   struct letterOther_Prop
   {
      constexpr letterOther_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::letterOther_Prop & operator= (CharCategories::letterOther_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } letterOther;
   struct punctuationConnector_Prop
   {
      constexpr punctuationConnector_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::punctuationConnector_Prop & operator= (CharCategories::punctuationConnector_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } punctuationConnector;
   struct punctuationDash_Prop
   {
      constexpr punctuationDash_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::punctuationDash_Prop & operator= (CharCategories::punctuationDash_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } punctuationDash;
   struct punctuationOpen_Prop
   {
      constexpr punctuationOpen_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::punctuationOpen_Prop & operator= (CharCategories::punctuationOpen_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } punctuationOpen;
   struct punctuationClose_Prop
   {
      constexpr punctuationClose_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::punctuationClose_Prop & operator= (CharCategories::punctuationClose_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } punctuationClose;
   struct punctuationInitial_Prop
   {
      constexpr punctuationInitial_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::punctuationInitial_Prop & operator= (CharCategories::punctuationInitial_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } punctuationInitial;
   struct punctuationFinal_Prop
   {
      constexpr punctuationFinal_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::punctuationFinal_Prop & operator= (CharCategories::punctuationFinal_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } punctuationFinal;
   struct punctuationOther_Prop
   {
      constexpr punctuationOther_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::punctuationOther_Prop & operator= (CharCategories::punctuationOther_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } punctuationOther;
   struct symbolMath_Prop
   {
      constexpr symbolMath_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::symbolMath_Prop & operator= (CharCategories::symbolMath_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } symbolMath;
   struct symbolCurrency_Prop
   {
      constexpr symbolCurrency_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::symbolCurrency_Prop & operator= (CharCategories::symbolCurrency_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } symbolCurrency;
   struct symbolModifier_Prop
   {
      constexpr symbolModifier_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::symbolModifier_Prop & operator= (CharCategories::symbolModifier_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } symbolModifier;
   struct symbolOther_Prop
   {
      constexpr symbolOther_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline CharCategories::symbolOther_Prop & operator= (CharCategories::symbolOther_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } symbolOther;
};

class Distance
{
public:
   C(Distance) impl;
   constexpr Distance() : impl(0) { }
   constexpr Distance(C(Distance) value) : impl(value) { }
   operator C(Distance)() const { return impl; }
   constexpr Distance(const Distance & value) : impl(value.impl) { }
   Distance & operator =(double value) { impl = value; return *this; }
   Distance & operator +=(Distance value) { impl += value.impl; return *this; }
   Distance & operator -=(Distance value) { impl -= value.impl; return *this; }
   Distance operator +(const Distance & b) const { return Distance(impl + b.impl); }
   Distance operator -(const Distance & b) const { return Distance(impl - b.impl); }
   bool operator ==(const Distance & value) const { return impl == value.impl; }
   bool operator !=(const Distance & value) const { return impl != value.impl; }
   bool operator <(const Distance & value) const { return impl < value.impl; }
   bool operator >(const Distance & value) const { return impl > value.impl; }
   bool operator <=(const Distance & value) const { return impl <= value.impl; }
   bool operator >=(const Distance & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Distance(value).impl; }
   bool operator !=(double value) const { return impl != Distance(value).impl; }
   bool operator <(double value) const { return impl < Distance(value).impl; }
   bool operator >(double value) const { return impl > Distance(value).impl; }
   bool operator <=(double value) const { return impl <= Distance(value).impl; }
   bool operator >=(double value) const { return impl >= Distance(value).impl; }
   bool operator ==(int value) const { return impl == Distance(value).impl; }
   bool operator !=(int value) const { return impl != Distance(value).impl; }
   bool operator <(int value) const { return impl < Distance(value).impl; }
   bool operator >(int value) const { return impl > Distance(value).impl; }
   bool operator <=(int value) const { return impl <= Distance(value).impl; }
   bool operator >=(int value) const { return impl >= Distance(value).impl; }
};

class ErrorCode
{
public:
   C(ErrorCode) impl;
   constexpr ErrorCode() : impl(0) { }

   ErrorCode(GuiErrorCode impl) : impl((C(ErrorCode))impl) { }
   ErrorCode & operator =(GuiErrorCode impl) { this->impl = (C(ErrorCode))impl; return *this; }
   ErrorCode(SysErrorCode impl) : impl((C(ErrorCode))impl) { }
   ErrorCode & operator =(SysErrorCode impl) { this->impl = (C(ErrorCode))impl; return *this; }

   constexpr ErrorCode(C(ErrorCode) impl) : impl(impl) { }
   ErrorCode(ErrorLevel level, uint code);
   operator C(ErrorCode)() { return impl; }
   ErrorCode & operator =(C(ErrorCode) impl) { impl = impl; return *this; }
   bool operator ==(const ErrorCode & value) const { return impl == value.impl; }
   bool operator !=(const ErrorCode & value) const { return impl != value.impl; }

   struct level_Prop
   {
      constexpr level_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/ErrorLevel operator= (/*0H*/ErrorLevel v);
      /*regSet*/inline ErrorCode::level_Prop & operator= (ErrorCode::level_Prop & prop);
      /*regGet*/inline operator /*0I*/ErrorLevel () const;
   } level;
   struct code_Prop
   {
      constexpr code_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint operator= (/*0H*/uint v);
      /*regSet*/inline ErrorCode::code_Prop & operator= (ErrorCode::code_Prop & prop);
      /*regGet*/inline operator /*0I*/uint () const;
   } code;
};

enum class SettingsIOResult : int
{
   error = SettingsIOResult_error,
   success = SettingsIOResult_success,
   fileNotFound = SettingsIOResult_fileNotFound,
   fileNotCompatibleWithDriver = SettingsIOResult_fileNotCompatibleWithDriver
};

#define REG_GlobalSettings_load(m, c)                REGVMETHOD(GlobalSettings, load,                c::m, (/*1Ab*/GlobalSettings & self), c, ())
#define REG_GlobalSettings_onAskReloadSettings(m, c) REGVMETHOD(GlobalSettings, onAskReloadSettings, c::m, (/*1Ab*/GlobalSettings & self), c, ())
#define REG_GlobalSettings_save(m, c)                REGVMETHOD(GlobalSettings, save,                c::m, (/*1Ab*/GlobalSettings & self), c, ())

#define REG_GlobalSettings(c) \
      GlobalSettings::class_registration(_cpp_class); \
      REG_GlobalSettings_load(load, c); \
      REG_GlobalSettings_onAskReloadSettings(onAskReloadSettings, c); \
      REG_GlobalSettings_save(save, c);

#define GLOBALSETTINGS_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(load, load, c, GlobalSettings, \
      SettingsIOResult, c &, , ); \
   VIRTUAL_METHOD_PROTO(onAskReloadSettings, onAskReloadSettings, c, GlobalSettings, \
      void, c &, , ); \
   VIRTUAL_METHOD_PROTO(save, save, c, GlobalSettings, \
      SettingsIOResult, c &, , );

#define GLOBALSETTINGS_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(load, load, c, GlobalSettings, \
   SettingsIOResult, c &, , , \
   return (SettingsIOResult)GlobalSettings_load(self ? self->impl : (C(GlobalSettings))null);); \
VIRTUAL_METHOD(onAskReloadSettings, onAskReloadSettings, c, GlobalSettings, \
   void, c &, , , \
   GlobalSettings_onAskReloadSettings(self ? self->impl : (C(GlobalSettings))null);); \
VIRTUAL_METHOD(save, save, c, GlobalSettings, \
   SettingsIOResult, c &, , , \
   return (SettingsIOResult)GlobalSettings_save(self ? self->impl : (C(GlobalSettings))null););

class GlobalSettings : public Instance
{
public:
   inline GlobalSettings(GlobalSettings && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GlobalSettings & operator= (GlobalSettings && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   GlobalSettings() : GlobalSettings((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GlobalSettings> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GlobalSettings * inst = new GlobalSettings(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GlobalSettings * inst = (GlobalSettings *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GlobalSettings & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GlobalSettings(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void close(); // GlobalSettings_close
   inline void closeAndMonitor(); // GlobalSettings_closeAndMonitor
   inline C(bool) openAndLock(/*1Ab*/FileSize * fileSize); // GlobalSettings_openAndLock

   struct GlobalSettings_load_Functor
   {
      [[no_unique_address]] int _[0];
      typedef SettingsIOResult (* FunctionType)(GlobalSettings &);
      inline FunctionType operator= (FunctionType func);
      inline SettingsIOResult operator()( );
   } load;
   // inline static void register_load(CPPClass & cl, GlobalSettings::GlobalSettings_load_Functor::FunctionType func)

   struct GlobalSettings_onAskReloadSettings_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(GlobalSettings &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( );
   } onAskReloadSettings;
   // inline static void register_onAskReloadSettings(CPPClass & cl, GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::FunctionType func)

   struct GlobalSettings_save_Functor
   {
      [[no_unique_address]] int _[0];
      typedef SettingsIOResult (* FunctionType)(GlobalSettings &);
      inline FunctionType operator= (FunctionType func);
      inline SettingsIOResult operator()( );
   } save;
   // inline static void register_save(CPPClass & cl, GlobalSettings::GlobalSettings_save_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline GlobalSettings(const char * settingsName, const char * settingsExtension, const char * settingsDirectory, const char * settingsLocation, const char * settingsFilePath, bool allowDefaultLocations, bool allUsers, bool portable, /*CT-D*/constString driver);

   struct settingsName_Prop
   {
      constexpr settingsName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GlobalSettings::settingsName_Prop & operator= (GlobalSettings::settingsName_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } settingsName;
   struct settingsExtension_Prop
   {
      constexpr settingsExtension_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GlobalSettings::settingsExtension_Prop & operator= (GlobalSettings::settingsExtension_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } settingsExtension;
   struct settingsDirectory_Prop
   {
      constexpr settingsDirectory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GlobalSettings::settingsDirectory_Prop & operator= (GlobalSettings::settingsDirectory_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } settingsDirectory;
   struct settingsLocation_Prop
   {
      constexpr settingsLocation_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GlobalSettings::settingsLocation_Prop & operator= (GlobalSettings::settingsLocation_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } settingsLocation;
   struct settingsFilePath_Prop
   {
      constexpr settingsFilePath_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline GlobalSettings::settingsFilePath_Prop & operator= (GlobalSettings::settingsFilePath_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } settingsFilePath;
   struct allowDefaultLocations_Prop
   {
      constexpr allowDefaultLocations_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GlobalSettings::allowDefaultLocations_Prop & operator= (GlobalSettings::allowDefaultLocations_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } allowDefaultLocations;
   struct allUsers_Prop
   {
      constexpr allUsers_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GlobalSettings::allUsers_Prop & operator= (GlobalSettings::allUsers_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } allUsers;
   struct portable_Prop
   {
      constexpr portable_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline GlobalSettings::portable_Prop & operator= (GlobalSettings::portable_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } portable;
   struct driver_Prop
   {
      constexpr driver_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*//*CT-D*/constString operator= (/*0H*//*CT-D*/constString v);
      /*regSet*/inline GlobalSettings::driver_Prop & operator= (GlobalSettings::driver_Prop & prop);
      /*regGet*/inline operator /*0I*//*CT-D*/constString () const;
   } driver;
   struct isGlobalPath_Prop
   {
      constexpr isGlobalPath_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } isGlobalPath;

   struct data_Prop
   {
      constexpr data_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/GlobalSettingsData operator= (/*0H*/GlobalSettingsData v);
      /*regSet*/inline GlobalSettings::data_Prop & operator= (GlobalSettings::data_Prop & prop);
      /*regGet*/inline operator /*0I*/GlobalSettingsData () const;
   } data;
   struct dataOwner_Prop
   {
      constexpr dataOwner_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/C(GlobalSettingsData)* operator= (/*0H*/C(GlobalSettingsData)* v);
      /*regSet*/inline GlobalSettings::dataOwner_Prop & operator= (GlobalSettings::dataOwner_Prop & prop);
      /*regGet*/inline operator /*0I*/C(GlobalSettingsData)* () const;
   } dataOwner;
};

#define REG_GlobalSettingsDriver_load(m, c) REGVMETHOD(GlobalSettingsDriver, load, c::m, (/*1Ab*/File & f, /*1Ab*/GlobalSettings & globalSettings), c, (/*4Im*/f, /*4Im*/globalSettings))
#define REG_GlobalSettingsDriver_save(m, c) REGVMETHOD(GlobalSettingsDriver, save, c::m, (/*1Ab*/File & f, /*1Ab*/GlobalSettings & globalSettings), c, (/*4Im*/f, /*4Im*/globalSettings))

#define REG_GlobalSettingsDriver(c) \
      GlobalSettingsDriver::class_registration(_cpp_class); \
      REG_GlobalSettingsDriver_load(load, c); \
      REG_GlobalSettingsDriver_save(save, c);

#define GLOBALSETTINGSDRIVER_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(load, load, c, GlobalSettingsDriver, \
      SettingsIOResult, c & _ARG, , /*6Fj*/File & f _ARG /*6Fj*/GlobalSettings & globalSettings); \
   VIRTUAL_METHOD_PROTO(save, save, c, GlobalSettingsDriver, \
      SettingsIOResult, c & _ARG, , /*6Fj*/File & f _ARG /*6Fj*/GlobalSettings & globalSettings);

#define GLOBALSETTINGSDRIVER_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(load, load, c, GlobalSettingsDriver, \
   SettingsIOResult, c & _ARG, , /*6Fj*/File & f _ARG /*6Fj*/GlobalSettings & globalSettings, \
   return (SettingsIOResult)GlobalSettingsDriver_load(self ? self->impl : (C(GlobalSettingsDriver))null, /*7Al*/f.impl, /*7Al*/globalSettings.impl);); \
VIRTUAL_METHOD(save, save, c, GlobalSettingsDriver, \
   SettingsIOResult, c & _ARG, , /*6Fj*/File & f _ARG /*6Fj*/GlobalSettings & globalSettings, \
   return (SettingsIOResult)GlobalSettingsDriver_save(self ? self->impl : (C(GlobalSettingsDriver))null, /*7Al*/f.impl, /*7Al*/globalSettings.impl););

class GlobalSettingsDriver : public Instance
{
public:
   inline GlobalSettingsDriver(GlobalSettingsDriver && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GlobalSettingsDriver & operator= (GlobalSettingsDriver && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   GlobalSettingsDriver() : GlobalSettingsDriver((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GlobalSettingsDriver> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GlobalSettingsDriver * inst = new GlobalSettingsDriver(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GlobalSettingsDriver * inst = (GlobalSettingsDriver *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GlobalSettingsDriver & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GlobalSettingsDriver(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct GlobalSettingsDriver_load_Functor
   {
      [[no_unique_address]] int _[0];
      typedef SettingsIOResult (* FunctionType)(GlobalSettingsDriver & , /*6Fj*/File & f, /*6Fj*/GlobalSettings & globalSettings);
      inline FunctionType operator= (FunctionType func);
      inline SettingsIOResult operator()( /*6Fj*/File & f, /*6Fj*/GlobalSettings & globalSettings);
   } load;
   // inline static void register_load(CPPClass & cl, GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::FunctionType func)

   struct GlobalSettingsDriver_save_Functor
   {
      [[no_unique_address]] int _[0];
      typedef SettingsIOResult (* FunctionType)(GlobalSettingsDriver & , /*6Fj*/File & f, /*6Fj*/GlobalSettings & globalSettings);
      inline FunctionType operator= (FunctionType func);
      inline SettingsIOResult operator()( /*6Fj*/File & f, /*6Fj*/GlobalSettings & globalSettings);
   } save;
   // inline static void register_save(CPPClass & cl, GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_JSONParser(c) \
      JSONParser::class_registration(_cpp_class);

#define JSONPARSER_VIRTUAL_METHODS_PROTO(c) \

#define JSONPARSER_VIRTUAL_METHODS(c) \

class JSONParser : public Instance
{
public:
   inline JSONParser(JSONParser && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline JSONParser & operator= (JSONParser && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   JSONParser() : JSONParser((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<JSONParser> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         JSONParser * inst = new JSONParser(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      JSONParser * inst = (JSONParser *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(JSONParser & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline JSONParser(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline C(JSONResult) getObject(/*1Ab*/Class objectType, /*1Ab*/void ** object); // JSONParser_getObject

   static void class_registration(CPPClass & _cpp_class);

   struct debug_Prop
   {
      constexpr debug_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONParser::debug_Prop & operator= (JSONParser::debug_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } debug;
   struct warnings_Prop
   {
      constexpr warnings_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONParser::warnings_Prop & operator= (JSONParser::warnings_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } warnings;

   struct f_Prop
   {
      constexpr f_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/File operator= (/*0H*/File v);
      /*regSet*/inline JSONParser::f_Prop & operator= (JSONParser::f_Prop & prop);
      /*regGet*/inline operator /*0I*/File () const;
   } f;
   struct customJsonOptions_Prop
   {
      constexpr customJsonOptions_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0Z*/const OptionsMap & operator= (/*0Z*/const OptionsMap & v);
      /*regSet*/inline JSONParser::customJsonOptions_Prop & operator= (JSONParser::customJsonOptions_Prop & prop);
      /*regGet*/inline operator /*0I*/OptionsMap * () const;
   } customJsonOptions;
};

class SecSince1970
{
public:
   C(SecSince1970) impl;
   constexpr SecSince1970() : impl(0) { }
   constexpr SecSince1970(C(SecSince1970) value) : impl(value) { }
   operator C(SecSince1970)() const { return impl; }
   constexpr SecSince1970(const SecSince1970 & value) : impl(value.impl) { }
   SecSince1970 & operator =(int64 value) { impl = value; return *this; }
   SecSince1970 & operator +=(SecSince1970 value) { impl += value.impl; return *this; }
   SecSince1970 & operator -=(SecSince1970 value) { impl -= value.impl; return *this; }
   SecSince1970 operator +(const SecSince1970 & b) const { return SecSince1970(impl + b.impl); }
   SecSince1970 operator -(const SecSince1970 & b) const { return SecSince1970(impl - b.impl); }
   bool operator ==(const SecSince1970 & value) const { return impl == value.impl; }
   bool operator !=(const SecSince1970 & value) const { return impl != value.impl; }
   bool operator <(const SecSince1970 & value) const { return impl < value.impl; }
   bool operator >(const SecSince1970 & value) const { return impl > value.impl; }
   bool operator <=(const SecSince1970 & value) const { return impl <= value.impl; }
   bool operator >=(const SecSince1970 & value) const { return impl >= value.impl; }
   bool operator ==(int64 value) const { return impl == SecSince1970(value).impl; }
   bool operator !=(int64 value) const { return impl != SecSince1970(value).impl; }
   bool operator <(int64 value) const { return impl < SecSince1970(value).impl; }
   bool operator >(int64 value) const { return impl > SecSince1970(value).impl; }
   bool operator <=(int64 value) const { return impl <= SecSince1970(value).impl; }
   bool operator >=(int64 value) const { return impl >= SecSince1970(value).impl; }

   struct global_Prop
   {
      constexpr global_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/SecSince1970 () const;
      /*regGet*/inline operator /*0J*/C(SecSince1970) () const;
   } global;
   struct local_Prop
   {
      constexpr local_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/SecSince1970 () const;
      /*regGet*/inline operator /*0J*/C(SecSince1970) () const;
   } local;
};

class Time
{
public:
   C(Time) impl;
   constexpr Time() : impl(0) { }
   constexpr Time(C(Time) value) : impl(value) { }
   operator C(Time)() const { return impl; }
   constexpr Time(const Time & value) : impl(value.impl) { }
   Time & operator =(double value) { impl = value; return *this; }
   Time & operator +=(Time value) { impl += value.impl; return *this; }
   Time & operator -=(Time value) { impl -= value.impl; return *this; }
   Time operator +(const Time & b) const { return Time(impl + b.impl); }
   Time operator -(const Time & b) const { return Time(impl - b.impl); }
   bool operator ==(const Time & value) const { return impl == value.impl; }
   bool operator !=(const Time & value) const { return impl != value.impl; }
   bool operator <(const Time & value) const { return impl < value.impl; }
   bool operator >(const Time & value) const { return impl > value.impl; }
   bool operator <=(const Time & value) const { return impl <= value.impl; }
   bool operator >=(const Time & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Time(value).impl; }
   bool operator !=(double value) const { return impl != Time(value).impl; }
   bool operator <(double value) const { return impl < Time(value).impl; }
   bool operator >(double value) const { return impl > Time(value).impl; }
   bool operator <=(double value) const { return impl <= Time(value).impl; }
   bool operator >=(double value) const { return impl >= Time(value).impl; }
   bool operator ==(int value) const { return impl == Time(value).impl; }
   bool operator !=(int value) const { return impl != Time(value).impl; }
   bool operator <(int value) const { return impl < Time(value).impl; }
   bool operator >(int value) const { return impl > Time(value).impl; }
   bool operator <=(int value) const { return impl <= Time(value).impl; }
   bool operator >=(int value) const { return impl >= Time(value).impl; }
};

#define REG_Archive_clear(m, c)              REGVMETHOD(Archive, clear,              c::m, (/*1Ab*/Archive & self),                                                                                      c, ())
#define REG_Archive_fileExists(m, c)         REGVMETHOD(Archive, fileExists,         c::m, (/*1Ab*/Archive & self, /*1Ab*/const char * fileName),                                                        c, (/*4Im*/fileName))
#define REG_Archive_fileOpen(m, c)           REGVMETHOD(Archive, fileOpen,           c::m, (/*1Ab*/Archive & self, /*1Ab*/const char * fileName),                                                        c, (/*4Im*/fileName))
#define REG_Archive_fileOpenAtPosition(m, c) REGVMETHOD(Archive, fileOpenAtPosition, c::m, (/*1Ab*/Archive & self, /*1Ab*/uint position),                                                                c, (/*4Im*/position))
#define REG_Archive_fileOpenCompressed(m, c) REGVMETHOD(Archive, fileOpenCompressed, c::m, (/*1Ab*/Archive & self, /*1Ab*/const char * fileName, /*1Ab*/C(bool) * isCompressed, /*1Ab*/uint64 * ucSize), c, (/*4Im*/fileName, /*4Hm*/(C(bool) *)isCompressed, /*4Im*/ucSize))
#define REG_Archive_openDirectory(m, c)      REGVMETHOD(Archive, openDirectory,      c::m, (/*1Ab*/Archive & self, /*1Ab*/const char * name, /*1Ab*/FileStats & stats, /*1Ab*/ArchiveAddMode addMode),   c, (/*4Im*/name, /*4Im*/stats, /*4Hm*/(ArchiveAddMode)addMode))
#define REG_Archive_setBufferRead(m, c)      REGVMETHOD(Archive, setBufferRead,      c::m, (/*1Ab*/Archive & self, /*1Ab*/uint bufferRead),                                                              c, (/*4Im*/bufferRead))
#define REG_Archive_setBufferSize(m, c)      REGVMETHOD(Archive, setBufferSize,      c::m, (/*1Ab*/Archive & self, /*1Ab*/uint bufferSize),                                                              c, (/*4Im*/bufferSize))

#define REG_Archive(c) \
      Archive::class_registration(_cpp_class); \
      REG_Archive_clear(clear, c); \
      REG_Archive_fileExists(fileExists, c); \
      REG_Archive_fileOpen(fileOpen, c); \
      REG_Archive_fileOpenAtPosition(fileOpenAtPosition, c); \
      REG_Archive_fileOpenCompressed(fileOpenCompressed, c); \
      REG_Archive_openDirectory(openDirectory, c); \
      REG_Archive_setBufferRead(setBufferRead, c); \
      REG_Archive_setBufferSize(setBufferSize, c);

#define ARCHIVE_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(clear, clear, c, Archive, \
      bool, c &, , ); \
   VIRTUAL_METHOD_PROTO(fileExists, fileExists, c, Archive, \
      FileAttribs, c & _ARG, , /*6Fj*/const char * fileName); \
   VIRTUAL_METHOD_PROTO(fileOpen, fileOpen, c, Archive, \
      File *, c & _ARG, , /*6Fj*/const char * fileName); \
   VIRTUAL_METHOD_PROTO(fileOpenAtPosition, fileOpenAtPosition, c, Archive, \
      File *, c & _ARG, , /*6Fj*/uint position); \
   VIRTUAL_METHOD_PROTO(fileOpenCompressed, fileOpenCompressed, c, Archive, \
      File *, c & _ARG, , /*6Fj*/const char * fileName _ARG /*6Cj*/C(bool) * isCompressed _ARG /*6Fj*/uint64 * ucSize); \
   VIRTUAL_METHOD_PROTO(openDirectory, openDirectory, c, Archive, \
      ArchiveDir *, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode); \
   VIRTUAL_METHOD_PROTO(setBufferRead, setBufferRead, c, Archive, \
      void, c & _ARG, , /*6Fj*/uint bufferRead); \
   VIRTUAL_METHOD_PROTO(setBufferSize, setBufferSize, c, Archive, \
      void, c & _ARG, , /*6Fj*/uint bufferSize);

#define ARCHIVE_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(clear, clear, c, Archive, \
   bool, c &, , , \
   return (bool)Archive_clear(self ? self->impl : (C(Archive))null);); \
VIRTUAL_METHOD(fileExists, fileExists, c, Archive, \
   FileAttribs, c & _ARG, , /*6Fj*/const char * fileName, \
   return Archive_fileExists(self ? self->impl : (C(Archive))null, /*7Al*/fileName);); \
VIRTUAL_METHOD(fileOpen, fileOpen, c, Archive, \
   File *, c & _ARG, , /*6Fj*/const char * fileName, \
   C(File) retFile = Archive_fileOpen(self ? self->impl : (C(Archive))null, /*7Al*/fileName); \
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;); \
VIRTUAL_METHOD(fileOpenAtPosition, fileOpenAtPosition, c, Archive, \
   File *, c & _ARG, , /*6Fj*/uint position, \
   C(File) retFile = Archive_fileOpenAtPosition(self ? self->impl : (C(Archive))null, /*7Al*/position); \
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;); \
VIRTUAL_METHOD(fileOpenCompressed, fileOpenCompressed, c, Archive, \
   File *, c & _ARG, , /*6Fj*/const char * fileName _ARG /*6Cj*/C(bool) * isCompressed _ARG /*6Fj*/uint64 * ucSize, \
   C(File) retFile = Archive_fileOpenCompressed(self ? self->impl : (C(Archive))null, /*7Al*/fileName, /*7Al*/isCompressed, /*7Al*/ucSize); \
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;); \
VIRTUAL_METHOD(openDirectory, openDirectory, c, Archive, \
   ArchiveDir *, c & _ARG, , /*6Fj*/const char * name _ARG /*6Fj*/FileStats & stats _ARG /*6Fj*/ArchiveAddMode addMode, \
   C(ArchiveDir) retArchiveDir = Archive_openDirectory(self ? self->impl : (C(Archive))null, /*7Al*/name, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode); \
      return BINDINGS_CLASS(retArchiveDir) ? (ArchiveDir *)INSTANCEL(retArchiveDir, retArchiveDir->_class) : (ArchiveDir *)0;); \
VIRTUAL_METHOD(setBufferRead, setBufferRead, c, Archive, \
   void, c & _ARG, , /*6Fj*/uint bufferRead, \
   Archive_setBufferRead(self ? self->impl : (C(Archive))null, /*7Al*/bufferRead);); \
VIRTUAL_METHOD(setBufferSize, setBufferSize, c, Archive, \
   void, c & _ARG, , /*6Fj*/uint bufferSize, \
   Archive_setBufferSize(self ? self->impl : (C(Archive))null, /*7Al*/bufferSize););

class Archive : public Instance
{
public:
   inline Archive(Archive && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Archive & operator= (Archive && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Archive() : Archive((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Archive> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Archive * inst = new Archive(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Archive * inst = (Archive *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Archive & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Archive(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   struct Archive_clear_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Archive &);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()( );
   } clear;
   // inline static void register_clear(CPPClass & cl, Archive::Archive_clear_Functor::FunctionType func)

   struct Archive_fileExists_Functor
   {
      [[no_unique_address]] int _[0];
      typedef FileAttribs (* FunctionType)(Archive & , /*6Fj*/const char * fileName);
      inline FunctionType operator= (FunctionType func);
      inline FileAttribs operator()( /*6Fj*/const char * fileName);
   } fileExists;
   // inline static void register_fileExists(CPPClass & cl, Archive::Archive_fileExists_Functor::FunctionType func)

   struct Archive_fileOpen_Functor
   {
      [[no_unique_address]] int _[0];
      typedef File * (* FunctionType)(Archive & , /*6Fj*/const char * fileName);
      inline FunctionType operator= (FunctionType func);
      inline File * operator()( /*6Fj*/const char * fileName);
   } fileOpen;
   // inline static void register_fileOpen(CPPClass & cl, Archive::Archive_fileOpen_Functor::FunctionType func)

   struct Archive_fileOpenAtPosition_Functor
   {
      [[no_unique_address]] int _[0];
      typedef File * (* FunctionType)(Archive & , /*6Fj*/uint position);
      inline FunctionType operator= (FunctionType func);
      inline File * operator()( /*6Fj*/uint position);
   } fileOpenAtPosition;
   // inline static void register_fileOpenAtPosition(CPPClass & cl, Archive::Archive_fileOpenAtPosition_Functor::FunctionType func)

   struct Archive_fileOpenCompressed_Functor
   {
      [[no_unique_address]] int _[0];
      typedef File * (* FunctionType)(Archive & , /*6Fj*/const char * fileName, /*6Cj*/C(bool) * isCompressed, /*6Fj*/uint64 * ucSize);
      inline FunctionType operator= (FunctionType func);
      inline File * operator()( /*6Fj*/const char * fileName, /*6Cj*/C(bool) * isCompressed, /*6Fj*/uint64 * ucSize);
   } fileOpenCompressed;
   // inline static void register_fileOpenCompressed(CPPClass & cl, Archive::Archive_fileOpenCompressed_Functor::FunctionType func)

   struct Archive_openDirectory_Functor
   {
      [[no_unique_address]] int _[0];
      typedef ArchiveDir * (* FunctionType)(Archive & , /*6Fj*/const char * name, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode);
      inline FunctionType operator= (FunctionType func);
      inline ArchiveDir * operator()( /*6Fj*/const char * name, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode);
   } openDirectory;
   // inline static void register_openDirectory(CPPClass & cl, Archive::Archive_openDirectory_Functor::FunctionType func)

   struct Archive_setBufferRead_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Archive & , /*6Fj*/uint bufferRead);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/uint bufferRead);
   } setBufferRead;
   // inline static void register_setBufferRead(CPPClass & cl, Archive::Archive_setBufferRead_Functor::FunctionType func)

   struct Archive_setBufferSize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Archive & , /*6Fj*/uint bufferSize);
      inline FunctionType operator= (FunctionType func);
      inline void operator()( /*6Fj*/uint bufferSize);
   } setBufferSize;
   // inline static void register_setBufferSize(CPPClass & cl, Archive::Archive_setBufferSize_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline Archive(FileSize totalSize, uint bufferSize, uint bufferRead);

   struct totalSize_Prop
   {
      constexpr totalSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FileSize operator= (/*0H*/FileSize v);
      /*regSet*/inline Archive::totalSize_Prop & operator= (Archive::totalSize_Prop & prop);
      /*regGet*/inline operator /*0I*/FileSize () const;
      /*regGet*/inline operator /*0J*/C(FileSize) () const;
   } totalSize;
   struct bufferSize_Prop
   {
      constexpr bufferSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/uint operator= (/*0G*/uint v);
   } bufferSize;
   struct bufferRead_Prop
   {
      constexpr bufferRead_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/uint operator= (/*0G*/uint v);
   } bufferRead;
};

enum class ArchiveAddMode : int
{
   replace = ArchiveAddMode_replace,
   refresh = ArchiveAddMode_refresh,
   update = ArchiveAddMode_update,
   readOnlyDir = ArchiveAddMode_readOnlyDir
};

class ArchiveOpenFlags
{
public:
   C(ArchiveOpenFlags) impl;
   constexpr ArchiveOpenFlags() : impl(0) { }
   constexpr ArchiveOpenFlags(C(ArchiveOpenFlags) impl) : impl(impl) { }
   ArchiveOpenFlags(bool writeAccess, bool buffered, bool exclusive, bool waitLock);
   operator C(ArchiveOpenFlags)() { return impl; }
   ArchiveOpenFlags & operator =(C(ArchiveOpenFlags) impl) { impl = impl; return *this; }
   bool operator ==(const ArchiveOpenFlags & value) const { return impl == value.impl; }
   bool operator !=(const ArchiveOpenFlags & value) const { return impl != value.impl; }

   struct writeAccess_Prop
   {
      constexpr writeAccess_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ArchiveOpenFlags::writeAccess_Prop & operator= (ArchiveOpenFlags::writeAccess_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } writeAccess;
   struct buffered_Prop
   {
      constexpr buffered_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ArchiveOpenFlags::buffered_Prop & operator= (ArchiveOpenFlags::buffered_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } buffered;
   struct exclusive_Prop
   {
      constexpr exclusive_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ArchiveOpenFlags::exclusive_Prop & operator= (ArchiveOpenFlags::exclusive_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } exclusive;
   struct waitLock_Prop
   {
      constexpr waitLock_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline ArchiveOpenFlags::waitLock_Prop & operator= (ArchiveOpenFlags::waitLock_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } waitLock;
};

struct Box : public TStruct<Box>
{
public:
   C(Box) impl;
   constexpr Box() : impl({}) { }
   constexpr Box(const C(Box) impl) : impl(impl) { }

   inline void clip(/*1Ab*/Box & against); // Box_clip
   inline void clip(/*1Ac*/Box * against); // Box_clip
   inline void clipOffset(/*1Ab*/Box & against, /*1Ab*/int x, /*1Ab*/int y); // Box_clipOffset
   inline void clipOffset(/*1Ac*/Box * against, /*1Ac*/int x, /*1Ac*/int y); // Box_clipOffset
   inline C(bool) isPointInside(/*1Ab*/Point & point); // Box_isPointInside
   inline C(bool) isPointInside(/*1Ac*/Point * point); // Box_isPointInside
   inline C(bool) overlap(/*1Ab*/Box & box); // Box_overlap
   inline C(bool) overlap(/*1Ac*/Box * box); // Box_overlap

   inline Box(int left, int top, int right, int bottom);

   struct width_Prop
   {
      constexpr width_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Box::width_Prop & operator= (Box::width_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } width;
   struct height_Prop
   {
      constexpr height_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Box::height_Prop & operator= (Box::height_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } height;

   struct left_Prop
   {
      constexpr left_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Box::left_Prop & operator= (Box::left_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } left;
   struct top_Prop
   {
      constexpr top_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Box::top_Prop & operator= (Box::top_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } top;
   struct right_Prop
   {
      constexpr right_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Box::right_Prop & operator= (Box::right_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } right;
   struct bottom_Prop
   {
      constexpr bottom_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Box::bottom_Prop & operator= (Box::bottom_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } bottom;
};


#define REG_BufferedFile(c) \
      BufferedFile::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define BUFFEREDFILE_VIRTUAL_METHODS_PROTO(c) \

#define BUFFEREDFILE_VIRTUAL_METHODS(c) \

class BufferedFile : public File
{
public:
   inline BufferedFile(BufferedFile && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline BufferedFile & operator= (BufferedFile && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   BufferedFile() : BufferedFile((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<BufferedFile> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         BufferedFile * inst = new BufferedFile(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      BufferedFile * inst = (BufferedFile *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(BufferedFile & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline BufferedFile(C(Instance) _impl, CPPClass & cl = _cpp_class) : File(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   struct handle_Prop
   {
      constexpr handle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0A*/const File & operator= (/*0A*/const File & v);
      /*regSet*/inline BufferedFile::handle_Prop & operator= (BufferedFile::handle_Prop & prop);
      /*nstSet*/inline /*0C*/const File * operator= (/*0C*/const File * v);
      /*regGet*/inline operator /*0B*/TIH<File> () const;
      /*regGet*/inline TIH<File> operator /*0D*/-> () const;
      /*regGet*/inline operator /*0E*/File () const;
      /*regGet*/inline operator /*0F*/File* () const;
   } handle;
   struct bufferSize_Prop
   {
      constexpr bufferSize_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uintsize operator= (/*0H*/uintsize v);
      /*regSet*/inline BufferedFile::bufferSize_Prop & operator= (BufferedFile::bufferSize_Prop & prop);
      /*regGet*/inline operator /*0I*/uintsize () const;
   } bufferSize;
   struct bufferRead_Prop
   {
      constexpr bufferRead_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uintsize operator= (/*0H*/uintsize v);
      /*regSet*/inline BufferedFile::bufferRead_Prop & operator= (BufferedFile::bufferRead_Prop & prop);
      /*regGet*/inline operator /*0I*/uintsize () const;
   } bufferRead;
};

class Centimeters : public Distance
{
public:
   constexpr Centimeters() : Distance() { }
   constexpr Centimeters(const Distance value) : Distance(value) { }
   constexpr Centimeters(double value) : Distance(CENTIMETERS(value)) { }
   constexpr operator double() const { return Distance_in_Centimeters(impl); }
   constexpr Centimeters & operator =(double value) { impl = CENTIMETERS(value); return *this; }
   bool operator ==(const Centimeters & value) const { return impl == value.impl; }
   bool operator !=(const Centimeters & value) const { return impl != value.impl; }
   bool operator <(const Centimeters & value) const { return impl < value.impl; }
   bool operator >(const Centimeters & value) const { return impl > value.impl; }
   bool operator <=(const Centimeters & value) const { return impl <= value.impl; }
   bool operator >=(const Centimeters & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Centimeters(value).impl; }
   bool operator !=(double value) const { return impl != Centimeters(value).impl; }
   bool operator <(double value) const { return impl < Centimeters(value).impl; }
   bool operator >(double value) const { return impl > Centimeters(value).impl; }
   bool operator <=(double value) const { return impl <= Centimeters(value).impl; }
   bool operator >=(double value) const { return impl >= Centimeters(value).impl; }
   bool operator ==(int value) const { return impl == Centimeters(value).impl; }
   bool operator !=(int value) const { return impl != Centimeters(value).impl; }
   bool operator <(int value) const { return impl < Centimeters(value).impl; }
   bool operator >(int value) const { return impl > Centimeters(value).impl; }
   bool operator <=(int value) const { return impl <= Centimeters(value).impl; }
   bool operator >=(int value) const { return impl >= Centimeters(value).impl; }
   inline constexpr operator Meters() const;
   inline constexpr Centimeters(const Meters & m);
   inline constexpr Centimeters & operator =(const Meters & m);
};

enum class CharCategory : int
{
   none = CharCategory_none,
   Mn = CharCategory_Mn,
   markNonSpacing = CharCategory_markNonSpacing,
   Mc = CharCategory_Mc,
   markSpacing = CharCategory_markSpacing,
   Me = CharCategory_Me,
   markEnclosing = CharCategory_markEnclosing,
   Nd = CharCategory_Nd,
   numberDecimalDigit = CharCategory_numberDecimalDigit,
   Nl = CharCategory_Nl,
   numberLetter = CharCategory_numberLetter,
   No = CharCategory_No,
   numberOther = CharCategory_numberOther,
   Zs = CharCategory_Zs,
   separatorSpace = CharCategory_separatorSpace,
   Zl = CharCategory_Zl,
   separatorLine = CharCategory_separatorLine,
   Zp = CharCategory_Zp,
   separatorParagraph = CharCategory_separatorParagraph,
   Cc = CharCategory_Cc,
   otherControl = CharCategory_otherControl,
   Cf = CharCategory_Cf,
   otherFormat = CharCategory_otherFormat,
   Cs = CharCategory_Cs,
   otherSurrogate = CharCategory_otherSurrogate,
   Co = CharCategory_Co,
   otherPrivateUse = CharCategory_otherPrivateUse,
   Cn = CharCategory_Cn,
   otherNotAssigned = CharCategory_otherNotAssigned,
   Lu = CharCategory_Lu,
   letterUpperCase = CharCategory_letterUpperCase,
   Ll = CharCategory_Ll,
   letterLowerCase = CharCategory_letterLowerCase,
   Lt = CharCategory_Lt,
   letterTitleCase = CharCategory_letterTitleCase,
   Lm = CharCategory_Lm,
   letterModifier = CharCategory_letterModifier,
   Lo = CharCategory_Lo,
   letterOther = CharCategory_letterOther,
   Pc = CharCategory_Pc,
   punctuationConnector = CharCategory_punctuationConnector,
   Pd = CharCategory_Pd,
   punctuationDash = CharCategory_punctuationDash,
   Ps = CharCategory_Ps,
   punctuationOpen = CharCategory_punctuationOpen,
   Pe = CharCategory_Pe,
   punctuationClose = CharCategory_punctuationClose,
   Pi_ = CharCategory_Pi,
   punctuationInitial = CharCategory_punctuationInitial,
   Pf = CharCategory_Pf,
   punctuationFinal = CharCategory_punctuationFinal,
   Po = CharCategory_Po,
   punctuationOther = CharCategory_punctuationOther,
   Sm = CharCategory_Sm,
   symbolMath = CharCategory_symbolMath,
   Sc = CharCategory_Sc,
   symbolCurrency = CharCategory_symbolCurrency,
   Sk = CharCategory_Sk,
   symbolModifier = CharCategory_symbolModifier,
   So = CharCategory_So,
   symbolOther = CharCategory_symbolOther
};

template <class TC, C(Class) ** TCO>
class TCondition : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline void signal(); // Condition_signal
   inline void wait(/*1Ab*/Mutex mutex); // Condition_wait

   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline typename TCondition<TC, TCO>::name_Prop & operator= (typename TCondition<TC, TCO>::name_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } name;
   ~TCondition()
   {
      this->impl = null; // How to know not to delete?
   }
};


#define REG_ConsoleFile(c) \
      ConsoleFile::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define CONSOLEFILE_VIRTUAL_METHODS_PROTO(c) \

#define CONSOLEFILE_VIRTUAL_METHODS(c) \

class ConsoleFile : public File
{
public:
   inline ConsoleFile(ConsoleFile && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ConsoleFile & operator= (ConsoleFile && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ConsoleFile() : ConsoleFile((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ConsoleFile> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ConsoleFile * inst = new ConsoleFile(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ConsoleFile * inst = (ConsoleFile *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ConsoleFile & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ConsoleFile(C(Instance) _impl, CPPClass & cl = _cpp_class) : File(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

struct Date : public TStruct<Date>
{
public:
   C(Date) impl;
   constexpr Date() : impl({}) { }
   constexpr Date(const C(Date) impl) : impl(impl) { }

   inline const char * onGetStringEn(/*1Ab*/char * stringOutput, /*1Ab*/void * fieldData, /*1Ab*/ObjectNotationType * onType); // Date_onGetStringEn

   inline Date(int year, Month month, int day);

   struct dayOfTheWeek_Prop
   {
      constexpr dayOfTheWeek_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/DayOfTheWeek () const;
   } dayOfTheWeek;

   struct year_Prop
   {
      constexpr year_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Date::year_Prop & operator= (Date::year_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } year;
   struct month_Prop
   {
      constexpr month_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Month operator= (/*0H*/Month v);
      /*regSet*/inline Date::month_Prop & operator= (Date::month_Prop & prop);
      /*regGet*/inline operator /*0I*/Month () const;
   } month;
   struct day_Prop
   {
      constexpr day_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Date::day_Prop & operator= (Date::day_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } day;
};

struct DateTime : public TStruct<DateTime>
{
public:
   C(DateTime) impl;
   constexpr DateTime() : impl({}) { }
   constexpr DateTime(const C(DateTime) impl) : impl(impl) { }
   inline operator SecSince1970() const;
   inline DateTime(const SecSince1970 & s);
   inline DateTime & operator =(const SecSince1970 & s);
   inline operator Date() const;
   inline DateTime(const Date & d);
   inline DateTime & operator =(const Date & d);

   inline C(bool) fixDayOfYear(); // DateTime_fixDayOfYear
   inline C(bool) getLocalTime(); // DateTime_getLocalTime

   inline DateTime(int year, Month month, int day, int hour, int minute, int second, DayOfTheWeek dayOfTheWeek, int dayInTheYear);

   struct global_Prop
   {
      constexpr global_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DateTime operator= (/*0H*/DateTime v);
      /*regSet*/inline DateTime::global_Prop & operator= (DateTime::global_Prop & prop);
      /*regGet*/inline operator /*0I*/DateTime () const;
   } global;
   struct local_Prop
   {
      constexpr local_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DateTime operator= (/*0H*/DateTime v);
      /*regSet*/inline DateTime::local_Prop & operator= (DateTime::local_Prop & prop);
      /*regGet*/inline operator /*0I*/DateTime () const;
   } local;
   struct daysSince1970_Prop
   {
      constexpr daysSince1970_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/int64 () const;
   } daysSince1970;

   struct year_Prop
   {
      constexpr year_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DateTime::year_Prop & operator= (DateTime::year_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } year;
   struct month_Prop
   {
      constexpr month_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Month operator= (/*0H*/Month v);
      /*regSet*/inline DateTime::month_Prop & operator= (DateTime::month_Prop & prop);
      /*regGet*/inline operator /*0I*/Month () const;
   } month;
   struct day_Prop
   {
      constexpr day_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DateTime::day_Prop & operator= (DateTime::day_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } day;
   struct hour_Prop
   {
      constexpr hour_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DateTime::hour_Prop & operator= (DateTime::hour_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } hour;
   struct minute_Prop
   {
      constexpr minute_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DateTime::minute_Prop & operator= (DateTime::minute_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } minute;
   struct second_Prop
   {
      constexpr second_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DateTime::second_Prop & operator= (DateTime::second_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } second;
   struct dayOfTheWeek_Prop
   {
      constexpr dayOfTheWeek_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/DayOfTheWeek operator= (/*0H*/DayOfTheWeek v);
      /*regSet*/inline DateTime::dayOfTheWeek_Prop & operator= (DateTime::dayOfTheWeek_Prop & prop);
      /*regGet*/inline operator /*0I*/DayOfTheWeek () const;
   } dayOfTheWeek;
   struct dayInTheYear_Prop
   {
      constexpr dayInTheYear_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline DateTime::dayInTheYear_Prop & operator= (DateTime::dayInTheYear_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } dayInTheYear;
};

enum class DayOfTheWeek : int
{
   sunday = DayOfTheWeek_sunday,
   monday = DayOfTheWeek_monday,
   tuesday = DayOfTheWeek_tuesday,
   wednesday = DayOfTheWeek_wednesday,
   thursday = DayOfTheWeek_thursday,
   friday = DayOfTheWeek_friday,
   saturday = DayOfTheWeek_saturday
};

class Degrees : public Angle
{
public:
   constexpr Degrees() : Angle() { }
   constexpr Degrees(const Angle value) : Angle(value) { }
   constexpr Degrees(double value) : Angle(DEGREES(value)) { }
   constexpr operator double() const { return Angle_in_Degrees(impl); }
   constexpr Degrees & operator =(double value) { impl = DEGREES(value); return *this; }
   bool operator ==(const Degrees & value) const { return impl == value.impl; }
   bool operator !=(const Degrees & value) const { return impl != value.impl; }
   bool operator <(const Degrees & value) const { return impl < value.impl; }
   bool operator >(const Degrees & value) const { return impl > value.impl; }
   bool operator <=(const Degrees & value) const { return impl <= value.impl; }
   bool operator >=(const Degrees & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Degrees(value).impl; }
   bool operator !=(double value) const { return impl != Degrees(value).impl; }
   bool operator <(double value) const { return impl < Degrees(value).impl; }
   bool operator >(double value) const { return impl > Degrees(value).impl; }
   bool operator <=(double value) const { return impl <= Degrees(value).impl; }
   bool operator >=(double value) const { return impl >= Degrees(value).impl; }
   bool operator ==(int value) const { return impl == Degrees(value).impl; }
   bool operator !=(int value) const { return impl != Degrees(value).impl; }
   bool operator <(int value) const { return impl < Degrees(value).impl; }
   bool operator >(int value) const { return impl > Degrees(value).impl; }
   bool operator <=(int value) const { return impl <= Degrees(value).impl; }
   bool operator >=(int value) const { return impl >= Degrees(value).impl; }
   inline constexpr operator Radians() const;
   inline constexpr Degrees(const Radians & r);
   inline constexpr Degrees & operator =(const Radians & r);
};


#define REG_DualPipe(c) \
      DualPipe::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define DUALPIPE_VIRTUAL_METHODS_PROTO(c) \

#define DUALPIPE_VIRTUAL_METHODS(c) \

class DualPipe : public File
{
public:
   inline DualPipe(DualPipe && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline DualPipe & operator= (DualPipe && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   DualPipe() : DualPipe((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<DualPipe> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         DualPipe * inst = new DualPipe(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      DualPipe * inst = (DualPipe *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(DualPipe & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline DualPipe(C(Instance) _impl, CPPClass & cl = _cpp_class) : File(_impl, cl) { }

   inline int getExitCode(); // DualPipe_getExitCode
   inline C(bool) getLinePeek(/*1Ab*/char * s, /*1Ab*/int max, /*1Ab*/int * charsRead); // DualPipe_getLinePeek
   inline int getProcessID(); // DualPipe_getProcessID
   inline C(bool) peek(); // DualPipe_peek
   inline void terminate(); // DualPipe_terminate
   inline void wait(); // DualPipe_wait

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_ECONGlobalSettings(c) \
      ECONGlobalSettings::class_registration(_cpp_class); \
      REG_GlobalSettingsDriver_load(load, c); \
      REG_GlobalSettingsDriver_save(save, c);

#define ECONGLOBALSETTINGS_VIRTUAL_METHODS_PROTO(c) \

#define ECONGLOBALSETTINGS_VIRTUAL_METHODS(c) \

class ECONGlobalSettings : public GlobalSettingsDriver
{
public:
   inline ECONGlobalSettings(ECONGlobalSettings && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ECONGlobalSettings & operator= (ECONGlobalSettings && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ECONGlobalSettings() : ECONGlobalSettings((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ECONGlobalSettings> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ECONGlobalSettings * inst = new ECONGlobalSettings(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ECONGlobalSettings * inst = (ECONGlobalSettings *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ECONGlobalSettings & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ECONGlobalSettings(C(Instance) _impl, CPPClass & cl = _cpp_class) : GlobalSettingsDriver(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};


#define REG_ECONParser(c) \
      ECONParser::class_registration(_cpp_class);

#define ECONPARSER_VIRTUAL_METHODS_PROTO(c) \

#define ECONPARSER_VIRTUAL_METHODS(c) \

class ECONParser : public JSONParser
{
public:
   inline ECONParser(ECONParser && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline ECONParser & operator= (ECONParser && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   ECONParser() : ECONParser((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<ECONParser> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         ECONParser * inst = new ECONParser(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      ECONParser * inst = (ECONParser *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(ECONParser & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline ECONParser(C(Instance) _impl, CPPClass & cl = _cpp_class) : JSONParser(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

enum class ErrorLevel : int
{
   veryFatal = ErrorLevel_veryFatal,
   fatal = ErrorLevel_fatal,
   major = ErrorLevel_major,
   minor = ErrorLevel_minor
};

class Feet : public Distance
{
public:
   constexpr Feet() : Distance() { }
   constexpr Feet(const Distance value) : Distance(value) { }
   constexpr Feet(double value) : Distance(FEET(value)) { }
   constexpr operator double() const { return Distance_in_Feet(impl); }
   constexpr Feet & operator =(double value) { impl = FEET(value); return *this; }
   bool operator ==(const Feet & value) const { return impl == value.impl; }
   bool operator !=(const Feet & value) const { return impl != value.impl; }
   bool operator <(const Feet & value) const { return impl < value.impl; }
   bool operator >(const Feet & value) const { return impl > value.impl; }
   bool operator <=(const Feet & value) const { return impl <= value.impl; }
   bool operator >=(const Feet & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Feet(value).impl; }
   bool operator !=(double value) const { return impl != Feet(value).impl; }
   bool operator <(double value) const { return impl < Feet(value).impl; }
   bool operator >(double value) const { return impl > Feet(value).impl; }
   bool operator <=(double value) const { return impl <= Feet(value).impl; }
   bool operator >=(double value) const { return impl >= Feet(value).impl; }
   bool operator ==(int value) const { return impl == Feet(value).impl; }
   bool operator !=(int value) const { return impl != Feet(value).impl; }
   bool operator <(int value) const { return impl < Feet(value).impl; }
   bool operator >(int value) const { return impl > Feet(value).impl; }
   bool operator <=(int value) const { return impl <= Feet(value).impl; }
   bool operator >=(int value) const { return impl >= Feet(value).impl; }
   inline constexpr operator Meters() const;
   inline constexpr Feet(const Meters & m);
   inline constexpr Feet & operator =(const Meters & m);
};

class FileChange
{
public:
   C(FileChange) impl;
   constexpr FileChange() : impl(0) { }
   constexpr FileChange(C(FileChange) impl) : impl(impl) { }
   FileChange(bool created, bool renamed, bool modified, bool deleted, bool attribs);
   operator C(FileChange)() { return impl; }
   FileChange & operator =(C(FileChange) impl) { impl = impl; return *this; }
   bool operator ==(const FileChange & value) const { return impl == value.impl; }
   bool operator !=(const FileChange & value) const { return impl != value.impl; }

   struct created_Prop
   {
      constexpr created_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileChange::created_Prop & operator= (FileChange::created_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } created;
   struct renamed_Prop
   {
      constexpr renamed_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileChange::renamed_Prop & operator= (FileChange::renamed_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } renamed;
   struct modified_Prop
   {
      constexpr modified_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileChange::modified_Prop & operator= (FileChange::modified_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } modified;
   struct deleted_Prop
   {
      constexpr deleted_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileChange::deleted_Prop & operator= (FileChange::deleted_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } deleted;
   struct attribs_Prop
   {
      constexpr attribs_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline FileChange::attribs_Prop & operator= (FileChange::attribs_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } attribs;
};

struct FileListing : public TStruct<FileListing>
{
public:
   C(FileListing) impl;
   constexpr FileListing() : impl({}) { }
   constexpr FileListing(const C(FileListing) impl) : impl(impl) { }

   inline C(bool) find(); // FileListing_find
   inline void stop(); // FileListing_stop

   inline FileListing(const char * directory, const char * extensions);

   struct name_Prop
   {
      constexpr name_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/const char * () const;
   } name;
   struct path_Prop
   {
      constexpr path_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/const char * () const;
   } path;
   struct stats_Prop
   {
      constexpr stats_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/FileStats () const;
   } stats;

   struct directory_Prop
   {
      constexpr directory_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileListing::directory_Prop & operator= (FileListing::directory_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } directory;
   struct extensions_Prop
   {
      constexpr extensions_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileListing::extensions_Prop & operator= (FileListing::extensions_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } extensions;
};

enum class FileLock : int
{
   unlocked = FileLock_unlocked,
   shared = FileLock_shared,
   exclusive = FileLock_exclusive
};

#define REG_FileMonitor_onDirNotify(m, c)  REGVMETHOD(FileMonitor, onDirNotify,  c::m, (/*1Ab*/any_object self, /*1Ab*/FileChange action, /*1Ab*/const char * fileName, /*1Ab*/const char * param), c, (/*4Im*/self, /*4Hm*/(FileChange)action, /*4Im*/fileName, /*4Im*/param))
#define REG_FileMonitor_onFileNotify(m, c) REGVMETHOD(FileMonitor, onFileNotify, c::m, (/*1Ab*/any_object self, /*1Ab*/FileChange action, /*1Ab*/const char * param),                               c, (/*4Im*/self, /*4Hm*/(FileChange)action, /*4Im*/param))

#define REG_FileMonitor(c) \
      FileMonitor::class_registration(_cpp_class); \
      REG_FileMonitor_onDirNotify(onDirNotify, c); \
      REG_FileMonitor_onFileNotify(onFileNotify, c);

#define FILEMONITOR_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(onDirNotify, onDirNotify, c, FileMonitor, \
      bool, any_object _ARG, /*6Fk*/any_object o_ _ARG, /*6Fj*/FileChange action _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/const char * param); \
   VIRTUAL_METHOD_PROTO(onFileNotify, onFileNotify, c, FileMonitor, \
      bool, any_object _ARG, /*6Fk*/any_object o_ _ARG, /*6Fj*/FileChange action _ARG /*6Fj*/const char * param);

#define FILEMONITOR_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(onDirNotify, onDirNotify, c, FileMonitor, \
   bool, any_object _ARG, /*6Fk*/any_object o_ _ARG, /*6Fj*/FileChange action _ARG /*6Fj*/const char * fileName _ARG /*6Fj*/const char * param, \
   return (bool)FileMonitor_onDirNotify(self ? self->impl : (C(FileMonitor))null, o_, /*7Al*/(C(FileChange))action, /*7Al*/fileName, /*7Al*/param);); \
VIRTUAL_METHOD(onFileNotify, onFileNotify, c, FileMonitor, \
   bool, any_object _ARG, /*6Fk*/any_object o_ _ARG, /*6Fj*/FileChange action _ARG /*6Fj*/const char * param, \
   return (bool)FileMonitor_onFileNotify(self ? self->impl : (C(FileMonitor))null, o_, /*7Al*/(C(FileChange))action, /*7Al*/param););

class FileMonitor : public Instance
{
public:
   inline FileMonitor(FileMonitor && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline FileMonitor & operator= (FileMonitor && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   FileMonitor() : FileMonitor((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { Timer_set_userData(this->impl, this); }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<FileMonitor> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         FileMonitor * inst = new FileMonitor(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      FileMonitor * inst = (FileMonitor *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(FileMonitor & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline FileMonitor(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void startMonitoring(); // FileMonitor_startMonitoring
   inline void stopMonitoring(); // FileMonitor_stopMonitoring

   struct FileMonitor_onDirNotify_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(any_object , /*6Fj*/FileChange action, /*6Fj*/const char * fileName, /*6Fj*/const char * param);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/any_object o_ , /*6Fj*/FileChange action, /*6Fj*/const char * fileName, /*6Fj*/const char * param);
   } onDirNotify;
   // inline static void register_onDirNotify(CPPClass & cl, FileMonitor::FileMonitor_onDirNotify_Functor::FunctionType func)

   struct FileMonitor_onFileNotify_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(any_object , /*6Fj*/FileChange action, /*6Fj*/const char * param);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Fk*/any_object o_ , /*6Fj*/FileChange action, /*6Fj*/const char * param);
   } onFileNotify;
   // inline static void register_onFileNotify(CPPClass & cl, FileMonitor::FileMonitor_onFileNotify_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   inline FileMonitor(void * userData, FileChange fileChange, const char * fileName, const char * directoryName);

private:
   void * _userData;
public:

   struct userData_Prop
   {
      constexpr userData_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/void * operator= (/*0G*/void * v);
   } userData;
   struct fileChange_Prop
   {
      constexpr fileChange_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/FileChange operator= (/*0G*/FileChange v);
   } fileChange;
   struct fileName_Prop
   {
      constexpr fileName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileMonitor::fileName_Prop & operator= (FileMonitor::fileName_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } fileName;
   struct directoryName_Prop
   {
      constexpr directoryName_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/const char * operator= (/*0H*/const char * v);
      /*regSet*/inline FileMonitor::directoryName_Prop & operator= (FileMonitor::directoryName_Prop & prop);
      /*regGet*/inline operator /*0I*/const char * () const;
   } directoryName;
};

enum class FileOpenMode : int
{
   read = FileOpenMode_read,
   write = FileOpenMode_write,
   append = FileOpenMode_append,
   readWrite = FileOpenMode_readWrite,
   writeRead = FileOpenMode_writeRead,
   appendRead = FileOpenMode_appendRead
};

enum class FileSeekMode : int
{
   start = FileSeekMode_start,
   current = FileSeekMode_current,
   end = FileSeekMode_end
};

class FileSize
{
public:
   C(FileSize) impl;
   constexpr FileSize() : impl(0) { }
   constexpr FileSize(C(FileSize) value) : impl(value) { }
   operator C(FileSize)() const { return impl; }
   constexpr FileSize(const FileSize & value) : impl(value.impl) { }
   FileSize & operator =(uint value) { impl = value; return *this; }
   FileSize & operator +=(FileSize value) { impl += value.impl; return *this; }
   FileSize & operator -=(FileSize value) { impl -= value.impl; return *this; }
   FileSize operator +(const FileSize & b) const { return FileSize(impl + b.impl); }
   FileSize operator -(const FileSize & b) const { return FileSize(impl - b.impl); }
   bool operator ==(const FileSize & value) const { return impl == value.impl; }
   bool operator !=(const FileSize & value) const { return impl != value.impl; }
   bool operator <(const FileSize & value) const { return impl < value.impl; }
   bool operator >(const FileSize & value) const { return impl > value.impl; }
   bool operator <=(const FileSize & value) const { return impl <= value.impl; }
   bool operator >=(const FileSize & value) const { return impl >= value.impl; }
   bool operator ==(uint value) const { return impl == FileSize(value).impl; }
   bool operator !=(uint value) const { return impl != FileSize(value).impl; }
   bool operator <(uint value) const { return impl < FileSize(value).impl; }
   bool operator >(uint value) const { return impl > FileSize(value).impl; }
   bool operator <=(uint value) const { return impl <= FileSize(value).impl; }
   bool operator >=(uint value) const { return impl >= FileSize(value).impl; }
};

class FileSize64
{
public:
   C(FileSize64) impl;
   constexpr FileSize64() : impl(0) { }
   constexpr FileSize64(C(FileSize64) value) : impl(value) { }
   operator C(FileSize64)() const { return impl; }
   constexpr FileSize64(const FileSize64 & value) : impl(value.impl) { }
   FileSize64 & operator =(uint64 value) { impl = value; return *this; }
   FileSize64 & operator +=(FileSize64 value) { impl += value.impl; return *this; }
   FileSize64 & operator -=(FileSize64 value) { impl -= value.impl; return *this; }
   FileSize64 operator +(const FileSize64 & b) const { return FileSize64(impl + b.impl); }
   FileSize64 operator -(const FileSize64 & b) const { return FileSize64(impl - b.impl); }
   bool operator ==(const FileSize64 & value) const { return impl == value.impl; }
   bool operator !=(const FileSize64 & value) const { return impl != value.impl; }
   bool operator <(const FileSize64 & value) const { return impl < value.impl; }
   bool operator >(const FileSize64 & value) const { return impl > value.impl; }
   bool operator <=(const FileSize64 & value) const { return impl <= value.impl; }
   bool operator >=(const FileSize64 & value) const { return impl >= value.impl; }
   bool operator ==(uint64 value) const { return impl == FileSize64(value).impl; }
   bool operator !=(uint64 value) const { return impl != FileSize64(value).impl; }
   bool operator <(uint64 value) const { return impl < FileSize64(value).impl; }
   bool operator >(uint64 value) const { return impl > FileSize64(value).impl; }
   bool operator <=(uint64 value) const { return impl <= FileSize64(value).impl; }
   bool operator >=(uint64 value) const { return impl >= FileSize64(value).impl; }
};

struct FileStats : public TStruct<FileStats>
{
public:
   C(FileStats) impl;
   constexpr FileStats() : impl({}) { }
   constexpr FileStats(const C(FileStats) impl) : impl(impl) { }

   inline FileStats(FileAttribs attribs, uint64 size, SecSince1970 accessed, SecSince1970 modified, SecSince1970 created);

   struct attribs_Prop
   {
      constexpr attribs_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FileAttribs operator= (/*0H*/FileAttribs v);
      /*regSet*/inline FileStats::attribs_Prop & operator= (FileStats::attribs_Prop & prop);
      /*regGet*/inline operator /*0I*/FileAttribs () const;
   } attribs;
   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uint64 operator= (/*0H*/uint64 v);
      /*regSet*/inline FileStats::size_Prop & operator= (FileStats::size_Prop & prop);
      /*regGet*/inline operator /*0I*/uint64 () const;
   } size;
   struct accessed_Prop
   {
      constexpr accessed_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SecSince1970 operator= (/*0H*/SecSince1970 v);
      /*regSet*/inline FileStats::accessed_Prop & operator= (FileStats::accessed_Prop & prop);
      /*regGet*/inline operator /*0I*/SecSince1970 () const;
      /*regGet*/inline operator /*0J*/C(SecSince1970) () const;
   } accessed;
   struct modified_Prop
   {
      constexpr modified_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SecSince1970 operator= (/*0H*/SecSince1970 v);
      /*regSet*/inline FileStats::modified_Prop & operator= (FileStats::modified_Prop & prop);
      /*regGet*/inline operator /*0I*/SecSince1970 () const;
      /*regGet*/inline operator /*0J*/C(SecSince1970) () const;
   } modified;
   struct created_Prop
   {
      constexpr created_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/SecSince1970 operator= (/*0H*/SecSince1970 v);
      /*regSet*/inline FileStats::created_Prop & operator= (FileStats::created_Prop & prop);
      /*regGet*/inline operator /*0I*/SecSince1970 () const;
      /*regGet*/inline operator /*0J*/C(SecSince1970) () const;
   } created;
};


#define REG_GlobalAppSettings(c) \
      GlobalAppSettings::class_registration(_cpp_class); \
      REG_GlobalSettings_load(load, c); \
      REG_GlobalSettings_onAskReloadSettings(onAskReloadSettings, c); \
      REG_GlobalSettings_save(save, c);

#define GLOBALAPPSETTINGS_VIRTUAL_METHODS_PROTO(c) \

#define GLOBALAPPSETTINGS_VIRTUAL_METHODS(c) \

class GlobalAppSettings : public GlobalSettings
{
public:
   inline GlobalAppSettings(GlobalAppSettings && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GlobalAppSettings & operator= (GlobalAppSettings && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   GlobalAppSettings() : GlobalAppSettings((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GlobalAppSettings> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GlobalAppSettings * inst = new GlobalAppSettings(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GlobalAppSettings * inst = (GlobalAppSettings *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GlobalAppSettings & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GlobalAppSettings(C(Instance) _impl, CPPClass & cl = _cpp_class) : GlobalSettings(_impl, cl) { }

   inline C(bool) getGlobalValue(/*1Ab*/const char * section, /*1Ab*/const char * name, /*1Ab*/GlobalSettingType type, /*1Ab*/void * value); // GlobalAppSettings_getGlobalValue
   inline C(bool) putGlobalValue(/*1Ab*/const char * section, /*1Ab*/const char * name, /*1Ab*/GlobalSettingType type, /*1Ab*/const void * value); // GlobalAppSettings_putGlobalValue

   static void class_registration(CPPClass & _cpp_class);
};

enum class GlobalSettingType : int
{
   integer = GlobalSettingType_integer,
   singleString = GlobalSettingType_singleString,
   stringList = GlobalSettingType_stringList
};


#define REG_GlobalSettingsData(c) \
      GlobalSettingsData::class_registration(_cpp_class);

#define GLOBALSETTINGSDATA_VIRTUAL_METHODS_PROTO(c) \

#define GLOBALSETTINGSDATA_VIRTUAL_METHODS(c) \

class GlobalSettingsData : public Instance
{
public:
   inline GlobalSettingsData(GlobalSettingsData && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline GlobalSettingsData & operator= (GlobalSettingsData && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   GlobalSettingsData() : GlobalSettingsData((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<GlobalSettingsData> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         GlobalSettingsData * inst = new GlobalSettingsData(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      GlobalSettingsData * inst = (GlobalSettingsData *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(GlobalSettingsData & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline GlobalSettingsData(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

enum class GuiErrorCode : uint
{
   driverNotSupported = GuiErrorCode_driverNotSupported,
   windowCreationFailed = GuiErrorCode_windowCreationFailed,
   graphicsLoadingFailed = GuiErrorCode_graphicsLoadingFailed,
   modeSwitchFailed = GuiErrorCode_modeSwitchFailed
};

enum class JSONFirstLetterCapitalization : int
{
   keepCase = JSONFirstLetterCapitalization_keepCase,
   upperCase = JSONFirstLetterCapitalization_upperCase,
   lowerCase = JSONFirstLetterCapitalization_lowerCase
};


#define REG_JSONGlobalSettings(c) \
      JSONGlobalSettings::class_registration(_cpp_class); \
      REG_GlobalSettingsDriver_load(load, c); \
      REG_GlobalSettingsDriver_save(save, c);

#define JSONGLOBALSETTINGS_VIRTUAL_METHODS_PROTO(c) \

#define JSONGLOBALSETTINGS_VIRTUAL_METHODS(c) \

class JSONGlobalSettings : public GlobalSettingsDriver
{
public:
   inline JSONGlobalSettings(JSONGlobalSettings && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline JSONGlobalSettings & operator= (JSONGlobalSettings && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   JSONGlobalSettings() : JSONGlobalSettings((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<JSONGlobalSettings> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         JSONGlobalSettings * inst = new JSONGlobalSettings(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      JSONGlobalSettings * inst = (JSONGlobalSettings *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(JSONGlobalSettings & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline JSONGlobalSettings(C(Instance) _impl, CPPClass & cl = _cpp_class) : GlobalSettingsDriver(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

enum class JSONResult : int
{
   syntaxError = JSONResult_syntaxError,
   success = JSONResult_success,
   typeMismatch = JSONResult_typeMismatch,
   noItem = JSONResult_noItem
};

class JSONTypeOptions
{
public:
   C(JSONTypeOptions) impl;
   constexpr JSONTypeOptions() : impl(0) { }
   constexpr JSONTypeOptions(C(JSONTypeOptions) impl) : impl(impl) { }
   operator C(JSONTypeOptions)() { return impl; }
   JSONTypeOptions & operator =(C(JSONTypeOptions) impl) { impl = impl; return *this; }
   bool operator ==(const JSONTypeOptions & value) const { return impl == value.impl; }
   bool operator !=(const JSONTypeOptions & value) const { return impl != value.impl; }

   struct numbersUseOGDFS_Prop
   {
      constexpr numbersUseOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::numbersUseOGDFS_Prop & operator= (JSONTypeOptions::numbersUseOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } numbersUseOGDFS;
   struct boolUseOGDFS_Prop
   {
      constexpr boolUseOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::boolUseOGDFS_Prop & operator= (JSONTypeOptions::boolUseOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } boolUseOGDFS;
   struct nullUseOGDFS_Prop
   {
      constexpr nullUseOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::nullUseOGDFS_Prop & operator= (JSONTypeOptions::nullUseOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } nullUseOGDFS;
   struct stringUseOGDFS_Prop
   {
      constexpr stringUseOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::stringUseOGDFS_Prop & operator= (JSONTypeOptions::stringUseOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } stringUseOGDFS;
   struct arrayUseOGDFS_Prop
   {
      constexpr arrayUseOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::arrayUseOGDFS_Prop & operator= (JSONTypeOptions::arrayUseOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } arrayUseOGDFS;
   struct objectUseOGDFS_Prop
   {
      constexpr objectUseOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::objectUseOGDFS_Prop & operator= (JSONTypeOptions::objectUseOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } objectUseOGDFS;
   struct stripQuotesForOGDFS_Prop
   {
      constexpr stripQuotesForOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::stripQuotesForOGDFS_Prop & operator= (JSONTypeOptions::stripQuotesForOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } stripQuotesForOGDFS;
   struct strictOGDFS_Prop
   {
      constexpr strictOGDFS_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline JSONTypeOptions::strictOGDFS_Prop & operator= (JSONTypeOptions::strictOGDFS_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } strictOGDFS;
};

enum class LoggingMode : int
{
   noLogging = LoggingMode_noLogging,
   stdOut = LoggingMode_stdOut,
   stdErr = LoggingMode_stdErr,
   debug = LoggingMode_debug,
   logFile = LoggingMode_logFile,
   msgBox = LoggingMode_msgBox,
   buffer = LoggingMode_buffer
};

class Meters : public Distance
{
public:
   constexpr Meters() : Distance() { }
   constexpr Meters(const Distance value) : Distance(value) { }
   constexpr Meters(double value) : Distance(METERS(value)) { }
   constexpr operator double() const { return Distance_in_Meters(impl); }
   constexpr Meters & operator =(double value) { impl = METERS(value); return *this; }
   bool operator ==(const Meters & value) const { return impl == value.impl; }
   bool operator !=(const Meters & value) const { return impl != value.impl; }
   bool operator <(const Meters & value) const { return impl < value.impl; }
   bool operator >(const Meters & value) const { return impl > value.impl; }
   bool operator <=(const Meters & value) const { return impl <= value.impl; }
   bool operator >=(const Meters & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Meters(value).impl; }
   bool operator !=(double value) const { return impl != Meters(value).impl; }
   bool operator <(double value) const { return impl < Meters(value).impl; }
   bool operator >(double value) const { return impl > Meters(value).impl; }
   bool operator <=(double value) const { return impl <= Meters(value).impl; }
   bool operator >=(double value) const { return impl >= Meters(value).impl; }
   bool operator ==(int value) const { return impl == Meters(value).impl; }
   bool operator !=(int value) const { return impl != Meters(value).impl; }
   bool operator <(int value) const { return impl < Meters(value).impl; }
   bool operator >(int value) const { return impl > Meters(value).impl; }
   bool operator <=(int value) const { return impl <= Meters(value).impl; }
   bool operator >=(int value) const { return impl >= Meters(value).impl; }
   inline Meters operator= (Centimeters value);
   inline Meters(Centimeters value);
   inline operator Centimeters() const;
   inline Meters operator= (Feet value);
   inline Meters(Feet value);
   inline operator Feet() const;
};

class MinMaxValue
{
public:
   C(MinMaxValue) impl;
   constexpr MinMaxValue() : impl(0) { }
   constexpr MinMaxValue(C(MinMaxValue) value) : impl(value) { }
   operator C(MinMaxValue)() const { return impl; }
   constexpr MinMaxValue(const MinMaxValue & value) : impl(value.impl) { }
   MinMaxValue & operator =(int value) { impl = value; return *this; }
   MinMaxValue & operator +=(MinMaxValue value) { impl += value.impl; return *this; }
   MinMaxValue & operator -=(MinMaxValue value) { impl -= value.impl; return *this; }
   MinMaxValue operator +(const MinMaxValue & b) const { return MinMaxValue(impl + b.impl); }
   MinMaxValue operator -(const MinMaxValue & b) const { return MinMaxValue(impl - b.impl); }
   bool operator ==(const MinMaxValue & value) const { return impl == value.impl; }
   bool operator !=(const MinMaxValue & value) const { return impl != value.impl; }
   bool operator <(const MinMaxValue & value) const { return impl < value.impl; }
   bool operator >(const MinMaxValue & value) const { return impl > value.impl; }
   bool operator <=(const MinMaxValue & value) const { return impl <= value.impl; }
   bool operator >=(const MinMaxValue & value) const { return impl >= value.impl; }
   bool operator ==(int value) const { return impl == MinMaxValue(value).impl; }
   bool operator !=(int value) const { return impl != MinMaxValue(value).impl; }
   bool operator <(int value) const { return impl < MinMaxValue(value).impl; }
   bool operator >(int value) const { return impl > MinMaxValue(value).impl; }
   bool operator <=(int value) const { return impl <= MinMaxValue(value).impl; }
   bool operator >=(int value) const { return impl >= MinMaxValue(value).impl; }
};

enum class Month : int
{
   january = Month_january,
   february = Month_february,
   march = Month_march,
   april = Month_april,
   may = Month_may,
   june = Month_june,
   july = Month_july,
   august = Month_august,
   september = Month_september,
   october = Month_october,
   november = Month_november,
   december = Month_december
};

class MoveFileOptions
{
public:
   C(MoveFileOptions) impl;
   constexpr MoveFileOptions() : impl(0) { }
   constexpr MoveFileOptions(C(MoveFileOptions) impl) : impl(impl) { }
   MoveFileOptions(bool overwrite, bool sync);
   operator C(MoveFileOptions)() { return impl; }
   MoveFileOptions & operator =(C(MoveFileOptions) impl) { impl = impl; return *this; }
   bool operator ==(const MoveFileOptions & value) const { return impl == value.impl; }
   bool operator !=(const MoveFileOptions & value) const { return impl != value.impl; }

   struct overwrite_Prop
   {
      constexpr overwrite_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MoveFileOptions::overwrite_Prop & operator= (MoveFileOptions::overwrite_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } overwrite;
   struct sync_Prop
   {
      constexpr sync_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline MoveFileOptions::sync_Prop & operator= (MoveFileOptions::sync_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } sync;
};


#define REG_OptionsMap(c) \
      OptionsMap::class_registration(_cpp_class);

#define OPTIONSMAP_VIRTUAL_METHODS_PROTO(c) \

#define OPTIONSMAP_VIRTUAL_METHODS(c) \

class OptionsMap : public TMap<MapNode, C(String)>
{
public:
   inline OptionsMap(OptionsMap && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline OptionsMap & operator= (OptionsMap && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   OptionsMap() : OptionsMap((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<OptionsMap> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         OptionsMap * inst = new OptionsMap(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      OptionsMap * inst = (OptionsMap *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(OptionsMap & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline OptionsMap(C(Instance) _impl, CPPClass & cl = _cpp_class) : TMap<MapNode, C(String)>(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);
};

class PipeOpenMode
{
public:
   C(PipeOpenMode) impl;
   constexpr PipeOpenMode() : impl(0) { }
   constexpr PipeOpenMode(C(PipeOpenMode) impl) : impl(impl) { }
   PipeOpenMode(bool output, bool error, bool input, bool showWindow);
   operator C(PipeOpenMode)() { return impl; }
   PipeOpenMode & operator =(C(PipeOpenMode) impl) { impl = impl; return *this; }
   bool operator ==(const PipeOpenMode & value) const { return impl == value.impl; }
   bool operator !=(const PipeOpenMode & value) const { return impl != value.impl; }

   struct output_Prop
   {
      constexpr output_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PipeOpenMode::output_Prop & operator= (PipeOpenMode::output_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } output;
   struct error_Prop
   {
      constexpr error_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PipeOpenMode::error_Prop & operator= (PipeOpenMode::error_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } error;
   struct input_Prop
   {
      constexpr input_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PipeOpenMode::input_Prop & operator= (PipeOpenMode::input_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } input;
   struct showWindow_Prop
   {
      constexpr showWindow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline PipeOpenMode::showWindow_Prop & operator= (PipeOpenMode::showWindow_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } showWindow;
};

struct Point : public TStruct<Point>
{
public:
   C(Point) impl;
   constexpr Point() : impl({}) { }
   constexpr Point(const C(Point) impl) : impl(impl) { }

   inline Point(int x, int y);

   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Point::x_Prop & operator= (Point::x_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline Point::y_Prop & operator= (Point::y_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } y;
};

struct Pointd : public TStruct<Pointd>
{
public:
   C(Pointd) impl;
   constexpr Pointd() : impl({}) { }
   constexpr Pointd(const C(Pointd) impl) : impl(impl) { }

   inline Pointd(double x, double y);

   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Pointd::x_Prop & operator= (Pointd::x_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/double operator= (/*0H*/double v);
      /*regSet*/inline Pointd::y_Prop & operator= (Pointd::y_Prop & prop);
      /*regGet*/inline operator /*0I*/double () const;
   } y;
};

struct Pointf : public TStruct<Pointf>
{
public:
   C(Pointf) impl;
   constexpr Pointf() : impl({}) { }
   constexpr Pointf(const C(Pointf) impl) : impl(impl) { }

   inline Pointf(float x, float y);

   struct x_Prop
   {
      constexpr x_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Pointf::x_Prop & operator= (Pointf::x_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } x;
   struct y_Prop
   {
      constexpr y_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/float operator= (/*0H*/float v);
      /*regSet*/inline Pointf::y_Prop & operator= (Pointf::y_Prop & prop);
      /*regGet*/inline operator /*0I*/float () const;
   } y;
};

enum class PredefinedCharCategories : uint
{
   none = PredefinedCharCategories_none,
   marks = PredefinedCharCategories_marks,
   numbers = PredefinedCharCategories_numbers,
   separators = PredefinedCharCategories_separators,
   others = PredefinedCharCategories_others,
   letters = PredefinedCharCategories_letters,
   punctuation = PredefinedCharCategories_punctuation,
   symbols = PredefinedCharCategories_symbols,
   connector = PredefinedCharCategories_connector
};

class Radians : public Angle
{
public:
   constexpr Radians() : Angle() { }
   constexpr Radians(const Angle value) : Angle(value) { }
   constexpr Radians(double value) : Angle(RADIANS(value)) { }
   constexpr operator double() const { return Angle_in_Radians(impl); }
   constexpr Radians & operator =(double value) { impl = RADIANS(value); return *this; }
   bool operator ==(const Radians & value) const { return impl == value.impl; }
   bool operator !=(const Radians & value) const { return impl != value.impl; }
   bool operator <(const Radians & value) const { return impl < value.impl; }
   bool operator >(const Radians & value) const { return impl > value.impl; }
   bool operator <=(const Radians & value) const { return impl <= value.impl; }
   bool operator >=(const Radians & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Radians(value).impl; }
   bool operator !=(double value) const { return impl != Radians(value).impl; }
   bool operator <(double value) const { return impl < Radians(value).impl; }
   bool operator >(double value) const { return impl > Radians(value).impl; }
   bool operator <=(double value) const { return impl <= Radians(value).impl; }
   bool operator >=(double value) const { return impl >= Radians(value).impl; }
   bool operator ==(int value) const { return impl == Radians(value).impl; }
   bool operator !=(int value) const { return impl != Radians(value).impl; }
   bool operator <(int value) const { return impl < Radians(value).impl; }
   bool operator >(int value) const { return impl > Radians(value).impl; }
   bool operator <=(int value) const { return impl <= Radians(value).impl; }
   bool operator >=(int value) const { return impl >= Radians(value).impl; }
   inline Radians operator= (Degrees value);
   inline Radians(Degrees value);
   inline operator Degrees() const;
};


#define REG_RepButton(c) \
      RepButton::class_registration(_cpp_class); \
      REG_Window_getDecorationsSize(getDecorationsSize, c); \
      REG_Window_isInside(isInside, c); \
      REG_Window_isMouseMoving(isMouseMoving, c); \
      REG_Window_isMouseResizing(isMouseResizing, c); \
      REG_Window_isOpaque(isOpaque, c); \
      REG_Window_notifyActivate(notifyActivate, c); \
      REG_Window_notifyDestroyed(notifyDestroyed, c); \
      REG_Window_notifySaved(notifySaved, c); \
      REG_Window_onActivate(onActivate, c); \
      REG_Window_onActivateClient(onActivateClient, c); \
      REG_Window_onApplyGraphics(onApplyGraphics, c); \
      REG_Window_onChildAddedOrRemoved(onChildAddedOrRemoved, c); \
      REG_Window_onChildResized(onChildResized, c); \
      REG_Window_onChildVisibilityToggled(onChildVisibilityToggled, c); \
      REG_Window_onClose(onClose, c); \
      REG_Window_onCreate(onCreate, c); \
      REG_Window_onDestroy(onDestroy, c); \
      REG_Window_onDestroyed(onDestroyed, c); \
      REG_Window_onDrawOverChildren(onDrawOverChildren, c); \
      REG_Window_onFileModified(onFileModified, c); \
      REG_Window_onHScroll(onHScroll, c); \
      REG_Window_onKeyDown(onKeyDown, c); \
      REG_Window_onKeyHit(onKeyHit, c); \
      REG_Window_onKeyUp(onKeyUp, c); \
      REG_Window_onLeftButtonDown(onLeftButtonDown, c); \
      REG_Window_onLeftButtonUp(onLeftButtonUp, c); \
      REG_Window_onLeftDoubleClick(onLeftDoubleClick, c); \
      REG_Window_onLoadGraphics(onLoadGraphics, c); \
      REG_Window_onMiddleButtonDown(onMiddleButtonDown, c); \
      REG_Window_onMiddleButtonUp(onMiddleButtonUp, c); \
      REG_Window_onMiddleDoubleClick(onMiddleDoubleClick, c); \
      REG_Window_onMouseCaptureLost(onMouseCaptureLost, c); \
      REG_Window_onMouseLeave(onMouseLeave, c); \
      REG_Window_onMouseMove(onMouseMove, c); \
      REG_Window_onMouseOver(onMouseOver, c); \
      REG_Window_onMoving(onMoving, c); \
      REG_Window_onMultiTouch(onMultiTouch, c); \
      REG_Window_onPosition(onPosition, c); \
      REG_Window_onPostCreate(onPostCreate, c); \
      REG_Window_onRedraw(onRedraw, c); \
      REG_Window_onResize(onResize, c); \
      REG_Window_onResizing(onResizing, c); \
      REG_Window_onRightButtonDown(onRightButtonDown, c); \
      REG_Window_onRightButtonUp(onRightButtonUp, c); \
      REG_Window_onRightDoubleClick(onRightDoubleClick, c); \
      REG_Window_onSaveFile(onSaveFile, c); \
      REG_Window_onStateChange(onStateChange, c); \
      REG_Window_onSysKeyDown(onSysKeyDown, c); \
      REG_Window_onSysKeyHit(onSysKeyHit, c); \
      REG_Window_onSysKeyUp(onSysKeyUp, c); \
      REG_Window_onUnloadGraphics(onUnloadGraphics, c); \
      REG_Window_onVScroll(onVScroll, c); \
      REG_Window_preShowDecorations(preShowDecorations, c); \
      REG_Window_setBox(setBox, c); \
      REG_Window_setWindowArea(setWindowArea, c); \
      REG_Window_setWindowMinimum(setWindowMinimum, c); \
      REG_Window_showDecorations(showDecorations, c); \
      REG_Window_updateNonClient(updateNonClient, c); \
      REG_Button_notifyClicked(notifyClicked, c); \
      REG_Button_notifyDoubleClick(notifyDoubleClick, c); \
      REG_Button_notifyMouseLeave(notifyMouseLeave, c); \
      REG_Button_notifyMouseMove(notifyMouseMove, c); \
      REG_Button_notifyMouseOver(notifyMouseOver, c); \
      REG_Button_notifyPushed(notifyPushed, c); \
      REG_Button_notifyReleased(notifyReleased, c);

#define REPBUTTON_VIRTUAL_METHODS_PROTO(c) \

#define REPBUTTON_VIRTUAL_METHODS(c) \

class RepButton : public Button
{
public:
   inline RepButton(RepButton && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline RepButton & operator= (RepButton && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   RepButton() : RepButton((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<RepButton> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         RepButton * inst = new RepButton(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      RepButton * inst = (RepButton *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(RepButton & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline RepButton(C(Instance) _impl, CPPClass & cl = _cpp_class) : Button(_impl, cl) { }

   static void class_registration(CPPClass & _cpp_class);

   inline RepButton(bool pressing, Seconds delay, Seconds delay0);

   struct delay_Prop
   {
      constexpr delay_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Seconds operator= (/*0G*/Seconds v);
   } delay;
   struct delay0_Prop
   {
      constexpr delay0_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0G*/Seconds operator= (/*0G*/Seconds v);
   } delay0;

   struct pressing_Prop
   {
      constexpr pressing_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline RepButton::pressing_Prop & operator= (RepButton::pressing_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } pressing;
   struct timer_Prop
   {
      constexpr timer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Timer operator= (/*0H*/Timer v);
      /*regSet*/inline RepButton::timer_Prop & operator= (RepButton::timer_Prop & prop);
      /*regGet*/inline operator /*0I*/Timer () const;
   } timer;
   struct timer2_Prop
   {
      constexpr timer2_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/Timer operator= (/*0H*/Timer v);
      /*regSet*/inline RepButton::timer2_Prop & operator= (RepButton::timer2_Prop & prop);
      /*regGet*/inline operator /*0I*/Timer () const;
   } timer2;
};

class Seconds : public Time
{
public:
   constexpr Seconds() : Time() { }
   constexpr Seconds(const Time value) : Time(value) { }
   constexpr Seconds(double value) : Time(SECONDS(value)) { }
   constexpr operator double() const { return Time_in_Seconds(impl); }
   constexpr Seconds & operator =(double value) { impl = SECONDS(value); return *this; }
   bool operator ==(const Seconds & value) const { return impl == value.impl; }
   bool operator !=(const Seconds & value) const { return impl != value.impl; }
   bool operator <(const Seconds & value) const { return impl < value.impl; }
   bool operator >(const Seconds & value) const { return impl > value.impl; }
   bool operator <=(const Seconds & value) const { return impl <= value.impl; }
   bool operator >=(const Seconds & value) const { return impl >= value.impl; }
   bool operator ==(double value) const { return impl == Seconds(value).impl; }
   bool operator !=(double value) const { return impl != Seconds(value).impl; }
   bool operator <(double value) const { return impl < Seconds(value).impl; }
   bool operator >(double value) const { return impl > Seconds(value).impl; }
   bool operator <=(double value) const { return impl <= Seconds(value).impl; }
   bool operator >=(double value) const { return impl >= Seconds(value).impl; }
   bool operator ==(int value) const { return impl == Seconds(value).impl; }
   bool operator !=(int value) const { return impl != Seconds(value).impl; }
   bool operator <(int value) const { return impl < Seconds(value).impl; }
   bool operator >(int value) const { return impl > Seconds(value).impl; }
   bool operator <=(int value) const { return impl <= Seconds(value).impl; }
   bool operator >=(int value) const { return impl >= Seconds(value).impl; }
};

template <class TC, C(Class) ** TCO>
class TSemaphore : public TNHInstance<TC, TCO>
{
public:
   using TNHInstance<TC, TCO>::TNHInstance;

   inline void release(); // Semaphore_release
   inline C(bool) tryWait(); // Semaphore_tryWait
   inline void wait(); // Semaphore_wait

   struct initCount_Prop
   {
      constexpr initCount_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TSemaphore<TC, TCO>::initCount_Prop & operator= (typename TSemaphore<TC, TCO>::initCount_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } initCount;
   struct maxCount_Prop
   {
      constexpr maxCount_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/int operator= (/*0H*/int v);
      /*regSet*/inline typename TSemaphore<TC, TCO>::maxCount_Prop & operator= (typename TSemaphore<TC, TCO>::maxCount_Prop & prop);
      /*regGet*/inline operator /*0I*/int () const;
   } maxCount;
   ~TSemaphore()
   {
      this->impl = null; // How to know not to delete?
   }
};

enum class SetBool : uint
{
   unset = SetBool_unset,
   false_ = SetBool_false,
   true_ = SetBool_true
};

struct Size : public TStruct<Size>
{
public:
   C(Size) impl;
   constexpr Size() : impl({}) { }
   constexpr Size(const C(Size) impl) : impl(impl) { }

   inline Size(MinMaxValue w, MinMaxValue h);

   struct w_Prop
   {
      constexpr w_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/MinMaxValue operator= (/*0H*/MinMaxValue v);
      /*regSet*/inline Size::w_Prop & operator= (Size::w_Prop & prop);
      /*regGet*/inline operator /*0I*/MinMaxValue () const;
      /*regGet*/inline operator /*0J*/C(MinMaxValue) () const;
   } w;
   struct h_Prop
   {
      constexpr h_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/MinMaxValue operator= (/*0H*/MinMaxValue v);
      /*regSet*/inline Size::h_Prop & operator= (Size::h_Prop & prop);
      /*regGet*/inline operator /*0I*/MinMaxValue () const;
      /*regGet*/inline operator /*0J*/C(MinMaxValue) () const;
   } h;
};

enum class SysErrorCode : uint
{
   allocationFailed = SysErrorCode_allocationFailed,
   nameInexistant = SysErrorCode_nameInexistant,
   nameExists = SysErrorCode_nameExists,
   missingLibrary = SysErrorCode_missingLibrary,
   fileNotFound = SysErrorCode_fileNotFound,
   writeFailed = SysErrorCode_writeFailed
};


#define REG_TempFile(c) \
      TempFile::class_registration(_cpp_class); \
      REG_IOChannel_readData(readData, c); \
      REG_IOChannel_writeData(writeData, c); \
      REG_File_close(close, c); \
      REG_File_closeInput(closeInput, c); \
      REG_File_closeOutput(closeOutput, c); \
      REG_File_eof(eof, c); \
      REG_File_getSize(getSize, c); \
      REG_File_getc(getc, c); \
      REG_File_lock(lock, c); \
      REG_File_putc(putc, c); \
      REG_File_puts(puts, c); \
      REG_File_read(read, c); \
      REG_File_seek(seek, c); \
      REG_File_tell(tell, c); \
      REG_File_truncate(truncate, c); \
      REG_File_unlock(unlock, c); \
      REG_File_write(write, c);

#define TEMPFILE_VIRTUAL_METHODS_PROTO(c) \

#define TEMPFILE_VIRTUAL_METHODS(c) \

class TempFile : public File
{
public:
   inline TempFile(TempFile && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline TempFile & operator= (TempFile && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   TempFile() : TempFile((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<TempFile> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         TempFile * inst = new TempFile(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      TempFile * inst = (TempFile *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(TempFile & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline TempFile(C(Instance) _impl, CPPClass & cl = _cpp_class) : File(_impl, cl) { }

   inline byte * stealBuffer(); // TempFile_stealBuffer

   static void class_registration(CPPClass & _cpp_class);

   inline TempFile(FileOpenMode openMode, unsigned char * buffer, uintsize size, uintsize allocated);

   struct openMode_Prop
   {
      constexpr openMode_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/FileOpenMode operator= (/*0H*/FileOpenMode v);
      /*regSet*/inline TempFile::openMode_Prop & operator= (TempFile::openMode_Prop & prop);
      /*regGet*/inline operator /*0I*/FileOpenMode () const;
   } openMode;
   struct buffer_Prop
   {
      constexpr buffer_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/unsigned char * operator= (/*0H*/unsigned char * v);
      /*regSet*/inline TempFile::buffer_Prop & operator= (TempFile::buffer_Prop & prop);
      /*regGet*/inline operator /*0I*/unsigned char * () const;
   } buffer;
   struct size_Prop
   {
      constexpr size_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uintsize operator= (/*0H*/uintsize v);
      /*regSet*/inline TempFile::size_Prop & operator= (TempFile::size_Prop & prop);
      /*regGet*/inline operator /*0I*/uintsize () const;
   } size;
   struct allocated_Prop
   {
      constexpr allocated_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/uintsize operator= (/*0H*/uintsize v);
      /*regSet*/inline TempFile::allocated_Prop & operator= (TempFile::allocated_Prop & prop);
      /*regGet*/inline operator /*0I*/uintsize () const;
   } allocated;
};

#define REG_Thread_main(m, c) REGVMETHOD(Thread, main, c::m, (/*1Ab*/Thread & self), c, ())

#define REG_Thread(c) \
      Thread::class_registration(_cpp_class); \
      REG_Thread_main(main, c);

#define THREAD_VIRTUAL_METHODS_PROTO(c) \
   VIRTUAL_METHOD_PROTO(main, main, c, Thread, \
      uint, c &, , );

#define THREAD_VIRTUAL_METHODS(c) \
VIRTUAL_METHOD(main, main, c, Thread, \
   uint, c &, , , \
   return Thread_main(self ? self->impl : (C(Thread))null););

class Thread : public Instance
{
public:
   inline Thread(Thread && i)
   {
      Instance * self = (Instance *)this;
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
   }
   inline Thread & operator= (Thread && i)
   {
      Instance * self = (Instance *)this;
      if(self->impl)
      {
         C(Instance) impl = self->impl;
         int refCount = impl->_refCount;
         Instance_decRef(impl);
         if(refCount > 1)
         {
            Instance ** inst = (Instance **)&INSTANCEL(impl, impl->_class);
            if(inst && *inst == self)
               *inst = null;
         }
      }
      self->impl = i.impl;
      self->vTbl = i.vTbl;
      self->mustFree = i.mustFree; /* checking: should this be in all these instances? */
      i.impl = null;
      i.vTbl = null;
      return *this;
   }
   Thread() : Thread((C(Instance))Instance_newEx(_cpp_class.impl, false), _cpp_class) { }
   struct Instance_onCompare_Functor
   {
      [[no_unique_address]] int _[0];
      typedef int (* FunctionType)(Instance & , /*6Bj*/Instance & object);
      inline FunctionType operator= (FunctionType func);
      inline int operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & object);
   } onCompare;
   // inline static void register_onCompare(CPPClass & cl, Instance::Instance_onCompare_Functor::FunctionType func)

   struct Instance_onCopy_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Bj*/Instance & newData);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Bj*/Instance & newData);
   } onCopy;
   // inline static void register_onCopy(CPPClass & cl, Instance::Instance_onCopy_Functor::FunctionType func)

   struct Instance_onDisplay_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/Surface & surface, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/void * fieldData, /*6Fj*/Alignment alignment, /*6Fj*/DataDisplayFlags displayFlags);
   } onDisplay;
   // inline static void register_onDisplay(CPPClass & cl, Instance::Instance_onDisplay_Functor::FunctionType func)

   struct Instance_onEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef Instance & (* FunctionType)(Instance & , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
      inline FunctionType operator= (FunctionType func);
      inline Instance & operator()(/*6Bk*/Instance & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/DataBox & obsolete, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * userData);
   } onEdit;
   // inline static void register_onEdit(CPPClass & cl, Instance::Instance_onEdit_Functor::FunctionType func)

   struct Instance_onFree_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance &);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ );
   } onFree;
   // inline static void register_onFree(CPPClass & cl, Instance::Instance_onFree_Functor::FunctionType func)

   struct Instance_onGetDataFromString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/const char * string);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/const char * string);
   } onGetDataFromString;
   // inline static void register_onGetDataFromString(CPPClass & cl, Instance::Instance_onGetDataFromString_Functor::FunctionType func)

   struct Instance_onGetString_Functor
   {
      [[no_unique_address]] int _[0];
      typedef const char * (* FunctionType)(Instance & , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
      inline FunctionType operator= (FunctionType func);
      inline const char * operator()(/*6Bk*/Instance & o_ , /*6Fj*/char * tempString, /*6Fj*/void * reserved, /*6Fj*/ObjectNotationType * onType);
   } onGetString;
   // inline static void register_onGetString(CPPClass & cl, Instance::Instance_onGetString_Functor::FunctionType func)

   struct Instance_onSaveEdit_Functor
   {
      [[no_unique_address]] int _[0];
      typedef bool (* FunctionType)(Instance & , /*6Fj*/Window & window, /*6Fj*/void * object);
      inline FunctionType operator= (FunctionType func);
      inline bool operator()(/*6Bk*/Instance & o_ , /*6Fj*/Window & window, /*6Fj*/void * object);
   } onSaveEdit;
   // inline static void register_onSaveEdit(CPPClass & cl, Instance::Instance_onSaveEdit_Functor::FunctionType func)

   struct Instance_onSerialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onSerialize;
   // inline static void register_onSerialize(CPPClass & cl, Instance::Instance_onSerialize_Functor::FunctionType func)

   struct Instance_onUnserialize_Functor
   {
      [[no_unique_address]] int _[0];
      typedef void (* FunctionType)(Instance & , /*6Fj*/IOChannel & channel);
      inline FunctionType operator= (FunctionType func);
      inline void operator()(/*6Bk*/Instance & o_ , /*6Fj*/IOChannel & channel);
   } onUnserialize;
   // inline static void register_onUnserialize(CPPClass & cl, Instance::Instance_onUnserialize_Functor::FunctionType func)

   static TCPPClass<Thread> _cpp_class;
   static C(bool) constructor(C(Instance) i, C(bool) alloc)
   {
      if(alloc && !INSTANCEL(i, i->_class))
      {
         Thread * inst = new Thread(i, _cpp_class);
         if(inst)
         {
            /* printf("Must free!\n");*/
            inst->mustFree = true;
         }
         return inst != null;
      }
      return true;
   }
   static void destructor(C(Instance) i)
   {
      Thread * inst = (Thread *)INSTANCEL(i, i->_class);
      if(inst)
      {
         if(_cpp_class.destructor)
            ((void (*)(Thread & self))_cpp_class.destructor)(*inst);
         if(inst->mustFree)
            delete inst;
      }
   }
   explicit inline Thread(C(Instance) _impl, CPPClass & cl = _cpp_class) : Instance(_impl, cl) { }

   inline void create(); // Thread_create
   inline void kill(); // Thread_kill
   inline void setPriority(/*1Ab*/ThreadPriority priority); // Thread_setPriority
   inline void wait(); // Thread_wait

   struct Thread_main_Functor
   {
      [[no_unique_address]] int _[0];
      typedef uint (* FunctionType)(Thread &);
      inline FunctionType operator= (FunctionType func);
      inline uint operator()( );
   } main;
   // inline static void register_main(CPPClass & cl, Thread::Thread_main_Functor::FunctionType func)

   static void class_registration(CPPClass & _cpp_class);

   struct created_Prop
   {
      constexpr created_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*regGet*/inline operator /*0I*/bool () const;
   } created;
};

enum class ThreadPriority : int
{
   normal = ThreadPriority_normal,
   aboveNormal = ThreadPriority_aboveNormal,
   belowNormal = ThreadPriority_belowNormal,
   highest = ThreadPriority_highest,
   lowest = ThreadPriority_lowest,
   idle = ThreadPriority_idle,
   timeCritical = ThreadPriority_timeCritical
};

class TimeStamp : public SecSince1970
{
public:
   constexpr TimeStamp() : SecSince1970() { }
   constexpr TimeStamp(const SecSince1970 value) : SecSince1970(value) { }
   constexpr TimeStamp(int64 value) : SecSince1970(TIMESTAMP(value)) { }
   constexpr operator int64() const { return SecSince1970_in_TimeStamp(impl); }
   constexpr TimeStamp & operator =(int64 value) { impl = TIMESTAMP(value); return *this; }
   bool operator ==(const TimeStamp & value) const { return impl == value.impl; }
   bool operator !=(const TimeStamp & value) const { return impl != value.impl; }
   bool operator <(const TimeStamp & value) const { return impl < value.impl; }
   bool operator >(const TimeStamp & value) const { return impl > value.impl; }
   bool operator <=(const TimeStamp & value) const { return impl <= value.impl; }
   bool operator >=(const TimeStamp & value) const { return impl >= value.impl; }
   bool operator ==(int64 value) const { return impl == TimeStamp(value).impl; }
   bool operator !=(int64 value) const { return impl != TimeStamp(value).impl; }
   bool operator <(int64 value) const { return impl < TimeStamp(value).impl; }
   bool operator >(int64 value) const { return impl > TimeStamp(value).impl; }
   bool operator <=(int64 value) const { return impl <= TimeStamp(value).impl; }
   bool operator >=(int64 value) const { return impl >= TimeStamp(value).impl; }
};

class TimeStamp32
{
public:
   C(TimeStamp32) impl;
   constexpr TimeStamp32() : impl(0) { }
   constexpr TimeStamp32(C(TimeStamp32) value) : impl(value) { }
   operator C(TimeStamp32)() const { return impl; }
   constexpr TimeStamp32(const TimeStamp32 & value) : impl(value.impl) { }
   TimeStamp32 & operator =(uint value) { impl = value; return *this; }
   TimeStamp32 & operator +=(TimeStamp32 value) { impl += value.impl; return *this; }
   TimeStamp32 & operator -=(TimeStamp32 value) { impl -= value.impl; return *this; }
   TimeStamp32 operator +(const TimeStamp32 & b) const { return TimeStamp32(impl + b.impl); }
   TimeStamp32 operator -(const TimeStamp32 & b) const { return TimeStamp32(impl - b.impl); }
   bool operator ==(const TimeStamp32 & value) const { return impl == value.impl; }
   bool operator !=(const TimeStamp32 & value) const { return impl != value.impl; }
   bool operator <(const TimeStamp32 & value) const { return impl < value.impl; }
   bool operator >(const TimeStamp32 & value) const { return impl > value.impl; }
   bool operator <=(const TimeStamp32 & value) const { return impl <= value.impl; }
   bool operator >=(const TimeStamp32 & value) const { return impl >= value.impl; }
   bool operator ==(uint value) const { return impl == TimeStamp32(value).impl; }
   bool operator !=(uint value) const { return impl != TimeStamp32(value).impl; }
   bool operator <(uint value) const { return impl < TimeStamp32(value).impl; }
   bool operator >(uint value) const { return impl > TimeStamp32(value).impl; }
   bool operator <=(uint value) const { return impl <= TimeStamp32(value).impl; }
   bool operator >=(uint value) const { return impl >= TimeStamp32(value).impl; }
};

class UnicodeDecomposition
{
public:
   C(UnicodeDecomposition) impl;
   constexpr UnicodeDecomposition() : impl(0) { }
   constexpr UnicodeDecomposition(C(UnicodeDecomposition) impl) : impl(impl) { }
   operator C(UnicodeDecomposition)() { return impl; }
   UnicodeDecomposition & operator =(C(UnicodeDecomposition) impl) { impl = impl; return *this; }
   bool operator ==(const UnicodeDecomposition & value) const { return impl == value.impl; }
   bool operator !=(const UnicodeDecomposition & value) const { return impl != value.impl; }

   struct canonical_Prop
   {
      constexpr canonical_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::canonical_Prop & operator= (UnicodeDecomposition::canonical_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } canonical;
   struct compat_Prop
   {
      constexpr compat_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::compat_Prop & operator= (UnicodeDecomposition::compat_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } compat;
   struct fraction_Prop
   {
      constexpr fraction_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::fraction_Prop & operator= (UnicodeDecomposition::fraction_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } fraction;
   struct font_Prop
   {
      constexpr font_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::font_Prop & operator= (UnicodeDecomposition::font_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } font;
   struct noBreak_Prop
   {
      constexpr noBreak_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::noBreak_Prop & operator= (UnicodeDecomposition::noBreak_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } noBreak;
   struct initial_Prop
   {
      constexpr initial_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::initial_Prop & operator= (UnicodeDecomposition::initial_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } initial;
   struct final_Prop
   {
      constexpr final_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::final_Prop & operator= (UnicodeDecomposition::final_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } final;
   struct medial_Prop
   {
      constexpr medial_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::medial_Prop & operator= (UnicodeDecomposition::medial_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } medial;
   struct isolated_Prop
   {
      constexpr isolated_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::isolated_Prop & operator= (UnicodeDecomposition::isolated_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } isolated;
   struct circle_Prop
   {
      constexpr circle_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::circle_Prop & operator= (UnicodeDecomposition::circle_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } circle;
   struct square_Prop
   {
      constexpr square_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::square_Prop & operator= (UnicodeDecomposition::square_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } square;
   struct sub_Prop
   {
      constexpr sub_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::sub_Prop & operator= (UnicodeDecomposition::sub_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } sub;
   struct super_Prop
   {
      constexpr super_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::super_Prop & operator= (UnicodeDecomposition::super_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } super;
   struct small_Prop
   {
      constexpr small_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::small_Prop & operator= (UnicodeDecomposition::small_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } small;
   struct vertical_Prop
   {
      constexpr vertical_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::vertical_Prop & operator= (UnicodeDecomposition::vertical_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } vertical;
   struct wide_Prop
   {
      constexpr wide_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::wide_Prop & operator= (UnicodeDecomposition::wide_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } wide;
   struct narrow_Prop
   {
      constexpr narrow_Prop() :_() { };
      [[no_unique_address]] int _[0];
      /*nstSet*/inline /*0H*/bool operator= (/*0H*/bool v);
      /*regSet*/inline UnicodeDecomposition::narrow_Prop & operator= (UnicodeDecomposition::narrow_Prop & prop);
      /*regGet*/inline operator /*0I*/bool () const;
   } narrow;
};
//////////////////////////////////////////////////////////////////////////////// ////////////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////////////
////                                                                        //// ////////////////////////
////    split implementations                                               //// ////////////////////////
////                                                                        //// ////////////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////////////


////////////////////////////////////////////////////////////// [ecere]/ //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


///////////////////////////////////////////////////////// [ecere]/ecere //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


inline FreeSpots::FreeSpots(uint size, int * spots = null, int nextSpot = 0, int used = 0)
{
   impl.size = size;
   impl.spots = spots;
   impl.nextSpot = nextSpot;
   impl.used = used;
}


inline void FreeSpots::init(/*1Ab*/uint count)
{
   FreeSpots_init(&impl, /*5Ge*/count);
}
inline void FreeSpots::markFree(/*1Ab*/int spot)
{
   FreeSpots_markFree(&impl, /*5Ge*/spot);
}
inline int FreeSpots::next()
{
   return FreeSpots_next(&impl);
}
inline void FreeSpots::resize(/*1Ab*/uint count)
{
   FreeSpots_resize(&impl, /*5Ge*/count);
}


// member accessors: FreeSpots::size
// (struct::uint)

/*nstSet*/inline /*0H*/uint FreeSpots::size_Prop::operator= (/*0H*/uint v)
{
   SELF(FreeSpots, size);
   self->impl.size = v;
   return v;
}

/*regSet*/inline FreeSpots::size_Prop & FreeSpots::size_Prop::operator= (FreeSpots::size_Prop & prop)
{
   SELF(FreeSpots, size);
   /*0H*/uint v = prop;
   self->impl.size = v;
   return prop;
}
/*regGet*/inline FreeSpots::size_Prop::operator /*0I*/uint () const
{
   SELF(FreeSpots, size);
   return self ? ((C(FreeSpots) *)&self->impl)->size : 0;
}

// member accessors: FreeSpots::spots
// (struct::int *)

/*nstSet*/inline /*0H*/int * FreeSpots::spots_Prop::operator= (/*0H*/int * v)
{
   SELF(FreeSpots, spots);
   self->impl.spots = v;
   return v;
}

/*regSet*/inline FreeSpots::spots_Prop & FreeSpots::spots_Prop::operator= (FreeSpots::spots_Prop & prop)
{
   SELF(FreeSpots, spots);
   /*0H*/int * v = prop;
   self->impl.spots = v;
   return prop;
}
/*regGet*/inline FreeSpots::spots_Prop::operator /*0I*/int * () const
{
   SELF(FreeSpots, spots);
   return self ? ((C(FreeSpots) *)&self->impl)->spots : null;
}

// member accessors: FreeSpots::nextSpot
// (struct::int)

/*nstSet*/inline /*0H*/int FreeSpots::nextSpot_Prop::operator= (/*0H*/int v)
{
   SELF(FreeSpots, nextSpot);
   self->impl.nextSpot = v;
   return v;
}

/*regSet*/inline FreeSpots::nextSpot_Prop & FreeSpots::nextSpot_Prop::operator= (FreeSpots::nextSpot_Prop & prop)
{
   SELF(FreeSpots, nextSpot);
   /*0H*/int v = prop;
   self->impl.nextSpot = v;
   return prop;
}
/*regGet*/inline FreeSpots::nextSpot_Prop::operator /*0I*/int () const
{
   SELF(FreeSpots, nextSpot);
   return self ? ((C(FreeSpots) *)&self->impl)->nextSpot : 0;
}

// member accessors: FreeSpots::used
// (struct::int)

/*nstSet*/inline /*0H*/int FreeSpots::used_Prop::operator= (/*0H*/int v)
{
   SELF(FreeSpots, used);
   self->impl.used = v;
   return v;
}

/*regSet*/inline FreeSpots::used_Prop & FreeSpots::used_Prop::operator= (FreeSpots::used_Prop & prop)
{
   SELF(FreeSpots, used);
   /*0H*/int v = prop;
   self->impl.used = v;
   return prop;
}
/*regGet*/inline FreeSpots::used_Prop::operator /*0I*/int () const
{
   SELF(FreeSpots, used);
   return self ? ((C(FreeSpots) *)&self->impl)->used : 0;
}

inline GLArrayTexture::GLArrayTexture(uint texture, uint width = 0, uint height = 0, uint numLayers = 0, uint numLevels = 0, bool maxLevel = (bool)0, int format = 0, FreeSpots spots = FreeSpots())
{
   impl.texture = texture;
   impl.width = width;
   impl.height = height;
   impl.numLayers = numLayers;
   impl.numLevels = numLevels;
   impl.maxLevel = (C(bool))maxLevel;
   impl.format = format;
   impl.spots = spots.impl;
}


inline void GLArrayTexture::_init(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count, /*1Ab*/int format, /*1Ab*/bool setMaxLevel)
{
   GLArrayTexture__init(&impl, /*5Ge*/levels, /*5Ge*/w, /*5Ge*/h, /*5Ge*/count, /*5Ge*/format, /*5Ee*/(C(bool))setMaxLevel);
}
inline int GLArrayTexture::allocateLayer(/*1Ab*/uint targetFBO)
{
   return GLArrayTexture_allocateLayer(&impl, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::bind()
{
   GLArrayTexture_bind(&impl);
}
inline void GLArrayTexture::copy(/*1Ab*/GLArrayTexture & src, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_copy(&impl, /*5De*/&src.impl, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::copy(/*1Ac*/GLArrayTexture * src, /*1Ac*/uint targetFBO)
{
   GLArrayTexture_copy(&impl, /*5Cf*/(C(GLArrayTexture) *)src, /*5Gf*/targetFBO);
}
inline void GLArrayTexture::free()
{
   GLArrayTexture_free(&impl);
}
inline void GLArrayTexture::freeLayer(/*1Ab*/int layer)
{
   GLArrayTexture_freeLayer(&impl, /*5Ge*/layer);
}
inline void GLArrayTexture::init(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count)
{
   GLArrayTexture_init(&impl, /*5Ge*/levels, /*5Ge*/w, /*5Ge*/h, /*5Ge*/count);
}
inline void GLArrayTexture::initMaxLevel(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count)
{
   GLArrayTexture_initMaxLevel(&impl, /*5Ge*/levels, /*5Ge*/w, /*5Ge*/h, /*5Ge*/count);
}
inline void GLArrayTexture::initRGBAUShort(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count)
{
   GLArrayTexture_initRGBAUShort(&impl, /*5Ge*/levels, /*5Ge*/w, /*5Ge*/h, /*5Ge*/count);
}
inline void GLArrayTexture::initRGBUShort(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count)
{
   GLArrayTexture_initRGBUShort(&impl, /*5Ge*/levels, /*5Ge*/w, /*5Ge*/h, /*5Ge*/count);
}
inline void GLArrayTexture::initUShort(/*1Ab*/int levels, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int count)
{
   GLArrayTexture_initUShort(&impl, /*5Ge*/levels, /*5Ge*/w, /*5Ge*/h, /*5Ge*/count);
}
inline void GLArrayTexture::resize(/*1Ab*/uint numLayers, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_resize(&impl, /*5Ge*/numLayers, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::set1x1Layer(/*1Ab*/int layer, /*1Ab*/ColorAlpha color, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_set1x1Layer(&impl, /*5Ge*/layer, /*5Ee*/(C(ColorAlpha))color.impl, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::setFilter(/*1Ab*/GLTextureFilter minFilter, /*1Ab*/GLTextureFilter magFilter)
{
   GLArrayTexture_setFilter(&impl, /*5Ee*/(C(GLTextureFilter))minFilter, /*5Ee*/(C(GLTextureFilter))magFilter);
}
inline void GLArrayTexture::setLayer(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_setLayer(&impl, /*5Ge*/level, /*5Ge*/x, /*5Ge*/y, /*5Ge*/layer, /*5Ge*/c, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::setLayerCompressed(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uintsize sizeBytes, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_setLayerCompressed(&impl, /*5Ge*/level, /*5Ge*/x, /*5Ge*/y, /*5Ge*/layer, /*5Ge*/c, /*5Ge*/sizeBytes, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::setLayerFormat(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO, /*1Ab*/int format, /*1Ab*/int type)
{
   GLArrayTexture_setLayerFormat(&impl, /*5Ge*/level, /*5Ge*/x, /*5Ge*/y, /*5Ge*/layer, /*5Ge*/c, /*5Ge*/targetFBO, /*5Ge*/format, /*5Ge*/type);
}
inline void GLArrayTexture::setLayerRGBAUShort(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_setLayerRGBAUShort(&impl, /*5Ge*/level, /*5Ge*/x, /*5Ge*/y, /*5Ge*/layer, /*5Ge*/c, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::setLayerRGBUShort(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_setLayerRGBUShort(&impl, /*5Ge*/level, /*5Ge*/x, /*5Ge*/y, /*5Ge*/layer, /*5Ge*/c, /*5Ge*/targetFBO);
}
inline void GLArrayTexture::setLayerUShort(/*1Ab*/int level, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int layer, /*1Ab*/byte * c, /*1Ab*/uint targetFBO)
{
   GLArrayTexture_setLayerUShort(&impl, /*5Ge*/level, /*5Ge*/x, /*5Ge*/y, /*5Ge*/layer, /*5Ge*/c, /*5Ge*/targetFBO);
}


// member accessors: GLArrayTexture::texture
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLArrayTexture::texture_Prop::operator= (/*0H*/uint v)
{
   SELF(GLArrayTexture, texture);
   self->impl.texture = v;
   return v;
}

/*regSet*/inline GLArrayTexture::texture_Prop & GLArrayTexture::texture_Prop::operator= (GLArrayTexture::texture_Prop & prop)
{
   SELF(GLArrayTexture, texture);
   /*0H*/uint v = prop;
   self->impl.texture = v;
   return prop;
}
/*regGet*/inline GLArrayTexture::texture_Prop::operator /*0I*/uint () const
{
   SELF(GLArrayTexture, texture);
   return self ? ((C(GLArrayTexture) *)&self->impl)->texture : 0;
}

// member accessors: GLArrayTexture::width
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLArrayTexture::width_Prop::operator= (/*0H*/uint v)
{
   SELF(GLArrayTexture, width);
   self->impl.width = v;
   return v;
}

/*regSet*/inline GLArrayTexture::width_Prop & GLArrayTexture::width_Prop::operator= (GLArrayTexture::width_Prop & prop)
{
   SELF(GLArrayTexture, width);
   /*0H*/uint v = prop;
   self->impl.width = v;
   return prop;
}
/*regGet*/inline GLArrayTexture::width_Prop::operator /*0I*/uint () const
{
   SELF(GLArrayTexture, width);
   return self ? ((C(GLArrayTexture) *)&self->impl)->width : 0;
}

// member accessors: GLArrayTexture::height
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLArrayTexture::height_Prop::operator= (/*0H*/uint v)
{
   SELF(GLArrayTexture, height);
   self->impl.height = v;
   return v;
}

/*regSet*/inline GLArrayTexture::height_Prop & GLArrayTexture::height_Prop::operator= (GLArrayTexture::height_Prop & prop)
{
   SELF(GLArrayTexture, height);
   /*0H*/uint v = prop;
   self->impl.height = v;
   return prop;
}
/*regGet*/inline GLArrayTexture::height_Prop::operator /*0I*/uint () const
{
   SELF(GLArrayTexture, height);
   return self ? ((C(GLArrayTexture) *)&self->impl)->height : 0;
}

// member accessors: GLArrayTexture::numLayers
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLArrayTexture::numLayers_Prop::operator= (/*0H*/uint v)
{
   SELF(GLArrayTexture, numLayers);
   self->impl.numLayers = v;
   return v;
}

/*regSet*/inline GLArrayTexture::numLayers_Prop & GLArrayTexture::numLayers_Prop::operator= (GLArrayTexture::numLayers_Prop & prop)
{
   SELF(GLArrayTexture, numLayers);
   /*0H*/uint v = prop;
   self->impl.numLayers = v;
   return prop;
}
/*regGet*/inline GLArrayTexture::numLayers_Prop::operator /*0I*/uint () const
{
   SELF(GLArrayTexture, numLayers);
   return self ? ((C(GLArrayTexture) *)&self->impl)->numLayers : 0;
}

// member accessors: GLArrayTexture::numLevels
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLArrayTexture::numLevels_Prop::operator= (/*0H*/uint v)
{
   SELF(GLArrayTexture, numLevels);
   self->impl.numLevels = v;
   return v;
}

/*regSet*/inline GLArrayTexture::numLevels_Prop & GLArrayTexture::numLevels_Prop::operator= (GLArrayTexture::numLevels_Prop & prop)
{
   SELF(GLArrayTexture, numLevels);
   /*0H*/uint v = prop;
   self->impl.numLevels = v;
   return prop;
}
/*regGet*/inline GLArrayTexture::numLevels_Prop::operator /*0I*/uint () const
{
   SELF(GLArrayTexture, numLevels);
   return self ? ((C(GLArrayTexture) *)&self->impl)->numLevels : 0;
}

// member accessors: GLArrayTexture::maxLevel
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool GLArrayTexture::maxLevel_Prop::operator= (/*0H*/bool v)
{
   SELF(GLArrayTexture, maxLevel);
   self->impl.maxLevel = (C(bool))v;
   return v;
}

/*regSet*/inline GLArrayTexture::maxLevel_Prop & GLArrayTexture::maxLevel_Prop::operator= (GLArrayTexture::maxLevel_Prop & prop)
{
   SELF(GLArrayTexture, maxLevel);
   /*0H*/bool v = prop;
   self->impl.maxLevel = (C(bool))v;
   return prop;
}
/*regGet*/inline GLArrayTexture::maxLevel_Prop::operator /*0I*/bool () const
{
   SELF(GLArrayTexture, maxLevel);
   return self ? (bool)((C(GLArrayTexture) *)&self->impl)->maxLevel : (bool)0;
}

// member accessors: GLArrayTexture::format
// (struct::int)

/*nstSet*/inline /*0H*/int GLArrayTexture::format_Prop::operator= (/*0H*/int v)
{
   SELF(GLArrayTexture, format);
   self->impl.format = v;
   return v;
}

/*regSet*/inline GLArrayTexture::format_Prop & GLArrayTexture::format_Prop::operator= (GLArrayTexture::format_Prop & prop)
{
   SELF(GLArrayTexture, format);
   /*0H*/int v = prop;
   self->impl.format = v;
   return prop;
}
/*regGet*/inline GLArrayTexture::format_Prop::operator /*0I*/int () const
{
   SELF(GLArrayTexture, format);
   return self ? ((C(GLArrayTexture) *)&self->impl)->format : 0;
}

// member accessors: GLArrayTexture::spots
// (struct::struct)

/*nstSet*/inline /*0H*/FreeSpots GLArrayTexture::spots_Prop::operator= (/*0H*/FreeSpots v)
{
   SELF(GLArrayTexture, spots);
   self->impl.spots = v.impl;
   return v;
}

/*regSet*/inline GLArrayTexture::spots_Prop & GLArrayTexture::spots_Prop::operator= (GLArrayTexture::spots_Prop & prop)
{
   SELF(GLArrayTexture, spots);
   /*0H*/FreeSpots v = prop;
   self->impl.spots = v.impl;
   return prop;
}
/*regGet*/inline GLArrayTexture::spots_Prop::operator /*0I*/FreeSpots () const
{
   SELF(GLArrayTexture, spots);
   FreeSpots value(((C(GLArrayTexture) *)&self->impl)->spots);
   return value;
}

inline GLDrawCommand::GLDrawCommand(uint count, uint instanceCount = 0, uint firstIndex = 0, uint baseVertex = 0, uint baseInstance = 0)
{
   impl.count = count;
   impl.instanceCount = instanceCount;
   impl.firstIndex = firstIndex;
   impl.baseVertex = baseVertex;
   impl.baseInstance = baseInstance;
}



// member accessors: GLDrawCommand::count
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLDrawCommand::count_Prop::operator= (/*0H*/uint v)
{
   SELF(GLDrawCommand, count);
   self->impl.count = v;
   return v;
}

/*regSet*/inline GLDrawCommand::count_Prop & GLDrawCommand::count_Prop::operator= (GLDrawCommand::count_Prop & prop)
{
   SELF(GLDrawCommand, count);
   /*0H*/uint v = prop;
   self->impl.count = v;
   return prop;
}
/*regGet*/inline GLDrawCommand::count_Prop::operator /*0I*/uint () const
{
   SELF(GLDrawCommand, count);
   return self ? ((C(GLDrawCommand) *)&self->impl)->count : 0;
}

// member accessors: GLDrawCommand::instanceCount
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLDrawCommand::instanceCount_Prop::operator= (/*0H*/uint v)
{
   SELF(GLDrawCommand, instanceCount);
   self->impl.instanceCount = v;
   return v;
}

/*regSet*/inline GLDrawCommand::instanceCount_Prop & GLDrawCommand::instanceCount_Prop::operator= (GLDrawCommand::instanceCount_Prop & prop)
{
   SELF(GLDrawCommand, instanceCount);
   /*0H*/uint v = prop;
   self->impl.instanceCount = v;
   return prop;
}
/*regGet*/inline GLDrawCommand::instanceCount_Prop::operator /*0I*/uint () const
{
   SELF(GLDrawCommand, instanceCount);
   return self ? ((C(GLDrawCommand) *)&self->impl)->instanceCount : 0;
}

// member accessors: GLDrawCommand::firstIndex
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLDrawCommand::firstIndex_Prop::operator= (/*0H*/uint v)
{
   SELF(GLDrawCommand, firstIndex);
   self->impl.firstIndex = v;
   return v;
}

/*regSet*/inline GLDrawCommand::firstIndex_Prop & GLDrawCommand::firstIndex_Prop::operator= (GLDrawCommand::firstIndex_Prop & prop)
{
   SELF(GLDrawCommand, firstIndex);
   /*0H*/uint v = prop;
   self->impl.firstIndex = v;
   return prop;
}
/*regGet*/inline GLDrawCommand::firstIndex_Prop::operator /*0I*/uint () const
{
   SELF(GLDrawCommand, firstIndex);
   return self ? ((C(GLDrawCommand) *)&self->impl)->firstIndex : 0;
}

// member accessors: GLDrawCommand::baseVertex
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLDrawCommand::baseVertex_Prop::operator= (/*0H*/uint v)
{
   SELF(GLDrawCommand, baseVertex);
   self->impl.baseVertex = v;
   return v;
}

/*regSet*/inline GLDrawCommand::baseVertex_Prop & GLDrawCommand::baseVertex_Prop::operator= (GLDrawCommand::baseVertex_Prop & prop)
{
   SELF(GLDrawCommand, baseVertex);
   /*0H*/uint v = prop;
   self->impl.baseVertex = v;
   return prop;
}
/*regGet*/inline GLDrawCommand::baseVertex_Prop::operator /*0I*/uint () const
{
   SELF(GLDrawCommand, baseVertex);
   return self ? ((C(GLDrawCommand) *)&self->impl)->baseVertex : 0;
}

// member accessors: GLDrawCommand::baseInstance
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLDrawCommand::baseInstance_Prop::operator= (/*0H*/uint v)
{
   SELF(GLDrawCommand, baseInstance);
   self->impl.baseInstance = v;
   return v;
}

/*regSet*/inline GLDrawCommand::baseInstance_Prop & GLDrawCommand::baseInstance_Prop::operator= (GLDrawCommand::baseInstance_Prop & prop)
{
   SELF(GLDrawCommand, baseInstance);
   /*0H*/uint v = prop;
   self->impl.baseInstance = v;
   return prop;
}
/*regGet*/inline GLDrawCommand::baseInstance_Prop::operator /*0I*/uint () const
{
   SELF(GLDrawCommand, baseInstance);
   return self ? ((C(GLDrawCommand) *)&self->impl)->baseInstance : 0;
}


inline void GLMultiDraw::addDrawCommand(/*1Ab*/uint indexCount, /*1Ab*/uint instanceCount, /*1Ab*/uint firstIndex, /*1Ab*/uint baseVertex, /*1Ab*/uint baseInstance)
{
   GLMultiDraw_addDrawCommand(&impl, /*5Ge*/indexCount, /*5Ge*/instanceCount, /*5Ge*/firstIndex, /*5Ge*/baseVertex, /*5Ge*/baseInstance);
}
inline void GLMultiDraw::addDrawCommandCustomID(/*1Ab*/uint indexCount, /*1Ab*/uint instanceCount, /*1Ab*/uint firstIndex, /*1Ab*/uint baseVertex, /*1Ab*/uint baseInstance, /*1Ab*/uint layer)
{
   GLMultiDraw_addDrawCommandCustomID(&impl, /*5Ge*/indexCount, /*5Ge*/instanceCount, /*5Ge*/firstIndex, /*5Ge*/baseVertex, /*5Ge*/baseInstance, /*5Ge*/layer);
}
inline int GLMultiDraw::allocateIx(/*1Ab*/uint nIndices, /*1Ab*/uint indexSize, /*1Ab*/const void * data)
{
   return GLMultiDraw_allocateIx(&impl, /*5Ge*/nIndices, /*5Ge*/indexSize, /*5Ge*/data);
}
inline int GLMultiDraw::allocateVbo(/*1Ab*/uint nVertices, /*1Ab*/uint vertexSize, /*1Ab*/const void * data)
{
   return GLMultiDraw_allocateVbo(&impl, /*5Ge*/nVertices, /*5Ge*/vertexSize, /*5Ge*/data);
}
inline void GLMultiDraw::draw()
{
   GLMultiDraw_draw(&impl);
}
inline void GLMultiDraw::free()
{
   GLMultiDraw_free(&impl);
}
inline void GLMultiDraw::freeIx(/*1Ab*/int baseIndex, /*1Ab*/uint indexSize, /*1Ab*/uint count)
{
   GLMultiDraw_freeIx(&impl, /*5Ge*/baseIndex, /*5Ge*/indexSize, /*5Ge*/count);
}
inline void GLMultiDraw::freeVbo(/*1Ab*/int baseVertex, /*1Ab*/uint vertexSize, /*1Ab*/uint count)
{
   GLMultiDraw_freeVbo(&impl, /*5Ge*/baseVertex, /*5Ge*/vertexSize, /*5Ge*/count);
}
inline void GLMultiDraw::init(/*1Ab*/GLIMTKMode mode, /*1Ab*/uint minAlloc)
{
   GLMultiDraw_init(&impl, /*5Ee*/(C(GLIMTKMode))mode, /*5Ge*/minAlloc);
}
inline void GLMultiDraw::prepare(/*1Ab*/int vertNCoords, /*1Ab*/int verticesStride)
{
   GLMultiDraw_prepare(&impl, /*5Ge*/vertNCoords, /*5Ge*/verticesStride);
}
inline void GLMultiDraw::printStats()
{
   GLMultiDraw_printStats(&impl);
}
inline void GLMultiDraw::resize(/*1Ab*/uint size)
{
   GLMultiDraw_resize(&impl, /*5Ge*/size);
}
inline void GLMultiDraw::resizeCommands(/*1Ab*/uint size)
{
   GLMultiDraw_resizeCommands(&impl, /*5Ge*/size);
}
inline void GLMultiDraw::resizeIDs(/*1Ab*/uint size)
{
   GLMultiDraw_resizeIDs(&impl, /*5Ge*/size);
}


// property callers: GLMultiDraw::ix32   // set only
// (struct::enum|uint)

/*nstSet*/inline /*0G*/bool GLMultiDraw::ix32_Prop::operator= (/*0G*/bool v)
{
   SELF(GLMultiDraw, ix32);
   GLMultiDraw_set_ix32(&self->impl, (C(bool))v);
   return v;
}



// member accessors: GLMultiDraw::indexGLMB
// (struct::normal)

/*nstSet*/inline /*0Z*/const GLMB & GLMultiDraw::indexGLMB_Prop::operator= (/*0Z*/const GLMB & v)
{
   SELF(GLMultiDraw, indexGLMB);
   ((C(GLMultiDraw) *)&self->impl)->indexGLMB = ((Instance *)&v)->impl;
   return v;
}

/*regSet*/inline GLMultiDraw::indexGLMB_Prop & GLMultiDraw::indexGLMB_Prop::operator= (GLMultiDraw::indexGLMB_Prop & prop)
{
   SELF(GLMultiDraw, indexGLMB);
   /*0H*/GLMB * v = prop;
   self->impl.indexGLMB = ((Instance *)v)->impl;
   return prop;
}
/*regGet*/inline GLMultiDraw::indexGLMB_Prop::operator /*0I*/GLMB * () const
{
   SELF(GLMultiDraw, indexGLMB);
   C(Instance) i = ((C(GLMultiDraw) *)&self->impl)->indexGLMB;
   return BINDINGS_CLASS(i) ? (GLMB *)INSTANCEL(i, i->_class) : (GLMB *)0;
}

// member accessors: GLMultiDraw::vertexGLMB
// (struct::normal)

/*nstSet*/inline /*0Z*/const GLMB & GLMultiDraw::vertexGLMB_Prop::operator= (/*0Z*/const GLMB & v)
{
   SELF(GLMultiDraw, vertexGLMB);
   ((C(GLMultiDraw) *)&self->impl)->vertexGLMB = ((Instance *)&v)->impl;
   return v;
}

/*regSet*/inline GLMultiDraw::vertexGLMB_Prop & GLMultiDraw::vertexGLMB_Prop::operator= (GLMultiDraw::vertexGLMB_Prop & prop)
{
   SELF(GLMultiDraw, vertexGLMB);
   /*0H*/GLMB * v = prop;
   self->impl.vertexGLMB = ((Instance *)v)->impl;
   return prop;
}
/*regGet*/inline GLMultiDraw::vertexGLMB_Prop::operator /*0I*/GLMB * () const
{
   SELF(GLMultiDraw, vertexGLMB);
   C(Instance) i = ((C(GLMultiDraw) *)&self->impl)->vertexGLMB;
   return BINDINGS_CLASS(i) ? (GLMB *)INSTANCEL(i, i->_class) : (GLMB *)0;
}

// member accessors: GLMultiDraw::idsAB
// (struct::struct)

/*nstSet*/inline /*0H*/GLAB GLMultiDraw::idsAB_Prop::operator= (/*0H*/GLAB v)
{
   SELF(GLMultiDraw, idsAB);
   self->impl.idsAB = v.impl;
   return v;
}

/*regSet*/inline GLMultiDraw::idsAB_Prop & GLMultiDraw::idsAB_Prop::operator= (GLMultiDraw::idsAB_Prop & prop)
{
   SELF(GLMultiDraw, idsAB);
   /*0H*/GLAB v = prop;
   self->impl.idsAB = v.impl;
   return prop;
}
/*regGet*/inline GLMultiDraw::idsAB_Prop::operator /*0I*/GLAB () const
{
   SELF(GLMultiDraw, idsAB);
   GLAB value(((C(GLMultiDraw) *)&self->impl)->idsAB);
   return value;
}

// member accessors: GLMultiDraw::commandsB
// (struct::struct)

/*nstSet*/inline /*0H*/GLCAB GLMultiDraw::commandsB_Prop::operator= (/*0H*/GLCAB v)
{
   SELF(GLMultiDraw, commandsB);
   self->impl.commandsB = v.impl;
   return v;
}

/*regSet*/inline GLMultiDraw::commandsB_Prop & GLMultiDraw::commandsB_Prop::operator= (GLMultiDraw::commandsB_Prop & prop)
{
   SELF(GLMultiDraw, commandsB);
   /*0H*/GLCAB v = prop;
   self->impl.commandsB = v.impl;
   return prop;
}
/*regGet*/inline GLMultiDraw::commandsB_Prop::operator /*0I*/GLCAB () const
{
   SELF(GLMultiDraw, commandsB);
   GLCAB value(((C(GLMultiDraw) *)&self->impl)->commandsB);
   return value;
}

// member accessors: GLMultiDraw::vao
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::vao_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, vao);
   self->impl.vao = v;
   return v;
}

/*regSet*/inline GLMultiDraw::vao_Prop & GLMultiDraw::vao_Prop::operator= (GLMultiDraw::vao_Prop & prop)
{
   SELF(GLMultiDraw, vao);
   /*0H*/uint v = prop;
   self->impl.vao = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::vao_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, vao);
   return self ? ((C(GLMultiDraw) *)&self->impl)->vao : 0;
}

// member accessors: GLMultiDraw::commandsCount
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::commandsCount_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, commandsCount);
   self->impl.commandsCount = v;
   return v;
}

/*regSet*/inline GLMultiDraw::commandsCount_Prop & GLMultiDraw::commandsCount_Prop::operator= (GLMultiDraw::commandsCount_Prop & prop)
{
   SELF(GLMultiDraw, commandsCount);
   /*0H*/uint v = prop;
   self->impl.commandsCount = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::commandsCount_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, commandsCount);
   return self ? ((C(GLMultiDraw) *)&self->impl)->commandsCount : 0;
}

// member accessors: GLMultiDraw::drawMode
// (struct::enum|int)

/*nstSet*/inline /*0H*/GLIMTKMode GLMultiDraw::drawMode_Prop::operator= (/*0H*/GLIMTKMode v)
{
   SELF(GLMultiDraw, drawMode);
   self->impl.drawMode = (C(GLIMTKMode))v;
   return v;
}

/*regSet*/inline GLMultiDraw::drawMode_Prop & GLMultiDraw::drawMode_Prop::operator= (GLMultiDraw::drawMode_Prop & prop)
{
   SELF(GLMultiDraw, drawMode);
   /*0H*/GLIMTKMode v = prop;
   self->impl.drawMode = (C(GLIMTKMode))v;
   return prop;
}
/*regGet*/inline GLMultiDraw::drawMode_Prop::operator /*0I*/GLIMTKMode () const
{
   SELF(GLMultiDraw, drawMode);
   return self ? (GLIMTKMode)((C(GLMultiDraw) *)&self->impl)->drawMode : (GLIMTKMode)0;
}

// member accessors: GLMultiDraw::commandsAlloced
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::commandsAlloced_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, commandsAlloced);
   self->impl.commandsAlloced = v;
   return v;
}

/*regSet*/inline GLMultiDraw::commandsAlloced_Prop & GLMultiDraw::commandsAlloced_Prop::operator= (GLMultiDraw::commandsAlloced_Prop & prop)
{
   SELF(GLMultiDraw, commandsAlloced);
   /*0H*/uint v = prop;
   self->impl.commandsAlloced = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::commandsAlloced_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, commandsAlloced);
   return self ? ((C(GLMultiDraw) *)&self->impl)->commandsAlloced : 0;
}

// member accessors: GLMultiDraw::drawIDs
// (struct::uint *)

/*nstSet*/inline /*0H*/uint * GLMultiDraw::drawIDs_Prop::operator= (/*0H*/uint * v)
{
   SELF(GLMultiDraw, drawIDs);
   self->impl.drawIDs = v;
   return v;
}

/*regSet*/inline GLMultiDraw::drawIDs_Prop & GLMultiDraw::drawIDs_Prop::operator= (GLMultiDraw::drawIDs_Prop & prop)
{
   SELF(GLMultiDraw, drawIDs);
   /*0H*/uint * v = prop;
   self->impl.drawIDs = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::drawIDs_Prop::operator /*0I*/uint * () const
{
   SELF(GLMultiDraw, drawIDs);
   return self ? ((C(GLMultiDraw) *)&self->impl)->drawIDs : null;
}

// member accessors: GLMultiDraw::type
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::type_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, type);
   self->impl.type = v;
   return v;
}

/*regSet*/inline GLMultiDraw::type_Prop & GLMultiDraw::type_Prop::operator= (GLMultiDraw::type_Prop & prop)
{
   SELF(GLMultiDraw, type);
   /*0H*/uint v = prop;
   self->impl.type = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::type_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, type);
   return self ? ((C(GLMultiDraw) *)&self->impl)->type : 0;
}

// member accessors: GLMultiDraw::idsAlloced
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::idsAlloced_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, idsAlloced);
   self->impl.idsAlloced = v;
   return v;
}

/*regSet*/inline GLMultiDraw::idsAlloced_Prop & GLMultiDraw::idsAlloced_Prop::operator= (GLMultiDraw::idsAlloced_Prop & prop)
{
   SELF(GLMultiDraw, idsAlloced);
   /*0H*/uint v = prop;
   self->impl.idsAlloced = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::idsAlloced_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, idsAlloced);
   return self ? ((C(GLMultiDraw) *)&self->impl)->idsAlloced : 0;
}

// member accessors: GLMultiDraw::totalInstances
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::totalInstances_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, totalInstances);
   self->impl.totalInstances = v;
   return v;
}

/*regSet*/inline GLMultiDraw::totalInstances_Prop & GLMultiDraw::totalInstances_Prop::operator= (GLMultiDraw::totalInstances_Prop & prop)
{
   SELF(GLMultiDraw, totalInstances);
   /*0H*/uint v = prop;
   self->impl.totalInstances = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::totalInstances_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, totalInstances);
   return self ? ((C(GLMultiDraw) *)&self->impl)->totalInstances : 0;
}

// member accessors: GLMultiDraw::vertexStride
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::vertexStride_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, vertexStride);
   self->impl.vertexStride = v;
   return v;
}

/*regSet*/inline GLMultiDraw::vertexStride_Prop & GLMultiDraw::vertexStride_Prop::operator= (GLMultiDraw::vertexStride_Prop & prop)
{
   SELF(GLMultiDraw, vertexStride);
   /*0H*/uint v = prop;
   self->impl.vertexStride = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::vertexStride_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, vertexStride);
   return self ? ((C(GLMultiDraw) *)&self->impl)->vertexStride : 0;
}

// member accessors: GLMultiDraw::transformsAB
// (struct::struct)

/*nstSet*/inline /*0H*/GLAB GLMultiDraw::transformsAB_Prop::operator= (/*0H*/GLAB v)
{
   SELF(GLMultiDraw, transformsAB);
   self->impl.transformsAB = v.impl;
   return v;
}

/*regSet*/inline GLMultiDraw::transformsAB_Prop & GLMultiDraw::transformsAB_Prop::operator= (GLMultiDraw::transformsAB_Prop & prop)
{
   SELF(GLMultiDraw, transformsAB);
   /*0H*/GLAB v = prop;
   self->impl.transformsAB = v.impl;
   return prop;
}
/*regGet*/inline GLMultiDraw::transformsAB_Prop::operator /*0I*/GLAB () const
{
   SELF(GLMultiDraw, transformsAB);
   GLAB value(((C(GLMultiDraw) *)&self->impl)->transformsAB);
   return value;
}

// member accessors: GLMultiDraw::transformSize
// (struct::int)

/*nstSet*/inline /*0H*/int GLMultiDraw::transformSize_Prop::operator= (/*0H*/int v)
{
   SELF(GLMultiDraw, transformSize);
   self->impl.transformSize = v;
   return v;
}

/*regSet*/inline GLMultiDraw::transformSize_Prop & GLMultiDraw::transformSize_Prop::operator= (GLMultiDraw::transformSize_Prop & prop)
{
   SELF(GLMultiDraw, transformSize);
   /*0H*/int v = prop;
   self->impl.transformSize = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::transformSize_Prop::operator /*0I*/int () const
{
   SELF(GLMultiDraw, transformSize);
   return self ? ((C(GLMultiDraw) *)&self->impl)->transformSize : 0;
}

// member accessors: GLMultiDraw::transforms
// (struct::float *)

/*nstSet*/inline /*0H*/float * GLMultiDraw::transforms_Prop::operator= (/*0H*/float * v)
{
   SELF(GLMultiDraw, transforms);
   self->impl.transforms = v;
   return v;
}

/*regSet*/inline GLMultiDraw::transforms_Prop & GLMultiDraw::transforms_Prop::operator= (GLMultiDraw::transforms_Prop & prop)
{
   SELF(GLMultiDraw, transforms);
   /*0H*/float * v = prop;
   self->impl.transforms = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::transforms_Prop::operator /*0I*/float * () const
{
   SELF(GLMultiDraw, transforms);
   return self ? ((C(GLMultiDraw) *)&self->impl)->transforms : null;
}

// member accessors: GLMultiDraw::lastTransformAB
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::lastTransformAB_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, lastTransformAB);
   self->impl.lastTransformAB = v;
   return v;
}

/*regSet*/inline GLMultiDraw::lastTransformAB_Prop & GLMultiDraw::lastTransformAB_Prop::operator= (GLMultiDraw::lastTransformAB_Prop & prop)
{
   SELF(GLMultiDraw, lastTransformAB);
   /*0H*/uint v = prop;
   self->impl.lastTransformAB = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::lastTransformAB_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, lastTransformAB);
   return self ? ((C(GLMultiDraw) *)&self->impl)->lastTransformAB : 0;
}

// member accessors: GLMultiDraw::lastIDAB
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::lastIDAB_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, lastIDAB);
   self->impl.lastIDAB = v;
   return v;
}

/*regSet*/inline GLMultiDraw::lastIDAB_Prop & GLMultiDraw::lastIDAB_Prop::operator= (GLMultiDraw::lastIDAB_Prop & prop)
{
   SELF(GLMultiDraw, lastIDAB);
   /*0H*/uint v = prop;
   self->impl.lastIDAB = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::lastIDAB_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, lastIDAB);
   return self ? ((C(GLMultiDraw) *)&self->impl)->lastIDAB : 0;
}

// member accessors: GLMultiDraw::lastVBO
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::lastVBO_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, lastVBO);
   self->impl.lastVBO = v;
   return v;
}

/*regSet*/inline GLMultiDraw::lastVBO_Prop & GLMultiDraw::lastVBO_Prop::operator= (GLMultiDraw::lastVBO_Prop & prop)
{
   SELF(GLMultiDraw, lastVBO);
   /*0H*/uint v = prop;
   self->impl.lastVBO = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::lastVBO_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, lastVBO);
   return self ? ((C(GLMultiDraw) *)&self->impl)->lastVBO : 0;
}

// member accessors: GLMultiDraw::lastIBO
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLMultiDraw::lastIBO_Prop::operator= (/*0H*/uint v)
{
   SELF(GLMultiDraw, lastIBO);
   self->impl.lastIBO = v;
   return v;
}

/*regSet*/inline GLMultiDraw::lastIBO_Prop & GLMultiDraw::lastIBO_Prop::operator= (GLMultiDraw::lastIBO_Prop & prop)
{
   SELF(GLMultiDraw, lastIBO);
   /*0H*/uint v = prop;
   self->impl.lastIBO = v;
   return prop;
}
/*regGet*/inline GLMultiDraw::lastIBO_Prop::operator /*0I*/uint () const
{
   SELF(GLMultiDraw, lastIBO);
   return self ? ((C(GLMultiDraw) *)&self->impl)->lastIBO : 0;
}

//////////////////////////////////////////////////// [ecere]/ecere::gfx //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


inline Bitmap::Bitmap(int width, int height = 0, PixelFormat pixelFormat = (PixelFormat)0, unsigned char * picture = null, uint stride = 0, uint size = 0, uint sizeBytes = 0, ColorAlpha * palette = null, bool allocatePalette = (bool)0, bool transparent = (bool)0, int shadeShift = 0, unsigned char * paletteShades = null, bool alphaBlend = (bool)0) : Bitmap()
{
   this->width = width;
   this->height = height;
   this->pixelFormat = pixelFormat;
   this->picture = picture;
   this->stride = stride;
   this->size = size;
   this->sizeBytes = sizeBytes;
   this->palette = palette;
   this->allocatePalette = allocatePalette;
   this->transparent = transparent;
   this->shadeShift = shadeShift;
   this->paletteShades = paletteShades;
   this->alphaBlend = alphaBlend;
}


inline C(bool) Bitmap::allocate(/*1Ab*/const char * driverName, /*1Ab*/int width, /*1Ab*/int height, /*1Ab*/int stride, /*1Ab*/PixelFormat format, /*1Ab*/bool allocatePalette)
{
   return Bitmap_allocate(impl, /*5Ge*/driverName, /*5Ge*/width, /*5Ge*/height, /*5Ge*/stride, /*5Ee*/(C(PixelFormat))format, /*5Ee*/(C(bool))allocatePalette);
}
inline C(bool) Bitmap::allocateDD(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/int width, /*1Ab*/int height)
{
   return Bitmap_allocateDD(impl, /*5De*/displaySystem.impl, /*5Ge*/width, /*5Ge*/height);
}
inline C(bool) Bitmap::convert(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/PixelFormat format, /*1Ab*/ColorAlpha * palette)
{
   return Bitmap_convert(impl, /*5De*/displaySystem.impl, /*5Ee*/(C(PixelFormat))format, /*5Ee*/(C(ColorAlpha) *)palette);
}
inline C(bool) Bitmap::copy(/*1Ab*/Bitmap & source)
{
   return Bitmap_copy(impl, /*5De*/source.impl);
}
inline C(bool) Bitmap::copy2(/*1Ab*/Bitmap & source, /*1Ab*/bool moveStuff)
{
   return Bitmap_copy2(impl, /*5De*/source.impl, /*5Ee*/(C(bool))moveStuff);
}
inline void Bitmap::free()
{
   Bitmap_free(impl);
}
inline Surface Bitmap::getSurface(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Box & clip)
{
   return Surface(Bitmap_getSurface(impl, /*5Ge*/x, /*5Ge*/y, /*5De*/&clip.impl));
}
inline Surface Bitmap::getSurface(/*1Ac*/int x, /*1Ac*/int y, /*1Ac*/Box * clip)
{
   return Surface(Bitmap_getSurface(impl, /*5Gf*/x, /*5Gf*/y, /*5Cf*/(C(Box) *)clip));
}
inline void Bitmap::grab(/*1Ab*/Bitmap & src, /*1Ab*/int x, /*1Ab*/int y)
{
   Bitmap_grab(impl, /*5De*/src.impl, /*5Ge*/x, /*5Ge*/y);
}
inline C(bool) Bitmap::load(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_load(impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::loadFromFile(/*1Ab*/File & file, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_loadFromFile(impl, /*5De*/file.impl, /*5Ge*/type, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::loadGrayed(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_loadGrayed(impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::loadMipMaps(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_loadMipMaps(impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::loadMonochrome(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_loadMonochrome(impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::loadT(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_loadT(impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::loadTMipMaps(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_loadTMipMaps(impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::makeDD(/*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_makeDD(impl, /*5De*/displaySystem.impl);
}
inline C(bool) Bitmap::makeMipMaps(/*1Ab*/DisplaySystem & displaySystem)
{
   return Bitmap_makeMipMaps(impl, /*5De*/displaySystem.impl);
}
inline Bitmap Bitmap::processDD(/*1Ab*/bool mipMaps, /*1Ab*/uint cubeMapFace, /*1Ab*/bool compress, /*1Ab*/int maxTextureSize, /*1Ab*/bool makePow2, /*1Ab*/int enforcedWidth, /*1Ab*/int enforcedHeight)
{
   return Bitmap(Bitmap_processDD(impl, /*5Ee*/(C(bool))mipMaps, /*5Ge*/cubeMapFace, /*5Ee*/(C(bool))compress, /*5Ge*/maxTextureSize, /*5Ee*/(C(bool))makePow2, /*5Ge*/enforcedWidth, /*5Ge*/enforcedHeight));
}
inline C(ColorAlpha) * Bitmap::quantize(/*1Ab*/uint start, /*1Ab*/uint end)
{
   return Bitmap_quantize(impl, /*5Ge*/start, /*5Ge*/end);
}
inline C(bool) Bitmap::save(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/void * options)
{
   return Bitmap_save(impl, /*5Ge*/fileName, /*5Ge*/type, /*5Ge*/options);
}
inline void Bitmap::smoothEdges(/*1Ab*/int size)
{
   Bitmap_smoothEdges(impl, /*5Ge*/size);
}


// member accessors: Bitmap::width
// (normal::int)

/*nstSet*/inline /*0H*/int Bitmap::width_Prop::operator= (/*0H*/int v)
{
   SELF(Bitmap, width);
   IPTR(self->impl, Bitmap)->width = v;
   return v;
}

/*regSet*/inline Bitmap::width_Prop & Bitmap::width_Prop::operator= (Bitmap::width_Prop & prop)
{
   SELF(Bitmap, width);
   /*0H*/int v = prop;
   IPTR(self->impl, Bitmap)->width = v;
   return prop;
}
/*regGet*/inline Bitmap::width_Prop::operator /*0I*/int () const
{
   SELF(Bitmap, width);
   return self ? IPTR(self->impl, Bitmap)->width : 0;
}

// member accessors: Bitmap::height
// (normal::int)

/*nstSet*/inline /*0H*/int Bitmap::height_Prop::operator= (/*0H*/int v)
{
   SELF(Bitmap, height);
   IPTR(self->impl, Bitmap)->height = v;
   return v;
}

/*regSet*/inline Bitmap::height_Prop & Bitmap::height_Prop::operator= (Bitmap::height_Prop & prop)
{
   SELF(Bitmap, height);
   /*0H*/int v = prop;
   IPTR(self->impl, Bitmap)->height = v;
   return prop;
}
/*regGet*/inline Bitmap::height_Prop::operator /*0I*/int () const
{
   SELF(Bitmap, height);
   return self ? IPTR(self->impl, Bitmap)->height : 0;
}

// member accessors: Bitmap::pixelFormat
// (normal::enum|int)

/*nstSet*/inline /*0H*/PixelFormat Bitmap::pixelFormat_Prop::operator= (/*0H*/PixelFormat v)
{
   SELF(Bitmap, pixelFormat);
   IPTR(self->impl, Bitmap)->pixelFormat = (C(PixelFormat))v;
   return v;
}

/*regSet*/inline Bitmap::pixelFormat_Prop & Bitmap::pixelFormat_Prop::operator= (Bitmap::pixelFormat_Prop & prop)
{
   SELF(Bitmap, pixelFormat);
   /*0H*/PixelFormat v = prop;
   IPTR(self->impl, Bitmap)->pixelFormat = (C(PixelFormat))v;
   return prop;
}
/*regGet*/inline Bitmap::pixelFormat_Prop::operator /*0I*/PixelFormat () const
{
   SELF(Bitmap, pixelFormat);
   return self ? (PixelFormat)IPTR(self->impl, Bitmap)->pixelFormat : (PixelFormat)0;
}

// member accessors: Bitmap::picture
// (normal::byte *)

/*nstSet*/inline /*0H*/unsigned char * Bitmap::picture_Prop::operator= (/*0H*/unsigned char * v)
{
   SELF(Bitmap, picture);
   IPTR(self->impl, Bitmap)->picture = v;
   return v;
}

/*regSet*/inline Bitmap::picture_Prop & Bitmap::picture_Prop::operator= (Bitmap::picture_Prop & prop)
{
   SELF(Bitmap, picture);
   /*0H*/unsigned char * v = prop;
   IPTR(self->impl, Bitmap)->picture = v;
   return prop;
}
/*regGet*/inline Bitmap::picture_Prop::operator /*0I*/unsigned char * () const
{
   SELF(Bitmap, picture);
   return self ? IPTR(self->impl, Bitmap)->picture : null;
}

// member accessors: Bitmap::stride
// (normal::uint)

/*nstSet*/inline /*0H*/uint Bitmap::stride_Prop::operator= (/*0H*/uint v)
{
   SELF(Bitmap, stride);
   IPTR(self->impl, Bitmap)->stride = v;
   return v;
}

/*regSet*/inline Bitmap::stride_Prop & Bitmap::stride_Prop::operator= (Bitmap::stride_Prop & prop)
{
   SELF(Bitmap, stride);
   /*0H*/uint v = prop;
   IPTR(self->impl, Bitmap)->stride = v;
   return prop;
}
/*regGet*/inline Bitmap::stride_Prop::operator /*0I*/uint () const
{
   SELF(Bitmap, stride);
   return self ? IPTR(self->impl, Bitmap)->stride : 0;
}

// member accessors: Bitmap::size
// (normal::uint)

/*nstSet*/inline /*0H*/uint Bitmap::size_Prop::operator= (/*0H*/uint v)
{
   SELF(Bitmap, size);
   IPTR(self->impl, Bitmap)->size = v;
   return v;
}

/*regSet*/inline Bitmap::size_Prop & Bitmap::size_Prop::operator= (Bitmap::size_Prop & prop)
{
   SELF(Bitmap, size);
   /*0H*/uint v = prop;
   IPTR(self->impl, Bitmap)->size = v;
   return prop;
}
/*regGet*/inline Bitmap::size_Prop::operator /*0I*/uint () const
{
   SELF(Bitmap, size);
   return self ? IPTR(self->impl, Bitmap)->size : 0;
}

// member accessors: Bitmap::sizeBytes
// (normal::uint)

/*nstSet*/inline /*0H*/uint Bitmap::sizeBytes_Prop::operator= (/*0H*/uint v)
{
   SELF(Bitmap, sizeBytes);
   IPTR(self->impl, Bitmap)->sizeBytes = v;
   return v;
}

/*regSet*/inline Bitmap::sizeBytes_Prop & Bitmap::sizeBytes_Prop::operator= (Bitmap::sizeBytes_Prop & prop)
{
   SELF(Bitmap, sizeBytes);
   /*0H*/uint v = prop;
   IPTR(self->impl, Bitmap)->sizeBytes = v;
   return prop;
}
/*regGet*/inline Bitmap::sizeBytes_Prop::operator /*0I*/uint () const
{
   SELF(Bitmap, sizeBytes);
   return self ? IPTR(self->impl, Bitmap)->sizeBytes : 0;
}

// member accessors: Bitmap::palette
// (normal::bits|unsigned int)

/*nstSet*/inline /*0H*/ColorAlpha * Bitmap::palette_Prop::operator= (/*0H*/ColorAlpha * v)
{
   SELF(Bitmap, palette);
   IPTR(self->impl, Bitmap)->palette = (C(ColorAlpha)*)v;
   return v;
}

/*regSet*/inline Bitmap::palette_Prop & Bitmap::palette_Prop::operator= (Bitmap::palette_Prop & prop)
{
   SELF(Bitmap, palette);
   /*0H*/ColorAlpha * v = prop;
   IPTR(self->impl, Bitmap)->palette = (C(ColorAlpha)*)v;
   return prop;
}
/*regGet*/inline Bitmap::palette_Prop::operator /*0I*/ColorAlpha * () const
{
   SELF(Bitmap, palette);
   return self ? (ColorAlpha *)IPTR(self->impl, Bitmap)->palette : null;
}

// member accessors: Bitmap::allocatePalette
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Bitmap::allocatePalette_Prop::operator= (/*0H*/bool v)
{
   SELF(Bitmap, allocatePalette);
   IPTR(self->impl, Bitmap)->allocatePalette = (C(bool))v;
   return v;
}

/*regSet*/inline Bitmap::allocatePalette_Prop & Bitmap::allocatePalette_Prop::operator= (Bitmap::allocatePalette_Prop & prop)
{
   SELF(Bitmap, allocatePalette);
   /*0H*/bool v = prop;
   IPTR(self->impl, Bitmap)->allocatePalette = (C(bool))v;
   return prop;
}
/*regGet*/inline Bitmap::allocatePalette_Prop::operator /*0I*/bool () const
{
   SELF(Bitmap, allocatePalette);
   return self ? (bool)IPTR(self->impl, Bitmap)->allocatePalette : (bool)0;
}

// member accessors: Bitmap::transparent
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Bitmap::transparent_Prop::operator= (/*0H*/bool v)
{
   SELF(Bitmap, transparent);
   IPTR(self->impl, Bitmap)->transparent = (C(bool))v;
   return v;
}

/*regSet*/inline Bitmap::transparent_Prop & Bitmap::transparent_Prop::operator= (Bitmap::transparent_Prop & prop)
{
   SELF(Bitmap, transparent);
   /*0H*/bool v = prop;
   IPTR(self->impl, Bitmap)->transparent = (C(bool))v;
   return prop;
}
/*regGet*/inline Bitmap::transparent_Prop::operator /*0I*/bool () const
{
   SELF(Bitmap, transparent);
   return self ? (bool)IPTR(self->impl, Bitmap)->transparent : (bool)0;
}

// member accessors: Bitmap::shadeShift
// (normal::int)

/*nstSet*/inline /*0H*/int Bitmap::shadeShift_Prop::operator= (/*0H*/int v)
{
   SELF(Bitmap, shadeShift);
   IPTR(self->impl, Bitmap)->shadeShift = v;
   return v;
}

/*regSet*/inline Bitmap::shadeShift_Prop & Bitmap::shadeShift_Prop::operator= (Bitmap::shadeShift_Prop & prop)
{
   SELF(Bitmap, shadeShift);
   /*0H*/int v = prop;
   IPTR(self->impl, Bitmap)->shadeShift = v;
   return prop;
}
/*regGet*/inline Bitmap::shadeShift_Prop::operator /*0I*/int () const
{
   SELF(Bitmap, shadeShift);
   return self ? IPTR(self->impl, Bitmap)->shadeShift : 0;
}

// member accessors: Bitmap::paletteShades
// (normal::byte *)

/*nstSet*/inline /*0H*/unsigned char * Bitmap::paletteShades_Prop::operator= (/*0H*/unsigned char * v)
{
   SELF(Bitmap, paletteShades);
   IPTR(self->impl, Bitmap)->paletteShades = v;
   return v;
}

/*regSet*/inline Bitmap::paletteShades_Prop & Bitmap::paletteShades_Prop::operator= (Bitmap::paletteShades_Prop & prop)
{
   SELF(Bitmap, paletteShades);
   /*0H*/unsigned char * v = prop;
   IPTR(self->impl, Bitmap)->paletteShades = v;
   return prop;
}
/*regGet*/inline Bitmap::paletteShades_Prop::operator /*0I*/unsigned char * () const
{
   SELF(Bitmap, paletteShades);
   return self ? IPTR(self->impl, Bitmap)->paletteShades : null;
}

// member accessors: Bitmap::alphaBlend
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Bitmap::alphaBlend_Prop::operator= (/*0H*/bool v)
{
   SELF(Bitmap, alphaBlend);
   IPTR(self->impl, Bitmap)->alphaBlend = (C(bool))v;
   return v;
}

/*regSet*/inline Bitmap::alphaBlend_Prop & Bitmap::alphaBlend_Prop::operator= (Bitmap::alphaBlend_Prop & prop)
{
   SELF(Bitmap, alphaBlend);
   /*0H*/bool v = prop;
   IPTR(self->impl, Bitmap)->alphaBlend = (C(bool))v;
   return prop;
}
/*regGet*/inline Bitmap::alphaBlend_Prop::operator /*0I*/bool () const
{
   SELF(Bitmap, alphaBlend);
   return self ? (bool)IPTR(self->impl, Bitmap)->alphaBlend : (bool)0;
}

// member accessors: Bitmap::displaySystem
// (normal::normal)

/*nstSet*/inline /*0H*/DisplaySystem Bitmap::displaySystem_Prop::operator= (/*0H*/DisplaySystem v)
{
   SELF(Bitmap, displaySystem);
   IPTR(self->impl, Bitmap)->displaySystem = v.impl;
   return v;
}

/*regSet*/inline Bitmap::displaySystem_Prop & Bitmap::displaySystem_Prop::operator= (Bitmap::displaySystem_Prop & prop)
{
   SELF(Bitmap, displaySystem);
   /*0H*/DisplaySystem v = prop;
   IPTR(self->impl, Bitmap)->displaySystem = v.impl;
   return prop;
}
/*regGet*/inline Bitmap::displaySystem_Prop::operator /*0I*/DisplaySystem () const
{
   SELF(Bitmap, displaySystem);
   DisplaySystem value(IPTR(self->impl, Bitmap)->displaySystem, Bitmap::_cpp_class);
   return value;
}

// member accessors: Bitmap::driverData
// (normal::void *)

/*nstSet*/inline /*0H*/void * Bitmap::driverData_Prop::operator= (/*0H*/void * v)
{
   SELF(Bitmap, driverData);
   IPTR(self->impl, Bitmap)->driverData = v;
   return v;
}

/*regSet*/inline Bitmap::driverData_Prop & Bitmap::driverData_Prop::operator= (Bitmap::driverData_Prop & prop)
{
   SELF(Bitmap, driverData);
   /*0H*/void * v = prop;
   IPTR(self->impl, Bitmap)->driverData = v;
   return prop;
}
/*regGet*/inline Bitmap::driverData_Prop::operator /*0I*/void * () const
{
   SELF(Bitmap, driverData);
   return self ? IPTR(self->impl, Bitmap)->driverData : null;
}

// member accessors: Bitmap::keepData
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Bitmap::keepData_Prop::operator= (/*0H*/bool v)
{
   SELF(Bitmap, keepData);
   IPTR(self->impl, Bitmap)->keepData = (C(bool))v;
   return v;
}

/*regSet*/inline Bitmap::keepData_Prop & Bitmap::keepData_Prop::operator= (Bitmap::keepData_Prop & prop)
{
   SELF(Bitmap, keepData);
   /*0H*/bool v = prop;
   IPTR(self->impl, Bitmap)->keepData = (C(bool))v;
   return prop;
}
/*regGet*/inline Bitmap::keepData_Prop::operator /*0I*/bool () const
{
   SELF(Bitmap, keepData);
   return self ? (bool)IPTR(self->impl, Bitmap)->keepData : (bool)0;
}

// member accessors: Bitmap::mipMaps
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Bitmap::mipMaps_Prop::operator= (/*0H*/bool v)
{
   SELF(Bitmap, mipMaps);
   IPTR(self->impl, Bitmap)->mipMaps = (C(bool))v;
   return v;
}

/*regSet*/inline Bitmap::mipMaps_Prop & Bitmap::mipMaps_Prop::operator= (Bitmap::mipMaps_Prop & prop)
{
   SELF(Bitmap, mipMaps);
   /*0H*/bool v = prop;
   IPTR(self->impl, Bitmap)->mipMaps = (C(bool))v;
   return prop;
}
/*regGet*/inline Bitmap::mipMaps_Prop::operator /*0I*/bool () const
{
   SELF(Bitmap, mipMaps);
   return self ? (bool)IPTR(self->impl, Bitmap)->mipMaps : (bool)0;
}

// member accessors: Bitmap::sRGB2Linear
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Bitmap::sRGB2Linear_Prop::operator= (/*0H*/bool v)
{
   SELF(Bitmap, sRGB2Linear);
   IPTR(self->impl, Bitmap)->sRGB2Linear = (C(bool))v;
   return v;
}

/*regSet*/inline Bitmap::sRGB2Linear_Prop & Bitmap::sRGB2Linear_Prop::operator= (Bitmap::sRGB2Linear_Prop & prop)
{
   SELF(Bitmap, sRGB2Linear);
   /*0H*/bool v = prop;
   IPTR(self->impl, Bitmap)->sRGB2Linear = (C(bool))v;
   return prop;
}
/*regGet*/inline Bitmap::sRGB2Linear_Prop::operator /*0I*/bool () const
{
   SELF(Bitmap, sRGB2Linear);
   return self ? (bool)IPTR(self->impl, Bitmap)->sRGB2Linear : (bool)0;
}

// member accessors: Bitmap::numMipMaps
// (normal::int)

/*nstSet*/inline /*0H*/int Bitmap::numMipMaps_Prop::operator= (/*0H*/int v)
{
   SELF(Bitmap, numMipMaps);
   IPTR(self->impl, Bitmap)->numMipMaps = v;
   return v;
}

/*regSet*/inline Bitmap::numMipMaps_Prop & Bitmap::numMipMaps_Prop::operator= (Bitmap::numMipMaps_Prop & prop)
{
   SELF(Bitmap, numMipMaps);
   /*0H*/int v = prop;
   IPTR(self->impl, Bitmap)->numMipMaps = v;
   return prop;
}
/*regGet*/inline Bitmap::numMipMaps_Prop::operator /*0I*/int () const
{
   SELF(Bitmap, numMipMaps);
   return self ? IPTR(self->impl, Bitmap)->numMipMaps : 0;
}

// member accessors: Bitmap::bitmaps
// (normal::normal)

/*nstSet*/inline /*0H*/C(Bitmap)* Bitmap::bitmaps_Prop::operator= (/*0H*/C(Bitmap)* v)
{
   SELF(Bitmap, bitmaps);
   IPTR(self->impl, Bitmap)->bitmaps = v;
   return v;
}

/*regSet*/inline Bitmap::bitmaps_Prop & Bitmap::bitmaps_Prop::operator= (Bitmap::bitmaps_Prop & prop)
{
   SELF(Bitmap, bitmaps);
   /*0H*/C(Bitmap)* v = prop;
   IPTR(self->impl, Bitmap)->bitmaps = v;
   return prop;
}
/*regGet*/inline Bitmap::bitmaps_Prop::operator /*0I*/C(Bitmap)* () const
{
   SELF(Bitmap, bitmaps);
   return self ? IPTR(self->impl, Bitmap)->bitmaps : null;
}


inline BitmapResource::BitmapResource(const char * fileName, bool grayed = (bool)0, bool monochrome = (bool)0, bool transparent = (bool)0, bool alphaBlend = (bool)0, bool mipMaps = (bool)0, bool keepData = (bool)0) : BitmapResource()
{
   this->fileName = fileName;
   this->grayed = grayed;
   this->monochrome = monochrome;
   this->transparent = transparent;
   this->alphaBlend = alphaBlend;
   this->mipMaps = mipMaps;
   this->keepData = keepData;
}



// property callers: BitmapResource::fileName
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * BitmapResource::fileName_Prop::operator= (/*0H*/const char * v)
{
   SELF(BitmapResource, fileName);
   BitmapResource_set_fileName(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline BitmapResource::fileName_Prop & BitmapResource::fileName_Prop::operator= (BitmapResource::fileName_Prop & prop)
{
   SELF(BitmapResource, fileName);
   /*0H*/const char * v = prop;
   BitmapResource_set_fileName(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline BitmapResource::fileName_Prop::operator /*0I*/const char * () const
{
   SELF(BitmapResource, fileName);
   return BitmapResource_get_fileName(self ? self->impl : null);
}

// property callers: BitmapResource::grayed
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool BitmapResource::grayed_Prop::operator= (/*0H*/bool v)
{
   SELF(BitmapResource, grayed);
   BitmapResource_set_grayed(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline BitmapResource::grayed_Prop & BitmapResource::grayed_Prop::operator= (BitmapResource::grayed_Prop & prop)
{
   SELF(BitmapResource, grayed);
   /*0H*/bool v = prop;
   BitmapResource_set_grayed(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline BitmapResource::grayed_Prop::operator /*0I*/bool () const
{
   SELF(BitmapResource, grayed);
   return (bool)BitmapResource_get_grayed(self ? self->impl : null);
}

// property callers: BitmapResource::monochrome
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool BitmapResource::monochrome_Prop::operator= (/*0H*/bool v)
{
   SELF(BitmapResource, monochrome);
   BitmapResource_set_monochrome(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline BitmapResource::monochrome_Prop & BitmapResource::monochrome_Prop::operator= (BitmapResource::monochrome_Prop & prop)
{
   SELF(BitmapResource, monochrome);
   /*0H*/bool v = prop;
   BitmapResource_set_monochrome(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline BitmapResource::monochrome_Prop::operator /*0I*/bool () const
{
   SELF(BitmapResource, monochrome);
   return (bool)BitmapResource_get_monochrome(self ? self->impl : null);
}

// property callers: BitmapResource::transparent
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool BitmapResource::transparent_Prop::operator= (/*0H*/bool v)
{
   SELF(BitmapResource, transparent);
   BitmapResource_set_transparent(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline BitmapResource::transparent_Prop & BitmapResource::transparent_Prop::operator= (BitmapResource::transparent_Prop & prop)
{
   SELF(BitmapResource, transparent);
   /*0H*/bool v = prop;
   BitmapResource_set_transparent(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline BitmapResource::transparent_Prop::operator /*0I*/bool () const
{
   SELF(BitmapResource, transparent);
   return (bool)BitmapResource_get_transparent(self ? self->impl : null);
}

// property callers: BitmapResource::alphaBlend
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool BitmapResource::alphaBlend_Prop::operator= (/*0H*/bool v)
{
   SELF(BitmapResource, alphaBlend);
   BitmapResource_set_alphaBlend(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline BitmapResource::alphaBlend_Prop & BitmapResource::alphaBlend_Prop::operator= (BitmapResource::alphaBlend_Prop & prop)
{
   SELF(BitmapResource, alphaBlend);
   /*0H*/bool v = prop;
   BitmapResource_set_alphaBlend(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline BitmapResource::alphaBlend_Prop::operator /*0I*/bool () const
{
   SELF(BitmapResource, alphaBlend);
   return (bool)BitmapResource_get_alphaBlend(self ? self->impl : null);
}

// property callers: BitmapResource::mipMaps
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool BitmapResource::mipMaps_Prop::operator= (/*0H*/bool v)
{
   SELF(BitmapResource, mipMaps);
   BitmapResource_set_mipMaps(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline BitmapResource::mipMaps_Prop & BitmapResource::mipMaps_Prop::operator= (BitmapResource::mipMaps_Prop & prop)
{
   SELF(BitmapResource, mipMaps);
   /*0H*/bool v = prop;
   BitmapResource_set_mipMaps(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline BitmapResource::mipMaps_Prop::operator /*0I*/bool () const
{
   SELF(BitmapResource, mipMaps);
   return (bool)BitmapResource_get_mipMaps(self ? self->impl : null);
}

// property callers: BitmapResource::keepData
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool BitmapResource::keepData_Prop::operator= (/*0H*/bool v)
{
   SELF(BitmapResource, keepData);
   BitmapResource_set_keepData(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline BitmapResource::keepData_Prop & BitmapResource::keepData_Prop::operator= (BitmapResource::keepData_Prop & prop)
{
   SELF(BitmapResource, keepData);
   /*0H*/bool v = prop;
   BitmapResource_set_keepData(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline BitmapResource::keepData_Prop::operator /*0I*/bool () const
{
   SELF(BitmapResource, keepData);
   return (bool)BitmapResource_get_keepData(self ? self->impl : null);
}

// property callers: BitmapResource::bitmap
// (normal::normal)

/*nstSet*/inline /*0A*/const Bitmap & BitmapResource::bitmap_Prop::operator= (/*0A*/const Bitmap & v)
{
   SELF(BitmapResource, bitmap);
   BitmapResource_set_bitmap(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline BitmapResource::bitmap_Prop & BitmapResource::bitmap_Prop::operator= (BitmapResource::bitmap_Prop & prop)
{
   SELF(BitmapResource, bitmap);
   /*0A*/const Bitmap & v = prop;
   BitmapResource_set_bitmap(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Bitmap * BitmapResource::bitmap_Prop::operator= (/*0C*/const Bitmap * v)
{
   SELF(BitmapResource, bitmap);
   BitmapResource_set_bitmap(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline BitmapResource::bitmap_Prop::operator /*0B*/TIH<Bitmap> () const
{
   SELF(BitmapResource, bitmap);
   C(Instance) i = BitmapResource_get_bitmap(self ? self->impl : null);
   TIH<Bitmap> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Bitmap> BitmapResource::bitmap_Prop::operator /*0D*/-> () const
{
   SELF(BitmapResource, bitmap);
   C(Instance) i = BitmapResource_get_bitmap(self ? self->impl : null);
   TIH<Bitmap> holder(i);
   return holder;
}
/*regGet*/inline BitmapResource::bitmap_Prop::operator /*0E*/Bitmap () const
{
   SELF(BitmapResource, bitmap);
   C(Instance) i = BitmapResource_get_bitmap(self ? self->impl : null);
   return Bitmap(i);
}
/*regGet*/inline BitmapResource::bitmap_Prop::operator /*0F*/Bitmap* () const
{
   SELF(BitmapResource, bitmap);
   C(Instance) i = BitmapResource_get_bitmap(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Bitmap *)INSTANCEL(i, i->_class) : (Bitmap *)0;
}

// property callers: BitmapResource::window   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & BitmapResource::window_Prop::operator= (/*0A*/const Window & v)
{
   SELF(BitmapResource, window);
   BitmapResource_set_window(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const Window * BitmapResource::window_Prop::operator= (/*0C*/const Window * v)
{
   SELF(BitmapResource, window);
   BitmapResource_set_window(self ? self->impl : null, v ? v->impl : null);
   return v;
}

// A (bits:struct)
inline Color::operator ColorRGB() const { ColorRGB c; Color_to_ColorRGB(impl, &c.impl); return c; }
inline Color::Color(const ColorRGB & c) { Color_from_ColorRGB(&c.impl); }
inline Color & Color::operator =(const ColorRGB & c) { Color_from_ColorRGB(&c.impl); return *this; }
// B (bits:bits)
inline Color Color::operator= (Color444 value) { return Color444_to_Color(value.impl); }
inline Color::Color(Color444 value) { Color444_to_Color(value.impl); }
inline Color::operator Color444() const { return Color444_from_Color(impl); }
// B (bits:bits)
inline Color Color::operator= (Color555 value) { return Color555_to_Color(value.impl); }
inline Color::Color(Color555 value) { Color555_to_Color(value.impl); }
inline Color::operator Color555() const { return Color555_from_Color(impl); }
// B (bits:bits)
inline Color Color::operator= (Color565 value) { return Color565_to_Color(value.impl); }
inline Color::Color(Color565 value) { Color565_to_Color(value.impl); }
inline Color::operator Color565() const { return Color565_from_Color(impl); }
// B (bits:bits)
inline Color Color::operator= (ColorAlpha value) { return ColorAlpha_to_Color(value.impl); }
inline Color::Color(ColorAlpha value) { ColorAlpha_to_Color(value.impl); }
inline Color::operator ColorAlpha() const { return ColorAlpha_from_Color(impl); }
// B (bits:bits)
inline Color Color::operator= (ColorRGBA value) { return ColorRGBA_to_Color(value.impl); }
inline Color::Color(ColorRGBA value) { ColorRGBA_to_Color(value.impl); }
inline Color::operator ColorRGBA() const { return ColorRGBA_from_Color(impl); }



// member accessors: Color::r
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color::r_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color, r);
   COLOR_SET_r(self->impl, v);
   return v;
}

/*regSet*/inline Color::r_Prop & Color::r_Prop::operator= (Color::r_Prop & prop)
{
   SELF(Color, r);
   /*0H*/unsigned char v = prop;
   COLOR_SET_r(self->impl, v);
   return prop;
}
/*regGet*/inline Color::r_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color, r);
   return COLOR_r(self->impl);
}

// member accessors: Color::g
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color::g_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color, g);
   COLOR_SET_g(self->impl, v);
   return v;
}

/*regSet*/inline Color::g_Prop & Color::g_Prop::operator= (Color::g_Prop & prop)
{
   SELF(Color, g);
   /*0H*/unsigned char v = prop;
   COLOR_SET_g(self->impl, v);
   return prop;
}
/*regGet*/inline Color::g_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color, g);
   return COLOR_g(self->impl);
}

// member accessors: Color::b
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color::b_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color, b);
   COLOR_SET_b(self->impl, v);
   return v;
}

/*regSet*/inline Color::b_Prop & Color::b_Prop::operator= (Color::b_Prop & prop)
{
   SELF(Color, b);
   /*0H*/unsigned char v = prop;
   COLOR_SET_b(self->impl, v);
   return prop;
}
/*regGet*/inline Color::b_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color, b);
   return COLOR_b(self->impl);
}
// A (bits:bits)
inline constexpr Color444::operator Color() const { return Color(impl); }
inline constexpr Color444::Color444(const Color & c) : impl(c.impl) { }
inline constexpr Color444 & Color444::operator =(const Color & c) { impl = c.impl; return *this; }



// member accessors: Color444::r
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color444::r_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color444, r);
   COLOR444_SET_r(self->impl, v);
   return v;
}

/*regSet*/inline Color444::r_Prop & Color444::r_Prop::operator= (Color444::r_Prop & prop)
{
   SELF(Color444, r);
   /*0H*/unsigned char v = prop;
   COLOR444_SET_r(self->impl, v);
   return prop;
}
/*regGet*/inline Color444::r_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color444, r);
   return COLOR444_r(self->impl);
}

// member accessors: Color444::g
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color444::g_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color444, g);
   COLOR444_SET_g(self->impl, v);
   return v;
}

/*regSet*/inline Color444::g_Prop & Color444::g_Prop::operator= (Color444::g_Prop & prop)
{
   SELF(Color444, g);
   /*0H*/unsigned char v = prop;
   COLOR444_SET_g(self->impl, v);
   return prop;
}
/*regGet*/inline Color444::g_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color444, g);
   return COLOR444_g(self->impl);
}

// member accessors: Color444::b
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color444::b_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color444, b);
   COLOR444_SET_b(self->impl, v);
   return v;
}

/*regSet*/inline Color444::b_Prop & Color444::b_Prop::operator= (Color444::b_Prop & prop)
{
   SELF(Color444, b);
   /*0H*/unsigned char v = prop;
   COLOR444_SET_b(self->impl, v);
   return prop;
}
/*regGet*/inline Color444::b_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color444, b);
   return COLOR444_b(self->impl);
}
// A (bits:bits)
inline constexpr Color555::operator Color() const { return Color(impl); }
inline constexpr Color555::Color555(const Color & c) : impl(c.impl) { }
inline constexpr Color555 & Color555::operator =(const Color & c) { impl = c.impl; return *this; }



// member accessors: Color555::r
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color555::r_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color555, r);
   COLOR555_SET_r(self->impl, v);
   return v;
}

/*regSet*/inline Color555::r_Prop & Color555::r_Prop::operator= (Color555::r_Prop & prop)
{
   SELF(Color555, r);
   /*0H*/unsigned char v = prop;
   COLOR555_SET_r(self->impl, v);
   return prop;
}
/*regGet*/inline Color555::r_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color555, r);
   return COLOR555_r(self->impl);
}

// member accessors: Color555::g
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color555::g_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color555, g);
   COLOR555_SET_g(self->impl, v);
   return v;
}

/*regSet*/inline Color555::g_Prop & Color555::g_Prop::operator= (Color555::g_Prop & prop)
{
   SELF(Color555, g);
   /*0H*/unsigned char v = prop;
   COLOR555_SET_g(self->impl, v);
   return prop;
}
/*regGet*/inline Color555::g_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color555, g);
   return COLOR555_g(self->impl);
}

// member accessors: Color555::b
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color555::b_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color555, b);
   COLOR555_SET_b(self->impl, v);
   return v;
}

/*regSet*/inline Color555::b_Prop & Color555::b_Prop::operator= (Color555::b_Prop & prop)
{
   SELF(Color555, b);
   /*0H*/unsigned char v = prop;
   COLOR555_SET_b(self->impl, v);
   return prop;
}
/*regGet*/inline Color555::b_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color555, b);
   return COLOR555_b(self->impl);
}
// A (bits:bits)
inline constexpr Color565::operator Color() const { return Color(impl); }
inline constexpr Color565::Color565(const Color & c) : impl(c.impl) { }
inline constexpr Color565 & Color565::operator =(const Color & c) { impl = c.impl; return *this; }



// member accessors: Color565::r
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color565::r_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color565, r);
   COLOR565_SET_r(self->impl, v);
   return v;
}

/*regSet*/inline Color565::r_Prop & Color565::r_Prop::operator= (Color565::r_Prop & prop)
{
   SELF(Color565, r);
   /*0H*/unsigned char v = prop;
   COLOR565_SET_r(self->impl, v);
   return prop;
}
/*regGet*/inline Color565::r_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color565, r);
   return COLOR565_r(self->impl);
}

// member accessors: Color565::g
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color565::g_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color565, g);
   COLOR565_SET_g(self->impl, v);
   return v;
}

/*regSet*/inline Color565::g_Prop & Color565::g_Prop::operator= (Color565::g_Prop & prop)
{
   SELF(Color565, g);
   /*0H*/unsigned char v = prop;
   COLOR565_SET_g(self->impl, v);
   return prop;
}
/*regGet*/inline Color565::g_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color565, g);
   return COLOR565_g(self->impl);
}

// member accessors: Color565::b
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char Color565::b_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(Color565, b);
   COLOR565_SET_b(self->impl, v);
   return v;
}

/*regSet*/inline Color565::b_Prop & Color565::b_Prop::operator= (Color565::b_Prop & prop)
{
   SELF(Color565, b);
   /*0H*/unsigned char v = prop;
   COLOR565_SET_b(self->impl, v);
   return prop;
}
/*regGet*/inline Color565::b_Prop::operator /*0I*/unsigned char () const
{
   SELF(Color565, b);
   return COLOR565_b(self->impl);
}
// A (bits:bits)
inline constexpr ColorAlpha::operator Color() const { return Color(impl); }
inline constexpr ColorAlpha::ColorAlpha(const Color & c) : impl(c.impl) { }
inline constexpr ColorAlpha & ColorAlpha::operator =(const Color & c) { impl = c.impl; return *this; }
// B (bits:bits)
inline ColorAlpha ColorAlpha::operator= (ColorRGBA value) { return ColorRGBA_to_ColorAlpha(value.impl); }
inline ColorAlpha::ColorAlpha(ColorRGBA value) { ColorRGBA_to_ColorAlpha(value.impl); }
inline ColorAlpha::operator ColorRGBA() const { return ColorRGBA_from_ColorAlpha(impl); }



// member accessors: ColorAlpha::a
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char ColorAlpha::a_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(ColorAlpha, a);
   COLORALPHA_SET_a(self->impl, v);
   return v;
}

/*regSet*/inline ColorAlpha::a_Prop & ColorAlpha::a_Prop::operator= (ColorAlpha::a_Prop & prop)
{
   SELF(ColorAlpha, a);
   /*0H*/unsigned char v = prop;
   COLORALPHA_SET_a(self->impl, v);
   return prop;
}
/*regGet*/inline ColorAlpha::a_Prop::operator /*0I*/unsigned char () const
{
   SELF(ColorAlpha, a);
   return COLORALPHA_a(self->impl);
}

// member accessors: ColorAlpha::color
// (bits::bits|uint)

/*nstSet*/inline /*0H*/Color ColorAlpha::color_Prop::operator= (/*0H*/Color v)
{
   SELF(ColorAlpha, color);
   COLORALPHA_SET_color(self->impl, v);
   return v;
}

/*regSet*/inline ColorAlpha::color_Prop & ColorAlpha::color_Prop::operator= (ColorAlpha::color_Prop & prop)
{
   SELF(ColorAlpha, color);
   /*0H*/Color v = prop;
   COLORALPHA_SET_color(self->impl, v);
   return prop;
}
/*regGet*/inline ColorAlpha::color_Prop::operator /*0I*/Color () const
{
   SELF(ColorAlpha, color);
   return COLORALPHA_color(self->impl);
}
// A (struct:struct)
inline ColorCMYK::operator ColorRGB() const { ColorRGB c; ColorCMYK_to_ColorRGB(&impl, &c.impl); return c; }
inline ColorCMYK::ColorCMYK(const ColorRGB & c) { ColorCMYK_from_ColorRGB(&impl, &c.impl); }
inline ColorCMYK & ColorCMYK::operator =(const ColorRGB & c) { ColorCMYK_from_ColorRGB(&impl, &c.impl); return *this; }

inline ColorCMYK::ColorCMYK(float c, float m = 0, float y = 0, float k = 0)
{
   impl.c = c;
   impl.m = m;
   impl.y = y;
   impl.k = k;
}



// member accessors: ColorCMYK::c
// (struct::float)

/*nstSet*/inline /*0H*/float ColorCMYK::c_Prop::operator= (/*0H*/float v)
{
   SELF(ColorCMYK, c);
   self->impl.c = v;
   return v;
}

/*regSet*/inline ColorCMYK::c_Prop & ColorCMYK::c_Prop::operator= (ColorCMYK::c_Prop & prop)
{
   SELF(ColorCMYK, c);
   /*0H*/float v = prop;
   self->impl.c = v;
   return prop;
}
/*regGet*/inline ColorCMYK::c_Prop::operator /*0I*/float () const
{
   SELF(ColorCMYK, c);
   return self ? ((C(ColorCMYK) *)&self->impl)->c : 0;
}

// member accessors: ColorCMYK::m
// (struct::float)

/*nstSet*/inline /*0H*/float ColorCMYK::m_Prop::operator= (/*0H*/float v)
{
   SELF(ColorCMYK, m);
   self->impl.m = v;
   return v;
}

/*regSet*/inline ColorCMYK::m_Prop & ColorCMYK::m_Prop::operator= (ColorCMYK::m_Prop & prop)
{
   SELF(ColorCMYK, m);
   /*0H*/float v = prop;
   self->impl.m = v;
   return prop;
}
/*regGet*/inline ColorCMYK::m_Prop::operator /*0I*/float () const
{
   SELF(ColorCMYK, m);
   return self ? ((C(ColorCMYK) *)&self->impl)->m : 0;
}

// member accessors: ColorCMYK::y
// (struct::float)

/*nstSet*/inline /*0H*/float ColorCMYK::y_Prop::operator= (/*0H*/float v)
{
   SELF(ColorCMYK, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline ColorCMYK::y_Prop & ColorCMYK::y_Prop::operator= (ColorCMYK::y_Prop & prop)
{
   SELF(ColorCMYK, y);
   /*0H*/float v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline ColorCMYK::y_Prop::operator /*0I*/float () const
{
   SELF(ColorCMYK, y);
   return self ? ((C(ColorCMYK) *)&self->impl)->y : 0;
}

// member accessors: ColorCMYK::k
// (struct::float)

/*nstSet*/inline /*0H*/float ColorCMYK::k_Prop::operator= (/*0H*/float v)
{
   SELF(ColorCMYK, k);
   self->impl.k = v;
   return v;
}

/*regSet*/inline ColorCMYK::k_Prop & ColorCMYK::k_Prop::operator= (ColorCMYK::k_Prop & prop)
{
   SELF(ColorCMYK, k);
   /*0H*/float v = prop;
   self->impl.k = v;
   return prop;
}
/*regGet*/inline ColorCMYK::k_Prop::operator /*0I*/float () const
{
   SELF(ColorCMYK, k);
   return self ? ((C(ColorCMYK) *)&self->impl)->k : 0;
}
// A (struct:struct)
inline ColorHSV::operator ColorRGB() const { ColorRGB c; ColorHSV_to_ColorRGB(&impl, &c.impl); return c; }
inline ColorHSV::ColorHSV(const ColorRGB & c) { ColorHSV_from_ColorRGB(&impl, &c.impl); }
inline ColorHSV & ColorHSV::operator =(const ColorRGB & c) { ColorHSV_from_ColorRGB(&impl, &c.impl); return *this; }

inline ColorHSV::ColorHSV(Degrees h, float s = 0, float v = 0)
{
   impl.h = h.impl;
   impl.s = s;
   impl.v = v;
}



// member accessors: ColorHSV::h
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees ColorHSV::h_Prop::operator= (/*0H*/Degrees v)
{
   SELF(ColorHSV, h);
   self->impl.h = (double)v.impl;
   return v;
}

/*regSet*/inline ColorHSV::h_Prop & ColorHSV::h_Prop::operator= (ColorHSV::h_Prop & prop)
{
   SELF(ColorHSV, h);
   /*0H*/Degrees v = prop;
   self->impl.h = (double)v.impl;
   return prop;
}
/*regGet*/inline ColorHSV::h_Prop::operator /*0I*/Degrees () const
{
   SELF(ColorHSV, h);
   return Degrees(Angle(self->impl.h));
}
/*regGet*/inline ColorHSV::h_Prop::operator /*0J*/C(Angle) () const
{
   SELF(ColorHSV, h);
   return Degrees(self->h);
}

// member accessors: ColorHSV::s
// (struct::float)

/*nstSet*/inline /*0H*/float ColorHSV::s_Prop::operator= (/*0H*/float v)
{
   SELF(ColorHSV, s);
   self->impl.s = v;
   return v;
}

/*regSet*/inline ColorHSV::s_Prop & ColorHSV::s_Prop::operator= (ColorHSV::s_Prop & prop)
{
   SELF(ColorHSV, s);
   /*0H*/float v = prop;
   self->impl.s = v;
   return prop;
}
/*regGet*/inline ColorHSV::s_Prop::operator /*0I*/float () const
{
   SELF(ColorHSV, s);
   return self ? ((C(ColorHSV) *)&self->impl)->s : 0;
}

// member accessors: ColorHSV::v
// (struct::float)

/*nstSet*/inline /*0H*/float ColorHSV::v_Prop::operator= (/*0H*/float v)
{
   SELF(ColorHSV, v);
   self->impl.v = v;
   return v;
}

/*regSet*/inline ColorHSV::v_Prop & ColorHSV::v_Prop::operator= (ColorHSV::v_Prop & prop)
{
   SELF(ColorHSV, v);
   /*0H*/float v = prop;
   self->impl.v = v;
   return prop;
}
/*regGet*/inline ColorHSV::v_Prop::operator /*0I*/float () const
{
   SELF(ColorHSV, v);
   return self ? ((C(ColorHSV) *)&self->impl)->v : 0;
}

inline ColorKey::ColorKey(ColorAlpha color, float percent = 0)
{
   impl.color = color;
   impl.percent = percent;
}



// member accessors: ColorKey::color
// (struct::bits|unsigned int)

/*nstSet*/inline /*0H*/ColorAlpha ColorKey::color_Prop::operator= (/*0H*/ColorAlpha v)
{
   SELF(ColorKey, color);
   self->impl.color = v;
   return v;
}

/*regSet*/inline ColorKey::color_Prop & ColorKey::color_Prop::operator= (ColorKey::color_Prop & prop)
{
   SELF(ColorKey, color);
   /*0H*/ColorAlpha v = prop;
   self->impl.color = v;
   return prop;
}
/*regGet*/inline ColorKey::color_Prop::operator /*0I*/ColorAlpha () const
{
   SELF(ColorKey, color);
   return self ? ColorAlpha(((C(ColorKey) *)&self->impl)->color) : ColorAlpha();
}

// member accessors: ColorKey::percent
// (struct::float)

/*nstSet*/inline /*0H*/float ColorKey::percent_Prop::operator= (/*0H*/float v)
{
   SELF(ColorKey, percent);
   self->impl.percent = v;
   return v;
}

/*regSet*/inline ColorKey::percent_Prop & ColorKey::percent_Prop::operator= (ColorKey::percent_Prop & prop)
{
   SELF(ColorKey, percent);
   /*0H*/float v = prop;
   self->impl.percent = v;
   return prop;
}
/*regGet*/inline ColorKey::percent_Prop::operator /*0I*/float () const
{
   SELF(ColorKey, percent);
   return self ? ((C(ColorKey) *)&self->impl)->percent : 0;
}
// A (struct:struct)
inline ColorLab::operator ColorRGB() const { ColorRGB c; ColorLab_to_ColorRGB(&impl, &c.impl); return c; }
inline ColorLab::ColorLab(const ColorRGB & c) { ColorLab_from_ColorRGB(&impl, &c.impl); }
inline ColorLab & ColorLab::operator =(const ColorRGB & c) { ColorLab_from_ColorRGB(&impl, &c.impl); return *this; }

inline ColorLab::ColorLab(float l, float a = 0, float b = 0)
{
   impl.l = l;
   impl.a = a;
   impl.b = b;
}



// member accessors: ColorLab::l
// (struct::float)

/*nstSet*/inline /*0H*/float ColorLab::l_Prop::operator= (/*0H*/float v)
{
   SELF(ColorLab, l);
   self->impl.l = v;
   return v;
}

/*regSet*/inline ColorLab::l_Prop & ColorLab::l_Prop::operator= (ColorLab::l_Prop & prop)
{
   SELF(ColorLab, l);
   /*0H*/float v = prop;
   self->impl.l = v;
   return prop;
}
/*regGet*/inline ColorLab::l_Prop::operator /*0I*/float () const
{
   SELF(ColorLab, l);
   return self ? ((C(ColorLab) *)&self->impl)->l : 0;
}

// member accessors: ColorLab::a
// (struct::float)

/*nstSet*/inline /*0H*/float ColorLab::a_Prop::operator= (/*0H*/float v)
{
   SELF(ColorLab, a);
   self->impl.a = v;
   return v;
}

/*regSet*/inline ColorLab::a_Prop & ColorLab::a_Prop::operator= (ColorLab::a_Prop & prop)
{
   SELF(ColorLab, a);
   /*0H*/float v = prop;
   self->impl.a = v;
   return prop;
}
/*regGet*/inline ColorLab::a_Prop::operator /*0I*/float () const
{
   SELF(ColorLab, a);
   return self ? ((C(ColorLab) *)&self->impl)->a : 0;
}

// member accessors: ColorLab::b
// (struct::float)

/*nstSet*/inline /*0H*/float ColorLab::b_Prop::operator= (/*0H*/float v)
{
   SELF(ColorLab, b);
   self->impl.b = v;
   return v;
}

/*regSet*/inline ColorLab::b_Prop & ColorLab::b_Prop::operator= (ColorLab::b_Prop & prop)
{
   SELF(ColorLab, b);
   /*0H*/float v = prop;
   self->impl.b = v;
   return prop;
}
/*regGet*/inline ColorLab::b_Prop::operator /*0I*/float () const
{
   SELF(ColorLab, b);
   return self ? ((C(ColorLab) *)&self->impl)->b : 0;
}
// B (struct:bits)
inline ColorRGB & ColorRGB::operator= (Color value) { Color_to_ColorRGB(value.impl, &impl); return *this; }
inline ColorRGB::ColorRGB(Color value) { Color_to_ColorRGB(value.impl, &impl); }
inline ColorRGB::operator Color() const { return Color_from_ColorRGB(&impl); }
// C (struct:enum)
inline ColorRGB & ColorRGB::operator= (DefinedColor value) { Color_to_ColorRGB((C(Color))value, &impl); return *this; }
inline ColorRGB::ColorRGB(DefinedColor value) { Color_to_ColorRGB((C(Color))value, &impl); }
// C (struct:enum)
inline ColorRGB & ColorRGB::operator= (SystemColor value) { Color_to_ColorRGB((C(Color))value, &impl); return *this; }
inline ColorRGB::ColorRGB(SystemColor value) { Color_to_ColorRGB((C(Color))value, &impl); }

inline ColorRGB::ColorRGB(float r, float g = 0, float b = 0)
{
   impl.r = r;
   impl.g = g;
   impl.b = b;
}



// member accessors: ColorRGB::r
// (struct::float)

/*nstSet*/inline /*0H*/float ColorRGB::r_Prop::operator= (/*0H*/float v)
{
   SELF(ColorRGB, r);
   self->impl.r = v;
   return v;
}

/*regSet*/inline ColorRGB::r_Prop & ColorRGB::r_Prop::operator= (ColorRGB::r_Prop & prop)
{
   SELF(ColorRGB, r);
   /*0H*/float v = prop;
   self->impl.r = v;
   return prop;
}
/*regGet*/inline ColorRGB::r_Prop::operator /*0I*/float () const
{
   SELF(ColorRGB, r);
   return self ? ((C(ColorRGB) *)&self->impl)->r : 0;
}

// member accessors: ColorRGB::g
// (struct::float)

/*nstSet*/inline /*0H*/float ColorRGB::g_Prop::operator= (/*0H*/float v)
{
   SELF(ColorRGB, g);
   self->impl.g = v;
   return v;
}

/*regSet*/inline ColorRGB::g_Prop & ColorRGB::g_Prop::operator= (ColorRGB::g_Prop & prop)
{
   SELF(ColorRGB, g);
   /*0H*/float v = prop;
   self->impl.g = v;
   return prop;
}
/*regGet*/inline ColorRGB::g_Prop::operator /*0I*/float () const
{
   SELF(ColorRGB, g);
   return self ? ((C(ColorRGB) *)&self->impl)->g : 0;
}

// member accessors: ColorRGB::b
// (struct::float)

/*nstSet*/inline /*0H*/float ColorRGB::b_Prop::operator= (/*0H*/float v)
{
   SELF(ColorRGB, b);
   self->impl.b = v;
   return v;
}

/*regSet*/inline ColorRGB::b_Prop & ColorRGB::b_Prop::operator= (ColorRGB::b_Prop & prop)
{
   SELF(ColorRGB, b);
   /*0H*/float v = prop;
   self->impl.b = v;
   return prop;
}
/*regGet*/inline ColorRGB::b_Prop::operator /*0I*/float () const
{
   SELF(ColorRGB, b);
   return self ? ((C(ColorRGB) *)&self->impl)->b : 0;
}
// A (bits:bits)
inline constexpr ColorRGBA::operator ColorAlpha() const { return ColorAlpha(impl); }
inline constexpr ColorRGBA::ColorRGBA(const ColorAlpha & c) : impl(c.impl) { }
inline constexpr ColorRGBA & ColorRGBA::operator =(const ColorAlpha & c) { impl = c.impl; return *this; }
// A (bits:bits)
inline constexpr ColorRGBA::operator Color() const { return Color(impl); }
inline constexpr ColorRGBA::ColorRGBA(const Color & c) : impl(c.impl) { }
inline constexpr ColorRGBA & ColorRGBA::operator =(const Color & c) { impl = c.impl; return *this; }



// member accessors: ColorRGBA::r
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char ColorRGBA::r_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(ColorRGBA, r);
   COLORRGBA_SET_r(self->impl, v);
   return v;
}

/*regSet*/inline ColorRGBA::r_Prop & ColorRGBA::r_Prop::operator= (ColorRGBA::r_Prop & prop)
{
   SELF(ColorRGBA, r);
   /*0H*/unsigned char v = prop;
   COLORRGBA_SET_r(self->impl, v);
   return prop;
}
/*regGet*/inline ColorRGBA::r_Prop::operator /*0I*/unsigned char () const
{
   SELF(ColorRGBA, r);
   return COLORRGBA_r(self->impl);
}

// member accessors: ColorRGBA::g
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char ColorRGBA::g_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(ColorRGBA, g);
   COLORRGBA_SET_g(self->impl, v);
   return v;
}

/*regSet*/inline ColorRGBA::g_Prop & ColorRGBA::g_Prop::operator= (ColorRGBA::g_Prop & prop)
{
   SELF(ColorRGBA, g);
   /*0H*/unsigned char v = prop;
   COLORRGBA_SET_g(self->impl, v);
   return prop;
}
/*regGet*/inline ColorRGBA::g_Prop::operator /*0I*/unsigned char () const
{
   SELF(ColorRGBA, g);
   return COLORRGBA_g(self->impl);
}

// member accessors: ColorRGBA::b
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char ColorRGBA::b_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(ColorRGBA, b);
   COLORRGBA_SET_b(self->impl, v);
   return v;
}

/*regSet*/inline ColorRGBA::b_Prop & ColorRGBA::b_Prop::operator= (ColorRGBA::b_Prop & prop)
{
   SELF(ColorRGBA, b);
   /*0H*/unsigned char v = prop;
   COLORRGBA_SET_b(self->impl, v);
   return prop;
}
/*regGet*/inline ColorRGBA::b_Prop::operator /*0I*/unsigned char () const
{
   SELF(ColorRGBA, b);
   return COLORRGBA_b(self->impl);
}

// member accessors: ColorRGBA::a
// (bits::byte)

/*nstSet*/inline /*0H*/unsigned char ColorRGBA::a_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(ColorRGBA, a);
   COLORRGBA_SET_a(self->impl, v);
   return v;
}

/*regSet*/inline ColorRGBA::a_Prop & ColorRGBA::a_Prop::operator= (ColorRGBA::a_Prop & prop)
{
   SELF(ColorRGBA, a);
   /*0H*/unsigned char v = prop;
   COLORRGBA_SET_a(self->impl, v);
   return prop;
}
/*regGet*/inline ColorRGBA::a_Prop::operator /*0I*/unsigned char () const
{
   SELF(ColorRGBA, a);
   return COLORRGBA_a(self->impl);
}
// A (struct:bits)
inline ColorRGBAf::operator ColorAlpha() const { ColorAlpha c = ColorRGBAf_to_ColorAlpha(&impl); return c; }
inline ColorRGBAf::ColorRGBAf(const ColorAlpha & c) { ColorRGBAf_from_ColorAlpha(&impl, c.impl); }
inline ColorRGBAf & ColorRGBAf::operator =(const ColorAlpha & c) { ColorRGBAf_from_ColorAlpha(&impl, c.impl); return *this; }
// A (struct:bits)
inline ColorRGBAf::operator Color() const { Color c = ColorRGBAf_to_Color(&impl); return c; }
inline ColorRGBAf::ColorRGBAf(const Color & c) { ColorRGBAf_from_Color(&impl, c.impl); }
inline ColorRGBAf & ColorRGBAf::operator =(const Color & c) { ColorRGBAf_from_Color(&impl, c.impl); return *this; }

inline ColorRGBAf::ColorRGBAf(float r, float g = 0, float b = 0, float a = 0)
{
   impl.r = r;
   impl.g = g;
   impl.b = b;
   impl.a = a;
}



// member accessors: ColorRGBAf::r
// (struct::float)

/*nstSet*/inline /*0H*/float ColorRGBAf::r_Prop::operator= (/*0H*/float v)
{
   SELF(ColorRGBAf, r);
   self->impl.r = v;
   return v;
}

/*regSet*/inline ColorRGBAf::r_Prop & ColorRGBAf::r_Prop::operator= (ColorRGBAf::r_Prop & prop)
{
   SELF(ColorRGBAf, r);
   /*0H*/float v = prop;
   self->impl.r = v;
   return prop;
}
/*regGet*/inline ColorRGBAf::r_Prop::operator /*0I*/float () const
{
   SELF(ColorRGBAf, r);
   return self ? ((C(ColorRGBAf) *)&self->impl)->r : 0;
}

// member accessors: ColorRGBAf::g
// (struct::float)

/*nstSet*/inline /*0H*/float ColorRGBAf::g_Prop::operator= (/*0H*/float v)
{
   SELF(ColorRGBAf, g);
   self->impl.g = v;
   return v;
}

/*regSet*/inline ColorRGBAf::g_Prop & ColorRGBAf::g_Prop::operator= (ColorRGBAf::g_Prop & prop)
{
   SELF(ColorRGBAf, g);
   /*0H*/float v = prop;
   self->impl.g = v;
   return prop;
}
/*regGet*/inline ColorRGBAf::g_Prop::operator /*0I*/float () const
{
   SELF(ColorRGBAf, g);
   return self ? ((C(ColorRGBAf) *)&self->impl)->g : 0;
}

// member accessors: ColorRGBAf::b
// (struct::float)

/*nstSet*/inline /*0H*/float ColorRGBAf::b_Prop::operator= (/*0H*/float v)
{
   SELF(ColorRGBAf, b);
   self->impl.b = v;
   return v;
}

/*regSet*/inline ColorRGBAf::b_Prop & ColorRGBAf::b_Prop::operator= (ColorRGBAf::b_Prop & prop)
{
   SELF(ColorRGBAf, b);
   /*0H*/float v = prop;
   self->impl.b = v;
   return prop;
}
/*regGet*/inline ColorRGBAf::b_Prop::operator /*0I*/float () const
{
   SELF(ColorRGBAf, b);
   return self ? ((C(ColorRGBAf) *)&self->impl)->b : 0;
}

// member accessors: ColorRGBAf::a
// (struct::float)

/*nstSet*/inline /*0H*/float ColorRGBAf::a_Prop::operator= (/*0H*/float v)
{
   SELF(ColorRGBAf, a);
   self->impl.a = v;
   return v;
}

/*regSet*/inline ColorRGBAf::a_Prop & ColorRGBAf::a_Prop::operator= (ColorRGBAf::a_Prop & prop)
{
   SELF(ColorRGBAf, a);
   /*0H*/float v = prop;
   self->impl.a = v;
   return prop;
}
/*regGet*/inline ColorRGBAf::a_Prop::operator /*0I*/float () const
{
   SELF(ColorRGBAf, a);
   return self ? ((C(ColorRGBAf) *)&self->impl)->a : 0;
}


inline C(bool) CubeMap::load(/*1Ab*/DisplaySystem & displaySystem, constString * names, constString extension, /*1Ab*/bool oldStyle)
{
   return CubeMap_load(impl, /*5De*/displaySystem.impl, /*5Ge*/names, /*5Ge*/extension, /*5Ee*/(C(bool))oldStyle);
}
inline C(bool) CubeMap::loadFromFiles(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/C(File) files[6], constString extension, /*1Ab*/bool oldStyle)
{
   return CubeMap_loadFromFiles(impl, /*5De*/displaySystem.impl, /*5Ge*/files, /*5Ge*/extension, /*5Ee*/(C(bool))oldStyle);
}

inline Display::Display(FillModeValue fillMode, bool depthTest = (bool)0, bool depthWrite = (bool)0, float fogDensity = 0, Color fogColor = Color(), bool blend = (bool)0, Color ambient = Color(), bool alphaWrite = (bool)0, bool antiAlias = (bool)0, bool vSync = (bool)0, bool pickingPlanes = (bool)0, int maxFullSort = 0, bool fullProjCheck = (bool)0, bool alphaBlend = (bool)0, bool useSharedMemory = (bool)0, GLCapabilities glCapabilities = GLCapabilities(), int width = 0, int height = 0, void * driverData = null) : Display()
{
   this->fillMode = fillMode;
   this->depthTest = depthTest;
   this->depthWrite = depthWrite;
   this->fogDensity = fogDensity;
   this->fogColor = fogColor;
   this->blend = blend;
   this->ambient = ambient;
   this->alphaWrite = alphaWrite;
   this->antiAlias = antiAlias;
   this->vSync = vSync;
   this->pickingPlanes = pickingPlanes;
   this->maxFullSort = maxFullSort;
   this->fullProjCheck = fullProjCheck;
   this->alphaBlend = alphaBlend;
   this->useSharedMemory = useSharedMemory;
   this->glCapabilities = glCapabilities;
   this->width = width;
   this->height = height;
   this->driverData = driverData;
}


inline void Display::applyMaterial(/*1Ab*/Material material, /*1Ab*/Mesh mesh)
{
   Display_applyMaterial(impl, /*5De*/material.impl, /*5De*/mesh.impl);
}
inline void Display::collectHits()
{
   Display_collectHits(impl);
}
inline C(bool) Display::create(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/void * window)
{
   return Display_create(impl, /*5De*/displaySystem.impl, /*5Ge*/window);
}
inline C(bool) Display::drawMesh(/*1Ab*/Object object)
{
   return Display_drawMesh(impl, /*5De*/object.impl);
}
inline C(bool) Display::drawMeshEx(/*1Ab*/Object object, /*1Ab*/uint64 * id)
{
   return Display_drawMeshEx(impl, /*5De*/object.impl, /*5Ge*/id);
}
inline C(bool) Display::drawObject(/*1Ab*/Object object)
{
   return Display_drawObject(impl, /*5De*/object.impl);
}
inline C(bool) Display::drawObjectEx(/*1Ab*/Object object, /*1Ab*/uint64 * id)
{
   return Display_drawObjectEx(impl, /*5De*/object.impl, /*5Ge*/id);
}
inline void Display::drawPrimitives(/*1Ab*/PrimitiveSingle & primitive, /*1Ab*/Mesh mesh)
{
   Display_drawPrimitives(impl, /*5De*/&primitive.impl, /*5De*/mesh.impl);
}
inline void Display::drawPrimitives(/*1Ac*/PrimitiveSingle * primitive, /*1Ac*/Mesh mesh)
{
   Display_drawPrimitives(impl, /*5Cf*/(C(PrimitiveSingle) *)primitive, /*5Df*/mesh.impl);
}
inline void Display::drawTranslucency()
{
   Display_drawTranslucency(impl);
}
inline void Display::endUpdate()
{
   Display_endUpdate(impl);
}
inline void Display::fontExtent(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height)
{
   Display_fontExtent(impl, /*5De*/font.impl, /*5Ge*/text, /*5Ge*/len, /*5Ge*/width, /*5Ge*/height);
}
inline void Display::fontExtent2(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang)
{
   Display_fontExtent2(impl, /*5De*/font.impl, /*5Ge*/text, /*5Ge*/len, /*5Ge*/width, /*5Ge*/height, /*5Ge*/prevGlyph, /*5Ge*/rPrevGlyph, /*5Ge*/overHang);
}
inline int Display::getHits(/*1Ab*/OldList & list)
{
   return Display_getHits(impl, /*5De*/&list.impl);
}
inline int Display::getHits(/*1Ac*/OldList * list)
{
   return Display_getHits(impl, /*5Cf*/(C(OldList) *)list);
}
inline C(bool) Display::getIntersect(/*1Ab*/Vector3D & intersect)
{
   return Display_getIntersect(impl, /*5De*/&intersect.impl);
}
inline C(bool) Display::getIntersect(/*1Ac*/Vector3D * intersect)
{
   return Display_getIntersect(impl, /*5Cf*/(C(Vector3D) *)intersect);
}
inline Surface Display::getSurface(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Box & clip)
{
   return Surface(Display_getSurface(impl, /*5Ge*/x, /*5Ge*/y, /*5De*/&clip.impl));
}
inline Surface Display::getSurface(/*1Ac*/int x, /*1Ac*/int y, /*1Ac*/Box * clip)
{
   return Surface(Display_getSurface(impl, /*5Gf*/x, /*5Gf*/y, /*5Cf*/(C(Box) *)clip));
}
inline C(bool) Display::grab(/*1Ab*/Bitmap & bitmap, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h)
{
   return Display_grab(impl, /*5De*/bitmap.impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/w, /*5Ge*/h);
}
inline void Display::intersectPolygons()
{
   Display_intersectPolygons(impl);
}
inline C(bool) Display::isObjectVisible(/*1Ab*/Object object)
{
   return Display_isObjectVisible(impl, /*5De*/object.impl);
}
inline C(bool) Display::lock(/*1Ab*/bool render)
{
   return Display_lock(impl, /*5Ee*/(C(bool))render);
}
inline void Display::nextPage()
{
   Display_nextPage(impl);
}
inline void Display::popMatrix()
{
   Display_popMatrix(impl);
}
inline void Display::position(/*1Ab*/int x, /*1Ab*/int y)
{
   Display_position(impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Display::pushMatrix()
{
   Display_pushMatrix(impl);
}
inline C(bool) Display::resize(/*1Ab*/int width, /*1Ab*/int height)
{
   return Display_resize(impl, /*5Ge*/width, /*5Ge*/height);
}
inline void Display::restorePalette()
{
   Display_restorePalette(impl);
}
inline void Display::scroll(/*1Ab*/Box & scroll, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Extent & dirty)
{
   Display_scroll(impl, /*5De*/&scroll.impl, /*5Ge*/x, /*5Ge*/y, /*5De*/&dirty.impl);
}
inline void Display::scroll(/*1Ac*/Box * scroll, /*1Ac*/int x, /*1Ac*/int y, /*1Ac*/Extent * dirty)
{
   Display_scroll(impl, /*5Cf*/(C(Box) *)scroll, /*5Gf*/x, /*5Gf*/y, /*5Cf*/(C(Extent) *)dirty);
}
inline void Display::selectMesh(/*1Ab*/Mesh mesh)
{
   Display_selectMesh(impl, /*5De*/mesh.impl);
}
inline void Display::setCamera(/*1Ab*/Surface & surface, /*1Ab*/const Camera & camera)
{
   Display_setCamera(impl, /*5De*/surface.impl, /*5De*/camera.impl);
}
inline void Display::setCameraVR(/*1Ab*/Camera & camera, /*1Ab*/int eye, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/GLFB & output, /*1Ab*/const Matrix & prjMat)
{
   Display_setCameraVR(impl, /*5De*/camera.impl, /*5Ge*/eye, /*5Ge*/w, /*5Ge*/h, /*5De*/&output.impl, /*5De*/&prjMat.impl);
}
inline void Display::setCameraVR(/*1Ac*/Camera & camera, /*1Ac*/int eye, /*1Ac*/int w, /*1Ac*/int h, /*1Ac*/GLFB * output, /*1Ac*/const Matrix * prjMat)
{
   Display_setCameraVR(impl, /*5Df*/camera.impl, /*5Gf*/eye, /*5Gf*/w, /*5Gf*/h, /*5Cf*/(C(GLFB) *)output, /*5Cf*/(C(Matrix) *)prjMat);
}
inline void Display::setLight(/*1Ab*/int id, /*1Ab*/Light & light)
{
   Display_setLight(impl, /*5Ge*/id, /*5De*/&light.impl);
}
inline void Display::setLight(/*1Ac*/int id, /*1Ac*/Light * light)
{
   Display_setLight(impl, /*5Gf*/id, /*5Cf*/(C(Light) *)light);
}
inline void Display::setLights(/*1Ab*/Object object)
{
   Display_setLights(impl, /*5De*/object.impl);
}
inline void Display::setPalette(/*1Ab*/ColorAlpha * palette, /*1Ab*/bool colorMatch)
{
   Display_setPalette(impl, /*5Ee*/(C(ColorAlpha) *)palette, /*5Ee*/(C(bool))colorMatch);
}
inline void Display::setTransform(/*1Ab*/Matrix & matrix, /*1Ab*/bool viewSpace)
{
   Display_setTransform(impl, /*5De*/&matrix.impl, /*5Ee*/(C(bool))viewSpace);
}
inline void Display::setTransform(/*1Ac*/Matrix * matrix, /*1Ac*/bool viewSpace)
{
   Display_setTransform(impl, /*5Cf*/(C(Matrix) *)matrix, /*5Ef*/(C(bool))viewSpace);
}
inline void Display::startSelection(/*1Ab*/int pickX, /*1Ab*/int pickY, /*1Ab*/int pickW, /*1Ab*/int pickH)
{
   Display_startSelection(impl, /*5Ge*/pickX, /*5Ge*/pickY, /*5Ge*/pickW, /*5Ge*/pickH);
}
inline void Display::startUpdate()
{
   Display_startUpdate(impl);
}
inline void Display::stopSelection()
{
   Display_stopSelection(impl);
}
inline void Display::unlock()
{
   Display_unlock(impl);
}
inline void Display::update(/*1Ab*/Box & updateBox)
{
   Display_update(impl, /*5De*/&updateBox.impl);
}
inline void Display::update(/*1Ac*/Box * updateBox)
{
   Display_update(impl, /*5Cf*/(C(Box) *)updateBox);
}


// property callers: Display::fillMode   // set only
// (normal::enum|int)

/*nstSet*/inline /*0G*/FillModeValue Display::fillMode_Prop::operator= (/*0G*/FillModeValue v)
{
   SELF(Display, fillMode);
   Display_set_fillMode(self->impl, (C(FillModeValue))v);
   return v;
}


// property callers: Display::depthTest   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Display::depthTest_Prop::operator= (/*0G*/bool v)
{
   SELF(Display, depthTest);
   Display_set_depthTest(self->impl, (C(bool))v);
   return v;
}


// property callers: Display::depthWrite   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Display::depthWrite_Prop::operator= (/*0G*/bool v)
{
   SELF(Display, depthWrite);
   Display_set_depthWrite(self->impl, (C(bool))v);
   return v;
}


// property callers: Display::fogDensity   // set only
// (normal::float)

/*nstSet*/inline /*0G*/float Display::fogDensity_Prop::operator= (/*0G*/float v)
{
   SELF(Display, fogDensity);
   Display_set_fogDensity(self->impl, v);
   return v;
}


// property callers: Display::fogColor   // set only
// (normal::bits|uint)

/*nstSet*/inline /*0G*/Color Display::fogColor_Prop::operator= (/*0G*/Color v)
{
   SELF(Display, fogColor);
   Display_set_fogColor(self->impl, v);
   return v;
}


// property callers: Display::blend   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Display::blend_Prop::operator= (/*0G*/bool v)
{
   SELF(Display, blend);
   Display_set_blend(self->impl, (C(bool))v);
   return v;
}


// property callers: Display::ambient   // set only
// (normal::bits|uint)

/*nstSet*/inline /*0G*/Color Display::ambient_Prop::operator= (/*0G*/Color v)
{
   SELF(Display, ambient);
   Display_set_ambient(self->impl, v);
   return v;
}


// property callers: Display::alphaWrite   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Display::alphaWrite_Prop::operator= (/*0G*/bool v)
{
   SELF(Display, alphaWrite);
   Display_set_alphaWrite(self->impl, (C(bool))v);
   return v;
}


// property callers: Display::antiAlias   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Display::antiAlias_Prop::operator= (/*0G*/bool v)
{
   SELF(Display, antiAlias);
   Display_set_antiAlias(self->impl, (C(bool))v);
   return v;
}


// property callers: Display::vSync   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Display::vSync_Prop::operator= (/*0G*/bool v)
{
   SELF(Display, vSync);
   Display_set_vSync(self->impl, (C(bool))v);
   return v;
}


// property callers: Display::pickingPlanes   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Display::pickingPlanes_Prop::operator= (/*0G*/bool v)
{
   SELF(Display, pickingPlanes);
   Display_set_pickingPlanes(self->impl, (C(bool))v);
   return v;
}


// property callers: Display::maxFullSort
// (normal::int)

/*nstSet*/inline /*0H*/int Display::maxFullSort_Prop::operator= (/*0H*/int v)
{
   SELF(Display, maxFullSort);
   Display_set_maxFullSort(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Display::maxFullSort_Prop & Display::maxFullSort_Prop::operator= (Display::maxFullSort_Prop & prop)
{
   SELF(Display, maxFullSort);
   /*0H*/int v = prop;
   Display_set_maxFullSort(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Display::maxFullSort_Prop::operator /*0I*/int () const
{
   SELF(Display, maxFullSort);
   return Display_get_maxFullSort(self ? self->impl : null);
}

// property callers: Display::fullProjCheck
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Display::fullProjCheck_Prop::operator= (/*0H*/bool v)
{
   SELF(Display, fullProjCheck);
   Display_set_fullProjCheck(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Display::fullProjCheck_Prop & Display::fullProjCheck_Prop::operator= (Display::fullProjCheck_Prop & prop)
{
   SELF(Display, fullProjCheck);
   /*0H*/bool v = prop;
   Display_set_fullProjCheck(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Display::fullProjCheck_Prop::operator /*0I*/bool () const
{
   SELF(Display, fullProjCheck);
   return (bool)Display_get_fullProjCheck(self ? self->impl : null);
}

// property callers: Display::flags   // get only
// (normal::bits|unsigned int)

/*regGet*/inline Display::flags_Prop::operator /*0I*/DisplayFlags () const
{
   SELF(Display, flags);
   return Display_get_flags(self ? self->impl : null);
}

// property callers: Display::pixelFormat   // get only
// (normal::enum|int)

/*regGet*/inline Display::pixelFormat_Prop::operator /*0I*/PixelFormat () const
{
   SELF(Display, pixelFormat);
   return (PixelFormat)Display_get_pixelFormat(self ? self->impl : null);
}

// property callers: Display::alphaBlend
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Display::alphaBlend_Prop::operator= (/*0H*/bool v)
{
   SELF(Display, alphaBlend);
   Display_set_alphaBlend(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Display::alphaBlend_Prop & Display::alphaBlend_Prop::operator= (Display::alphaBlend_Prop & prop)
{
   SELF(Display, alphaBlend);
   /*0H*/bool v = prop;
   Display_set_alphaBlend(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Display::alphaBlend_Prop::operator /*0I*/bool () const
{
   SELF(Display, alphaBlend);
   return (bool)Display_get_alphaBlend(self ? self->impl : null);
}

// property callers: Display::useSharedMemory
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Display::useSharedMemory_Prop::operator= (/*0H*/bool v)
{
   SELF(Display, useSharedMemory);
   Display_set_useSharedMemory(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Display::useSharedMemory_Prop & Display::useSharedMemory_Prop::operator= (Display::useSharedMemory_Prop & prop)
{
   SELF(Display, useSharedMemory);
   /*0H*/bool v = prop;
   Display_set_useSharedMemory(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Display::useSharedMemory_Prop::operator /*0I*/bool () const
{
   SELF(Display, useSharedMemory);
   return (bool)Display_get_useSharedMemory(self ? self->impl : null);
}

// property callers: Display::systemWindow   // get only
// (normal::void *)

/*regGet*/inline Display::systemWindow_Prop::operator /*0I*/void * () const
{
   SELF(Display, systemWindow);
   return Display_get_systemWindow(self ? self->impl : null);
}

// property callers: Display::displaySystem   // get only
// (normal::normal)

/*regGet*/inline Display::displaySystem_Prop::operator /*0B*/TIH<DisplaySystem> () const
{
   SELF(Display, displaySystem);
   C(Instance) i = Display_get_displaySystem(self ? self->impl : null);
   TIH<DisplaySystem> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DisplaySystem> Display::displaySystem_Prop::operator /*0D*/-> () const
{
   SELF(Display, displaySystem);
   C(Instance) i = Display_get_displaySystem(self ? self->impl : null);
   TIH<DisplaySystem> holder(i);
   return holder;
}
/*regGet*/inline Display::displaySystem_Prop::operator /*0E*/DisplaySystem () const
{
   SELF(Display, displaySystem);
   C(Instance) i = Display_get_displaySystem(self ? self->impl : null);
   return DisplaySystem(i);
}
/*regGet*/inline Display::displaySystem_Prop::operator /*0F*/DisplaySystem* () const
{
   SELF(Display, displaySystem);
   C(Instance) i = Display_get_displaySystem(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DisplaySystem *)INSTANCEL(i, i->_class) : (DisplaySystem *)0;
}

// property callers: Display::glCapabilities
// (normal::bits|uint)

/*nstSet*/inline /*0H*/GLCapabilities Display::glCapabilities_Prop::operator= (/*0H*/GLCapabilities v)
{
   SELF(Display, glCapabilities);
   Display_set_glCapabilities(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Display::glCapabilities_Prop & Display::glCapabilities_Prop::operator= (Display::glCapabilities_Prop & prop)
{
   SELF(Display, glCapabilities);
   /*0H*/GLCapabilities v = prop;
   Display_set_glCapabilities(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Display::glCapabilities_Prop::operator /*0I*/GLCapabilities () const
{
   SELF(Display, glCapabilities);
   return Display_get_glCapabilities(self ? self->impl : null);
}

// property callers: Display::glVersion   // get only
// (normal::int)

/*regGet*/inline Display::glVersion_Prop::operator /*0I*/int () const
{
   SELF(Display, glVersion);
   return Display_get_glVersion(self ? self->impl : null);
}


// member accessors: Display::width
// (normal::int)

/*nstSet*/inline /*0H*/int Display::width_Prop::operator= (/*0H*/int v)
{
   SELF(Display, width);
   IPTR(self->impl, Display)->width = v;
   return v;
}

/*regSet*/inline Display::width_Prop & Display::width_Prop::operator= (Display::width_Prop & prop)
{
   SELF(Display, width);
   /*0H*/int v = prop;
   IPTR(self->impl, Display)->width = v;
   return prop;
}
/*regGet*/inline Display::width_Prop::operator /*0I*/int () const
{
   SELF(Display, width);
   return self ? IPTR(self->impl, Display)->width : 0;
}

// member accessors: Display::height
// (normal::int)

/*nstSet*/inline /*0H*/int Display::height_Prop::operator= (/*0H*/int v)
{
   SELF(Display, height);
   IPTR(self->impl, Display)->height = v;
   return v;
}

/*regSet*/inline Display::height_Prop & Display::height_Prop::operator= (Display::height_Prop & prop)
{
   SELF(Display, height);
   /*0H*/int v = prop;
   IPTR(self->impl, Display)->height = v;
   return prop;
}
/*regGet*/inline Display::height_Prop::operator /*0I*/int () const
{
   SELF(Display, height);
   return self ? IPTR(self->impl, Display)->height : 0;
}

// member accessors: Display::driverData
// (normal::void *)

/*nstSet*/inline /*0H*/void * Display::driverData_Prop::operator= (/*0H*/void * v)
{
   SELF(Display, driverData);
   IPTR(self->impl, Display)->driverData = v;
   return v;
}

/*regSet*/inline Display::driverData_Prop & Display::driverData_Prop::operator= (Display::driverData_Prop & prop)
{
   SELF(Display, driverData);
   /*0H*/void * v = prop;
   IPTR(self->impl, Display)->driverData = v;
   return prop;
}
/*regGet*/inline Display::driverData_Prop::operator /*0I*/void * () const
{
   SELF(Display, driverData);
   return self ? IPTR(self->impl, Display)->driverData : null;
}

inline DisplayDriver::DisplayDriver_allocateBitmap_Functor::FunctionType DisplayDriver::DisplayDriver_allocateBitmap_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, allocateBitmap);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_allocateBitmap_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_allocateBitmap_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_allocateBitmap_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, allocateBitmap)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_allocateBitmap_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5, /*6Fj*/PixelFormat ap6, /*6Fj*/bool ap7)
{
   SELF(DisplayDriver, allocateBitmap);
   return (bool)DisplayDriver_allocateBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5, /*7Al*/(C(PixelFormat))ap6, /*7Al*/(C(bool))ap7);
}
// inline void DisplayDriver::register_allocateBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_allocateBitmap_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_allocateBitmap_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, allocateBitmap)] = func;
// }

inline DisplayDriver::DisplayDriver_allocateIndices_Functor::FunctionType DisplayDriver::DisplayDriver_allocateIndices_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, allocateIndices);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_allocateIndices_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_allocateIndices_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_allocateIndices_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, allocateIndices)] = func;
   return func;
}
inline void * DisplayDriver::DisplayDriver_allocateIndices_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/int nIndices, /*6Fj*/bool indices32bit)
{
   SELF(DisplayDriver, allocateIndices);
   return DisplayDriver_allocateIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/nIndices, /*7Al*/(C(bool))indices32bit);
}
// inline void DisplayDriver::register_allocateIndices(CPPClass & cl, DisplayDriver::DisplayDriver_allocateIndices_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_allocateIndices_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, allocateIndices)] = func;
// }

inline DisplayDriver::DisplayDriver_allocateMesh_Functor::FunctionType DisplayDriver::DisplayDriver_allocateMesh_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, allocateMesh);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_allocateMesh_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_allocateMesh_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_allocateMesh_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, allocateMesh)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_allocateMesh_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures ap3, /*6Fj*/int nVertices)
{
   SELF(DisplayDriver, allocateMesh);
   return (bool)DisplayDriver_allocateMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(MeshFeatures))ap3, /*7Al*/nVertices);
}
// inline void DisplayDriver::register_allocateMesh(CPPClass & cl, DisplayDriver::DisplayDriver_allocateMesh_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_allocateMesh_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, allocateMesh)] = func;
// }

inline DisplayDriver::DisplayDriver_applyMaterial_Functor::FunctionType DisplayDriver::DisplayDriver_applyMaterial_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, applyMaterial);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_applyMaterial_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_applyMaterial_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_applyMaterial_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, applyMaterial)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_applyMaterial_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Material ap2, /*6Fj*/Mesh ap3)
{
   SELF(DisplayDriver, applyMaterial);
   DisplayDriver_applyMaterial(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl);
}
// inline void DisplayDriver::register_applyMaterial(CPPClass & cl, DisplayDriver::DisplayDriver_applyMaterial_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_applyMaterial_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, applyMaterial)] = func;
// }

inline DisplayDriver::DisplayDriver_area_Functor::FunctionType DisplayDriver::DisplayDriver_area_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, area);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_area_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_area_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_area_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, area)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_area_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2)
{
   SELF(DisplayDriver, area);
   DisplayDriver_area(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x1, /*7Al*/y1, /*7Al*/x2, /*7Al*/y2);
}
// inline void DisplayDriver::register_area(CPPClass & cl, DisplayDriver::DisplayDriver_area_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_area_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, area)] = func;
// }

inline DisplayDriver::DisplayDriver_blit_Functor::FunctionType DisplayDriver::DisplayDriver_blit_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, blit);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_blit_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_blit_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_blit_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, blit)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_blit_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h)
{
   SELF(DisplayDriver, blit);
   DisplayDriver_blit(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h);
}
// inline void DisplayDriver::register_blit(CPPClass & cl, DisplayDriver::DisplayDriver_blit_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_blit_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, blit)] = func;
// }

inline DisplayDriver::DisplayDriver_blitDI_Functor::FunctionType DisplayDriver::DisplayDriver_blitDI_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, blitDI);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_blitDI_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_blitDI_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_blitDI_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, blitDI)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_blitDI_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h)
{
   SELF(DisplayDriver, blitDI);
   DisplayDriver_blitDI(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h);
}
// inline void DisplayDriver::register_blitDI(CPPClass & cl, DisplayDriver::DisplayDriver_blitDI_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_blitDI_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, blitDI)] = func;
// }

inline DisplayDriver::DisplayDriver_clear_Functor::FunctionType DisplayDriver::DisplayDriver_clear_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, clear);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_clear_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_clear_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_clear_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, clear)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_clear_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ClearType ap3)
{
   SELF(DisplayDriver, clear);
   DisplayDriver_clear(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ClearType))ap3);
}
// inline void DisplayDriver::register_clear(CPPClass & cl, DisplayDriver::DisplayDriver_clear_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_clear_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, clear)] = func;
// }

inline DisplayDriver::DisplayDriver_clip_Functor::FunctionType DisplayDriver::DisplayDriver_clip_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, clip);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_clip_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_clip_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_clip_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, clip)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_clip_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Box & ap3)
{
   SELF(DisplayDriver, clip);
   DisplayDriver_clip(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/&ap3.impl);
}
// inline void DisplayDriver::register_clip(CPPClass & cl, DisplayDriver::DisplayDriver_clip_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_clip_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, clip)] = func;
// }

inline DisplayDriver::DisplayDriver_convertBitmap_Functor::FunctionType DisplayDriver::DisplayDriver_convertBitmap_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, convertBitmap);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_convertBitmap_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_convertBitmap_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_convertBitmap_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, convertBitmap)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_convertBitmap_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/PixelFormat ap3, /*6Fj*/ColorAlpha * ap4)
{
   SELF(DisplayDriver, convertBitmap);
   return (bool)DisplayDriver_convertBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(PixelFormat))ap3, /*7Al*/(C(ColorAlpha) *)ap4);
}
// inline void DisplayDriver::register_convertBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_convertBitmap_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_convertBitmap_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, convertBitmap)] = func;
// }

inline DisplayDriver::DisplayDriver_createDisplay_Functor::FunctionType DisplayDriver::DisplayDriver_createDisplay_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, createDisplay);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_createDisplay_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_createDisplay_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_createDisplay_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, createDisplay)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_createDisplay_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, createDisplay);
   return (bool)DisplayDriver_createDisplay(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_createDisplay(CPPClass & cl, DisplayDriver::DisplayDriver_createDisplay_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_createDisplay_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, createDisplay)] = func;
// }

inline DisplayDriver::DisplayDriver_createDisplaySystem_Functor::FunctionType DisplayDriver::DisplayDriver_createDisplaySystem_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, createDisplaySystem);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_createDisplaySystem_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_createDisplaySystem_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_createDisplaySystem_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, createDisplaySystem)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_createDisplaySystem_Functor::operator()( /*6Fj*/DisplaySystem & ap1)
{
   SELF(DisplayDriver, createDisplaySystem);
   return (bool)DisplayDriver_createDisplaySystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_createDisplaySystem(CPPClass & cl, DisplayDriver::DisplayDriver_createDisplaySystem_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_createDisplaySystem_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, createDisplaySystem)] = func;
// }

inline DisplayDriver::DisplayDriver_destroyDisplay_Functor::FunctionType DisplayDriver::DisplayDriver_destroyDisplay_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, destroyDisplay);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_destroyDisplay_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_destroyDisplay_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_destroyDisplay_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, destroyDisplay)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_destroyDisplay_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, destroyDisplay);
   DisplayDriver_destroyDisplay(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_destroyDisplay(CPPClass & cl, DisplayDriver::DisplayDriver_destroyDisplay_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_destroyDisplay_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, destroyDisplay)] = func;
// }

inline DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::FunctionType DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, destroyDisplaySystem);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, destroyDisplaySystem)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::operator()( /*6Fj*/DisplaySystem & ap1)
{
   SELF(DisplayDriver, destroyDisplaySystem);
   DisplayDriver_destroyDisplaySystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_destroyDisplaySystem(CPPClass & cl, DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_destroyDisplaySystem_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, destroyDisplaySystem)] = func;
// }

inline DisplayDriver::DisplayDriver_displayPosition_Functor::FunctionType DisplayDriver::DisplayDriver_displayPosition_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, displayPosition);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_displayPosition_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_displayPosition_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_displayPosition_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, displayPosition)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_displayPosition_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3)
{
   SELF(DisplayDriver, displayPosition);
   DisplayDriver_displayPosition(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3);
}
// inline void DisplayDriver::register_displayPosition(CPPClass & cl, DisplayDriver::DisplayDriver_displayPosition_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_displayPosition_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, displayPosition)] = func;
// }

inline DisplayDriver::DisplayDriver_displaySize_Functor::FunctionType DisplayDriver::DisplayDriver_displaySize_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, displaySize);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_displaySize_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_displaySize_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_displaySize_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, displaySize)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_displaySize_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3)
{
   SELF(DisplayDriver, displaySize);
   return (bool)DisplayDriver_displaySize(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3);
}
// inline void DisplayDriver::register_displaySize(CPPClass & cl, DisplayDriver::DisplayDriver_displaySize_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_displaySize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, displaySize)] = func;
// }

inline DisplayDriver::DisplayDriver_drawLine_Functor::FunctionType DisplayDriver::DisplayDriver_drawLine_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, drawLine);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_drawLine_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_drawLine_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_drawLine_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, drawLine)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_drawLine_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2)
{
   SELF(DisplayDriver, drawLine);
   DisplayDriver_drawLine(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x1, /*7Al*/y1, /*7Al*/x2, /*7Al*/y2);
}
// inline void DisplayDriver::register_drawLine(CPPClass & cl, DisplayDriver::DisplayDriver_drawLine_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_drawLine_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, drawLine)] = func;
// }

inline DisplayDriver::DisplayDriver_drawPrimitives_Functor::FunctionType DisplayDriver::DisplayDriver_drawPrimitives_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, drawPrimitives);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_drawPrimitives_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_drawPrimitives_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_drawPrimitives_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, drawPrimitives)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_drawPrimitives_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/PrimitiveSingle & ap2, /*6Fj*/Mesh mesh)
{
   SELF(DisplayDriver, drawPrimitives);
   DisplayDriver_drawPrimitives(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl, /*7Al*/mesh.impl);
}
// inline void DisplayDriver::register_drawPrimitives(CPPClass & cl, DisplayDriver::DisplayDriver_drawPrimitives_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_drawPrimitives_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, drawPrimitives)] = func;
// }

inline DisplayDriver::DisplayDriver_drawingChar_Functor::FunctionType DisplayDriver::DisplayDriver_drawingChar_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, drawingChar);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_drawingChar_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_drawingChar_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_drawingChar_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, drawingChar)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_drawingChar_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/char ch)
{
   SELF(DisplayDriver, drawingChar);
   DisplayDriver_drawingChar(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ch);
}
// inline void DisplayDriver::register_drawingChar(CPPClass & cl, DisplayDriver::DisplayDriver_drawingChar_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_drawingChar_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, drawingChar)] = func;
// }

inline DisplayDriver::DisplayDriver_endUpdate_Functor::FunctionType DisplayDriver::DisplayDriver_endUpdate_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, endUpdate);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_endUpdate_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_endUpdate_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_endUpdate_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, endUpdate)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_endUpdate_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, endUpdate);
   DisplayDriver_endUpdate(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_endUpdate(CPPClass & cl, DisplayDriver::DisplayDriver_endUpdate_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_endUpdate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, endUpdate)] = func;
// }

inline DisplayDriver::DisplayDriver_filter_Functor::FunctionType DisplayDriver::DisplayDriver_filter_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, filter);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_filter_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_filter_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_filter_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, filter)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_filter_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh)
{
   SELF(DisplayDriver, filter);
   DisplayDriver_filter(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);
}
// inline void DisplayDriver::register_filter(CPPClass & cl, DisplayDriver::DisplayDriver_filter_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_filter_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, filter)] = func;
// }

inline DisplayDriver::DisplayDriver_filterDI_Functor::FunctionType DisplayDriver::DisplayDriver_filterDI_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, filterDI);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_filterDI_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_filterDI_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_filterDI_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, filterDI)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_filterDI_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh)
{
   SELF(DisplayDriver, filterDI);
   DisplayDriver_filterDI(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);
}
// inline void DisplayDriver::register_filterDI(CPPClass & cl, DisplayDriver::DisplayDriver_filterDI_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_filterDI_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, filterDI)] = func;
// }

inline DisplayDriver::DisplayDriver_fontExtent_Functor::FunctionType DisplayDriver::DisplayDriver_fontExtent_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, fontExtent);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_fontExtent_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_fontExtent_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_fontExtent_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, fontExtent)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_fontExtent_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Font ap2, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int * tw, /*6Fj*/int * th, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph, /*6Fj*/int * overHang)
{
   SELF(DisplayDriver, fontExtent);
   DisplayDriver_fontExtent(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/text, /*7Al*/len, /*7Al*/tw, /*7Al*/th, /*7Al*/prevGlyph, /*7Al*/rPrevGlyph, /*7Al*/overHang);
}
// inline void DisplayDriver::register_fontExtent(CPPClass & cl, DisplayDriver::DisplayDriver_fontExtent_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_fontExtent_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, fontExtent)] = func;
// }

inline DisplayDriver::DisplayDriver_freeBitmap_Functor::FunctionType DisplayDriver::DisplayDriver_freeBitmap_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, freeBitmap);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_freeBitmap_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_freeBitmap_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_freeBitmap_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, freeBitmap)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_freeBitmap_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2)
{
   SELF(DisplayDriver, freeBitmap);
   DisplayDriver_freeBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);
}
// inline void DisplayDriver::register_freeBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_freeBitmap_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_freeBitmap_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, freeBitmap)] = func;
// }

inline DisplayDriver::DisplayDriver_freeIndices_Functor::FunctionType DisplayDriver::DisplayDriver_freeIndices_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, freeIndices);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_freeIndices_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_freeIndices_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_freeIndices_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, freeIndices)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_freeIndices_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group)
{
   SELF(DisplayDriver, freeIndices);
   DisplayDriver_freeIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&group.impl);
}
// inline void DisplayDriver::register_freeIndices(CPPClass & cl, DisplayDriver::DisplayDriver_freeIndices_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_freeIndices_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, freeIndices)] = func;
// }

inline DisplayDriver::DisplayDriver_freeMesh_Functor::FunctionType DisplayDriver::DisplayDriver_freeMesh_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, freeMesh);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_freeMesh_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_freeMesh_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_freeMesh_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, freeMesh)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_freeMesh_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2)
{
   SELF(DisplayDriver, freeMesh);
   DisplayDriver_freeMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);
}
// inline void DisplayDriver::register_freeMesh(CPPClass & cl, DisplayDriver::DisplayDriver_freeMesh_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_freeMesh_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, freeMesh)] = func;
// }

inline DisplayDriver::DisplayDriver_getBitmapSurface_Functor::FunctionType DisplayDriver::DisplayDriver_getBitmapSurface_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, getBitmapSurface);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_getBitmapSurface_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_getBitmapSurface_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_getBitmapSurface_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, getBitmapSurface)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_getBitmapSurface_Functor::operator()( /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/Surface & surface, /*6Fj*/Bitmap & bitmap, /*6Fj*/int ap1, /*6Fj*/int ap2, /*6Fj*/Box & ap3)
{
   SELF(DisplayDriver, getBitmapSurface);
   return (bool)DisplayDriver_getBitmapSurface(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl, /*7Al*/surface.impl, /*7Al*/bitmap.impl, /*7Al*/ap1, /*7Al*/ap2, /*7Al*/&ap3.impl);
}
// inline void DisplayDriver::register_getBitmapSurface(CPPClass & cl, DisplayDriver::DisplayDriver_getBitmapSurface_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_getBitmapSurface_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, getBitmapSurface)] = func;
// }

inline DisplayDriver::DisplayDriver_getPixel_Functor::FunctionType DisplayDriver::DisplayDriver_getPixel_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, getPixel);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_getPixel_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_getPixel_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_getPixel_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, getPixel)] = func;
   return func;
}
inline ColorAlpha DisplayDriver::DisplayDriver_getPixel_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y)
{
   SELF(DisplayDriver, getPixel);
   return DisplayDriver_getPixel(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x, /*7Al*/y);
}
// inline void DisplayDriver::register_getPixel(CPPClass & cl, DisplayDriver::DisplayDriver_getPixel_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_getPixel_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, getPixel)] = func;
// }

inline DisplayDriver::DisplayDriver_getSurface_Functor::FunctionType DisplayDriver::DisplayDriver_getSurface_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, getSurface);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_getSurface_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_getSurface_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_getSurface_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, getSurface)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_getSurface_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & surface, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/Box & ap4)
{
   SELF(DisplayDriver, getSurface);
   return (bool)DisplayDriver_getSurface(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/surface.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/&ap4.impl);
}
// inline void DisplayDriver::register_getSurface(CPPClass & cl, DisplayDriver::DisplayDriver_getSurface_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_getSurface_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, getSurface)] = func;
// }

inline DisplayDriver::DisplayDriver_grabScreen_Functor::FunctionType DisplayDriver::DisplayDriver_grabScreen_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, grabScreen);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_grabScreen_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_grabScreen_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_grabScreen_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, grabScreen)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_grabScreen_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/uint ap5, /*6Fj*/uint ap6)
{
   SELF(DisplayDriver, grabScreen);
   return (bool)DisplayDriver_grabScreen(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5, /*7Al*/ap6);
}
// inline void DisplayDriver::register_grabScreen(CPPClass & cl, DisplayDriver::DisplayDriver_grabScreen_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_grabScreen_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, grabScreen)] = func;
// }

inline DisplayDriver::DisplayDriver_lineStipple_Functor::FunctionType DisplayDriver::DisplayDriver_lineStipple_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, lineStipple);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_lineStipple_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_lineStipple_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_lineStipple_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, lineStipple)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_lineStipple_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/uint pattern)
{
   SELF(DisplayDriver, lineStipple);
   DisplayDriver_lineStipple(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/pattern);
}
// inline void DisplayDriver::register_lineStipple(CPPClass & cl, DisplayDriver::DisplayDriver_lineStipple_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_lineStipple_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, lineStipple)] = func;
// }

inline DisplayDriver::DisplayDriver_loadFont_Functor::FunctionType DisplayDriver::DisplayDriver_loadFont_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, loadFont);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_loadFont_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_loadFont_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_loadFont_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, loadFont)] = func;
   return func;
}
inline Font DisplayDriver::DisplayDriver_loadFont_Functor::operator()( /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/const char * faceName, /*6Fj*/float size, /*6Fj*/FontFlags flags, /*6Fj*/float outlineSize, /*6Fj*/float outlineFade)
{
   SELF(DisplayDriver, loadFont);
   C(Font) * retFont = DisplayDriver_loadFont(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl, /*7Al*/faceName, /*7Al*/size, /*7Al*/(C(FontFlags))flags, /*7Al*/outlineSize, /*7Al*/outlineFade);
      return retFont;
}
// inline void DisplayDriver::register_loadFont(CPPClass & cl, DisplayDriver::DisplayDriver_loadFont_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_loadFont_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, loadFont)] = func;
// }

inline DisplayDriver::DisplayDriver_lock_Functor::FunctionType DisplayDriver::DisplayDriver_lock_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, lock);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_lock_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_lock_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_lock_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, lock)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_lock_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, lock);
   return (bool)DisplayDriver_lock(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_lock(CPPClass & cl, DisplayDriver::DisplayDriver_lock_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_lock_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, lock)] = func;
// }

inline DisplayDriver::DisplayDriver_lockIndices_Functor::FunctionType DisplayDriver::DisplayDriver_lockIndices_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, lockIndices);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_lockIndices_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_lockIndices_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_lockIndices_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, lockIndices)] = func;
   return func;
}
inline uint16 * DisplayDriver::DisplayDriver_lockIndices_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group)
{
   SELF(DisplayDriver, lockIndices);
   return DisplayDriver_lockIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&group.impl);
}
// inline void DisplayDriver::register_lockIndices(CPPClass & cl, DisplayDriver::DisplayDriver_lockIndices_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_lockIndices_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, lockIndices)] = func;
// }

inline DisplayDriver::DisplayDriver_lockMesh_Functor::FunctionType DisplayDriver::DisplayDriver_lockMesh_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, lockMesh);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_lockMesh_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_lockMesh_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_lockMesh_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, lockMesh)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_lockMesh_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures flags)
{
   SELF(DisplayDriver, lockMesh);
   return (bool)DisplayDriver_lockMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(MeshFeatures))flags);
}
// inline void DisplayDriver::register_lockMesh(CPPClass & cl, DisplayDriver::DisplayDriver_lockMesh_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_lockMesh_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, lockMesh)] = func;
// }

inline DisplayDriver::DisplayDriver_lockSystem_Functor::FunctionType DisplayDriver::DisplayDriver_lockSystem_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, lockSystem);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_lockSystem_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_lockSystem_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_lockSystem_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, lockSystem)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_lockSystem_Functor::operator()( /*6Fj*/DisplaySystem & displaySystem)
{
   SELF(DisplayDriver, lockSystem);
   return (bool)DisplayDriver_lockSystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl);
}
// inline void DisplayDriver::register_lockSystem(CPPClass & cl, DisplayDriver::DisplayDriver_lockSystem_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_lockSystem_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, lockSystem)] = func;
// }

inline DisplayDriver::DisplayDriver_makeDDBitmap_Functor::FunctionType DisplayDriver::DisplayDriver_makeDDBitmap_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, makeDDBitmap);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_makeDDBitmap_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_makeDDBitmap_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_makeDDBitmap_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, makeDDBitmap)] = func;
   return func;
}
inline bool DisplayDriver::DisplayDriver_makeDDBitmap_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Bitmap & ap2, /*6Fj*/bool mipMaps, /*6Fj*/int cubeMapFace)
{
   SELF(DisplayDriver, makeDDBitmap);
   return (bool)DisplayDriver_makeDDBitmap(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(bool))mipMaps, /*7Al*/cubeMapFace);
}
// inline void DisplayDriver::register_makeDDBitmap(CPPClass & cl, DisplayDriver::DisplayDriver_makeDDBitmap_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_makeDDBitmap_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, makeDDBitmap)] = func;
// }

inline DisplayDriver::DisplayDriver_nextPage_Functor::FunctionType DisplayDriver::DisplayDriver_nextPage_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, nextPage);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_nextPage_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_nextPage_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_nextPage_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, nextPage)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_nextPage_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, nextPage);
   DisplayDriver_nextPage(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_nextPage(CPPClass & cl, DisplayDriver::DisplayDriver_nextPage_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_nextPage_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, nextPage)] = func;
// }

inline DisplayDriver::DisplayDriver_popMatrix_Functor::FunctionType DisplayDriver::DisplayDriver_popMatrix_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, popMatrix);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_popMatrix_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_popMatrix_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_popMatrix_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, popMatrix)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_popMatrix_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/bool ap2)
{
   SELF(DisplayDriver, popMatrix);
   DisplayDriver_popMatrix(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/(C(bool))ap2);
}
// inline void DisplayDriver::register_popMatrix(CPPClass & cl, DisplayDriver::DisplayDriver_popMatrix_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_popMatrix_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, popMatrix)] = func;
// }

inline DisplayDriver::DisplayDriver_pushMatrix_Functor::FunctionType DisplayDriver::DisplayDriver_pushMatrix_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, pushMatrix);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_pushMatrix_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_pushMatrix_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_pushMatrix_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, pushMatrix)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_pushMatrix_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, pushMatrix);
   DisplayDriver_pushMatrix(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_pushMatrix(CPPClass & cl, DisplayDriver::DisplayDriver_pushMatrix_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_pushMatrix_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, pushMatrix)] = func;
// }

inline DisplayDriver::DisplayDriver_putPixel_Functor::FunctionType DisplayDriver::DisplayDriver_putPixel_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, putPixel);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_putPixel_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_putPixel_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_putPixel_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, putPixel)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_putPixel_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y)
{
   SELF(DisplayDriver, putPixel);
   DisplayDriver_putPixel(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x, /*7Al*/y);
}
// inline void DisplayDriver::register_putPixel(CPPClass & cl, DisplayDriver::DisplayDriver_putPixel_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_putPixel_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, putPixel)] = func;
// }

inline DisplayDriver::DisplayDriver_rectangle_Functor::FunctionType DisplayDriver::DisplayDriver_rectangle_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, rectangle);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_rectangle_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_rectangle_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_rectangle_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, rectangle)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_rectangle_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x1, /*6Fj*/int y1, /*6Fj*/int x2, /*6Fj*/int y2)
{
   SELF(DisplayDriver, rectangle);
   DisplayDriver_rectangle(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x1, /*7Al*/y1, /*7Al*/x2, /*7Al*/y2);
}
// inline void DisplayDriver::register_rectangle(CPPClass & cl, DisplayDriver::DisplayDriver_rectangle_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_rectangle_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, rectangle)] = func;
// }

inline DisplayDriver::DisplayDriver_releaseSurface_Functor::FunctionType DisplayDriver::DisplayDriver_releaseSurface_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, releaseSurface);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_releaseSurface_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_releaseSurface_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_releaseSurface_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, releaseSurface)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_releaseSurface_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2)
{
   SELF(DisplayDriver, releaseSurface);
   DisplayDriver_releaseSurface(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);
}
// inline void DisplayDriver::register_releaseSurface(CPPClass & cl, DisplayDriver::DisplayDriver_releaseSurface_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_releaseSurface_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, releaseSurface)] = func;
// }

inline DisplayDriver::DisplayDriver_restorePalette_Functor::FunctionType DisplayDriver::DisplayDriver_restorePalette_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, restorePalette);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_restorePalette_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_restorePalette_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_restorePalette_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, restorePalette)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_restorePalette_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, restorePalette);
   DisplayDriver_restorePalette(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_restorePalette(CPPClass & cl, DisplayDriver::DisplayDriver_restorePalette_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_restorePalette_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, restorePalette)] = func;
// }

inline DisplayDriver::DisplayDriver_scroll_Functor::FunctionType DisplayDriver::DisplayDriver_scroll_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, scroll);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_scroll_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_scroll_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_scroll_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, scroll)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_scroll_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Box & ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/Extent & ap5)
{
   SELF(DisplayDriver, scroll);
   DisplayDriver_scroll(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/&ap5.impl);
}
// inline void DisplayDriver::register_scroll(CPPClass & cl, DisplayDriver::DisplayDriver_scroll_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_scroll_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, scroll)] = func;
// }

inline DisplayDriver::DisplayDriver_selectMesh_Functor::FunctionType DisplayDriver::DisplayDriver_selectMesh_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, selectMesh);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_selectMesh_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_selectMesh_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_selectMesh_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, selectMesh)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_selectMesh_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Mesh ap2)
{
   SELF(DisplayDriver, selectMesh);
   DisplayDriver_selectMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);
}
// inline void DisplayDriver::register_selectMesh(CPPClass & cl, DisplayDriver::DisplayDriver_selectMesh_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_selectMesh_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, selectMesh)] = func;
// }

inline DisplayDriver::DisplayDriver_setBackground_Functor::FunctionType DisplayDriver::DisplayDriver_setBackground_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setBackground);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setBackground_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setBackground_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setBackground_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setBackground)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setBackground_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3)
{
   SELF(DisplayDriver, setBackground);
   DisplayDriver_setBackground(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ColorAlpha))ap3);
}
// inline void DisplayDriver::register_setBackground(CPPClass & cl, DisplayDriver::DisplayDriver_setBackground_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setBackground_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setBackground)] = func;
// }

inline DisplayDriver::DisplayDriver_setBlitTint_Functor::FunctionType DisplayDriver::DisplayDriver_setBlitTint_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setBlitTint);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setBlitTint_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setBlitTint_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setBlitTint_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setBlitTint)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setBlitTint_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3)
{
   SELF(DisplayDriver, setBlitTint);
   DisplayDriver_setBlitTint(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ColorAlpha))ap3);
}
// inline void DisplayDriver::register_setBlitTint(CPPClass & cl, DisplayDriver::DisplayDriver_setBlitTint_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setBlitTint_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setBlitTint)] = func;
// }

inline DisplayDriver::DisplayDriver_setCamera_Functor::FunctionType DisplayDriver::DisplayDriver_setCamera_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setCamera);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setCamera_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setCamera_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setCamera_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setCamera)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setCamera_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Camera & ap3)
{
   SELF(DisplayDriver, setCamera);
   DisplayDriver_setCamera(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl);
}
// inline void DisplayDriver::register_setCamera(CPPClass & cl, DisplayDriver::DisplayDriver_setCamera_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setCamera_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setCamera)] = func;
// }

inline DisplayDriver::DisplayDriver_setCameraVR_Functor::FunctionType DisplayDriver::DisplayDriver_setCameraVR_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setCameraVR);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setCameraVR_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setCameraVR_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setCameraVR_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setCameraVR)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setCameraVR_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Camera & ap2, /*6Fj*/int eye, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/void * fb, /*6Fj*/const Matrix & prjMat)
{
   SELF(DisplayDriver, setCameraVR);
   DisplayDriver_setCameraVR(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/eye, /*7Al*/w, /*7Al*/h, /*7Al*/fb, /*7Al*/&prjMat.impl);
}
// inline void DisplayDriver::register_setCameraVR(CPPClass & cl, DisplayDriver::DisplayDriver_setCameraVR_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setCameraVR_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setCameraVR)] = func;
// }

inline DisplayDriver::DisplayDriver_setForeground_Functor::FunctionType DisplayDriver::DisplayDriver_setForeground_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setForeground);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setForeground_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setForeground_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setForeground_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setForeground)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setForeground_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/ColorAlpha ap3)
{
   SELF(DisplayDriver, setForeground);
   DisplayDriver_setForeground(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(ColorAlpha))ap3);
}
// inline void DisplayDriver::register_setForeground(CPPClass & cl, DisplayDriver::DisplayDriver_setForeground_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setForeground_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setForeground)] = func;
// }

inline DisplayDriver::DisplayDriver_setLight_Functor::FunctionType DisplayDriver::DisplayDriver_setLight_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setLight);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setLight_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setLight_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setLight_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setLight)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setLight_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/int ap2, /*6Fj*/Light & ap3)
{
   SELF(DisplayDriver, setLight);
   DisplayDriver_setLight(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/&ap3.impl);
}
// inline void DisplayDriver::register_setLight(CPPClass & cl, DisplayDriver::DisplayDriver_setLight_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setLight_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setLight)] = func;
// }

inline DisplayDriver::DisplayDriver_setPalette_Functor::FunctionType DisplayDriver::DisplayDriver_setPalette_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setPalette);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setPalette_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setPalette_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setPalette_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setPalette)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setPalette_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/ColorAlpha * ap2, /*6Fj*/bool ap3)
{
   SELF(DisplayDriver, setPalette);
   DisplayDriver_setPalette(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/(C(ColorAlpha) *)ap2, /*7Al*/(C(bool))ap3);
}
// inline void DisplayDriver::register_setPalette(CPPClass & cl, DisplayDriver::DisplayDriver_setPalette_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setPalette_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setPalette)] = func;
// }

inline DisplayDriver::DisplayDriver_setRenderState_Functor::FunctionType DisplayDriver::DisplayDriver_setRenderState_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setRenderState);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setRenderState_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setRenderState_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setRenderState_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setRenderState)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setRenderState_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/RenderState ap2, /*6Fj*/uint ap3)
{
   SELF(DisplayDriver, setRenderState);
   DisplayDriver_setRenderState(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/(C(RenderState))ap2, /*7Al*/ap3);
}
// inline void DisplayDriver::register_setRenderState(CPPClass & cl, DisplayDriver::DisplayDriver_setRenderState_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setRenderState_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setRenderState)] = func;
// }

inline DisplayDriver::DisplayDriver_setTransform_Functor::FunctionType DisplayDriver::DisplayDriver_setTransform_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, setTransform);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_setTransform_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_setTransform_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_setTransform_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, setTransform)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_setTransform_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Matrix & ap2, /*6Fj*/bool ap3, /*6Fj*/bool ap4)
{
   SELF(DisplayDriver, setTransform);
   DisplayDriver_setTransform(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl, /*7Al*/(C(bool))ap3, /*7Al*/(C(bool))ap4);
}
// inline void DisplayDriver::register_setTransform(CPPClass & cl, DisplayDriver::DisplayDriver_setTransform_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_setTransform_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, setTransform)] = func;
// }

inline DisplayDriver::DisplayDriver_startUpdate_Functor::FunctionType DisplayDriver::DisplayDriver_startUpdate_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, startUpdate);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_startUpdate_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_startUpdate_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_startUpdate_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, startUpdate)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_startUpdate_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, startUpdate);
   DisplayDriver_startUpdate(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_startUpdate(CPPClass & cl, DisplayDriver::DisplayDriver_startUpdate_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_startUpdate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, startUpdate)] = func;
// }

inline DisplayDriver::DisplayDriver_stretch_Functor::FunctionType DisplayDriver::DisplayDriver_stretch_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, stretch);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_stretch_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_stretch_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_stretch_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, stretch)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_stretch_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh)
{
   SELF(DisplayDriver, stretch);
   DisplayDriver_stretch(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);
}
// inline void DisplayDriver::register_stretch(CPPClass & cl, DisplayDriver::DisplayDriver_stretch_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_stretch_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, stretch)] = func;
// }

inline DisplayDriver::DisplayDriver_stretchDI_Functor::FunctionType DisplayDriver::DisplayDriver_stretchDI_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, stretchDI);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_stretchDI_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_stretchDI_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_stretchDI_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, stretchDI)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_stretchDI_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/int dx, /*6Fj*/int dy, /*6Fj*/int sx, /*6Fj*/int sy, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/int sw, /*6Fj*/int sh)
{
   SELF(DisplayDriver, stretchDI);
   DisplayDriver_stretchDI(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);
}
// inline void DisplayDriver::register_stretchDI(CPPClass & cl, DisplayDriver::DisplayDriver_stretchDI_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_stretchDI_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, stretchDI)] = func;
// }

inline DisplayDriver::DisplayDriver_stretchf_Functor::FunctionType DisplayDriver::DisplayDriver_stretchf_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, stretchf);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_stretchf_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_stretchf_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_stretchf_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, stretchf)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_stretchf_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Bitmap & ap3, /*6Fj*/float dx, /*6Fj*/float dy, /*6Fj*/float sx, /*6Fj*/float sy, /*6Fj*/float w, /*6Fj*/float h, /*6Fj*/float sw, /*6Fj*/float sh)
{
   SELF(DisplayDriver, stretchf);
   DisplayDriver_stretchf(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/dx, /*7Al*/dy, /*7Al*/sx, /*7Al*/sy, /*7Al*/w, /*7Al*/h, /*7Al*/sw, /*7Al*/sh);
}
// inline void DisplayDriver::register_stretchf(CPPClass & cl, DisplayDriver::DisplayDriver_stretchf_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_stretchf_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, stretchf)] = func;
// }

inline DisplayDriver::DisplayDriver_textExtent_Functor::FunctionType DisplayDriver::DisplayDriver_textExtent_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, textExtent);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_textExtent_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_textExtent_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_textExtent_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, textExtent)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_textExtent_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int * tw, /*6Fj*/int * th, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph, /*6Fj*/int * overHang)
{
   SELF(DisplayDriver, textExtent);
   DisplayDriver_textExtent(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/text, /*7Al*/len, /*7Al*/tw, /*7Al*/th, /*7Al*/prevGlyph, /*7Al*/rPrevGlyph, /*7Al*/overHang);
}
// inline void DisplayDriver::register_textExtent(CPPClass & cl, DisplayDriver::DisplayDriver_textExtent_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_textExtent_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, textExtent)] = func;
// }

inline DisplayDriver::DisplayDriver_textFont_Functor::FunctionType DisplayDriver::DisplayDriver_textFont_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, textFont);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_textFont_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_textFont_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_textFont_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, textFont)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_textFont_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/Font ap3)
{
   SELF(DisplayDriver, textFont);
   DisplayDriver_textFont(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/ap3.impl);
}
// inline void DisplayDriver::register_textFont(CPPClass & cl, DisplayDriver::DisplayDriver_textFont_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_textFont_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, textFont)] = func;
// }

inline DisplayDriver::DisplayDriver_textOpacity_Functor::FunctionType DisplayDriver::DisplayDriver_textOpacity_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, textOpacity);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_textOpacity_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_textOpacity_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_textOpacity_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, textOpacity)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_textOpacity_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/bool ap3)
{
   SELF(DisplayDriver, textOpacity);
   DisplayDriver_textOpacity(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(bool))ap3);
}
// inline void DisplayDriver::register_textOpacity(CPPClass & cl, DisplayDriver::DisplayDriver_textOpacity_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_textOpacity_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, textOpacity)] = func;
// }

inline DisplayDriver::DisplayDriver_unloadFont_Functor::FunctionType DisplayDriver::DisplayDriver_unloadFont_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, unloadFont);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_unloadFont_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_unloadFont_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_unloadFont_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, unloadFont)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_unloadFont_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Font ap2)
{
   SELF(DisplayDriver, unloadFont);
   DisplayDriver_unloadFont(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl);
}
// inline void DisplayDriver::register_unloadFont(CPPClass & cl, DisplayDriver::DisplayDriver_unloadFont_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_unloadFont_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, unloadFont)] = func;
// }

inline DisplayDriver::DisplayDriver_unlock_Functor::FunctionType DisplayDriver::DisplayDriver_unlock_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, unlock);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_unlock_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_unlock_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_unlock_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, unlock)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_unlock_Functor::operator()( /*6Fj*/Display & ap1)
{
   SELF(DisplayDriver, unlock);
   DisplayDriver_unlock(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl);
}
// inline void DisplayDriver::register_unlock(CPPClass & cl, DisplayDriver::DisplayDriver_unlock_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_unlock_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, unlock)] = func;
// }

inline DisplayDriver::DisplayDriver_unlockIndices_Functor::FunctionType DisplayDriver::DisplayDriver_unlockIndices_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, unlockIndices);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_unlockIndices_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_unlockIndices_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_unlockIndices_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, unlockIndices)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_unlockIndices_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/PrimitiveSingle & group, /*6Fj*/bool indices32bit, /*6Fj*/int nIndices, /*6Fj*/void * maeb)
{
   SELF(DisplayDriver, unlockIndices);
   DisplayDriver_unlockIndices(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&group.impl, /*7Al*/(C(bool))indices32bit, /*7Al*/nIndices, /*7Al*/maeb);
}
// inline void DisplayDriver::register_unlockIndices(CPPClass & cl, DisplayDriver::DisplayDriver_unlockIndices_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_unlockIndices_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, unlockIndices)] = func;
// }

inline DisplayDriver::DisplayDriver_unlockMesh_Functor::FunctionType DisplayDriver::DisplayDriver_unlockMesh_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, unlockMesh);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_unlockMesh_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_unlockMesh_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_unlockMesh_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, unlockMesh)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_unlockMesh_Functor::operator()( /*6Fj*/DisplaySystem & ap1, /*6Fj*/Mesh ap2, /*6Fj*/MeshFeatures flags)
{
   SELF(DisplayDriver, unlockMesh);
   DisplayDriver_unlockMesh(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/(C(MeshFeatures))flags);
}
// inline void DisplayDriver::register_unlockMesh(CPPClass & cl, DisplayDriver::DisplayDriver_unlockMesh_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_unlockMesh_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, unlockMesh)] = func;
// }

inline DisplayDriver::DisplayDriver_unlockSystem_Functor::FunctionType DisplayDriver::DisplayDriver_unlockSystem_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, unlockSystem);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_unlockSystem_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_unlockSystem_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_unlockSystem_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, unlockSystem)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_unlockSystem_Functor::operator()( /*6Fj*/DisplaySystem & displaySystem)
{
   SELF(DisplayDriver, unlockSystem);
   DisplayDriver_unlockSystem(self ? self->impl : (C(DisplayDriver))null, /*7Al*/displaySystem.impl);
}
// inline void DisplayDriver::register_unlockSystem(CPPClass & cl, DisplayDriver::DisplayDriver_unlockSystem_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_unlockSystem_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, unlockSystem)] = func;
// }

inline DisplayDriver::DisplayDriver_update_Functor::FunctionType DisplayDriver::DisplayDriver_update_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, update);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_update_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_update_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_update_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, update)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_update_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Box & ap2)
{
   SELF(DisplayDriver, update);
   DisplayDriver_update(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/&ap2.impl);
}
// inline void DisplayDriver::register_update(CPPClass & cl, DisplayDriver::DisplayDriver_update_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_update_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, update)] = func;
// }

inline DisplayDriver::DisplayDriver_writeText_Functor::FunctionType DisplayDriver::DisplayDriver_writeText_Functor::operator= (FunctionType func)
{
   SELF(DisplayDriver, writeText);
   if(self->vTbl == DisplayDriver::_cpp_class.vTbl)
   {
      uint size = DisplayDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DisplayDriver::DisplayDriver_writeText_Functor::FunctionType, size);
      memcpy(self->vTbl, DisplayDriver::_cpp_class.vTbl, sizeof(DisplayDriver::DisplayDriver_writeText_Functor::FunctionType) * size);
   }
   ((DisplayDriver::DisplayDriver_writeText_Functor::FunctionType *)self->vTbl)[M_VTBLID(DisplayDriver, writeText)] = func;
   return func;
}
inline void DisplayDriver::DisplayDriver_writeText_Functor::operator()( /*6Fj*/Display & ap1, /*6Fj*/Surface & ap2, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/constString text, /*6Fj*/int len, /*6Fj*/int prevGlyph, /*6Fj*/int * rPrevGlyph)
{
   SELF(DisplayDriver, writeText);
   DisplayDriver_writeText(self ? self->impl : (C(DisplayDriver))null, /*7Al*/ap1.impl, /*7Al*/ap2.impl, /*7Al*/x, /*7Al*/y, /*7Al*/text, /*7Al*/len, /*7Al*/prevGlyph, /*7Al*/rPrevGlyph);
}
// inline void DisplayDriver::register_writeText(CPPClass & cl, DisplayDriver::DisplayDriver_writeText_Functor::FunctionType func)
// {
//    ((DisplayDriver::DisplayDriver_writeText_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DisplayDriver, writeText)] = func;
// }




// member accessors: DisplayFlags::fullScreen
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DisplayFlags::fullScreen_Prop::operator= (/*0H*/bool v)
{
   SELF(DisplayFlags, fullScreen);
   DISPLAYFLAGS_SET_fullScreen(self->impl, v);
   return v;
}

/*regSet*/inline DisplayFlags::fullScreen_Prop & DisplayFlags::fullScreen_Prop::operator= (DisplayFlags::fullScreen_Prop & prop)
{
   SELF(DisplayFlags, fullScreen);
   /*0H*/bool v = prop;
   DISPLAYFLAGS_SET_fullScreen(self->impl, v);
   return prop;
}
/*regGet*/inline DisplayFlags::fullScreen_Prop::operator /*0I*/bool () const
{
   SELF(DisplayFlags, fullScreen);
   return (bool)DISPLAYFLAGS_fullScreen(self->impl);
}

// member accessors: DisplayFlags::flipping
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DisplayFlags::flipping_Prop::operator= (/*0H*/bool v)
{
   SELF(DisplayFlags, flipping);
   DISPLAYFLAGS_SET_flipping(self->impl, v);
   return v;
}

/*regSet*/inline DisplayFlags::flipping_Prop & DisplayFlags::flipping_Prop::operator= (DisplayFlags::flipping_Prop & prop)
{
   SELF(DisplayFlags, flipping);
   /*0H*/bool v = prop;
   DISPLAYFLAGS_SET_flipping(self->impl, v);
   return prop;
}
/*regGet*/inline DisplayFlags::flipping_Prop::operator /*0I*/bool () const
{
   SELF(DisplayFlags, flipping);
   return (bool)DISPLAYFLAGS_flipping(self->impl);
}

// member accessors: DisplayFlags::alpha
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DisplayFlags::alpha_Prop::operator= (/*0H*/bool v)
{
   SELF(DisplayFlags, alpha);
   DISPLAYFLAGS_SET_alpha(self->impl, v);
   return v;
}

/*regSet*/inline DisplayFlags::alpha_Prop & DisplayFlags::alpha_Prop::operator= (DisplayFlags::alpha_Prop & prop)
{
   SELF(DisplayFlags, alpha);
   /*0H*/bool v = prop;
   DISPLAYFLAGS_SET_alpha(self->impl, v);
   return prop;
}
/*regGet*/inline DisplayFlags::alpha_Prop::operator /*0I*/bool () const
{
   SELF(DisplayFlags, alpha);
   return (bool)DISPLAYFLAGS_alpha(self->impl);
}

// member accessors: DisplayFlags::memBackBuffer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DisplayFlags::memBackBuffer_Prop::operator= (/*0H*/bool v)
{
   SELF(DisplayFlags, memBackBuffer);
   DISPLAYFLAGS_SET_memBackBuffer(self->impl, v);
   return v;
}

/*regSet*/inline DisplayFlags::memBackBuffer_Prop & DisplayFlags::memBackBuffer_Prop::operator= (DisplayFlags::memBackBuffer_Prop & prop)
{
   SELF(DisplayFlags, memBackBuffer);
   /*0H*/bool v = prop;
   DISPLAYFLAGS_SET_memBackBuffer(self->impl, v);
   return prop;
}
/*regGet*/inline DisplayFlags::memBackBuffer_Prop::operator /*0I*/bool () const
{
   SELF(DisplayFlags, memBackBuffer);
   return (bool)DISPLAYFLAGS_memBackBuffer(self->impl);
}

// member accessors: DisplayFlags::text
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DisplayFlags::text_Prop::operator= (/*0H*/bool v)
{
   SELF(DisplayFlags, text);
   DISPLAYFLAGS_SET_text(self->impl, v);
   return v;
}

/*regSet*/inline DisplayFlags::text_Prop & DisplayFlags::text_Prop::operator= (DisplayFlags::text_Prop & prop)
{
   SELF(DisplayFlags, text);
   /*0H*/bool v = prop;
   DISPLAYFLAGS_SET_text(self->impl, v);
   return prop;
}
/*regGet*/inline DisplayFlags::text_Prop::operator /*0I*/bool () const
{
   SELF(DisplayFlags, text);
   return (bool)DISPLAYFLAGS_text(self->impl);
}

// member accessors: DisplayFlags::scrolling
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DisplayFlags::scrolling_Prop::operator= (/*0H*/bool v)
{
   SELF(DisplayFlags, scrolling);
   DISPLAYFLAGS_SET_scrolling(self->impl, v);
   return v;
}

/*regSet*/inline DisplayFlags::scrolling_Prop & DisplayFlags::scrolling_Prop::operator= (DisplayFlags::scrolling_Prop & prop)
{
   SELF(DisplayFlags, scrolling);
   /*0H*/bool v = prop;
   DISPLAYFLAGS_SET_scrolling(self->impl, v);
   return prop;
}
/*regGet*/inline DisplayFlags::scrolling_Prop::operator /*0I*/bool () const
{
   SELF(DisplayFlags, scrolling);
   return (bool)DISPLAYFLAGS_scrolling(self->impl);
}

// member accessors: DisplayFlags::printer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DisplayFlags::printer_Prop::operator= (/*0H*/bool v)
{
   SELF(DisplayFlags, printer);
   DISPLAYFLAGS_SET_printer(self->impl, v);
   return v;
}

/*regSet*/inline DisplayFlags::printer_Prop & DisplayFlags::printer_Prop::operator= (DisplayFlags::printer_Prop & prop)
{
   SELF(DisplayFlags, printer);
   /*0H*/bool v = prop;
   DISPLAYFLAGS_SET_printer(self->impl, v);
   return prop;
}
/*regGet*/inline DisplayFlags::printer_Prop::operator /*0I*/bool () const
{
   SELF(DisplayFlags, printer);
   return (bool)DISPLAYFLAGS_printer(self->impl);
}

inline DisplaySystem::DisplaySystem(PixelFormat pixelFormat, DisplayFlags flags = DisplayFlags()) : DisplaySystem()
{
   this->pixelFormat = pixelFormat;
   this->flags = flags;
}


inline C(bool) DisplaySystem::addMaterial(/*1Ab*/Material material)
{
   return DisplaySystem_addMaterial(impl, /*5De*/material.impl);
}
inline C(OldLink) * DisplaySystem::addMesh(/*1Ab*/Mesh mesh)
{
   return DisplaySystem_addMesh(impl, /*5De*/mesh.impl);
}
inline C(Material) * DisplaySystem::addNamedMaterial(/*1Ab*/const char * name)
{
   return DisplaySystem_addNamedMaterial(impl, /*5Ge*/name);
}
inline C(NamedLink) * DisplaySystem::addTexture(/*1Ab*/const char * name, /*1Ab*/Bitmap & bitmap)
{
   return DisplaySystem_addTexture(impl, /*5Ge*/name, /*5De*/bitmap.impl);
}
inline void DisplaySystem::clearMaterials()
{
   DisplaySystem_clearMaterials(impl);
}
inline void DisplaySystem::clearMeshes()
{
   DisplaySystem_clearMeshes(impl);
}
inline void DisplaySystem::clearTextures()
{
   DisplaySystem_clearTextures(impl);
}
inline C(bool) DisplaySystem::create(/*1Ab*/const char * driverName, /*1Ab*/void * window, /*1Ab*/bool fullScreen)
{
   return DisplaySystem_create(impl, /*5Ge*/driverName, /*5Ge*/window, /*5Ee*/(C(bool))fullScreen);
}
inline void DisplaySystem::fontExtent(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height)
{
   DisplaySystem_fontExtent(impl, /*5De*/font.impl, /*5Ge*/text, /*5Ge*/len, /*5Ge*/width, /*5Ge*/height);
}
inline void DisplaySystem::fontExtent2(/*1Ab*/Font font, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang)
{
   DisplaySystem_fontExtent2(impl, /*5De*/font.impl, /*5Ge*/text, /*5Ge*/len, /*5Ge*/width, /*5Ge*/height, /*5Ge*/prevGlyph, /*5Ge*/rPrevGlyph, /*5Ge*/overHang);
}
inline C(Material) * DisplaySystem::getMaterial(/*1Ab*/const char * name)
{
   return DisplaySystem_getMaterial(impl, /*5Ge*/name);
}
inline Bitmap DisplaySystem::getTexture(/*1Ab*/const char * name)
{
   return Bitmap(DisplaySystem_getTexture(impl, /*5Ge*/name));
}
inline C(Font) * DisplaySystem::loadFont(/*1Ab*/const char * faceName, /*1Ab*/float size, /*1Ab*/FontFlags flags)
{
   return DisplaySystem_loadFont(impl, /*5Ge*/faceName, /*5Ge*/size, /*5Ee*/(C(FontFlags))flags.impl);
}
inline C(Font) * DisplaySystem::loadOutlineFont(/*1Ab*/const char * faceName, /*1Ab*/float size, /*1Ab*/FontFlags flags, /*1Ab*/float outlineSize, /*1Ab*/float outlineFade)
{
   return DisplaySystem_loadOutlineFont(impl, /*5Ge*/faceName, /*5Ge*/size, /*5Ee*/(C(FontFlags))flags.impl, /*5Ge*/outlineSize, /*5Ge*/outlineFade);
}
inline void * DisplaySystem::loadResource(/*1Ab*/Resource & resource)
{
   return DisplaySystem_loadResource(impl, /*5De*/resource.impl);
}
inline void * DisplaySystem::loadResourceFM(/*1Ab*/Resource & resource, /*1Ab*/FontManager & fm)
{
   return DisplaySystem_loadResourceFM(impl, /*5De*/resource.impl, /*5De*/fm.impl);
}
inline C(bool) DisplaySystem::lock()
{
   return DisplaySystem_lock(impl);
}
inline C(bool) DisplaySystem::removeMaterial(/*1Ab*/Material material)
{
   return DisplaySystem_removeMaterial(impl, /*5De*/material.impl);
}
inline C(bool) DisplaySystem::removeMesh(/*1Ab*/Mesh mesh)
{
   return DisplaySystem_removeMesh(impl, /*5De*/mesh.impl);
}
inline C(bool) DisplaySystem::removeTexture(/*1Ab*/const char * name)
{
   return DisplaySystem_removeTexture(impl, /*5Ge*/name);
}
inline void DisplaySystem::unloadFont(/*1Ab*/Font font)
{
   DisplaySystem_unloadFont(impl, /*5De*/font.impl);
}
inline void DisplaySystem::unloadResource(/*1Ab*/Resource & resource, /*1Ab*/DisplaySystemResPtr res)
{
   DisplaySystem_unloadResource(impl, /*5De*/resource.impl, /*5De*/res.impl);
}
inline void DisplaySystem::unlock()
{
   DisplaySystem_unlock(impl);
}
inline void * DisplaySystem::_LoadResource(/*1Ab*/Resource & resource, /*1Ab*/void * fm)
{
   return DisplaySystem__LoadResource(impl, /*5De*/resource.impl, /*5Ge*/fm);
}


// member accessors: DisplaySystem::pixelFormat
// (normal::enum|int)

/*nstSet*/inline /*0H*/PixelFormat DisplaySystem::pixelFormat_Prop::operator= (/*0H*/PixelFormat v)
{
   SELF(DisplaySystem, pixelFormat);
   IPTR(self->impl, DisplaySystem)->pixelFormat = (C(PixelFormat))v;
   return v;
}

/*regSet*/inline DisplaySystem::pixelFormat_Prop & DisplaySystem::pixelFormat_Prop::operator= (DisplaySystem::pixelFormat_Prop & prop)
{
   SELF(DisplaySystem, pixelFormat);
   /*0H*/PixelFormat v = prop;
   IPTR(self->impl, DisplaySystem)->pixelFormat = (C(PixelFormat))v;
   return prop;
}
/*regGet*/inline DisplaySystem::pixelFormat_Prop::operator /*0I*/PixelFormat () const
{
   SELF(DisplaySystem, pixelFormat);
   return self ? (PixelFormat)IPTR(self->impl, DisplaySystem)->pixelFormat : (PixelFormat)0;
}

// member accessors: DisplaySystem::flags
// (normal::bits|unsigned int)

/*nstSet*/inline /*0H*/DisplayFlags DisplaySystem::flags_Prop::operator= (/*0H*/DisplayFlags v)
{
   SELF(DisplaySystem, flags);
   IPTR(self->impl, DisplaySystem)->flags = v;
   return v;
}

/*regSet*/inline DisplaySystem::flags_Prop & DisplaySystem::flags_Prop::operator= (DisplaySystem::flags_Prop & prop)
{
   SELF(DisplaySystem, flags);
   /*0H*/DisplayFlags v = prop;
   IPTR(self->impl, DisplaySystem)->flags = v;
   return prop;
}
/*regGet*/inline DisplaySystem::flags_Prop::operator /*0I*/DisplayFlags () const
{
   SELF(DisplaySystem, flags);
   return self ? DisplayFlags(IPTR(self->impl, DisplaySystem)->flags) : DisplayFlags();
}



inline void DrawList::addObject(/*1Ab*/Object object)
{
   DrawList_addObject(impl, /*5De*/object.impl);
}
inline void DrawList::init(/*1Ab*/Matrix & sm, /*1Ab*/Matrix & vm, /*1Ab*/Vector3D & cp, /*1Ab*/Plane * vp, /*1Ab*/Plane * wp, /*1Ab*/int guessCount)
{
   DrawList_init(impl, /*5De*/&sm.impl, /*5De*/&vm.impl, /*5De*/&cp.impl, /*5Ee*/(C(Plane) *)vp, /*5Ee*/(C(Plane) *)wp, /*5Ge*/guessCount);
}
inline void DrawList::init(/*1Ac*/Matrix * sm, /*1Ac*/Matrix * vm, /*1Ac*/Vector3D * cp, /*1Ac*/Plane * vp, /*1Ac*/Plane * wp, /*1Ac*/int guessCount)
{
   DrawList_init(impl, /*5Cf*/(C(Matrix) *)sm, /*5Cf*/(C(Matrix) *)vm, /*5Cf*/(C(Vector3D) *)cp, /*5Ef*/(C(Plane) *)vp, /*5Ef*/(C(Plane) *)wp, /*5Gf*/guessCount);
}
inline void DrawList::prepare()
{
   DrawList_prepare(impl);
}
inline void DrawList::render(/*1Ab*/Display & display)
{
   DrawList_render(impl, /*5De*/display.impl);
}

inline DrawManager::DrawManager(bool renderingFlipped) : DrawManager()
{
   this->renderingFlipped = renderingFlipped;
}

inline DrawManager::DrawManager_flush_Functor::FunctionType DrawManager::DrawManager_flush_Functor::operator= (FunctionType func)
{
   SELF(DrawManager, flush);
   if(self->vTbl == DrawManager::_cpp_class.vTbl)
   {
      uint size = DrawManager::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DrawManager::DrawManager_flush_Functor::FunctionType, size);
      memcpy(self->vTbl, DrawManager::_cpp_class.vTbl, sizeof(DrawManager::DrawManager_flush_Functor::FunctionType) * size);
   }
   ((DrawManager::DrawManager_flush_Functor::FunctionType *)self->vTbl)[M_VTBLID(DrawManager, flush)] = func;
   return func;
}
inline void DrawManager::DrawManager_flush_Functor::operator()( )
{
   SELF(DrawManager, flush);
   DrawManager_flush(self ? self->impl : (C(DrawManager))null);
}
// inline void DrawManager::register_flush(CPPClass & cl, DrawManager::DrawManager_flush_Functor::FunctionType func)
// {
//    ((DrawManager::DrawManager_flush_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DrawManager, flush)] = func;
// }


inline void DrawManager::clear()
{
   DrawManager_clear(impl);
}
inline void DrawManager::drawBarrier()
{
   DrawManager_drawBarrier(impl);
}
inline void DrawManager::drawImage(/*1Ab*/int index, /*1Ab*/float offsetx, /*1Ab*/float offsety, /*1Ab*/float angsin, /*1Ab*/float angcos, /*1Ab*/ColorAlpha color)
{
   DrawManager_drawImage(impl, /*5Ge*/index, /*5Ge*/offsetx, /*5Ge*/offsety, /*5Ge*/angsin, /*5Ge*/angcos, /*5Ee*/(C(ColorAlpha))color.impl);
}
inline void DrawManager::end()
{
   DrawManager_end(impl);
}
inline void DrawManager::finish()
{
   DrawManager_finish(impl);
}
inline C(bool) DrawManager::init()
{
   return DrawManager_init(impl);
}
inline void DrawManager::ready(/*1Ab*/int viewportWidth, /*1Ab*/int viewportHeight)
{
   DrawManager_ready(impl, /*5Ge*/viewportWidth, /*5Ge*/viewportHeight);
}


// property callers: DrawManager::renderingFlipped   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool DrawManager::renderingFlipped_Prop::operator= (/*0G*/bool v)
{
   SELF(DrawManager, renderingFlipped);
   DrawManager_set_renderingFlipped(self->impl, (C(bool))v);
   return v;
}




// member accessors: DrawSlot::object
// (struct::nohead)

/*nstSet*/inline /*0H*/Object DrawSlot::object_Prop::operator= (/*0H*/Object & v)
{
   SELF(DrawSlot, object);
   self->impl.object = v.impl;
   return v;
}

/*regSet*/inline DrawSlot::object_Prop & DrawSlot::object_Prop::operator= (DrawSlot::object_Prop & prop)
{
   SELF(DrawSlot, object);
   /*0H*/Object v = prop;
   self->impl.object = v.impl;
   return prop;
}
/*regGet*/inline DrawSlot::object_Prop::operator /*0I*/Object () const
{
   SELF(DrawSlot, object);
   Object value(((C(DrawSlot) *)&self->impl)->object);
   return value;
}

// member accessors: DrawSlot::baseMap
// (struct::normal)

/*nstSet*/inline /*0H*/Bitmap DrawSlot::baseMap_Prop::operator= (/*0H*/Bitmap v)
{
   SELF(DrawSlot, baseMap);
   self->impl.baseMap = v.impl;
   return v;
}

/*regSet*/inline DrawSlot::baseMap_Prop & DrawSlot::baseMap_Prop::operator= (DrawSlot::baseMap_Prop & prop)
{
   SELF(DrawSlot, baseMap);
   /*0H*/Bitmap v = prop;
   self->impl.baseMap = v.impl;
   return prop;
}
/*regGet*/inline DrawSlot::baseMap_Prop::operator /*0I*/Bitmap () const
{
   SELF(DrawSlot, baseMap);
   Bitmap value(((C(DrawSlot) *)&self->impl)->baseMap);
   return value;
}


template <class TC, C(Class) ** TCO> inline void TFMFont<TC, TCO>::setOutline(/*1Ab*/float size, /*1Ab*/float fade)
{
   FMFont_setOutline((C(FMFont)*)this->impl, /*5Ge*/size, /*5Ge*/fade);
}


// member accessors: FMFont::link
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/TLinkElement<C(FMFont)> TFMFont<TC, TCO>::link_Prop::operator= (/*0H*/TLinkElement<C(FMFont)> v)
{
   SELF(FMFont, link);
   ((C(FMFont) *)self->impl)->link = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TFMFont<TC, TCO>::link_Prop & TFMFont<TC, TCO>::link_Prop::operator= (typename TFMFont<TC, TCO>::link_Prop & prop)
{
   SELF(FMFont, link);
   /*0H*/TLinkElement<C(FMFont)> v = prop;
   ((C(FMFont) *)self->impl)->link = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TFMFont<TC, TCO>::link_Prop::operator /*0I*/TLinkElement<C(FMFont)> () const
{
   __attribute__((unused)) TFMFont TCTCO * self = CONTAINER_OF(this, TFMFont TCTCO, link);
   TLinkElement<C(FMFont)> value(((C(FMFont) *)self->impl)->link);
   return value;
}

inline FMPathDraw::FMPathDraw(int prevGlyphIndex, float middleAlign = 0)
{
   impl.prevGlyphIndex = prevGlyphIndex;
   impl.middleAlign = middleAlign;
}



// member accessors: FMPathDraw::prevGlyphIndex
// (struct::int)

/*nstSet*/inline /*0H*/int FMPathDraw::prevGlyphIndex_Prop::operator= (/*0H*/int v)
{
   SELF(FMPathDraw, prevGlyphIndex);
   self->impl.prevGlyphIndex = v;
   return v;
}

/*regSet*/inline FMPathDraw::prevGlyphIndex_Prop & FMPathDraw::prevGlyphIndex_Prop::operator= (FMPathDraw::prevGlyphIndex_Prop & prop)
{
   SELF(FMPathDraw, prevGlyphIndex);
   /*0H*/int v = prop;
   self->impl.prevGlyphIndex = v;
   return prop;
}
/*regGet*/inline FMPathDraw::prevGlyphIndex_Prop::operator /*0I*/int () const
{
   SELF(FMPathDraw, prevGlyphIndex);
   return self ? ((C(FMPathDraw) *)&self->impl)->prevGlyphIndex : 0;
}

// member accessors: FMPathDraw::middleAlign
// (struct::float)

/*nstSet*/inline /*0H*/float FMPathDraw::middleAlign_Prop::operator= (/*0H*/float v)
{
   SELF(FMPathDraw, middleAlign);
   self->impl.middleAlign = v;
   return v;
}

/*regSet*/inline FMPathDraw::middleAlign_Prop & FMPathDraw::middleAlign_Prop::operator= (FMPathDraw::middleAlign_Prop & prop)
{
   SELF(FMPathDraw, middleAlign);
   /*0H*/float v = prop;
   self->impl.middleAlign = v;
   return prop;
}
/*regGet*/inline FMPathDraw::middleAlign_Prop::operator /*0I*/float () const
{
   SELF(FMPathDraw, middleAlign);
   return self ? ((C(FMPathDraw) *)&self->impl)->middleAlign : 0;
}



// member accessors: FMTextAlignment::horzAlignment
// (bits::enum|int)

/*nstSet*/inline /*0H*/Alignment FMTextAlignment::horzAlignment_Prop::operator= (/*0H*/Alignment v)
{
   SELF(FMTextAlignment, horzAlignment);
   FMTEXTALIGNMENT_SET_horzAlignment(self->impl, v);
   return v;
}

/*regSet*/inline FMTextAlignment::horzAlignment_Prop & FMTextAlignment::horzAlignment_Prop::operator= (FMTextAlignment::horzAlignment_Prop & prop)
{
   SELF(FMTextAlignment, horzAlignment);
   /*0H*/Alignment v = prop;
   FMTEXTALIGNMENT_SET_horzAlignment(self->impl, v);
   return prop;
}
/*regGet*/inline FMTextAlignment::horzAlignment_Prop::operator /*0I*/Alignment () const
{
   SELF(FMTextAlignment, horzAlignment);
   return (Alignment)FMTEXTALIGNMENT_horzAlignment(self->impl);
}

// member accessors: FMTextAlignment::vertAlignment
// (bits::enum|int)

/*nstSet*/inline /*0H*/FMVerticalAlignment FMTextAlignment::vertAlignment_Prop::operator= (/*0H*/FMVerticalAlignment v)
{
   SELF(FMTextAlignment, vertAlignment);
   FMTEXTALIGNMENT_SET_vertAlignment(self->impl, v);
   return v;
}

/*regSet*/inline FMTextAlignment::vertAlignment_Prop & FMTextAlignment::vertAlignment_Prop::operator= (FMTextAlignment::vertAlignment_Prop & prop)
{
   SELF(FMTextAlignment, vertAlignment);
   /*0H*/FMVerticalAlignment v = prop;
   FMTEXTALIGNMENT_SET_vertAlignment(self->impl, v);
   return prop;
}
/*regGet*/inline FMTextAlignment::vertAlignment_Prop::operator /*0I*/FMVerticalAlignment () const
{
   SELF(FMTextAlignment, vertAlignment);
   return (FMVerticalAlignment)FMTEXTALIGNMENT_vertAlignment(self->impl);
}



// member accessors: FaceInfo::fileName
// (nohead::string)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/char * TFaceInfo<TC, TCO>::fileName_Prop::operator= (/*0H*/char * v)
{
   SELF(FaceInfo, fileName);
   ((C(FaceInfo) *)self->impl)->fileName = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TFaceInfo<TC, TCO>::fileName_Prop & TFaceInfo<TC, TCO>::fileName_Prop::operator= (typename TFaceInfo<TC, TCO>::fileName_Prop & prop)
{
   SELF(FaceInfo, fileName);
   /*0H*/char * v = prop;
   ((C(FaceInfo) *)self->impl)->fileName = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TFaceInfo<TC, TCO>::fileName_Prop::operator /*0I*/char * () const
{
   __attribute__((unused)) TFaceInfo TCTCO * self = CONTAINER_OF(this, TFaceInfo TCTCO, fileName);
   return self ? ((C(FaceInfo) *)self->impl)->fileName : 0;
}

// member accessors: FaceInfo::fakeItalic
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TFaceInfo<TC, TCO>::fakeItalic_Prop::operator= (/*0H*/bool v)
{
   SELF(FaceInfo, fakeItalic);
   ((C(FaceInfo) *)self->impl)->fakeItalic = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TFaceInfo<TC, TCO>::fakeItalic_Prop & TFaceInfo<TC, TCO>::fakeItalic_Prop::operator= (typename TFaceInfo<TC, TCO>::fakeItalic_Prop & prop)
{
   SELF(FaceInfo, fakeItalic);
   /*0H*/bool v = prop;
   ((C(FaceInfo) *)self->impl)->fakeItalic = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TFaceInfo<TC, TCO>::fakeItalic_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TFaceInfo TCTCO * self = CONTAINER_OF(this, TFaceInfo TCTCO, fakeItalic);
   return self ? ((C(FaceInfo) *)self->impl)->fakeItalic : (bool)0;
}

// member accessors: FaceInfo::fontID
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TFaceInfo<TC, TCO>::fontID_Prop::operator= (/*0H*/int v)
{
   SELF(FaceInfo, fontID);
   ((C(FaceInfo) *)self->impl)->fontID = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TFaceInfo<TC, TCO>::fontID_Prop & TFaceInfo<TC, TCO>::fontID_Prop::operator= (typename TFaceInfo<TC, TCO>::fontID_Prop & prop)
{
   SELF(FaceInfo, fontID);
   /*0H*/int v = prop;
   ((C(FaceInfo) *)self->impl)->fontID = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TFaceInfo<TC, TCO>::fontID_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TFaceInfo TCTCO * self = CONTAINER_OF(this, TFaceInfo TCTCO, fontID);
   return self ? ((C(FaceInfo) *)self->impl)->fontID : 0;
}



// property callers: Font::ascent   // get only
// (nohead::int)

/*regGet*/template <class TC, C(Class) ** TCO> inline TFont<TC, TCO>::ascent_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TFont TCTCO * self = CONTAINER_OF(this, TFont TCTCO, ascent);
   return Font_get_ascent(self ? self->impl : null);
}

// property callers: Font::descent   // get only
// (nohead::int)

/*regGet*/template <class TC, C(Class) ** TCO> inline TFont<TC, TCO>::descent_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TFont TCTCO * self = CONTAINER_OF(this, TFont TCTCO, descent);
   return Font_get_descent(self ? self->impl : null);
}



// member accessors: FontFlags::bold
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FontFlags::bold_Prop::operator= (/*0H*/bool v)
{
   SELF(FontFlags, bold);
   FONTFLAGS_SET_bold(self->impl, v);
   return v;
}

/*regSet*/inline FontFlags::bold_Prop & FontFlags::bold_Prop::operator= (FontFlags::bold_Prop & prop)
{
   SELF(FontFlags, bold);
   /*0H*/bool v = prop;
   FONTFLAGS_SET_bold(self->impl, v);
   return prop;
}
/*regGet*/inline FontFlags::bold_Prop::operator /*0I*/bool () const
{
   SELF(FontFlags, bold);
   return (bool)FONTFLAGS_bold(self->impl);
}

// member accessors: FontFlags::italic
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FontFlags::italic_Prop::operator= (/*0H*/bool v)
{
   SELF(FontFlags, italic);
   FONTFLAGS_SET_italic(self->impl, v);
   return v;
}

/*regSet*/inline FontFlags::italic_Prop & FontFlags::italic_Prop::operator= (FontFlags::italic_Prop & prop)
{
   SELF(FontFlags, italic);
   /*0H*/bool v = prop;
   FONTFLAGS_SET_italic(self->impl, v);
   return prop;
}
/*regGet*/inline FontFlags::italic_Prop::operator /*0I*/bool () const
{
   SELF(FontFlags, italic);
   return (bool)FONTFLAGS_italic(self->impl);
}

// member accessors: FontFlags::underline
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FontFlags::underline_Prop::operator= (/*0H*/bool v)
{
   SELF(FontFlags, underline);
   FONTFLAGS_SET_underline(self->impl, v);
   return v;
}

/*regSet*/inline FontFlags::underline_Prop & FontFlags::underline_Prop::operator= (FontFlags::underline_Prop & prop)
{
   SELF(FontFlags, underline);
   /*0H*/bool v = prop;
   FONTFLAGS_SET_underline(self->impl, v);
   return prop;
}
/*regGet*/inline FontFlags::underline_Prop::operator /*0I*/bool () const
{
   SELF(FontFlags, underline);
   return (bool)FONTFLAGS_underline(self->impl);
}

inline FontInfo::FontInfo(bool fixedPitch, bool defaultOrAnsiCharSet = (bool)0)
{
   impl.fixedPitch = (C(bool))fixedPitch;
   impl.defaultOrAnsiCharSet = (C(bool))defaultOrAnsiCharSet;
}



// member accessors: FontInfo::fixedPitch
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool FontInfo::fixedPitch_Prop::operator= (/*0H*/bool v)
{
   SELF(FontInfo, fixedPitch);
   self->impl.fixedPitch = (C(bool))v;
   return v;
}

/*regSet*/inline FontInfo::fixedPitch_Prop & FontInfo::fixedPitch_Prop::operator= (FontInfo::fixedPitch_Prop & prop)
{
   SELF(FontInfo, fixedPitch);
   /*0H*/bool v = prop;
   self->impl.fixedPitch = (C(bool))v;
   return prop;
}
/*regGet*/inline FontInfo::fixedPitch_Prop::operator /*0I*/bool () const
{
   SELF(FontInfo, fixedPitch);
   return self ? (bool)((C(FontInfo) *)&self->impl)->fixedPitch : (bool)0;
}

// member accessors: FontInfo::defaultOrAnsiCharSet
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool FontInfo::defaultOrAnsiCharSet_Prop::operator= (/*0H*/bool v)
{
   SELF(FontInfo, defaultOrAnsiCharSet);
   self->impl.defaultOrAnsiCharSet = (C(bool))v;
   return v;
}

/*regSet*/inline FontInfo::defaultOrAnsiCharSet_Prop & FontInfo::defaultOrAnsiCharSet_Prop::operator= (FontInfo::defaultOrAnsiCharSet_Prop & prop)
{
   SELF(FontInfo, defaultOrAnsiCharSet);
   /*0H*/bool v = prop;
   self->impl.defaultOrAnsiCharSet = (C(bool))v;
   return prop;
}
/*regGet*/inline FontInfo::defaultOrAnsiCharSet_Prop::operator /*0I*/bool () const
{
   SELF(FontInfo, defaultOrAnsiCharSet);
   return self ? (bool)((C(FontInfo) *)&self->impl)->defaultOrAnsiCharSet : (bool)0;
}

inline FontManager::FontManager_onAtlasFull_Functor::FunctionType FontManager::FontManager_onAtlasFull_Functor::operator= (FunctionType func)
{
   SELF(FontManager, onAtlasFull);
   if(self->vTbl == FontManager::_cpp_class.vTbl)
   {
      uint size = FontManager::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManager::FontManager_onAtlasFull_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManager::_cpp_class.vTbl, sizeof(FontManager::FontManager_onAtlasFull_Functor::FunctionType) * size);
   }
   ((FontManager::FontManager_onAtlasFull_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManager, onAtlasFull)] = func;
   return func;
}
inline void FontManager::FontManager_onAtlasFull_Functor::operator()( )
{
   SELF(FontManager, onAtlasFull);
   FontManager_onAtlasFull(self ? self->impl : (C(FontManager))null);
}
// inline void FontManager::register_onAtlasFull(CPPClass & cl, FontManager::FontManager_onAtlasFull_Functor::FunctionType func)
// {
//    ((FontManager::FontManager_onAtlasFull_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManager, onAtlasFull)] = func;
// }


inline C(FMFont) * FontManager::addFont(constString path, /*1Ab*/int glyphPaddingWidth)
{
   return FontManager_addFont(impl, /*5Ge*/path, /*5Ge*/glyphPaddingWidth);
}
inline C(FMFont) * FontManager::addFontData(/*1Ab*/byte * data, /*1Ab*/int dataSize, /*1Ab*/int glyphPaddingWidth)
{
   return FontManager_addFontData(impl, /*5Ge*/data, /*5Ge*/dataSize, /*5Ge*/glyphPaddingWidth);
}
inline void FontManager::clearState()
{
   FontManager_clearState(impl);
}
inline C(bool) FontManager::create(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/int channelCount, /*1Ab*/int channelIndex, /*1Ab*/FontManagerRenderer & renderer)
{
   return FontManager_create(impl, /*5Ge*/width, /*5Ge*/height, /*5Ge*/channelCount, /*5Ge*/channelIndex, /*5De*/renderer.impl);
}
inline int FontManager::drawText(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * string, /*1Ab*/int stringlength)
{
   return FontManager_drawText(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/string, /*5Ge*/stringlength);
}
inline int FontManager::drawTextTruncate(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int truncatewidth, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/char * extstring, /*1Ab*/int extwidth)
{
   return FontManager_drawTextTruncate(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/truncatewidth, /*5Ge*/string, /*5Ge*/stringlength, /*5Ge*/extstring, /*5Ge*/extwidth);
}
inline int FontManager::drawTextWithCursor(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int cursoroffset)
{
   return FontManager_drawTextWithCursor(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/string, /*5Ge*/stringlength, /*5Ge*/cursoroffset);
}
inline C(bool) FontManager::expandAtlas(/*1Ab*/int width, /*1Ab*/int height)
{
   return FontManager_expandAtlas(impl, /*5Ge*/width, /*5Ge*/height);
}
inline void FontManager::flush(/*1Ab*/bool rendererFlush)
{
   FontManager_flush(impl, /*5Ee*/(C(bool))rendererFlush);
}
inline void FontManager::flushUpdate()
{
   FontManager_flushUpdate(impl);
}
inline void FontManager::freeFont(/*1Ab*/FMFont font)
{
   FontManager_freeFont(impl, /*5De*/font.impl);
}
inline void FontManager::getAtlasSize(/*1Ab*/int * retwidth, /*1Ab*/int * retheight)
{
   FontManager_getAtlasSize(impl, /*5Ge*/retwidth, /*5Ge*/retheight);
}
inline C(FMFont) * FontManager::getFont(/*1Ab*/FontResource & fontResource)
{
   return FontManager_getFont(impl, /*5De*/fontResource.impl);
}
inline void FontManager::getFontExtent(/*1Ab*/int * retascent, /*1Ab*/int * retdescent)
{
   FontManager_getFontExtent(impl, /*5Ge*/retascent, /*5Ge*/retdescent);
}
inline void FontManager::getFontLimits(/*1Ab*/int * retlimitminy, /*1Ab*/int * retlimitmaxy)
{
   FontManager_getFontLimits(impl, /*5Ge*/retlimitminy, /*5Ge*/retlimitmaxy);
}
inline int FontManager::getFontLineHeight()
{
   return FontManager_getFontLineHeight(impl);
}
inline int FontManager::getTextBounds(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int * bounds)
{
   return FontManager_getTextBounds(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/string, /*5Ge*/stringlength, /*5Ge*/bounds);
}
inline int FontManager::getTextNearestOffset(/*1Ab*/int targetwidth, /*1Ab*/const char * string, /*1Ab*/int stringlength)
{
   return FontManager_getTextNearestOffset(impl, /*5Ge*/targetwidth, /*5Ge*/string, /*5Ge*/stringlength);
}
inline int FontManager::getTextTruncateOffset(/*1Ab*/int truncatewidth, /*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int extwidth, /*1Ab*/int * retextflag, /*1Ab*/int * retfullwidth)
{
   return FontManager_getTextTruncateOffset(impl, /*5Ge*/truncatewidth, /*5Ge*/string, /*5Ge*/stringlength, /*5Ge*/extwidth, /*5Ge*/retextflag, /*5Ge*/retfullwidth);
}
inline int FontManager::getTextWidth(/*1Ab*/const char * string, /*1Ab*/int stringlength)
{
   return FontManager_getTextWidth(impl, /*5Ge*/string, /*5Ge*/stringlength);
}
inline int FontManager::getTextWidthTruncate(/*1Ab*/const char * string, /*1Ab*/int stringlength, /*1Ab*/int truncatewidth)
{
   return FontManager_getTextWidthTruncate(impl, /*5Ge*/string, /*5Ge*/stringlength, /*5Ge*/truncatewidth);
}
inline const byte * FontManager::getTextureData(/*1Ab*/int * width, /*1Ab*/int * height)
{
   return FontManager_getTextureData(impl, /*5Ge*/width, /*5Ge*/height);
}
inline C(bool) FontManager::initPathDraw(/*1Ab*/FMPathDraw & pathdraw)
{
   return FontManager_initPathDraw(impl, /*5De*/&pathdraw.impl);
}
inline C(bool) FontManager::initPathDraw(/*1Ac*/FMPathDraw * pathdraw)
{
   return FontManager_initPathDraw(impl, /*5Cf*/(C(FMPathDraw) *)pathdraw);
}
inline float FontManager::pathDrawCharacter(/*1Ab*/FMPathDraw & pathdraw, /*1Ab*/float x, /*1Ab*/float y, /*1Ab*/float vectorx, /*1Ab*/float vectory, /*1Ab*/int unicode)
{
   return FontManager_pathDrawCharacter(impl, /*5De*/&pathdraw.impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/vectorx, /*5Ge*/vectory, /*5Ge*/unicode);
}
inline float FontManager::pathDrawCharacter(/*1Ac*/FMPathDraw * pathdraw, /*1Ac*/float x, /*1Ac*/float y, /*1Ac*/float vectorx, /*1Ac*/float vectory, /*1Ac*/int unicode)
{
   return FontManager_pathDrawCharacter(impl, /*5Cf*/(C(FMPathDraw) *)pathdraw, /*5Gf*/x, /*5Gf*/y, /*5Gf*/vectorx, /*5Gf*/vectory, /*5Gf*/unicode);
}
inline float FontManager::pathDrawPredictAdvance(/*1Ab*/FMPathDraw & pathdraw, /*1Ab*/unichar unicode)
{
   return FontManager_pathDrawPredictAdvance(impl, /*5De*/&pathdraw.impl, /*5Ge*/unicode);
}
inline float FontManager::pathDrawPredictAdvance(/*1Ac*/FMPathDraw * pathdraw, /*1Ac*/unichar unicode)
{
   return FontManager_pathDrawPredictAdvance(impl, /*5Cf*/(C(FMPathDraw) *)pathdraw, /*5Gf*/unicode);
}
inline void FontManager::popState()
{
   FontManager_popState(impl);
}
inline void FontManager::pushState()
{
   FontManager_pushState(impl);
}
inline void FontManager::removeFont(/*1Ab*/FMFont font)
{
   FontManager_removeFont(impl, /*5De*/font.impl);
}
inline C(bool) FontManager::resetAtlas(/*1Ab*/int width, /*1Ab*/int height)
{
   return FontManager_resetAtlas(impl, /*5Ge*/width, /*5Ge*/height);
}
inline void FontManager::setAlign(/*1Ab*/int align)
{
   FontManager_setAlign(impl, /*5Ge*/align);
}
inline void FontManager::setFont(/*1Ab*/FMFont font)
{
   FontManager_setFont(impl, /*5De*/font.impl);
}
inline void FontManager::setFontImageProcessing(/*1Ab*/FMFont font, void (* processImage)(byte * image, int width, int height, int bytesperpixel, int bytesperline, int paddingwidth, void * opaquecontext), /*1Ab*/void * opaquecontext)
{
   FontManager_setFontImageProcessing(impl, /*5De*/font.impl, /*5Ge*/processImage, /*5Ge*/opaquecontext);
}
inline void FontManager::setSize(/*1Ab*/int size)
{
   FontManager_setSize(impl, /*5Ge*/size);
}
inline void FontManager::setState(/*1Ab*/FMFont font, /*1Ab*/int size, /*1Ab*/int align)
{
   FontManager_setState(impl, /*5De*/font.impl, /*5Ge*/size, /*5Ge*/align);
}
inline C(bool) FontManager::validateTexture(/*1Ab*/int * retdirtyrect)
{
   return FontManager_validateTexture(impl, /*5Ge*/retdirtyrect);
}


// property callers: FontManager::renderer
// (normal::normal)

/*nstSet*/inline /*0A*/const FontManagerRenderer & FontManager::renderer_Prop::operator= (/*0A*/const FontManagerRenderer & v)
{
   SELF(FontManager, renderer);
   FontManager_set_renderer(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline FontManager::renderer_Prop & FontManager::renderer_Prop::operator= (FontManager::renderer_Prop & prop)
{
   SELF(FontManager, renderer);
   /*0A*/const FontManagerRenderer & v = prop;
   FontManager_set_renderer(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const FontManagerRenderer * FontManager::renderer_Prop::operator= (/*0C*/const FontManagerRenderer * v)
{
   SELF(FontManager, renderer);
   FontManager_set_renderer(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline FontManager::renderer_Prop::operator /*0B*/TIH<FontManagerRenderer> () const
{
   SELF(FontManager, renderer);
   C(Instance) i = FontManager_get_renderer(self ? self->impl : null);
   TIH<FontManagerRenderer> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<FontManagerRenderer> FontManager::renderer_Prop::operator /*0D*/-> () const
{
   SELF(FontManager, renderer);
   C(Instance) i = FontManager_get_renderer(self ? self->impl : null);
   TIH<FontManagerRenderer> holder(i);
   return holder;
}
/*regGet*/inline FontManager::renderer_Prop::operator /*0E*/FontManagerRenderer () const
{
   SELF(FontManager, renderer);
   C(Instance) i = FontManager_get_renderer(self ? self->impl : null);
   return FontManagerRenderer(i);
}
/*regGet*/inline FontManager::renderer_Prop::operator /*0F*/FontManagerRenderer* () const
{
   SELF(FontManager, renderer);
   C(Instance) i = FontManager_get_renderer(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (FontManagerRenderer *)INSTANCEL(i, i->_class) : (FontManagerRenderer *)0;
}

inline FontManagerRenderer::FontManagerRenderer_createTexture_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_createTexture_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, createTexture);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_createTexture_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_createTexture_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_createTexture_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, createTexture)] = func;
   return func;
}
inline int FontManagerRenderer::FontManagerRenderer_createTexture_Functor::operator()( /*6Fj*/int width, /*6Fj*/int height)
{
   SELF(FontManagerRenderer, createTexture);
   return FontManagerRenderer_createTexture(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/width, /*7Al*/height);
}
// inline void FontManagerRenderer::register_createTexture(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_createTexture_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_createTexture_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, createTexture)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_drawImage_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_drawImage_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, drawImage);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_drawImage_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_drawImage_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_drawImage_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, drawImage)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_drawImage_Functor::operator()( /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int imageIndex, /*6Fj*/bool useExtColor)
{
   SELF(FontManagerRenderer, drawImage);
   FontManagerRenderer_drawImage(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/targetx, /*7Al*/targety, /*7Al*/imageIndex, /*7Al*/(C(bool))useExtColor);
}
// inline void FontManagerRenderer::register_drawImage(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImage_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_drawImage_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, drawImage)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, drawImageAlt);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, drawImageAlt)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::operator()( /*6Fj*/unsigned char * texdata, /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int offsetx, /*6Fj*/int offsety, /*6Fj*/int width, /*6Fj*/int height)
{
   SELF(FontManagerRenderer, drawImageAlt);
   FontManagerRenderer_drawImageAlt(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/texdata, /*7Al*/targetx, /*7Al*/targety, /*7Al*/offsetx, /*7Al*/offsety, /*7Al*/width, /*7Al*/height);
}
// inline void FontManagerRenderer::register_drawImageAlt(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_drawImageAlt_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, drawImageAlt)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, drawImageCursor);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, drawImageCursor)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::operator()( /*6Fj*/int targetx, /*6Fj*/int targety, /*6Fj*/int imageIndex)
{
   SELF(FontManagerRenderer, drawImageCursor);
   FontManagerRenderer_drawImageCursor(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/targetx, /*7Al*/targety, /*7Al*/imageIndex);
}
// inline void FontManagerRenderer::register_drawImageCursor(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_drawImageCursor_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, drawImageCursor)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, drawImageFloat);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, drawImageFloat)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::operator()( /*6Fj*/float targetx, /*6Fj*/float targety, /*6Fj*/float angsin, /*6Fj*/float angcos, /*6Fj*/int imageIndex, /*6Fj*/bool useExtColor)
{
   SELF(FontManagerRenderer, drawImageFloat);
   FontManagerRenderer_drawImageFloat(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/targetx, /*7Al*/targety, /*7Al*/angsin, /*7Al*/angcos, /*7Al*/imageIndex, /*7Al*/(C(bool))useExtColor);
}
// inline void FontManagerRenderer::register_drawImageFloat(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_drawImageFloat_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, drawImageFloat)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_flush_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_flush_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, flush);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_flush_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_flush_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_flush_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, flush)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_flush_Functor::operator()( )
{
   SELF(FontManagerRenderer, flush);
   FontManagerRenderer_flush(self ? self->impl : (C(FontManagerRenderer))null);
}
// inline void FontManagerRenderer::register_flush(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_flush_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_flush_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, flush)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_init_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_init_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, init);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_init_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_init_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_init_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, init)] = func;
   return func;
}
inline bool FontManagerRenderer::FontManagerRenderer_init_Functor::operator()( /*6Fj*/int channelCount)
{
   SELF(FontManagerRenderer, init);
   return (bool)FontManagerRenderer_init(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/channelCount);
}
// inline void FontManagerRenderer::register_init(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_init_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_init_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, init)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_registerImage_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_registerImage_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, registerImage);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_registerImage_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_registerImage_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_registerImage_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, registerImage)] = func;
   return func;
}
inline int FontManagerRenderer::FontManagerRenderer_registerImage_Functor::operator()( /*6Fj*/int offsetx, /*6Fj*/int offsety, /*6Fj*/int width, /*6Fj*/int height)
{
   SELF(FontManagerRenderer, registerImage);
   return FontManagerRenderer_registerImage(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/offsetx, /*7Al*/offsety, /*7Al*/width, /*7Al*/height);
}
// inline void FontManagerRenderer::register_registerImage(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_registerImage_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_registerImage_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, registerImage)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_resetImages_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_resetImages_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, resetImages);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_resetImages_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_resetImages_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_resetImages_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, resetImages)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_resetImages_Functor::operator()( )
{
   SELF(FontManagerRenderer, resetImages);
   FontManagerRenderer_resetImages(self ? self->impl : (C(FontManagerRenderer))null);
}
// inline void FontManagerRenderer::register_resetImages(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_resetImages_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_resetImages_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, resetImages)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, resizeTexture);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, resizeTexture)] = func;
   return func;
}
inline int FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::operator()( /*6Fj*/int width, /*6Fj*/int height)
{
   SELF(FontManagerRenderer, resizeTexture);
   return FontManagerRenderer_resizeTexture(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/width, /*7Al*/height);
}
// inline void FontManagerRenderer::register_resizeTexture(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_resizeTexture_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, resizeTexture)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_setLayer_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_setLayer_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, setLayer);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_setLayer_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_setLayer_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_setLayer_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, setLayer)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_setLayer_Functor::operator()( /*6Fj*/uint layerIndex)
{
   SELF(FontManagerRenderer, setLayer);
   FontManagerRenderer_setLayer(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/layerIndex);
}
// inline void FontManagerRenderer::register_setLayer(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_setLayer_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_setLayer_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, setLayer)] = func;
// }

inline FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::FunctionType FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::operator= (FunctionType func)
{
   SELF(FontManagerRenderer, updateTexture);
   if(self->vTbl == FontManagerRenderer::_cpp_class.vTbl)
   {
      uint size = FontManagerRenderer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::FunctionType, size);
      memcpy(self->vTbl, FontManagerRenderer::_cpp_class.vTbl, sizeof(FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::FunctionType) * size);
   }
   ((FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::FunctionType *)self->vTbl)[M_VTBLID(FontManagerRenderer, updateTexture)] = func;
   return func;
}
inline void FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::operator()( /*6Fj*/int * rect, /*6Fj*/const unsigned char * data)
{
   SELF(FontManagerRenderer, updateTexture);
   FontManagerRenderer_updateTexture(self ? self->impl : (C(FontManagerRenderer))null, /*7Al*/rect, /*7Al*/data);
}
// inline void FontManagerRenderer::register_updateTexture(CPPClass & cl, FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::FunctionType func)
// {
//    ((FontManagerRenderer::FontManagerRenderer_updateTexture_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FontManagerRenderer, updateTexture)] = func;
// }



// member accessors: FontManagerRenderer::fm
// (normal::normal)

/*nstSet*/inline /*0H*/FontManager FontManagerRenderer::fm_Prop::operator= (/*0H*/FontManager v)
{
   SELF(FontManagerRenderer, fm);
   IPTR(self->impl, FontManagerRenderer)->fm = v.impl;
   return v;
}

/*regSet*/inline FontManagerRenderer::fm_Prop & FontManagerRenderer::fm_Prop::operator= (FontManagerRenderer::fm_Prop & prop)
{
   SELF(FontManagerRenderer, fm);
   /*0H*/FontManager v = prop;
   IPTR(self->impl, FontManagerRenderer)->fm = v.impl;
   return prop;
}
/*regGet*/inline FontManagerRenderer::fm_Prop::operator /*0I*/FontManager () const
{
   SELF(FontManagerRenderer, fm);
   FontManager value(IPTR(self->impl, FontManagerRenderer)->fm, FontManagerRenderer::_cpp_class);
   return value;
}


inline void FontRenderer::setColor(/*1Ab*/ColorAlpha color)
{
   FontRenderer_setColor(impl, /*5Ee*/(C(ColorAlpha))color.impl);
}
inline void FontRenderer::setCursorColor(/*1Ab*/ColorAlpha color)
{
   FontRenderer_setCursorColor(impl, /*5Ee*/(C(ColorAlpha))color.impl);
}
inline void FontRenderer::setExtColor(/*1Ab*/ColorAlpha color)
{
   FontRenderer_setExtColor(impl, /*5Ee*/(C(ColorAlpha))color.impl);
}


// property callers: FontRenderer::drawManager   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const DrawManager & FontRenderer::drawManager_Prop::operator= (/*0A*/const DrawManager & v)
{
   SELF(FontRenderer, drawManager);
   FontRenderer_set_drawManager(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const DrawManager * FontRenderer::drawManager_Prop::operator= (/*0C*/const DrawManager * v)
{
   SELF(FontRenderer, drawManager);
   FontRenderer_set_drawManager(self ? self->impl : null, v ? v->impl : null);
   return v;
}


inline FontResource::FontResource(const char * faceName, float size = 0, bool bold = (bool)0, bool italic = (bool)0, bool underline = (bool)0) : FontResource()
{
   this->faceName = faceName;
   this->size = size;
   this->bold = bold;
   this->italic = italic;
   this->underline = underline;
}



// property callers: FontResource::faceName
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * FontResource::faceName_Prop::operator= (/*0H*/const char * v)
{
   SELF(FontResource, faceName);
   FontResource_set_faceName(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FontResource::faceName_Prop & FontResource::faceName_Prop::operator= (FontResource::faceName_Prop & prop)
{
   SELF(FontResource, faceName);
   /*0H*/const char * v = prop;
   FontResource_set_faceName(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FontResource::faceName_Prop::operator /*0I*/const char * () const
{
   SELF(FontResource, faceName);
   return FontResource_get_faceName(self ? self->impl : null);
}

// property callers: FontResource::size
// (normal::float)

/*nstSet*/inline /*0H*/float FontResource::size_Prop::operator= (/*0H*/float v)
{
   SELF(FontResource, size);
   FontResource_set_size(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FontResource::size_Prop & FontResource::size_Prop::operator= (FontResource::size_Prop & prop)
{
   SELF(FontResource, size);
   /*0H*/float v = prop;
   FontResource_set_size(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FontResource::size_Prop::operator /*0I*/float () const
{
   SELF(FontResource, size);
   return FontResource_get_size(self ? self->impl : null);
}

// property callers: FontResource::bold
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool FontResource::bold_Prop::operator= (/*0H*/bool v)
{
   SELF(FontResource, bold);
   FontResource_set_bold(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline FontResource::bold_Prop & FontResource::bold_Prop::operator= (FontResource::bold_Prop & prop)
{
   SELF(FontResource, bold);
   /*0H*/bool v = prop;
   FontResource_set_bold(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline FontResource::bold_Prop::operator /*0I*/bool () const
{
   SELF(FontResource, bold);
   return (bool)FontResource_get_bold(self ? self->impl : null);
}

// property callers: FontResource::italic
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool FontResource::italic_Prop::operator= (/*0H*/bool v)
{
   SELF(FontResource, italic);
   FontResource_set_italic(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline FontResource::italic_Prop & FontResource::italic_Prop::operator= (FontResource::italic_Prop & prop)
{
   SELF(FontResource, italic);
   /*0H*/bool v = prop;
   FontResource_set_italic(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline FontResource::italic_Prop::operator /*0I*/bool () const
{
   SELF(FontResource, italic);
   return (bool)FontResource_get_italic(self ? self->impl : null);
}

// property callers: FontResource::underline
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool FontResource::underline_Prop::operator= (/*0H*/bool v)
{
   SELF(FontResource, underline);
   FontResource_set_underline(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline FontResource::underline_Prop & FontResource::underline_Prop::operator= (FontResource::underline_Prop & prop)
{
   SELF(FontResource, underline);
   /*0H*/bool v = prop;
   FontResource_set_underline(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline FontResource::underline_Prop::operator /*0I*/bool () const
{
   SELF(FontResource, underline);
   return (bool)FontResource_get_underline(self ? self->impl : null);
}

// property callers: FontResource::font   // get only
// (normal::nohead)

/*regGet*/inline FontResource::font_Prop::operator /*0I*/Font () const
{
   SELF(FontResource, font);
   Font value(FontResource_get_font(self->impl));
   return value;
}

// property callers: FontResource::window   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & FontResource::window_Prop::operator= (/*0A*/const Window & v)
{
   SELF(FontResource, window);
   FontResource_set_window(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const Window * FontResource::window_Prop::operator= (/*0C*/const Window * v)
{
   SELF(FontResource, window);
   FontResource_set_window(self ? self->impl : null, v ? v->impl : null);
   return v;
}


// property callers: FontResource::outlineSize
// (normal::float)

/*nstSet*/inline /*0H*/float FontResource::outlineSize_Prop::operator= (/*0H*/float v)
{
   SELF(FontResource, outlineSize);
   FontResource_set_outlineSize(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FontResource::outlineSize_Prop & FontResource::outlineSize_Prop::operator= (FontResource::outlineSize_Prop & prop)
{
   SELF(FontResource, outlineSize);
   /*0H*/float v = prop;
   FontResource_set_outlineSize(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FontResource::outlineSize_Prop::operator /*0I*/float () const
{
   SELF(FontResource, outlineSize);
   return FontResource_get_outlineSize(self ? self->impl : null);
}

// property callers: FontResource::outlineFade
// (normal::float)

/*nstSet*/inline /*0H*/float FontResource::outlineFade_Prop::operator= (/*0H*/float v)
{
   SELF(FontResource, outlineFade);
   FontResource_set_outlineFade(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FontResource::outlineFade_Prop & FontResource::outlineFade_Prop::operator= (FontResource::outlineFade_Prop & prop)
{
   SELF(FontResource, outlineFade);
   /*0H*/float v = prop;
   FontResource_set_outlineFade(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FontResource::outlineFade_Prop::operator /*0I*/float () const
{
   SELF(FontResource, outlineFade);
   return FontResource_get_outlineFade(self ? self->impl : null);
}

// property callers: FontResource::fmFont   // get only
// (normal::nohead)

/*regGet*/inline FontResource::fmFont_Prop::operator /*0I*/FMFont () const
{
   SELF(FontResource, fmFont);
   FMFont value(FontResource_get_fmFont(self->impl));
   return value;
}



// member accessors: GLCapabilities::compatible
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::compatible_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, compatible);
   GLCAPABILITIES_SET_compatible(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::compatible_Prop & GLCapabilities::compatible_Prop::operator= (GLCapabilities::compatible_Prop & prop)
{
   SELF(GLCapabilities, compatible);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_compatible(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::compatible_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, compatible);
   return (bool)GLCAPABILITIES_compatible(self->impl);
}

// member accessors: GLCapabilities::vertexBuffer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::vertexBuffer_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, vertexBuffer);
   GLCAPABILITIES_SET_vertexBuffer(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::vertexBuffer_Prop & GLCapabilities::vertexBuffer_Prop::operator= (GLCapabilities::vertexBuffer_Prop & prop)
{
   SELF(GLCapabilities, vertexBuffer);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_vertexBuffer(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::vertexBuffer_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, vertexBuffer);
   return (bool)GLCAPABILITIES_vertexBuffer(self->impl);
}

// member accessors: GLCapabilities::quads
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::quads_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, quads);
   GLCAPABILITIES_SET_quads(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::quads_Prop & GLCapabilities::quads_Prop::operator= (GLCapabilities::quads_Prop & prop)
{
   SELF(GLCapabilities, quads);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_quads(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::quads_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, quads);
   return (bool)GLCAPABILITIES_quads(self->impl);
}

// member accessors: GLCapabilities::intAndDouble
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::intAndDouble_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, intAndDouble);
   GLCAPABILITIES_SET_intAndDouble(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::intAndDouble_Prop & GLCapabilities::intAndDouble_Prop::operator= (GLCapabilities::intAndDouble_Prop & prop)
{
   SELF(GLCapabilities, intAndDouble);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_intAndDouble(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::intAndDouble_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, intAndDouble);
   return (bool)GLCAPABILITIES_intAndDouble(self->impl);
}

// member accessors: GLCapabilities::legacyFormats
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::legacyFormats_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, legacyFormats);
   GLCAPABILITIES_SET_legacyFormats(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::legacyFormats_Prop & GLCapabilities::legacyFormats_Prop::operator= (GLCapabilities::legacyFormats_Prop & prop)
{
   SELF(GLCapabilities, legacyFormats);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_legacyFormats(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::legacyFormats_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, legacyFormats);
   return (bool)GLCAPABILITIES_legacyFormats(self->impl);
}

// member accessors: GLCapabilities::nonPow2Textures
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::nonPow2Textures_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, nonPow2Textures);
   GLCAPABILITIES_SET_nonPow2Textures(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::nonPow2Textures_Prop & GLCapabilities::nonPow2Textures_Prop::operator= (GLCapabilities::nonPow2Textures_Prop & prop)
{
   SELF(GLCapabilities, nonPow2Textures);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_nonPow2Textures(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::nonPow2Textures_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, nonPow2Textures);
   return (bool)GLCAPABILITIES_nonPow2Textures(self->impl);
}

// member accessors: GLCapabilities::vertexPointer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::vertexPointer_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, vertexPointer);
   GLCAPABILITIES_SET_vertexPointer(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::vertexPointer_Prop & GLCapabilities::vertexPointer_Prop::operator= (GLCapabilities::vertexPointer_Prop & prop)
{
   SELF(GLCapabilities, vertexPointer);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_vertexPointer(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::vertexPointer_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, vertexPointer);
   return (bool)GLCAPABILITIES_vertexPointer(self->impl);
}

// member accessors: GLCapabilities::legacy
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::legacy_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, legacy);
   GLCAPABILITIES_SET_legacy(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::legacy_Prop & GLCapabilities::legacy_Prop::operator= (GLCapabilities::legacy_Prop & prop)
{
   SELF(GLCapabilities, legacy);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_legacy(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::legacy_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, legacy);
   return (bool)GLCAPABILITIES_legacy(self->impl);
}

// member accessors: GLCapabilities::shaders
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::shaders_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, shaders);
   GLCAPABILITIES_SET_shaders(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::shaders_Prop & GLCapabilities::shaders_Prop::operator= (GLCapabilities::shaders_Prop & prop)
{
   SELF(GLCapabilities, shaders);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_shaders(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::shaders_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, shaders);
   return (bool)GLCAPABILITIES_shaders(self->impl);
}

// member accessors: GLCapabilities::fixedFunction
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::fixedFunction_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, fixedFunction);
   GLCAPABILITIES_SET_fixedFunction(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::fixedFunction_Prop & GLCapabilities::fixedFunction_Prop::operator= (GLCapabilities::fixedFunction_Prop & prop)
{
   SELF(GLCapabilities, fixedFunction);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_fixedFunction(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::fixedFunction_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, fixedFunction);
   return (bool)GLCAPABILITIES_fixedFunction(self->impl);
}

// member accessors: GLCapabilities::immediate
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::immediate_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, immediate);
   GLCAPABILITIES_SET_immediate(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::immediate_Prop & GLCapabilities::immediate_Prop::operator= (GLCapabilities::immediate_Prop & prop)
{
   SELF(GLCapabilities, immediate);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_immediate(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::immediate_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, immediate);
   return (bool)GLCAPABILITIES_immediate(self->impl);
}

// member accessors: GLCapabilities::frameBuffer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::frameBuffer_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, frameBuffer);
   GLCAPABILITIES_SET_frameBuffer(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::frameBuffer_Prop & GLCapabilities::frameBuffer_Prop::operator= (GLCapabilities::frameBuffer_Prop & prop)
{
   SELF(GLCapabilities, frameBuffer);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_frameBuffer(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::frameBuffer_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, frameBuffer);
   return (bool)GLCAPABILITIES_frameBuffer(self->impl);
}

// member accessors: GLCapabilities::pointSize
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::pointSize_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, pointSize);
   GLCAPABILITIES_SET_pointSize(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::pointSize_Prop & GLCapabilities::pointSize_Prop::operator= (GLCapabilities::pointSize_Prop & prop)
{
   SELF(GLCapabilities, pointSize);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_pointSize(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::pointSize_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, pointSize);
   return (bool)GLCAPABILITIES_pointSize(self->impl);
}

// member accessors: GLCapabilities::vao
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::vao_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, vao);
   GLCAPABILITIES_SET_vao(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::vao_Prop & GLCapabilities::vao_Prop::operator= (GLCapabilities::vao_Prop & prop)
{
   SELF(GLCapabilities, vao);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_vao(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::vao_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, vao);
   return (bool)GLCAPABILITIES_vao(self->impl);
}

// member accessors: GLCapabilities::select
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::select_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, select);
   GLCAPABILITIES_SET_select(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::select_Prop & GLCapabilities::select_Prop::operator= (GLCapabilities::select_Prop & prop)
{
   SELF(GLCapabilities, select);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_select(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::select_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, select);
   return (bool)GLCAPABILITIES_select(self->impl);
}

// member accessors: GLCapabilities::debug
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::debug_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, debug);
   GLCAPABILITIES_SET_debug(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::debug_Prop & GLCapabilities::debug_Prop::operator= (GLCapabilities::debug_Prop & prop)
{
   SELF(GLCapabilities, debug);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_debug(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::debug_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, debug);
   return (bool)GLCAPABILITIES_debug(self->impl);
}

// member accessors: GLCapabilities::gpuCommands
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::gpuCommands_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, gpuCommands);
   GLCAPABILITIES_SET_gpuCommands(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::gpuCommands_Prop & GLCapabilities::gpuCommands_Prop::operator= (GLCapabilities::gpuCommands_Prop & prop)
{
   SELF(GLCapabilities, gpuCommands);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_gpuCommands(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::gpuCommands_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, gpuCommands);
   return (bool)GLCAPABILITIES_gpuCommands(self->impl);
}

// member accessors: GLCapabilities::mdei
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool GLCapabilities::mdei_Prop::operator= (/*0H*/bool v)
{
   SELF(GLCapabilities, mdei);
   GLCAPABILITIES_SET_mdei(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::mdei_Prop & GLCapabilities::mdei_Prop::operator= (GLCapabilities::mdei_Prop & prop)
{
   SELF(GLCapabilities, mdei);
   /*0H*/bool v = prop;
   GLCAPABILITIES_SET_mdei(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::mdei_Prop::operator /*0I*/bool () const
{
   SELF(GLCapabilities, mdei);
   return (bool)GLCAPABILITIES_mdei(self->impl);
}

// member accessors: GLCapabilities::samples
// (bits::enum|int)

/*nstSet*/inline /*0H*/GLSamplesCount GLCapabilities::samples_Prop::operator= (/*0H*/GLSamplesCount v)
{
   SELF(GLCapabilities, samples);
   GLCAPABILITIES_SET_samples(self->impl, v);
   return v;
}

/*regSet*/inline GLCapabilities::samples_Prop & GLCapabilities::samples_Prop::operator= (GLCapabilities::samples_Prop & prop)
{
   SELF(GLCapabilities, samples);
   /*0H*/GLSamplesCount v = prop;
   GLCAPABILITIES_SET_samples(self->impl, v);
   return prop;
}
/*regGet*/inline GLCapabilities::samples_Prop::operator /*0I*/GLSamplesCount () const
{
   SELF(GLCapabilities, samples);
   return (GLSamplesCount)GLCAPABILITIES_samples(self->impl);
}


template <class TC, C(Class) ** TCO> inline int THitRecord<TC, TCO>::compare(/*1Ab*/THitRecord<TC, TCO> recordB, /*1Ab*/void * unused)
{
   return HitRecord_compare((C(HitRecord)*)this->impl, /*5De*/recordB.impl, /*5Ge*/unused);
}


// member accessors: HitRecord::prev
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/HitRecord THitRecord<TC, TCO>::prev_Prop::operator= (/*0H*/HitRecord & v)
{
   SELF(HitRecord, prev);
   ((C(HitRecord) *)self->impl)->prev = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename THitRecord<TC, TCO>::prev_Prop & THitRecord<TC, TCO>::prev_Prop::operator= (typename THitRecord<TC, TCO>::prev_Prop & prop)
{
   SELF(HitRecord, prev);
   /*0H*/HitRecord v = prop;
   ((C(HitRecord) *)self->impl)->prev = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline THitRecord<TC, TCO>::prev_Prop::operator /*0I*/HitRecord () const
{
   __attribute__((unused)) THitRecord TCTCO * self = CONTAINER_OF(this, THitRecord TCTCO, prev);
   HitRecord value(((C(HitRecord) *)self->impl)->prev);
   return value;
}

// member accessors: HitRecord::next
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/HitRecord THitRecord<TC, TCO>::next_Prop::operator= (/*0H*/HitRecord & v)
{
   SELF(HitRecord, next);
   ((C(HitRecord) *)self->impl)->next = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename THitRecord<TC, TCO>::next_Prop & THitRecord<TC, TCO>::next_Prop::operator= (typename THitRecord<TC, TCO>::next_Prop & prop)
{
   SELF(HitRecord, next);
   /*0H*/HitRecord v = prop;
   ((C(HitRecord) *)self->impl)->next = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline THitRecord<TC, TCO>::next_Prop::operator /*0I*/HitRecord () const
{
   __attribute__((unused)) THitRecord TCTCO * self = CONTAINER_OF(this, THitRecord TCTCO, next);
   HitRecord value(((C(HitRecord) *)self->impl)->next);
   return value;
}

// member accessors: HitRecord::pos
// (nohead::uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint THitRecord<TC, TCO>::pos_Prop::operator= (/*0H*/uint v)
{
   SELF(HitRecord, pos);
   ((C(HitRecord) *)self->impl)->pos = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename THitRecord<TC, TCO>::pos_Prop & THitRecord<TC, TCO>::pos_Prop::operator= (typename THitRecord<TC, TCO>::pos_Prop & prop)
{
   SELF(HitRecord, pos);
   /*0H*/uint v = prop;
   ((C(HitRecord) *)self->impl)->pos = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline THitRecord<TC, TCO>::pos_Prop::operator /*0I*/uint () const
{
   __attribute__((unused)) THitRecord TCTCO * self = CONTAINER_OF(this, THitRecord TCTCO, pos);
   return self ? ((C(HitRecord) *)self->impl)->pos : 0;
}

// member accessors: HitRecord::numTags
// (nohead::uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint THitRecord<TC, TCO>::numTags_Prop::operator= (/*0H*/uint v)
{
   SELF(HitRecord, numTags);
   ((C(HitRecord) *)self->impl)->numTags = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename THitRecord<TC, TCO>::numTags_Prop & THitRecord<TC, TCO>::numTags_Prop::operator= (typename THitRecord<TC, TCO>::numTags_Prop & prop)
{
   SELF(HitRecord, numTags);
   /*0H*/uint v = prop;
   ((C(HitRecord) *)self->impl)->numTags = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline THitRecord<TC, TCO>::numTags_Prop::operator /*0I*/uint () const
{
   __attribute__((unused)) THitRecord TCTCO * self = CONTAINER_OF(this, THitRecord TCTCO, numTags);
   return self ? ((C(HitRecord) *)self->impl)->numTags : 0;
}

// member accessors: HitRecord::center
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Vector3D THitRecord<TC, TCO>::center_Prop::operator= (/*0H*/Vector3D v)
{
   SELF(HitRecord, center);
   ((C(HitRecord) *)self->impl)->center = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename THitRecord<TC, TCO>::center_Prop & THitRecord<TC, TCO>::center_Prop::operator= (typename THitRecord<TC, TCO>::center_Prop & prop)
{
   SELF(HitRecord, center);
   /*0H*/Vector3D v = prop;
   ((C(HitRecord) *)self->impl)->center = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline THitRecord<TC, TCO>::center_Prop::operator /*0I*/Vector3D () const
{
   __attribute__((unused)) THitRecord TCTCO * self = CONTAINER_OF(this, THitRecord TCTCO, center);
   Vector3D value(((C(HitRecord) *)self->impl)->center);
   return value;
}

inline Light::Light(LightFlags flags, ColorRGB ambient = ColorRGB(), ColorRGB diffuse = ColorRGB(), ColorRGB specular = ColorRGB(), Vector3D direction = Vector3D(), Quaternion orientation = Quaternion())
{
   impl.flags = flags;
   impl.ambient = ambient.impl;
   impl.diffuse = diffuse.impl;
   impl.specular = specular.impl;
   impl.direction = direction.impl;
   impl.orientation = orientation.impl;
}



// member accessors: Light::flags
// (struct::bits|unsigned int)

/*nstSet*/inline /*0H*/LightFlags Light::flags_Prop::operator= (/*0H*/LightFlags v)
{
   SELF(Light, flags);
   self->impl.flags = v;
   return v;
}

/*regSet*/inline Light::flags_Prop & Light::flags_Prop::operator= (Light::flags_Prop & prop)
{
   SELF(Light, flags);
   /*0H*/LightFlags v = prop;
   self->impl.flags = v;
   return prop;
}
/*regGet*/inline Light::flags_Prop::operator /*0I*/LightFlags () const
{
   SELF(Light, flags);
   return self ? LightFlags(((C(Light) *)&self->impl)->flags) : LightFlags();
}

// member accessors: Light::ambient
// (struct::struct)

/*nstSet*/inline /*0H*/ColorRGB Light::ambient_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(Light, ambient);
   self->impl.ambient = v.impl;
   return v;
}

/*regSet*/inline Light::ambient_Prop & Light::ambient_Prop::operator= (Light::ambient_Prop & prop)
{
   SELF(Light, ambient);
   /*0H*/ColorRGB v = prop;
   self->impl.ambient = v.impl;
   return prop;
}
/*regGet*/inline Light::ambient_Prop::operator /*0I*/ColorRGB () const
{
   SELF(Light, ambient);
   ColorRGB value(((C(Light) *)&self->impl)->ambient);
   return value;
}

// member accessors: Light::diffuse
// (struct::struct)

/*nstSet*/inline /*0H*/ColorRGB Light::diffuse_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(Light, diffuse);
   self->impl.diffuse = v.impl;
   return v;
}

/*regSet*/inline Light::diffuse_Prop & Light::diffuse_Prop::operator= (Light::diffuse_Prop & prop)
{
   SELF(Light, diffuse);
   /*0H*/ColorRGB v = prop;
   self->impl.diffuse = v.impl;
   return prop;
}
/*regGet*/inline Light::diffuse_Prop::operator /*0I*/ColorRGB () const
{
   SELF(Light, diffuse);
   ColorRGB value(((C(Light) *)&self->impl)->diffuse);
   return value;
}

// member accessors: Light::specular
// (struct::struct)

/*nstSet*/inline /*0H*/ColorRGB Light::specular_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(Light, specular);
   self->impl.specular = v.impl;
   return v;
}

/*regSet*/inline Light::specular_Prop & Light::specular_Prop::operator= (Light::specular_Prop & prop)
{
   SELF(Light, specular);
   /*0H*/ColorRGB v = prop;
   self->impl.specular = v.impl;
   return prop;
}
/*regGet*/inline Light::specular_Prop::operator /*0I*/ColorRGB () const
{
   SELF(Light, specular);
   ColorRGB value(((C(Light) *)&self->impl)->specular);
   return value;
}

// member accessors: Light::direction
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3D Light::direction_Prop::operator= (/*0H*/Vector3D v)
{
   SELF(Light, direction);
   self->impl.direction = v.impl;
   return v;
}

/*regSet*/inline Light::direction_Prop & Light::direction_Prop::operator= (Light::direction_Prop & prop)
{
   SELF(Light, direction);
   /*0H*/Vector3D v = prop;
   self->impl.direction = v.impl;
   return prop;
}
/*regGet*/inline Light::direction_Prop::operator /*0I*/Vector3D () const
{
   SELF(Light, direction);
   Vector3D value(((C(Light) *)&self->impl)->direction);
   return value;
}

// member accessors: Light::orientation
// (struct::struct)

/*nstSet*/inline /*0H*/Quaternion Light::orientation_Prop::operator= (/*0H*/Quaternion v)
{
   SELF(Light, orientation);
   self->impl.orientation = v.impl;
   return v;
}

/*regSet*/inline Light::orientation_Prop & Light::orientation_Prop::operator= (Light::orientation_Prop & prop)
{
   SELF(Light, orientation);
   /*0H*/Quaternion v = prop;
   self->impl.orientation = v.impl;
   return prop;
}
/*regGet*/inline Light::orientation_Prop::operator /*0I*/Quaternion () const
{
   SELF(Light, orientation);
   Quaternion value(((C(Light) *)&self->impl)->orientation);
   return value;
}

// member accessors: Light::lightObject
// (struct::nohead)

/*nstSet*/inline /*0H*/Object Light::lightObject_Prop::operator= (/*0H*/Object & v)
{
   SELF(Light, lightObject);
   self->impl.lightObject = v.impl;
   return v;
}

/*regSet*/inline Light::lightObject_Prop & Light::lightObject_Prop::operator= (Light::lightObject_Prop & prop)
{
   SELF(Light, lightObject);
   /*0H*/Object v = prop;
   self->impl.lightObject = v.impl;
   return prop;
}
/*regGet*/inline Light::lightObject_Prop::operator /*0I*/Object () const
{
   SELF(Light, lightObject);
   Object value(((C(Light) *)&self->impl)->lightObject);
   return value;
}

// member accessors: Light::target
// (struct::nohead)

/*nstSet*/inline /*0H*/Object Light::target_Prop::operator= (/*0H*/Object & v)
{
   SELF(Light, target);
   self->impl.target = v.impl;
   return v;
}

/*regSet*/inline Light::target_Prop & Light::target_Prop::operator= (Light::target_Prop & prop)
{
   SELF(Light, target);
   /*0H*/Object v = prop;
   self->impl.target = v.impl;
   return prop;
}
/*regGet*/inline Light::target_Prop::operator /*0I*/Object () const
{
   SELF(Light, target);
   Object value(((C(Light) *)&self->impl)->target);
   return value;
}

// member accessors: Light::fallOff
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees Light::fallOff_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Light, fallOff);
   self->impl.fallOff = (double)v.impl;
   return v;
}

/*regSet*/inline Light::fallOff_Prop & Light::fallOff_Prop::operator= (Light::fallOff_Prop & prop)
{
   SELF(Light, fallOff);
   /*0H*/Degrees v = prop;
   self->impl.fallOff = (double)v.impl;
   return prop;
}
/*regGet*/inline Light::fallOff_Prop::operator /*0I*/Degrees () const
{
   SELF(Light, fallOff);
   return Degrees(Angle(self->impl.fallOff));
}
/*regGet*/inline Light::fallOff_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Light, fallOff);
   return Degrees(self->fallOff);
}

// member accessors: Light::hotSpot
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees Light::hotSpot_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Light, hotSpot);
   self->impl.hotSpot = (double)v.impl;
   return v;
}

/*regSet*/inline Light::hotSpot_Prop & Light::hotSpot_Prop::operator= (Light::hotSpot_Prop & prop)
{
   SELF(Light, hotSpot);
   /*0H*/Degrees v = prop;
   self->impl.hotSpot = (double)v.impl;
   return prop;
}
/*regGet*/inline Light::hotSpot_Prop::operator /*0I*/Degrees () const
{
   SELF(Light, hotSpot);
   return Degrees(Angle(self->impl.hotSpot));
}
/*regGet*/inline Light::hotSpot_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Light, hotSpot);
   return Degrees(self->hotSpot);
}

// member accessors: Light::Kc
// (struct::float)

/*nstSet*/inline /*0H*/float Light::Kc_Prop::operator= (/*0H*/float v)
{
   SELF(Light, Kc);
   self->impl.Kc = v;
   return v;
}

/*regSet*/inline Light::Kc_Prop & Light::Kc_Prop::operator= (Light::Kc_Prop & prop)
{
   SELF(Light, Kc);
   /*0H*/float v = prop;
   self->impl.Kc = v;
   return prop;
}
/*regGet*/inline Light::Kc_Prop::operator /*0I*/float () const
{
   SELF(Light, Kc);
   return self ? ((C(Light) *)&self->impl)->Kc : 0;
}

// member accessors: Light::Kl
// (struct::float)

/*nstSet*/inline /*0H*/float Light::Kl_Prop::operator= (/*0H*/float v)
{
   SELF(Light, Kl);
   self->impl.Kl = v;
   return v;
}

/*regSet*/inline Light::Kl_Prop & Light::Kl_Prop::operator= (Light::Kl_Prop & prop)
{
   SELF(Light, Kl);
   /*0H*/float v = prop;
   self->impl.Kl = v;
   return prop;
}
/*regGet*/inline Light::Kl_Prop::operator /*0I*/float () const
{
   SELF(Light, Kl);
   return self ? ((C(Light) *)&self->impl)->Kl : 0;
}

// member accessors: Light::Kq
// (struct::float)

/*nstSet*/inline /*0H*/float Light::Kq_Prop::operator= (/*0H*/float v)
{
   SELF(Light, Kq);
   self->impl.Kq = v;
   return v;
}

/*regSet*/inline Light::Kq_Prop & Light::Kq_Prop::operator= (Light::Kq_Prop & prop)
{
   SELF(Light, Kq);
   /*0H*/float v = prop;
   self->impl.Kq = v;
   return prop;
}
/*regGet*/inline Light::Kq_Prop::operator /*0I*/float () const
{
   SELF(Light, Kq);
   return self ? ((C(Light) *)&self->impl)->Kq : 0;
}

// member accessors: Light::start
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees Light::start_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Light, start);
   self->impl.start = (double)v.impl;
   return v;
}

/*regSet*/inline Light::start_Prop & Light::start_Prop::operator= (Light::start_Prop & prop)
{
   SELF(Light, start);
   /*0H*/Degrees v = prop;
   self->impl.start = (double)v.impl;
   return prop;
}
/*regGet*/inline Light::start_Prop::operator /*0I*/Degrees () const
{
   SELF(Light, start);
   return Degrees(Angle(self->impl.start));
}
/*regGet*/inline Light::start_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Light, start);
   return Degrees(self->start);
}

// member accessors: Light::end
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees Light::end_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Light, end);
   self->impl.end = (double)v.impl;
   return v;
}

/*regSet*/inline Light::end_Prop & Light::end_Prop::operator= (Light::end_Prop & prop)
{
   SELF(Light, end);
   /*0H*/Degrees v = prop;
   self->impl.end = (double)v.impl;
   return prop;
}
/*regGet*/inline Light::end_Prop::operator /*0I*/Degrees () const
{
   SELF(Light, end);
   return Degrees(Angle(self->impl.end));
}
/*regGet*/inline Light::end_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Light, end);
   return Degrees(self->end);
}

// member accessors: Light::multiplier
// (struct::float)

/*nstSet*/inline /*0H*/float Light::multiplier_Prop::operator= (/*0H*/float v)
{
   SELF(Light, multiplier);
   self->impl.multiplier = v;
   return v;
}

/*regSet*/inline Light::multiplier_Prop & Light::multiplier_Prop::operator= (Light::multiplier_Prop & prop)
{
   SELF(Light, multiplier);
   /*0H*/float v = prop;
   self->impl.multiplier = v;
   return prop;
}
/*regGet*/inline Light::multiplier_Prop::operator /*0I*/float () const
{
   SELF(Light, multiplier);
   return self ? ((C(Light) *)&self->impl)->multiplier : 0;
}



// member accessors: LightFlags::off
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool LightFlags::off_Prop::operator= (/*0H*/bool v)
{
   SELF(LightFlags, off);
   LIGHTFLAGS_SET_off(self->impl, v);
   return v;
}

/*regSet*/inline LightFlags::off_Prop & LightFlags::off_Prop::operator= (LightFlags::off_Prop & prop)
{
   SELF(LightFlags, off);
   /*0H*/bool v = prop;
   LIGHTFLAGS_SET_off(self->impl, v);
   return prop;
}
/*regGet*/inline LightFlags::off_Prop::operator /*0I*/bool () const
{
   SELF(LightFlags, off);
   return (bool)LIGHTFLAGS_off(self->impl);
}

// member accessors: LightFlags::spot
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool LightFlags::spot_Prop::operator= (/*0H*/bool v)
{
   SELF(LightFlags, spot);
   LIGHTFLAGS_SET_spot(self->impl, v);
   return v;
}

/*regSet*/inline LightFlags::spot_Prop & LightFlags::spot_Prop::operator= (LightFlags::spot_Prop & prop)
{
   SELF(LightFlags, spot);
   /*0H*/bool v = prop;
   LIGHTFLAGS_SET_spot(self->impl, v);
   return prop;
}
/*regGet*/inline LightFlags::spot_Prop::operator /*0I*/bool () const
{
   SELF(LightFlags, spot);
   return (bool)LIGHTFLAGS_spot(self->impl);
}

// member accessors: LightFlags::omni
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool LightFlags::omni_Prop::operator= (/*0H*/bool v)
{
   SELF(LightFlags, omni);
   LIGHTFLAGS_SET_omni(self->impl, v);
   return v;
}

/*regSet*/inline LightFlags::omni_Prop & LightFlags::omni_Prop::operator= (LightFlags::omni_Prop & prop)
{
   SELF(LightFlags, omni);
   /*0H*/bool v = prop;
   LIGHTFLAGS_SET_omni(self->impl, v);
   return prop;
}
/*regGet*/inline LightFlags::omni_Prop::operator /*0I*/bool () const
{
   SELF(LightFlags, omni);
   return (bool)LIGHTFLAGS_omni(self->impl);
}

// member accessors: LightFlags::attenuation
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool LightFlags::attenuation_Prop::operator= (/*0H*/bool v)
{
   SELF(LightFlags, attenuation);
   LIGHTFLAGS_SET_attenuation(self->impl, v);
   return v;
}

/*regSet*/inline LightFlags::attenuation_Prop & LightFlags::attenuation_Prop::operator= (LightFlags::attenuation_Prop & prop)
{
   SELF(LightFlags, attenuation);
   /*0H*/bool v = prop;
   LIGHTFLAGS_SET_attenuation(self->impl, v);
   return prop;
}
/*regGet*/inline LightFlags::attenuation_Prop::operator /*0I*/bool () const
{
   SELF(LightFlags, attenuation);
   return (bool)LIGHTFLAGS_attenuation(self->impl);
}

inline RenderStateFloat::RenderStateFloat(float f, uint ui = 0)
{
   impl.f = f;
   impl.ui = ui;
}



// member accessors: RenderStateFloat::f
// (struct::float)

/*nstSet*/inline /*0H*/float RenderStateFloat::f_Prop::operator= (/*0H*/float v)
{
   SELF(RenderStateFloat, f);
   self->impl.f = v;
   return v;
}

/*regSet*/inline RenderStateFloat::f_Prop & RenderStateFloat::f_Prop::operator= (RenderStateFloat::f_Prop & prop)
{
   SELF(RenderStateFloat, f);
   /*0H*/float v = prop;
   self->impl.f = v;
   return prop;
}
/*regGet*/inline RenderStateFloat::f_Prop::operator /*0I*/float () const
{
   SELF(RenderStateFloat, f);
   return self ? ((C(RenderStateFloat) *)&self->impl)->f : 0;
}

// member accessors: RenderStateFloat::ui
// (struct::uint)

/*nstSet*/inline /*0H*/uint RenderStateFloat::ui_Prop::operator= (/*0H*/uint v)
{
   SELF(RenderStateFloat, ui);
   self->impl.ui = v;
   return v;
}

/*regSet*/inline RenderStateFloat::ui_Prop & RenderStateFloat::ui_Prop::operator= (RenderStateFloat::ui_Prop & prop)
{
   SELF(RenderStateFloat, ui);
   /*0H*/uint v = prop;
   self->impl.ui = v;
   return prop;
}
/*regGet*/inline RenderStateFloat::ui_Prop::operator /*0I*/uint () const
{
   SELF(RenderStateFloat, ui);
   return self ? ((C(RenderStateFloat) *)&self->impl)->ui : 0;
}


inline Surface::Surface(int width, int height = 0, Point offset = Point(), Box box = Box(), Box unclippedBox = Box(), void * driverData = null, AlphaWriteMode alphaWrite = (AlphaWriteMode)0, bool blend = (bool)0, ColorAlpha outlineColor = ColorAlpha(), ColorAlpha foreground = ColorAlpha(), ColorAlpha background = ColorAlpha(), ColorAlpha blitTint = ColorAlpha(), Color blackTint = Color(), uint lineStipple = 0) : Surface()
{
   this->width = width;
   this->height = height;
   this->offset = offset.impl;
   this->box = box.impl;
   this->unclippedBox = unclippedBox.impl;
   this->driverData = driverData;
   this->alphaWrite = alphaWrite;
   this->blend = blend;
   this->outlineColor = outlineColor;
   this->foreground = foreground;
   this->background = background;
   this->blitTint = blitTint;
   this->blackTint = blackTint;
   this->lineStipple = lineStipple;
}


inline void Surface::area(/*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2)
{
   Surface_area(impl, /*5Ge*/x1, /*5Ge*/y1, /*5Ge*/x2, /*5Ge*/y2);
}
inline void Surface::bevel(/*1Ab*/bool inner, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_bevel(impl, /*5Ee*/(C(bool))inner, /*5Ge*/x, /*5Ge*/y, /*5Ge*/w, /*5Ge*/h);
}
inline void Surface::blit(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_blit(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/sx, /*5Ge*/sy, /*5Ge*/w, /*5Ge*/h);
}
template<typename... Args> inline void Surface::centerTextf(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * format, /*1Ab*/Args... args)
{
   Surface_centerTextf(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/format, /*5Ae*/args...);
}
inline void Surface::clear(/*1Ab*/ClearType type)
{
   Surface_clear(impl, /*5Ee*/(C(ClearType))type);
}
inline void Surface::clip(/*1Ab*/Box & box)
{
   Surface_clip(impl, /*5De*/&box.impl);
}
inline void Surface::clip(/*1Ac*/Box * box)
{
   Surface_clip(impl, /*5Cf*/(C(Box) *)box);
}
inline void Surface::drawLine(/*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2)
{
   Surface_drawLine(impl, /*5Ge*/x1, /*5Ge*/y1, /*5Ge*/x2, /*5Ge*/y2);
}
inline void Surface::_drawingChar(/*1Ab*/byte value)
{
   Surface_drawingChar(impl, /*5Ge*/value);
}
inline void Surface::filter(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh)
{
   Surface_filter(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/sx, /*5Ge*/sy, /*5Ge*/w, /*5Ge*/h, /*5Ge*/sw, /*5Ge*/sh);
}
inline void Surface::filterHTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_filterHTile(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/w, /*5Ge*/h);
}
inline void Surface::filterVTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_filterVTile(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/w, /*5Ge*/h);
}
inline C(Color) Surface::getBackground()
{
   return Surface_getBackground(impl);
}
inline void Surface::getBox(/*1Ab*/Box & value)
{
   Surface_getBox(impl, /*5De*/&value.impl);
}
inline void Surface::getBox(/*1Ac*/Box * value)
{
   Surface_getBox(impl, /*5Cf*/(C(Box) *)value);
}
inline Display Surface::getDisplay()
{
   return Display(Surface_getDisplay(impl));
}
inline C(Font) * Surface::getFont()
{
   return Surface_getFont(impl);
}
inline C(Color) Surface::getForeground()
{
   return Surface_getForeground(impl);
}
inline C(ColorAlpha) Surface::getPixel(/*1Ab*/int x, /*1Ab*/int y)
{
   return Surface_getPixel(impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Surface::getSize(/*1Ab*/int * w, /*1Ab*/int * h)
{
   Surface_getSize(impl, /*5Ge*/w, /*5Ge*/h);
}
inline C(bool) Surface::getTextOpacity()
{
   return Surface_getTextOpacity(impl);
}
inline void Surface::gradient(/*1Ab*/ColorKey * keys, /*1Ab*/int numKeys, /*1Ab*/float smoothness, /*1Ab*/GradientDirection direction, /*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2)
{
   Surface_gradient(impl, /*5Ee*/(C(ColorKey) *)keys, /*5Ge*/numKeys, /*5Ge*/smoothness, /*5Ee*/(C(GradientDirection))direction, /*5Ge*/x1, /*5Ge*/y1, /*5Ge*/x2, /*5Ge*/y2);
}
inline void Surface::hLine(/*1Ab*/int x1, /*1Ab*/int x2, /*1Ab*/int y)
{
   Surface_hLine(impl, /*5Ge*/x1, /*5Ge*/x2, /*5Ge*/y);
}
inline void Surface::hTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_hTile(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/w, /*5Ge*/h);
}
inline void Surface::_lineStipple(/*1Ab*/uint value)
{
   Surface_lineStipple(impl, /*5Ge*/value);
}
inline void Surface::putPixel(/*1Ab*/int x, /*1Ab*/int y)
{
   Surface_putPixel(impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Surface::rectangle(/*1Ab*/int x1, /*1Ab*/int y1, /*1Ab*/int x2, /*1Ab*/int y2)
{
   Surface_rectangle(impl, /*5Ge*/x1, /*5Ge*/y1, /*5Ge*/x2, /*5Ge*/y2);
}
inline void Surface::setBackground(/*1Ab*/ColorAlpha value)
{
   Surface_setBackground(impl, /*5Ee*/(C(ColorAlpha))value.impl);
}
inline void Surface::setForeground(/*1Ab*/ColorAlpha value)
{
   Surface_setForeground(impl, /*5Ee*/(C(ColorAlpha))value.impl);
}
inline void Surface::stretch(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int sx, /*1Ab*/int sy, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/int sw, /*1Ab*/int sh)
{
   Surface_stretch(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/sx, /*5Ge*/sy, /*5Ge*/w, /*5Ge*/h, /*5Ge*/sw, /*5Ge*/sh);
}
inline void Surface::stretchf(/*1Ab*/Bitmap & src, /*1Ab*/float dx, /*1Ab*/float dy, /*1Ab*/float sx, /*1Ab*/float sy, /*1Ab*/float w, /*1Ab*/float h, /*1Ab*/float sw, /*1Ab*/float sh)
{
   Surface_stretchf(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/sx, /*5Ge*/sy, /*5Ge*/w, /*5Ge*/h, /*5Ge*/sw, /*5Ge*/sh);
}
inline void Surface::textExtent(/*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height)
{
   Surface_textExtent(impl, /*5Ge*/text, /*5Ge*/len, /*5Ge*/width, /*5Ge*/height);
}
inline void Surface::textExtent2(/*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int * width, /*1Ab*/int * height, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph, /*1Ab*/int * overHang)
{
   Surface_textExtent2(impl, /*5Ge*/text, /*5Ge*/len, /*5Ge*/width, /*5Ge*/height, /*5Ge*/prevGlyph, /*5Ge*/rPrevGlyph, /*5Ge*/overHang);
}
inline void Surface::textFont(/*1Ab*/Font value)
{
   Surface_textFont(impl, /*5De*/value.impl);
}
inline void Surface::_textOpacity(/*1Ab*/bool value)
{
   Surface_textOpacity(impl, /*5Ee*/(C(bool))value);
}
inline void Surface::thinBevel(/*1Ab*/bool inner, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_thinBevel(impl, /*5Ee*/(C(bool))inner, /*5Ge*/x, /*5Ge*/y, /*5Ge*/w, /*5Ge*/h);
}
inline void Surface::tile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_tile(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/w, /*5Ge*/h);
}
inline void Surface::vLine(/*1Ab*/int y1, /*1Ab*/int y2, /*1Ab*/int x)
{
   Surface_vLine(impl, /*5Ge*/y1, /*5Ge*/y2, /*5Ge*/x);
}
inline void Surface::vTile(/*1Ab*/Bitmap & src, /*1Ab*/int dx, /*1Ab*/int dy, /*1Ab*/int w, /*1Ab*/int h)
{
   Surface_vTile(impl, /*5De*/src.impl, /*5Ge*/dx, /*5Ge*/dy, /*5Ge*/w, /*5Ge*/h);
}
inline void Surface::writeText(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/int len)
{
   Surface_writeText(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/text, /*5Ge*/len);
}
inline void Surface::writeText2(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/int len, /*1Ab*/int prevGlyph, /*1Ab*/int * rPrevGlyph)
{
   Surface_writeText2(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/text, /*5Ge*/len, /*5Ge*/prevGlyph, /*5Ge*/rPrevGlyph);
}
inline void Surface::writeTextDots(/*1Ab*/Alignment alignment, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int width, /*1Ab*/const char * text, /*1Ab*/int len)
{
   Surface_writeTextDots(impl, /*5Ee*/(C(Alignment))alignment, /*5Ge*/x, /*5Ge*/y, /*5Ge*/width, /*5Ge*/text, /*5Ge*/len);
}
template<typename... Args> inline void Surface::writeTextDotsf(/*1Ab*/Alignment alignment, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int width, /*1Ab*/const char * format, /*1Ab*/Args... args)
{
   Surface_writeTextDotsf(impl, /*5Ee*/(C(Alignment))alignment, /*5Ge*/x, /*5Ge*/y, /*5Ge*/width, /*5Ge*/format, /*5Ae*/args...);
}
template<typename... Args> inline void Surface::writeTextf(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * format, /*1Ab*/Args... args)
{
   Surface_writeTextf(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/format, /*5Ae*/args...);
}


// property callers: Surface::alphaWrite
// (normal::enum|int)

/*nstSet*/inline /*0H*/AlphaWriteMode Surface::alphaWrite_Prop::operator= (/*0H*/AlphaWriteMode v)
{
   SELF(Surface, alphaWrite);
   Surface_set_alphaWrite(self ? self->impl : null, (C(AlphaWriteMode))v);
   return v;
}

/*regSet*/inline Surface::alphaWrite_Prop & Surface::alphaWrite_Prop::operator= (Surface::alphaWrite_Prop & prop)
{
   SELF(Surface, alphaWrite);
   /*0H*/AlphaWriteMode v = prop;
   Surface_set_alphaWrite(self ? self->impl : null, (C(AlphaWriteMode))v);
   return prop;
}
/*regGet*/inline Surface::alphaWrite_Prop::operator /*0I*/AlphaWriteMode () const
{
   SELF(Surface, alphaWrite);
   return (AlphaWriteMode)Surface_get_alphaWrite(self ? self->impl : null);
}

// property callers: Surface::blend
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Surface::blend_Prop::operator= (/*0H*/bool v)
{
   SELF(Surface, blend);
   Surface_set_blend(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Surface::blend_Prop & Surface::blend_Prop::operator= (Surface::blend_Prop & prop)
{
   SELF(Surface, blend);
   /*0H*/bool v = prop;
   Surface_set_blend(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Surface::blend_Prop::operator /*0I*/bool () const
{
   SELF(Surface, blend);
   return (bool)Surface_get_blend(self ? self->impl : null);
}

// property callers: Surface::bitmap   // get only
// (normal::normal)

/*regGet*/inline Surface::bitmap_Prop::operator /*0B*/TIH<Bitmap> () const
{
   SELF(Surface, bitmap);
   C(Instance) i = Surface_get_bitmap(self ? self->impl : null);
   TIH<Bitmap> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Bitmap> Surface::bitmap_Prop::operator /*0D*/-> () const
{
   SELF(Surface, bitmap);
   C(Instance) i = Surface_get_bitmap(self ? self->impl : null);
   TIH<Bitmap> holder(i);
   return holder;
}
/*regGet*/inline Surface::bitmap_Prop::operator /*0E*/Bitmap () const
{
   SELF(Surface, bitmap);
   C(Instance) i = Surface_get_bitmap(self ? self->impl : null);
   return Bitmap(i);
}
/*regGet*/inline Surface::bitmap_Prop::operator /*0F*/Bitmap* () const
{
   SELF(Surface, bitmap);
   C(Instance) i = Surface_get_bitmap(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Bitmap *)INSTANCEL(i, i->_class) : (Bitmap *)0;
}

// property callers: Surface::outlineColor
// (normal::bits|unsigned int)

/*nstSet*/inline /*0H*/ColorAlpha Surface::outlineColor_Prop::operator= (/*0H*/ColorAlpha v)
{
   SELF(Surface, outlineColor);
   Surface_set_outlineColor(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Surface::outlineColor_Prop & Surface::outlineColor_Prop::operator= (Surface::outlineColor_Prop & prop)
{
   SELF(Surface, outlineColor);
   /*0H*/ColorAlpha v = prop;
   Surface_set_outlineColor(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Surface::outlineColor_Prop::operator /*0I*/ColorAlpha () const
{
   SELF(Surface, outlineColor);
   return Surface_get_outlineColor(self ? self->impl : null);
}

// property callers: Surface::foreground
// (normal::bits|unsigned int)

/*nstSet*/inline /*0H*/ColorAlpha Surface::foreground_Prop::operator= (/*0H*/ColorAlpha v)
{
   SELF(Surface, foreground);
   Surface_set_foreground(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Surface::foreground_Prop & Surface::foreground_Prop::operator= (Surface::foreground_Prop & prop)
{
   SELF(Surface, foreground);
   /*0H*/ColorAlpha v = prop;
   Surface_set_foreground(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Surface::foreground_Prop::operator /*0I*/ColorAlpha () const
{
   SELF(Surface, foreground);
   return Surface_get_foreground(self ? self->impl : null);
}

// property callers: Surface::background
// (normal::bits|unsigned int)

/*nstSet*/inline /*0H*/ColorAlpha Surface::background_Prop::operator= (/*0H*/ColorAlpha v)
{
   SELF(Surface, background);
   Surface_set_background(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Surface::background_Prop & Surface::background_Prop::operator= (Surface::background_Prop & prop)
{
   SELF(Surface, background);
   /*0H*/ColorAlpha v = prop;
   Surface_set_background(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Surface::background_Prop::operator /*0I*/ColorAlpha () const
{
   SELF(Surface, background);
   return Surface_get_background(self ? self->impl : null);
}

// property callers: Surface::blitTint
// (normal::bits|unsigned int)

/*nstSet*/inline /*0H*/ColorAlpha Surface::blitTint_Prop::operator= (/*0H*/ColorAlpha v)
{
   SELF(Surface, blitTint);
   Surface_set_blitTint(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Surface::blitTint_Prop & Surface::blitTint_Prop::operator= (Surface::blitTint_Prop & prop)
{
   SELF(Surface, blitTint);
   /*0H*/ColorAlpha v = prop;
   Surface_set_blitTint(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Surface::blitTint_Prop::operator /*0I*/ColorAlpha () const
{
   SELF(Surface, blitTint);
   return Surface_get_blitTint(self ? self->impl : null);
}

// property callers: Surface::blackTint
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color Surface::blackTint_Prop::operator= (/*0H*/Color v)
{
   SELF(Surface, blackTint);
   Surface_set_blackTint(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Surface::blackTint_Prop & Surface::blackTint_Prop::operator= (Surface::blackTint_Prop & prop)
{
   SELF(Surface, blackTint);
   /*0H*/Color v = prop;
   Surface_set_blackTint(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Surface::blackTint_Prop::operator /*0I*/Color () const
{
   SELF(Surface, blackTint);
   return Surface_get_blackTint(self ? self->impl : null);
}

// property callers: Surface::lineStipple   // set only
// (normal::uint)

/*nstSet*/inline /*0G*/uint Surface::lineStipple_Prop::operator= (/*0G*/uint v)
{
   SELF(Surface, lineStipple);
   Surface_set_lineStipple(self->impl, v);
   return v;
}


// property callers: Surface::size   // get only
// (normal::struct)

/*regGet*/inline Surface::size_Prop::operator /*0I*/Size () const
{
   SELF(Surface, size);
   Size value;Surface_get_size(self->impl, &value.impl);
   return value;
}

// property callers: Surface::display   // get only
// (normal::normal)

/*regGet*/inline Surface::display_Prop::operator /*0B*/TIH<Display> () const
{
   SELF(Surface, display);
   C(Instance) i = Surface_get_display(self ? self->impl : null);
   TIH<Display> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Display> Surface::display_Prop::operator /*0D*/-> () const
{
   SELF(Surface, display);
   C(Instance) i = Surface_get_display(self ? self->impl : null);
   TIH<Display> holder(i);
   return holder;
}
/*regGet*/inline Surface::display_Prop::operator /*0E*/Display () const
{
   SELF(Surface, display);
   C(Instance) i = Surface_get_display(self ? self->impl : null);
   return Display(i);
}
/*regGet*/inline Surface::display_Prop::operator /*0F*/Display* () const
{
   SELF(Surface, display);
   C(Instance) i = Surface_get_display(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Display *)INSTANCEL(i, i->_class) : (Display *)0;
}

// property callers: Surface::font
// (normal::nohead)

/*nstSet*/inline /*0H*/Font Surface::font_Prop::operator= (/*0H*/Font & v)
{
   SELF(Surface, font);
   Surface_set_font(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Surface::font_Prop & Surface::font_Prop::operator= (Surface::font_Prop & prop)
{
   SELF(Surface, font);
   /*0H*/Font v = prop;
   Surface_set_font(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline Surface::font_Prop::operator /*0I*/Font () const
{
   SELF(Surface, font);
   Font value(Surface_get_font(self->impl));
   return value;
}

// property callers: Surface::textOpacity
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Surface::textOpacity_Prop::operator= (/*0H*/bool v)
{
   SELF(Surface, textOpacity);
   Surface_set_textOpacity(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Surface::textOpacity_Prop & Surface::textOpacity_Prop::operator= (Surface::textOpacity_Prop & prop)
{
   SELF(Surface, textOpacity);
   /*0H*/bool v = prop;
   Surface_set_textOpacity(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Surface::textOpacity_Prop::operator /*0I*/bool () const
{
   SELF(Surface, textOpacity);
   return (bool)Surface_get_textOpacity(self ? self->impl : null);
}

// property callers: Surface::drawingChar   // set only
// (normal::byte)

/*nstSet*/inline /*0G*/unsigned char Surface::drawingChar_Prop::operator= (/*0G*/unsigned char v)
{
   SELF(Surface, drawingChar);
   Surface_set_drawingChar(self->impl, v);
   return v;
}


// property callers: Surface::clipping   // set only
// (normal::struct)

/*nstSet*/inline /*0G*/Box Surface::clipping_Prop::operator= (/*0G*/Box v)
{
   SELF(Surface, clipping);
   Surface_set_clipping(self->impl, &v.impl);
   return v;
}



// member accessors: Surface::width
// (normal::int)

/*nstSet*/inline /*0H*/int Surface::width_Prop::operator= (/*0H*/int v)
{
   SELF(Surface, width);
   IPTR(self->impl, Surface)->width = v;
   return v;
}

/*regSet*/inline Surface::width_Prop & Surface::width_Prop::operator= (Surface::width_Prop & prop)
{
   SELF(Surface, width);
   /*0H*/int v = prop;
   IPTR(self->impl, Surface)->width = v;
   return prop;
}
/*regGet*/inline Surface::width_Prop::operator /*0I*/int () const
{
   SELF(Surface, width);
   return self ? IPTR(self->impl, Surface)->width : 0;
}

// member accessors: Surface::height
// (normal::int)

/*nstSet*/inline /*0H*/int Surface::height_Prop::operator= (/*0H*/int v)
{
   SELF(Surface, height);
   IPTR(self->impl, Surface)->height = v;
   return v;
}

/*regSet*/inline Surface::height_Prop & Surface::height_Prop::operator= (Surface::height_Prop & prop)
{
   SELF(Surface, height);
   /*0H*/int v = prop;
   IPTR(self->impl, Surface)->height = v;
   return prop;
}
/*regGet*/inline Surface::height_Prop::operator /*0I*/int () const
{
   SELF(Surface, height);
   return self ? IPTR(self->impl, Surface)->height : 0;
}

// member accessors: Surface::offset
// (normal::struct)

/*nstSet*/inline /*0H*/Point Surface::offset_Prop::operator= (/*0H*/Point v)
{
   SELF(Surface, offset);
   IPTR(self->impl, Surface)->offset = v.impl;
   return v;
}

/*regSet*/inline Surface::offset_Prop & Surface::offset_Prop::operator= (Surface::offset_Prop & prop)
{
   SELF(Surface, offset);
   /*0H*/Point v = prop;
   IPTR(self->impl, Surface)->offset = v.impl;
   return prop;
}
/*regGet*/inline Surface::offset_Prop::operator /*0I*/Point () const
{
   SELF(Surface, offset);
   Point value(IPTR(self->impl, Surface)->offset);
   return value;
}

// member accessors: Surface::box
// (normal::struct)

/*nstSet*/inline /*0H*/Box Surface::box_Prop::operator= (/*0H*/Box v)
{
   SELF(Surface, box);
   IPTR(self->impl, Surface)->box = v.impl;
   return v;
}

/*regSet*/inline Surface::box_Prop & Surface::box_Prop::operator= (Surface::box_Prop & prop)
{
   SELF(Surface, box);
   /*0H*/Box v = prop;
   IPTR(self->impl, Surface)->box = v.impl;
   return prop;
}
/*regGet*/inline Surface::box_Prop::operator /*0I*/Box () const
{
   SELF(Surface, box);
   Box value(IPTR(self->impl, Surface)->box);
   return value;
}

// member accessors: Surface::unclippedBox
// (normal::struct)

/*nstSet*/inline /*0H*/Box Surface::unclippedBox_Prop::operator= (/*0H*/Box v)
{
   SELF(Surface, unclippedBox);
   IPTR(self->impl, Surface)->unclippedBox = v.impl;
   return v;
}

/*regSet*/inline Surface::unclippedBox_Prop & Surface::unclippedBox_Prop::operator= (Surface::unclippedBox_Prop & prop)
{
   SELF(Surface, unclippedBox);
   /*0H*/Box v = prop;
   IPTR(self->impl, Surface)->unclippedBox = v.impl;
   return prop;
}
/*regGet*/inline Surface::unclippedBox_Prop::operator /*0I*/Box () const
{
   SELF(Surface, unclippedBox);
   Box value(IPTR(self->impl, Surface)->unclippedBox);
   return value;
}

// member accessors: Surface::driverData
// (normal::void *)

/*nstSet*/inline /*0H*/void * Surface::driverData_Prop::operator= (/*0H*/void * v)
{
   SELF(Surface, driverData);
   IPTR(self->impl, Surface)->driverData = v;
   return v;
}

/*regSet*/inline Surface::driverData_Prop & Surface::driverData_Prop::operator= (Surface::driverData_Prop & prop)
{
   SELF(Surface, driverData);
   /*0H*/void * v = prop;
   IPTR(self->impl, Surface)->driverData = v;
   return prop;
}
/*regGet*/inline Surface::driverData_Prop::operator /*0I*/void * () const
{
   SELF(Surface, driverData);
   return self ? IPTR(self->impl, Surface)->driverData : null;
}

/////////////////////////////////////////// [ecere]/ecere::gfx::bitmaps //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


inline PNGOptions::PNGOptions(int zlibCompressionLevel)
{
   impl.zlibCompressionLevel = zlibCompressionLevel;
}



// member accessors: PNGOptions::zlibCompressionLevel
// (struct::int)

/*nstSet*/inline /*0H*/int PNGOptions::zlibCompressionLevel_Prop::operator= (/*0H*/int v)
{
   SELF(PNGOptions, zlibCompressionLevel);
   self->impl.zlibCompressionLevel = v;
   return v;
}

/*regSet*/inline PNGOptions::zlibCompressionLevel_Prop & PNGOptions::zlibCompressionLevel_Prop::operator= (PNGOptions::zlibCompressionLevel_Prop & prop)
{
   SELF(PNGOptions, zlibCompressionLevel);
   /*0H*/int v = prop;
   self->impl.zlibCompressionLevel = v;
   return prop;
}
/*regGet*/inline PNGOptions::zlibCompressionLevel_Prop::operator /*0I*/int () const
{
   SELF(PNGOptions, zlibCompressionLevel);
   return self ? ((C(PNGOptions) *)&self->impl)->zlibCompressionLevel : 0;
}

/////////////////////////////////////////// [ecere]/ecere::gfx::drivers //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////




// member accessors: BlockEntry::start
// (bits::uint)

/*nstSet*/inline /*0H*/uint BlockEntry::start_Prop::operator= (/*0H*/uint v)
{
   SELF(BlockEntry, start);
   BLOCKENTRY_SET_start(self->impl, v);
   return v;
}

/*regSet*/inline BlockEntry::start_Prop & BlockEntry::start_Prop::operator= (BlockEntry::start_Prop & prop)
{
   SELF(BlockEntry, start);
   /*0H*/uint v = prop;
   BLOCKENTRY_SET_start(self->impl, v);
   return prop;
}
/*regGet*/inline BlockEntry::start_Prop::operator /*0I*/uint () const
{
   SELF(BlockEntry, start);
   return BLOCKENTRY_start(self->impl);
}

// member accessors: BlockEntry::end
// (bits::uint)

/*nstSet*/inline /*0H*/uint BlockEntry::end_Prop::operator= (/*0H*/uint v)
{
   SELF(BlockEntry, end);
   BLOCKENTRY_SET_end(self->impl, v);
   return v;
}

/*regSet*/inline BlockEntry::end_Prop & BlockEntry::end_Prop::operator= (BlockEntry::end_Prop & prop)
{
   SELF(BlockEntry, end);
   /*0H*/uint v = prop;
   BLOCKENTRY_SET_end(self->impl, v);
   return prop;
}
/*regGet*/inline BlockEntry::end_Prop::operator /*0I*/uint () const
{
   SELF(BlockEntry, end);
   return BLOCKENTRY_end(self->impl);
}


template <class TC, C(Class) ** TCO> inline void TCompiledDefaultShader<TC, TCO>::registerUniforms(/*1Ab*/int program, /*1Ab*/DefaultShaderBits state)
{
   CompiledDefaultShader_registerUniforms((C(CompiledDefaultShader)*)this->impl, /*5Ge*/program, /*5Ee*/(C(DefaultShaderBits))state.impl);
}


// member accessors: CompiledDefaultShader::uPrjMatrix
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uPrjMatrix_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uPrjMatrix);
   ((C(CompiledDefaultShader) *)self->impl)->uPrjMatrix = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uPrjMatrix_Prop & TCompiledDefaultShader<TC, TCO>::uPrjMatrix_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uPrjMatrix_Prop & prop)
{
   SELF(CompiledDefaultShader, uPrjMatrix);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uPrjMatrix = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uPrjMatrix_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uPrjMatrix);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uPrjMatrix : 0;
}

// member accessors: CompiledDefaultShader::uMVMatrix
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMVMatrix_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMVMatrix);
   ((C(CompiledDefaultShader) *)self->impl)->uMVMatrix = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMVMatrix_Prop & TCompiledDefaultShader<TC, TCO>::uMVMatrix_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMVMatrix_Prop & prop)
{
   SELF(CompiledDefaultShader, uMVMatrix);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMVMatrix = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMVMatrix_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMVMatrix);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMVMatrix : 0;
}

// member accessors: CompiledDefaultShader::uTextureMatrix
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uTextureMatrix_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uTextureMatrix);
   ((C(CompiledDefaultShader) *)self->impl)->uTextureMatrix = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uTextureMatrix_Prop & TCompiledDefaultShader<TC, TCO>::uTextureMatrix_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uTextureMatrix_Prop & prop)
{
   SELF(CompiledDefaultShader, uTextureMatrix);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uTextureMatrix = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uTextureMatrix_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uTextureMatrix);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uTextureMatrix : 0;
}

// member accessors: CompiledDefaultShader::uNormalsMatrix
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uNormalsMatrix_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uNormalsMatrix);
   ((C(CompiledDefaultShader) *)self->impl)->uNormalsMatrix = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uNormalsMatrix_Prop & TCompiledDefaultShader<TC, TCO>::uNormalsMatrix_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uNormalsMatrix_Prop & prop)
{
   SELF(CompiledDefaultShader, uNormalsMatrix);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uNormalsMatrix = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uNormalsMatrix_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uNormalsMatrix);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uNormalsMatrix : 0;
}

// member accessors: CompiledDefaultShader::uNormalsInvScale2
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uNormalsInvScale2_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uNormalsInvScale2);
   ((C(CompiledDefaultShader) *)self->impl)->uNormalsInvScale2 = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uNormalsInvScale2_Prop & TCompiledDefaultShader<TC, TCO>::uNormalsInvScale2_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uNormalsInvScale2_Prop & prop)
{
   SELF(CompiledDefaultShader, uNormalsInvScale2);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uNormalsInvScale2 = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uNormalsInvScale2_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uNormalsInvScale2);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uNormalsInvScale2 : 0;
}

// member accessors: CompiledDefaultShader::uFogDensity
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uFogDensity_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uFogDensity);
   ((C(CompiledDefaultShader) *)self->impl)->uFogDensity = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uFogDensity_Prop & TCompiledDefaultShader<TC, TCO>::uFogDensity_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uFogDensity_Prop & prop)
{
   SELF(CompiledDefaultShader, uFogDensity);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uFogDensity = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uFogDensity_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uFogDensity);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uFogDensity : 0;
}

// member accessors: CompiledDefaultShader::uFogColor
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uFogColor_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uFogColor);
   ((C(CompiledDefaultShader) *)self->impl)->uFogColor = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uFogColor_Prop & TCompiledDefaultShader<TC, TCO>::uFogColor_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uFogColor_Prop & prop)
{
   SELF(CompiledDefaultShader, uFogColor);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uFogColor = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uFogColor_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uFogColor);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uFogColor : 0;
}

// member accessors: CompiledDefaultShader::uGlobalAmbient
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uGlobalAmbient_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uGlobalAmbient);
   ((C(CompiledDefaultShader) *)self->impl)->uGlobalAmbient = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uGlobalAmbient_Prop & TCompiledDefaultShader<TC, TCO>::uGlobalAmbient_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uGlobalAmbient_Prop & prop)
{
   SELF(CompiledDefaultShader, uGlobalAmbient);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uGlobalAmbient = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uGlobalAmbient_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uGlobalAmbient);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uGlobalAmbient : 0;
}

// member accessors: CompiledDefaultShader::uNearPlane
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uNearPlane_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uNearPlane);
   ((C(CompiledDefaultShader) *)self->impl)->uNearPlane = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uNearPlane_Prop & TCompiledDefaultShader<TC, TCO>::uNearPlane_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uNearPlane_Prop & prop)
{
   SELF(CompiledDefaultShader, uNearPlane);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uNearPlane = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uNearPlane_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uNearPlane);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uNearPlane : 0;
}

// member accessors: CompiledDefaultShader::uMatDiffuse
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMatDiffuse_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMatDiffuse);
   ((C(CompiledDefaultShader) *)self->impl)->uMatDiffuse = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMatDiffuse_Prop & TCompiledDefaultShader<TC, TCO>::uMatDiffuse_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMatDiffuse_Prop & prop)
{
   SELF(CompiledDefaultShader, uMatDiffuse);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMatDiffuse = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMatDiffuse_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMatDiffuse);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMatDiffuse : 0;
}

// member accessors: CompiledDefaultShader::uMatAmbient
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMatAmbient_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMatAmbient);
   ((C(CompiledDefaultShader) *)self->impl)->uMatAmbient = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMatAmbient_Prop & TCompiledDefaultShader<TC, TCO>::uMatAmbient_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMatAmbient_Prop & prop)
{
   SELF(CompiledDefaultShader, uMatAmbient);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMatAmbient = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMatAmbient_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMatAmbient);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMatAmbient : 0;
}

// member accessors: CompiledDefaultShader::uMatSpecular
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMatSpecular_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMatSpecular);
   ((C(CompiledDefaultShader) *)self->impl)->uMatSpecular = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMatSpecular_Prop & TCompiledDefaultShader<TC, TCO>::uMatSpecular_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMatSpecular_Prop & prop)
{
   SELF(CompiledDefaultShader, uMatSpecular);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMatSpecular = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMatSpecular_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMatSpecular);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMatSpecular : 0;
}

// member accessors: CompiledDefaultShader::uMatEmissive
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMatEmissive_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMatEmissive);
   ((C(CompiledDefaultShader) *)self->impl)->uMatEmissive = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMatEmissive_Prop & TCompiledDefaultShader<TC, TCO>::uMatEmissive_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMatEmissive_Prop & prop)
{
   SELF(CompiledDefaultShader, uMatEmissive);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMatEmissive = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMatEmissive_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMatEmissive);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMatEmissive : 0;
}

// member accessors: CompiledDefaultShader::uMatPower
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMatPower_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMatPower);
   ((C(CompiledDefaultShader) *)self->impl)->uMatPower = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMatPower_Prop & TCompiledDefaultShader<TC, TCO>::uMatPower_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMatPower_Prop & prop)
{
   SELF(CompiledDefaultShader, uMatPower);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMatPower = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMatPower_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMatPower);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMatPower : 0;
}

// member accessors: CompiledDefaultShader::uMatOpacity
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMatOpacity_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMatOpacity);
   ((C(CompiledDefaultShader) *)self->impl)->uMatOpacity = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMatOpacity_Prop & TCompiledDefaultShader<TC, TCO>::uMatOpacity_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMatOpacity_Prop & prop)
{
   SELF(CompiledDefaultShader, uMatOpacity);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMatOpacity = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMatOpacity_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMatOpacity);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMatOpacity : 0;
}

// member accessors: CompiledDefaultShader::uDiffuseTex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uDiffuseTex_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uDiffuseTex);
   ((C(CompiledDefaultShader) *)self->impl)->uDiffuseTex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uDiffuseTex_Prop & TCompiledDefaultShader<TC, TCO>::uDiffuseTex_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uDiffuseTex_Prop & prop)
{
   SELF(CompiledDefaultShader, uDiffuseTex);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uDiffuseTex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uDiffuseTex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uDiffuseTex);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uDiffuseTex : 0;
}

// member accessors: CompiledDefaultShader::uBumpTex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uBumpTex_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uBumpTex);
   ((C(CompiledDefaultShader) *)self->impl)->uBumpTex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uBumpTex_Prop & TCompiledDefaultShader<TC, TCO>::uBumpTex_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uBumpTex_Prop & prop)
{
   SELF(CompiledDefaultShader, uBumpTex);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uBumpTex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uBumpTex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uBumpTex);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uBumpTex : 0;
}

// member accessors: CompiledDefaultShader::uSpecularTex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uSpecularTex_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uSpecularTex);
   ((C(CompiledDefaultShader) *)self->impl)->uSpecularTex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uSpecularTex_Prop & TCompiledDefaultShader<TC, TCO>::uSpecularTex_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uSpecularTex_Prop & prop)
{
   SELF(CompiledDefaultShader, uSpecularTex);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uSpecularTex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uSpecularTex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uSpecularTex);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uSpecularTex : 0;
}

// member accessors: CompiledDefaultShader::uEnvTex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uEnvTex_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uEnvTex);
   ((C(CompiledDefaultShader) *)self->impl)->uEnvTex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uEnvTex_Prop & TCompiledDefaultShader<TC, TCO>::uEnvTex_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uEnvTex_Prop & prop)
{
   SELF(CompiledDefaultShader, uEnvTex);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uEnvTex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uEnvTex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uEnvTex);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uEnvTex : 0;
}

// member accessors: CompiledDefaultShader::uReflectTex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uReflectTex_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uReflectTex);
   ((C(CompiledDefaultShader) *)self->impl)->uReflectTex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uReflectTex_Prop & TCompiledDefaultShader<TC, TCO>::uReflectTex_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uReflectTex_Prop & prop)
{
   SELF(CompiledDefaultShader, uReflectTex);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uReflectTex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uReflectTex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uReflectTex);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uReflectTex : 0;
}

// member accessors: CompiledDefaultShader::uRefractionETA
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uRefractionETA_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uRefractionETA);
   ((C(CompiledDefaultShader) *)self->impl)->uRefractionETA = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uRefractionETA_Prop & TCompiledDefaultShader<TC, TCO>::uRefractionETA_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uRefractionETA_Prop & prop)
{
   SELF(CompiledDefaultShader, uRefractionETA);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uRefractionETA = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uRefractionETA_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uRefractionETA);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uRefractionETA : 0;
}

// member accessors: CompiledDefaultShader::uMatReflectivity
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uMatReflectivity_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uMatReflectivity);
   ((C(CompiledDefaultShader) *)self->impl)->uMatReflectivity = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uMatReflectivity_Prop & TCompiledDefaultShader<TC, TCO>::uMatReflectivity_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uMatReflectivity_Prop & prop)
{
   SELF(CompiledDefaultShader, uMatReflectivity);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uMatReflectivity = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uMatReflectivity_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uMatReflectivity);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uMatReflectivity : 0;
}

// member accessors: CompiledDefaultShader::uCubeMapMatrix
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uCubeMapMatrix_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uCubeMapMatrix);
   ((C(CompiledDefaultShader) *)self->impl)->uCubeMapMatrix = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uCubeMapMatrix_Prop & TCompiledDefaultShader<TC, TCO>::uCubeMapMatrix_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uCubeMapMatrix_Prop & prop)
{
   SELF(CompiledDefaultShader, uCubeMapMatrix);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uCubeMapMatrix = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uCubeMapMatrix_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uCubeMapMatrix);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uCubeMapMatrix : 0;
}

// member accessors: CompiledDefaultShader::uAlphaFuncValue
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uAlphaFuncValue_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uAlphaFuncValue);
   ((C(CompiledDefaultShader) *)self->impl)->uAlphaFuncValue = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uAlphaFuncValue_Prop & TCompiledDefaultShader<TC, TCO>::uAlphaFuncValue_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uAlphaFuncValue_Prop & prop)
{
   SELF(CompiledDefaultShader, uAlphaFuncValue);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uAlphaFuncValue = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uAlphaFuncValue_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uAlphaFuncValue);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uAlphaFuncValue : 0;
}

// member accessors: CompiledDefaultShader::uBlackTint
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uBlackTint_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uBlackTint);
   ((C(CompiledDefaultShader) *)self->impl)->uBlackTint = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uBlackTint_Prop & TCompiledDefaultShader<TC, TCO>::uBlackTint_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uBlackTint_Prop & prop)
{
   SELF(CompiledDefaultShader, uBlackTint);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uBlackTint = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uBlackTint_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uBlackTint);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uBlackTint : 0;
}

// member accessors: CompiledDefaultShader::uBoneMatrices
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uBoneMatrices_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uBoneMatrices);
   ((C(CompiledDefaultShader) *)self->impl)->uBoneMatrices = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uBoneMatrices_Prop & TCompiledDefaultShader<TC, TCO>::uBoneMatrices_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uBoneMatrices_Prop & prop)
{
   SELF(CompiledDefaultShader, uBoneMatrices);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uBoneMatrices = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uBoneMatrices_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uBoneMatrices);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uBoneMatrices : 0;
}

// member accessors: CompiledDefaultShader::uBoneOffsets
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledDefaultShader<TC, TCO>::uBoneOffsets_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledDefaultShader, uBoneOffsets);
   ((C(CompiledDefaultShader) *)self->impl)->uBoneOffsets = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::uBoneOffsets_Prop & TCompiledDefaultShader<TC, TCO>::uBoneOffsets_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::uBoneOffsets_Prop & prop)
{
   SELF(CompiledDefaultShader, uBoneOffsets);
   /*0H*/int v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->uBoneOffsets = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::uBoneOffsets_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, uBoneOffsets);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->uBoneOffsets : 0;
}

// member accessors: CompiledDefaultShader::initialSetup
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TCompiledDefaultShader<TC, TCO>::initialSetup_Prop::operator= (/*0H*/bool v)
{
   SELF(CompiledDefaultShader, initialSetup);
   ((C(CompiledDefaultShader) *)self->impl)->initialSetup = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::initialSetup_Prop & TCompiledDefaultShader<TC, TCO>::initialSetup_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::initialSetup_Prop & prop)
{
   SELF(CompiledDefaultShader, initialSetup);
   /*0H*/bool v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->initialSetup = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::initialSetup_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, initialSetup);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->initialSetup : (bool)0;
}

// member accessors: CompiledDefaultShader::useNearPlane
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TCompiledDefaultShader<TC, TCO>::useNearPlane_Prop::operator= (/*0H*/bool v)
{
   SELF(CompiledDefaultShader, useNearPlane);
   ((C(CompiledDefaultShader) *)self->impl)->useNearPlane = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledDefaultShader<TC, TCO>::useNearPlane_Prop & TCompiledDefaultShader<TC, TCO>::useNearPlane_Prop::operator= (typename TCompiledDefaultShader<TC, TCO>::useNearPlane_Prop & prop)
{
   SELF(CompiledDefaultShader, useNearPlane);
   /*0H*/bool v = prop;
   ((C(CompiledDefaultShader) *)self->impl)->useNearPlane = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledDefaultShader<TC, TCO>::useNearPlane_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TCompiledDefaultShader TCTCO * self = CONTAINER_OF(this, TCompiledDefaultShader TCTCO, useNearPlane);
   return self ? ((C(CompiledDefaultShader) *)self->impl)->useNearPlane : (bool)0;
}


template <class TC, C(Class) ** TCO> inline void TCompiledShader<TC, TCO>::free()
{
   CompiledShader_free((C(CompiledShader)*)this->impl);
}


// member accessors: CompiledShader::program
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledShader<TC, TCO>::program_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledShader, program);
   ((C(CompiledShader) *)self->impl)->program = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledShader<TC, TCO>::program_Prop & TCompiledShader<TC, TCO>::program_Prop::operator= (typename TCompiledShader<TC, TCO>::program_Prop & prop)
{
   SELF(CompiledShader, program);
   /*0H*/int v = prop;
   ((C(CompiledShader) *)self->impl)->program = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledShader<TC, TCO>::program_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledShader TCTCO * self = CONTAINER_OF(this, TCompiledShader TCTCO, program);
   return self ? ((C(CompiledShader) *)self->impl)->program : 0;
}

// member accessors: CompiledShader::vertex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledShader<TC, TCO>::vertex_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledShader, vertex);
   ((C(CompiledShader) *)self->impl)->vertex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledShader<TC, TCO>::vertex_Prop & TCompiledShader<TC, TCO>::vertex_Prop::operator= (typename TCompiledShader<TC, TCO>::vertex_Prop & prop)
{
   SELF(CompiledShader, vertex);
   /*0H*/int v = prop;
   ((C(CompiledShader) *)self->impl)->vertex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledShader<TC, TCO>::vertex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledShader TCTCO * self = CONTAINER_OF(this, TCompiledShader TCTCO, vertex);
   return self ? ((C(CompiledShader) *)self->impl)->vertex : 0;
}

// member accessors: CompiledShader::fragment
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TCompiledShader<TC, TCO>::fragment_Prop::operator= (/*0H*/int v)
{
   SELF(CompiledShader, fragment);
   ((C(CompiledShader) *)self->impl)->fragment = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCompiledShader<TC, TCO>::fragment_Prop & TCompiledShader<TC, TCO>::fragment_Prop::operator= (typename TCompiledShader<TC, TCO>::fragment_Prop & prop)
{
   SELF(CompiledShader, fragment);
   /*0H*/int v = prop;
   ((C(CompiledShader) *)self->impl)->fragment = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCompiledShader<TC, TCO>::fragment_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TCompiledShader TCTCO * self = CONTAINER_OF(this, TCompiledShader TCTCO, fragment);
   return self ? ((C(CompiledShader) *)self->impl)->fragment : 0;
}

inline DefaultShader::DefaultShader(DefaultShaderBits backLightState, Color blackTint = Color()) : DefaultShader()
{
   this->backLightState = backLightState;
   this->blackTint = blackTint;
}


inline void DefaultShader::debugging(/*1Ab*/bool on)
{
   DefaultShader_debugging(impl, /*5Ee*/(C(bool))on);
}
inline void DefaultShader::fog(/*1Ab*/bool on)
{
   DefaultShader_fog(impl, /*5Ee*/(C(bool))on);
}
inline void DefaultShader::lighting(/*1Ab*/bool on)
{
   DefaultShader_lighting(impl, /*5Ee*/(C(bool))on);
}
inline void DefaultShader::setBoneMatrices(/*1Ab*/int n, /*1Ab*/const Matrixf * matrices)
{
   DefaultShader_setBoneMatrices(impl, /*5Ge*/n, /*5Ee*/(const C(Matrixf) *)matrices);
}
inline void DefaultShader::setCamera(/*1Ab*/Camera & camera)
{
   DefaultShader_setCamera(impl, /*5De*/camera.impl);
}
inline void DefaultShader::setColor(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b, /*1Ab*/float a)
{
   DefaultShader_setColor(impl, /*5Ge*/r, /*5Ge*/g, /*5Ge*/b, /*5Ge*/a);
}
inline void DefaultShader::setFogColor(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b)
{
   DefaultShader_setFogColor(impl, /*5Ge*/r, /*5Ge*/g, /*5Ge*/b);
}
inline void DefaultShader::setFogDensity(/*1Ab*/float density)
{
   DefaultShader_setFogDensity(impl, /*5Ge*/density);
}
inline void DefaultShader::setGlobalAmbient(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b, /*1Ab*/float a)
{
   DefaultShader_setGlobalAmbient(impl, /*5Ge*/r, /*5Ge*/g, /*5Ge*/b, /*5Ge*/a);
}
inline void DefaultShader::setLight(/*1Ab*/Display & display, /*1Ab*/uint id, /*1Ab*/Light & light)
{
   DefaultShader_setLight(impl, /*5De*/display.impl, /*5Ge*/id, /*5De*/&light.impl);
}
inline void DefaultShader::setLight(/*1Ac*/Display & display, /*1Ac*/uint id, /*1Ac*/Light * light)
{
   DefaultShader_setLight(impl, /*5Df*/display.impl, /*5Gf*/id, /*5Cf*/(C(Light) *)light);
}
inline void DefaultShader::setPerVertexColor(/*1Ab*/bool perVertexColor)
{
   DefaultShader_setPerVertexColor(impl, /*5Ee*/(C(bool))perVertexColor);
}
inline void DefaultShader::setSimpleMaterial(/*1Ab*/ColorAlpha color, /*1Ab*/bool twoSided)
{
   DefaultShader_setSimpleMaterial(impl, /*5Ee*/(C(ColorAlpha))color.impl, /*5Ee*/(C(bool))twoSided);
}
inline DefaultShader DefaultShader::shader()
{
   return DefaultShader(DefaultShader_shader());
}
inline void DefaultShader::swizzle(/*1Ab*/SwizzleMode swizzle)
{
   DefaultShader_swizzle(impl, /*5Ee*/(C(SwizzleMode))swizzle);
}
inline void DefaultShader::texturing(/*1Ab*/bool on)
{
   DefaultShader_texturing(impl, /*5Ee*/(C(bool))on);
}
inline void DefaultShader::useExternalTexture(/*1Ab*/bool on)
{
   DefaultShader_useExternalTexture(impl, /*5Ee*/(C(bool))on);
}


// property callers: DefaultShader::blackTint   // set only
// (normal::bits|uint)

/*nstSet*/inline /*0G*/Color DefaultShader::blackTint_Prop::operator= (/*0G*/Color v)
{
   SELF(DefaultShader, blackTint);
   DefaultShader_set_blackTint(self->impl, v);
   return v;
}



// member accessors: DefaultShader::backLightState
// (normal::bits|uint64)

/*nstSet*/inline /*0H*/DefaultShaderBits DefaultShader::backLightState_Prop::operator= (/*0H*/DefaultShaderBits v)
{
   SELF(DefaultShader, backLightState);
   IPTR(self->impl, DefaultShader)->backLightState = v;
   return v;
}

/*regSet*/inline DefaultShader::backLightState_Prop & DefaultShader::backLightState_Prop::operator= (DefaultShader::backLightState_Prop & prop)
{
   SELF(DefaultShader, backLightState);
   /*0H*/DefaultShaderBits v = prop;
   IPTR(self->impl, DefaultShader)->backLightState = v;
   return prop;
}
/*regGet*/inline DefaultShader::backLightState_Prop::operator /*0I*/DefaultShaderBits () const
{
   SELF(DefaultShader, backLightState);
   return self ? DefaultShaderBits(IPTR(self->impl, DefaultShader)->backLightState) : DefaultShaderBits();
}



// member accessors: DefaultShaderBits::lighting
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::lighting_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, lighting);
   DEFAULTSHADERBITS_SET_lighting(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::lighting_Prop & DefaultShaderBits::lighting_Prop::operator= (DefaultShaderBits::lighting_Prop & prop)
{
   SELF(DefaultShaderBits, lighting);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_lighting(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::lighting_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, lighting);
   return (bool)DEFAULTSHADERBITS_lighting(self->impl);
}

// member accessors: DefaultShaderBits::nonLocalViewer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::nonLocalViewer_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, nonLocalViewer);
   DEFAULTSHADERBITS_SET_nonLocalViewer(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::nonLocalViewer_Prop & DefaultShaderBits::nonLocalViewer_Prop::operator= (DefaultShaderBits::nonLocalViewer_Prop & prop)
{
   SELF(DefaultShaderBits, nonLocalViewer);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_nonLocalViewer(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::nonLocalViewer_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, nonLocalViewer);
   return (bool)DEFAULTSHADERBITS_nonLocalViewer(self->impl);
}

// member accessors: DefaultShaderBits::twoSided
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::twoSided_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, twoSided);
   DEFAULTSHADERBITS_SET_twoSided(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::twoSided_Prop & DefaultShaderBits::twoSided_Prop::operator= (DefaultShaderBits::twoSided_Prop & prop)
{
   SELF(DefaultShaderBits, twoSided);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_twoSided(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::twoSided_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, twoSided);
   return (bool)DEFAULTSHADERBITS_twoSided(self->impl);
}

// member accessors: DefaultShaderBits::specular
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::specular_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, specular);
   DEFAULTSHADERBITS_SET_specular(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::specular_Prop & DefaultShaderBits::specular_Prop::operator= (DefaultShaderBits::specular_Prop & prop)
{
   SELF(DefaultShaderBits, specular);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_specular(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::specular_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, specular);
   return (bool)DEFAULTSHADERBITS_specular(self->impl);
}

// member accessors: DefaultShaderBits::separateSpecular
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::separateSpecular_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, separateSpecular);
   DEFAULTSHADERBITS_SET_separateSpecular(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::separateSpecular_Prop & DefaultShaderBits::separateSpecular_Prop::operator= (DefaultShaderBits::separateSpecular_Prop & prop)
{
   SELF(DefaultShaderBits, separateSpecular);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_separateSpecular(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::separateSpecular_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, separateSpecular);
   return (bool)DEFAULTSHADERBITS_separateSpecular(self->impl);
}

// member accessors: DefaultShaderBits::blinnSpecular
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::blinnSpecular_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, blinnSpecular);
   DEFAULTSHADERBITS_SET_blinnSpecular(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::blinnSpecular_Prop & DefaultShaderBits::blinnSpecular_Prop::operator= (DefaultShaderBits::blinnSpecular_Prop & prop)
{
   SELF(DefaultShaderBits, blinnSpecular);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_blinnSpecular(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::blinnSpecular_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, blinnSpecular);
   return (bool)DEFAULTSHADERBITS_blinnSpecular(self->impl);
}

// member accessors: DefaultShaderBits::lightBits
// (bits::uint)

/*nstSet*/inline /*0H*/uint DefaultShaderBits::lightBits_Prop::operator= (/*0H*/uint v)
{
   SELF(DefaultShaderBits, lightBits);
   DEFAULTSHADERBITS_SET_lightBits(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::lightBits_Prop & DefaultShaderBits::lightBits_Prop::operator= (DefaultShaderBits::lightBits_Prop & prop)
{
   SELF(DefaultShaderBits, lightBits);
   /*0H*/uint v = prop;
   DEFAULTSHADERBITS_SET_lightBits(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::lightBits_Prop::operator /*0I*/uint () const
{
   SELF(DefaultShaderBits, lightBits);
   return DEFAULTSHADERBITS_lightBits(self->impl);
}

// member accessors: DefaultShaderBits::perVertexColor
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::perVertexColor_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, perVertexColor);
   DEFAULTSHADERBITS_SET_perVertexColor(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::perVertexColor_Prop & DefaultShaderBits::perVertexColor_Prop::operator= (DefaultShaderBits::perVertexColor_Prop & prop)
{
   SELF(DefaultShaderBits, perVertexColor);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_perVertexColor(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::perVertexColor_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, perVertexColor);
   return (bool)DEFAULTSHADERBITS_perVertexColor(self->impl);
}

// member accessors: DefaultShaderBits::swizzle
// (bits::enum|int)

/*nstSet*/inline /*0H*/SwizzleMode DefaultShaderBits::swizzle_Prop::operator= (/*0H*/SwizzleMode v)
{
   SELF(DefaultShaderBits, swizzle);
   DEFAULTSHADERBITS_SET_swizzle(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::swizzle_Prop & DefaultShaderBits::swizzle_Prop::operator= (DefaultShaderBits::swizzle_Prop & prop)
{
   SELF(DefaultShaderBits, swizzle);
   /*0H*/SwizzleMode v = prop;
   DEFAULTSHADERBITS_SET_swizzle(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::swizzle_Prop::operator /*0I*/SwizzleMode () const
{
   SELF(DefaultShaderBits, swizzle);
   return (SwizzleMode)DEFAULTSHADERBITS_swizzle(self->impl);
}

// member accessors: DefaultShaderBits::textureMatrix
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::textureMatrix_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, textureMatrix);
   DEFAULTSHADERBITS_SET_textureMatrix(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::textureMatrix_Prop & DefaultShaderBits::textureMatrix_Prop::operator= (DefaultShaderBits::textureMatrix_Prop & prop)
{
   SELF(DefaultShaderBits, textureMatrix);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_textureMatrix(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::textureMatrix_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, textureMatrix);
   return (bool)DEFAULTSHADERBITS_textureMatrix(self->impl);
}

// member accessors: DefaultShaderBits::texturing
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::texturing_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, texturing);
   DEFAULTSHADERBITS_SET_texturing(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::texturing_Prop & DefaultShaderBits::texturing_Prop::operator= (DefaultShaderBits::texturing_Prop & prop)
{
   SELF(DefaultShaderBits, texturing);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_texturing(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::texturing_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, texturing);
   return (bool)DEFAULTSHADERBITS_texturing(self->impl);
}

// member accessors: DefaultShaderBits::alphaTest
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::alphaTest_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, alphaTest);
   DEFAULTSHADERBITS_SET_alphaTest(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::alphaTest_Prop & DefaultShaderBits::alphaTest_Prop::operator= (DefaultShaderBits::alphaTest_Prop & prop)
{
   SELF(DefaultShaderBits, alphaTest);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_alphaTest(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::alphaTest_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, alphaTest);
   return (bool)DEFAULTSHADERBITS_alphaTest(self->impl);
}

// member accessors: DefaultShaderBits::cubeMap
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::cubeMap_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, cubeMap);
   DEFAULTSHADERBITS_SET_cubeMap(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::cubeMap_Prop & DefaultShaderBits::cubeMap_Prop::operator= (DefaultShaderBits::cubeMap_Prop & prop)
{
   SELF(DefaultShaderBits, cubeMap);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_cubeMap(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::cubeMap_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, cubeMap);
   return (bool)DEFAULTSHADERBITS_cubeMap(self->impl);
}

// member accessors: DefaultShaderBits::modelView
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::modelView_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, modelView);
   DEFAULTSHADERBITS_SET_modelView(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::modelView_Prop & DefaultShaderBits::modelView_Prop::operator= (DefaultShaderBits::modelView_Prop & prop)
{
   SELF(DefaultShaderBits, modelView);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_modelView(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::modelView_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, modelView);
   return (bool)DEFAULTSHADERBITS_modelView(self->impl);
}

// member accessors: DefaultShaderBits::fog
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::fog_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, fog);
   DEFAULTSHADERBITS_SET_fog(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::fog_Prop & DefaultShaderBits::fog_Prop::operator= (DefaultShaderBits::fog_Prop & prop)
{
   SELF(DefaultShaderBits, fog);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_fog(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::fog_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, fog);
   return (bool)DEFAULTSHADERBITS_fog(self->impl);
}

// member accessors: DefaultShaderBits::normalsMapping
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::normalsMapping_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, normalsMapping);
   DEFAULTSHADERBITS_SET_normalsMapping(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::normalsMapping_Prop & DefaultShaderBits::normalsMapping_Prop::operator= (DefaultShaderBits::normalsMapping_Prop & prop)
{
   SELF(DefaultShaderBits, normalsMapping);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_normalsMapping(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::normalsMapping_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, normalsMapping);
   return (bool)DEFAULTSHADERBITS_normalsMapping(self->impl);
}

// member accessors: DefaultShaderBits::specularMapping
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::specularMapping_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, specularMapping);
   DEFAULTSHADERBITS_SET_specularMapping(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::specularMapping_Prop & DefaultShaderBits::specularMapping_Prop::operator= (DefaultShaderBits::specularMapping_Prop & prop)
{
   SELF(DefaultShaderBits, specularMapping);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_specularMapping(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::specularMapping_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, specularMapping);
   return (bool)DEFAULTSHADERBITS_specularMapping(self->impl);
}

// member accessors: DefaultShaderBits::environmentMapping
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::environmentMapping_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, environmentMapping);
   DEFAULTSHADERBITS_SET_environmentMapping(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::environmentMapping_Prop & DefaultShaderBits::environmentMapping_Prop::operator= (DefaultShaderBits::environmentMapping_Prop & prop)
{
   SELF(DefaultShaderBits, environmentMapping);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_environmentMapping(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::environmentMapping_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, environmentMapping);
   return (bool)DEFAULTSHADERBITS_environmentMapping(self->impl);
}

// member accessors: DefaultShaderBits::reflection
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::reflection_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, reflection);
   DEFAULTSHADERBITS_SET_reflection(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::reflection_Prop & DefaultShaderBits::reflection_Prop::operator= (DefaultShaderBits::reflection_Prop & prop)
{
   SELF(DefaultShaderBits, reflection);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_reflection(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::reflection_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, reflection);
   return (bool)DEFAULTSHADERBITS_reflection(self->impl);
}

// member accessors: DefaultShaderBits::reflectionMap
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::reflectionMap_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, reflectionMap);
   DEFAULTSHADERBITS_SET_reflectionMap(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::reflectionMap_Prop & DefaultShaderBits::reflectionMap_Prop::operator= (DefaultShaderBits::reflectionMap_Prop & prop)
{
   SELF(DefaultShaderBits, reflectionMap);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_reflectionMap(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::reflectionMap_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, reflectionMap);
   return (bool)DEFAULTSHADERBITS_reflectionMap(self->impl);
}

// member accessors: DefaultShaderBits::refraction
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::refraction_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, refraction);
   DEFAULTSHADERBITS_SET_refraction(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::refraction_Prop & DefaultShaderBits::refraction_Prop::operator= (DefaultShaderBits::refraction_Prop & prop)
{
   SELF(DefaultShaderBits, refraction);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_refraction(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::refraction_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, refraction);
   return (bool)DEFAULTSHADERBITS_refraction(self->impl);
}

// member accessors: DefaultShaderBits::debugging
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::debugging_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, debugging);
   DEFAULTSHADERBITS_SET_debugging(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::debugging_Prop & DefaultShaderBits::debugging_Prop::operator= (DefaultShaderBits::debugging_Prop & prop)
{
   SELF(DefaultShaderBits, debugging);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_debugging(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::debugging_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, debugging);
   return (bool)DEFAULTSHADERBITS_debugging(self->impl);
}

// member accessors: DefaultShaderBits::constantColor
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::constantColor_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, constantColor);
   DEFAULTSHADERBITS_SET_constantColor(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::constantColor_Prop & DefaultShaderBits::constantColor_Prop::operator= (DefaultShaderBits::constantColor_Prop & prop)
{
   SELF(DefaultShaderBits, constantColor);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_constantColor(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::constantColor_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, constantColor);
   return (bool)DEFAULTSHADERBITS_constantColor(self->impl);
}

// member accessors: DefaultShaderBits::normalsInvScale2
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::normalsInvScale2_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, normalsInvScale2);
   DEFAULTSHADERBITS_SET_normalsInvScale2(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::normalsInvScale2_Prop & DefaultShaderBits::normalsInvScale2_Prop::operator= (DefaultShaderBits::normalsInvScale2_Prop & prop)
{
   SELF(DefaultShaderBits, normalsInvScale2);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_normalsInvScale2(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::normalsInvScale2_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, normalsInvScale2);
   return (bool)DEFAULTSHADERBITS_normalsInvScale2(self->impl);
}

// member accessors: DefaultShaderBits::externalTexture
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::externalTexture_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, externalTexture);
   DEFAULTSHADERBITS_SET_externalTexture(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::externalTexture_Prop & DefaultShaderBits::externalTexture_Prop::operator= (DefaultShaderBits::externalTexture_Prop & prop)
{
   SELF(DefaultShaderBits, externalTexture);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_externalTexture(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::externalTexture_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, externalTexture);
   return (bool)DEFAULTSHADERBITS_externalTexture(self->impl);
}

// member accessors: DefaultShaderBits::blackTint
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::blackTint_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, blackTint);
   DEFAULTSHADERBITS_SET_blackTint(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::blackTint_Prop & DefaultShaderBits::blackTint_Prop::operator= (DefaultShaderBits::blackTint_Prop & prop)
{
   SELF(DefaultShaderBits, blackTint);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_blackTint(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::blackTint_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, blackTint);
   return (bool)DEFAULTSHADERBITS_blackTint(self->impl);
}

// member accessors: DefaultShaderBits::textureArray
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::textureArray_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, textureArray);
   DEFAULTSHADERBITS_SET_textureArray(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::textureArray_Prop & DefaultShaderBits::textureArray_Prop::operator= (DefaultShaderBits::textureArray_Prop & prop)
{
   SELF(DefaultShaderBits, textureArray);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_textureArray(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::textureArray_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, textureArray);
   return (bool)DEFAULTSHADERBITS_textureArray(self->impl);
}

// member accessors: DefaultShaderBits::multiDraw
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::multiDraw_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, multiDraw);
   DEFAULTSHADERBITS_SET_multiDraw(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::multiDraw_Prop & DefaultShaderBits::multiDraw_Prop::operator= (DefaultShaderBits::multiDraw_Prop & prop)
{
   SELF(DefaultShaderBits, multiDraw);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_multiDraw(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::multiDraw_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, multiDraw);
   return (bool)DEFAULTSHADERBITS_multiDraw(self->impl);
}

// member accessors: DefaultShaderBits::transform3D
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::transform3D_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, transform3D);
   DEFAULTSHADERBITS_SET_transform3D(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::transform3D_Prop & DefaultShaderBits::transform3D_Prop::operator= (DefaultShaderBits::transform3D_Prop & prop)
{
   SELF(DefaultShaderBits, transform3D);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_transform3D(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::transform3D_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, transform3D);
   return (bool)DEFAULTSHADERBITS_transform3D(self->impl);
}

// member accessors: DefaultShaderBits::squishFactor
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::squishFactor_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, squishFactor);
   DEFAULTSHADERBITS_SET_squishFactor(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::squishFactor_Prop & DefaultShaderBits::squishFactor_Prop::operator= (DefaultShaderBits::squishFactor_Prop & prop)
{
   SELF(DefaultShaderBits, squishFactor);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_squishFactor(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::squishFactor_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, squishFactor);
   return (bool)DEFAULTSHADERBITS_squishFactor(self->impl);
}

// member accessors: DefaultShaderBits::bones
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DefaultShaderBits::bones_Prop::operator= (/*0H*/bool v)
{
   SELF(DefaultShaderBits, bones);
   DEFAULTSHADERBITS_SET_bones(self->impl, v);
   return v;
}

/*regSet*/inline DefaultShaderBits::bones_Prop & DefaultShaderBits::bones_Prop::operator= (DefaultShaderBits::bones_Prop & prop)
{
   SELF(DefaultShaderBits, bones);
   /*0H*/bool v = prop;
   DEFAULTSHADERBITS_SET_bones(self->impl, v);
   return prop;
}
/*regGet*/inline DefaultShaderBits::bones_Prop::operator /*0I*/bool () const
{
   SELF(DefaultShaderBits, bones);
   return (bool)DEFAULTSHADERBITS_bones(self->impl);
}

inline FreeBlockMap::FreeBlockMap_onExpand_Functor::FunctionType FreeBlockMap::FreeBlockMap_onExpand_Functor::operator= (FunctionType func)
{
   SELF(FreeBlockMap, onExpand);
   if(self->vTbl == FreeBlockMap::_cpp_class.vTbl)
   {
      uint size = FreeBlockMap::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FreeBlockMap::FreeBlockMap_onExpand_Functor::FunctionType, size);
      memcpy(self->vTbl, FreeBlockMap::_cpp_class.vTbl, sizeof(FreeBlockMap::FreeBlockMap_onExpand_Functor::FunctionType) * size);
   }
   ((FreeBlockMap::FreeBlockMap_onExpand_Functor::FunctionType *)self->vTbl)[M_VTBLID(FreeBlockMap, onExpand)] = func;
   return func;
}
inline uint FreeBlockMap::FreeBlockMap_onExpand_Functor::operator()( /*6Fj*/GLBType type, /*6Fj*/uint required)
{
   SELF(FreeBlockMap, onExpand);
   return FreeBlockMap_onExpand(self ? self->impl : (C(FreeBlockMap))null, /*7Al*/(C(GLBType))type, /*7Al*/required);
}
// inline void FreeBlockMap::register_onExpand(CPPClass & cl, FreeBlockMap::FreeBlockMap_onExpand_Functor::FunctionType func)
// {
//    ((FreeBlockMap::FreeBlockMap_onExpand_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FreeBlockMap, onExpand)] = func;
// }


inline GLAB::GLAB(uint buffer)
{
   impl.buffer = buffer;
}


inline C(bool) GLAB::_allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLB__allocate((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLAB::_upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLB__upload((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}
inline C(bool) GLAB::allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLB_allocate((C(GLB)*)&impl, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLAB::copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size)
{
   GLB_copy((C(GLB)*)&impl, /*5De*/&src.impl, /*5Ge*/srcStart, /*5Ge*/dstStart, /*5Ge*/size);
}
inline void GLAB::copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size)
{
   GLB_copy((C(GLB)*)&impl, /*5Cf*/(C(GLB) *)src, /*5Gf*/srcStart, /*5Gf*/dstStart, /*5Gf*/size);
}
inline void GLAB::deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers)
{
   GLB_deleteBuffers(/*5Ge*/count, /*5Ee*/(C(GLB) *)buffers);
}
inline void GLAB::free()
{
   GLB_free((C(GLB)*)&impl);
}
inline C(bool) GLAB::resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID)
{
   return GLB_resize((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/oldSize, /*5Ge*/newSize, /*5Ee*/(C(GLBufferUsage))usage, /*5Ee*/(C(bool))keepSameBufferID);
}
inline void GLAB::upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLB_upload((C(GLB)*)&impl, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}
inline void GLAB::use(/*1Ab*/GLBufferContents contents, /*1Ab*/int n, /*1Ab*/int type, /*1Ab*/uint stride, /*1Ab*/GLAttribMode mode, /*1Ab*/const void * pointer)
{
   GLAB_use(&impl, /*5Ee*/(C(GLBufferContents))contents, /*5Ge*/n, /*5Ge*/type, /*5Ge*/stride, /*5Ee*/(C(GLAttribMode))mode, /*5Ge*/pointer);
}
inline void GLAB::useVertTrans(/*1Ab*/uint count, /*1Ab*/int n, /*1Ab*/int type, /*1Ab*/uint stride, /*1Ab*/GLAttribMode mode, /*1Ab*/const void * pointer)
{
   GLAB_useVertTrans(&impl, /*5Ge*/count, /*5Ge*/n, /*5Ge*/type, /*5Ge*/stride, /*5Ee*/(C(GLAttribMode))mode, /*5Ge*/pointer);
}


// member accessors: GLAB::buffer
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLAB::buffer_Prop::operator= (/*0H*/uint v)
{
   SELF(GLAB, buffer);
   self->impl.buffer = v;
   return v;
}

/*regSet*/inline GLAB::buffer_Prop & GLAB::buffer_Prop::operator= (GLAB::buffer_Prop & prop)
{
   SELF(GLAB, buffer);
   /*0H*/uint v = prop;
   self->impl.buffer = v;
   return prop;
}
/*regGet*/inline GLAB::buffer_Prop::operator /*0I*/uint () const
{
   SELF(GLAB, buffer);
   return self ? ((C(GLAB) *)&self->impl)->buffer : 0;
}

inline GLB::GLB(uint buffer)
{
   impl.buffer = buffer;
}


inline C(bool) GLB::_allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLB__allocate(&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLB::_upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLB__upload(&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}
inline C(bool) GLB::allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLB_allocate(&impl, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLB::copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size)
{
   GLB_copy(&impl, /*5De*/&src.impl, /*5Ge*/srcStart, /*5Ge*/dstStart, /*5Ge*/size);
}
inline void GLB::copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size)
{
   GLB_copy(&impl, /*5Cf*/(C(GLB) *)src, /*5Gf*/srcStart, /*5Gf*/dstStart, /*5Gf*/size);
}
inline void GLB::deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers)
{
   GLB_deleteBuffers(/*5Ge*/count, /*5Ee*/(C(GLB) *)buffers);
}
inline void GLB::free()
{
   GLB_free(&impl);
}
inline C(bool) GLB::resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID)
{
   return GLB_resize(&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/oldSize, /*5Ge*/newSize, /*5Ee*/(C(GLBufferUsage))usage, /*5Ee*/(C(bool))keepSameBufferID);
}
inline void GLB::upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLB_upload(&impl, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}


// member accessors: GLB::buffer
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLB::buffer_Prop::operator= (/*0H*/uint v)
{
   SELF(GLB, buffer);
   self->impl.buffer = v;
   return v;
}

/*regSet*/inline GLB::buffer_Prop & GLB::buffer_Prop::operator= (GLB::buffer_Prop & prop)
{
   SELF(GLB, buffer);
   /*0H*/uint v = prop;
   self->impl.buffer = v;
   return prop;
}
/*regGet*/inline GLB::buffer_Prop::operator /*0I*/uint () const
{
   SELF(GLB, buffer);
   return self ? ((C(GLB) *)&self->impl)->buffer : 0;
}

inline GLCAB::GLCAB(uint buffer)
{
   impl.buffer = buffer;
}


inline C(bool) GLCAB::_allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLB__allocate((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLCAB::_upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLB__upload((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}
inline void GLCAB::copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size)
{
   GLB_copy((C(GLB)*)&impl, /*5De*/&src.impl, /*5Ge*/srcStart, /*5Ge*/dstStart, /*5Ge*/size);
}
inline void GLCAB::copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size)
{
   GLB_copy((C(GLB)*)&impl, /*5Cf*/(C(GLB) *)src, /*5Gf*/srcStart, /*5Gf*/dstStart, /*5Gf*/size);
}
inline void GLCAB::deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers)
{
   GLB_deleteBuffers(/*5Ge*/count, /*5Ee*/(C(GLB) *)buffers);
}
inline void GLCAB::free()
{
   GLB_free((C(GLB)*)&impl);
}
inline C(bool) GLCAB::resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID)
{
   return GLB_resize((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/oldSize, /*5Ge*/newSize, /*5Ee*/(C(GLBufferUsage))usage, /*5Ee*/(C(bool))keepSameBufferID);
}
inline C(bool) GLCAB::allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLCAB_allocate(&impl, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLCAB::upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLCAB_upload(&impl, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}


// member accessors: GLCAB::buffer
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLCAB::buffer_Prop::operator= (/*0H*/uint v)
{
   SELF(GLCAB, buffer);
   self->impl.buffer = v;
   return v;
}

/*regSet*/inline GLCAB::buffer_Prop & GLCAB::buffer_Prop::operator= (GLCAB::buffer_Prop & prop)
{
   SELF(GLCAB, buffer);
   /*0H*/uint v = prop;
   self->impl.buffer = v;
   return prop;
}
/*regGet*/inline GLCAB::buffer_Prop::operator /*0I*/uint () const
{
   SELF(GLCAB, buffer);
   return self ? ((C(GLCAB) *)&self->impl)->buffer : 0;
}

inline GLEAB::GLEAB(uint buffer)
{
   impl.buffer = buffer;
}


inline C(bool) GLEAB::_allocate(/*1Ab*/GLBType type, /*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLB__allocate((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLEAB::_upload(/*1Ab*/GLBType type, /*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLB__upload((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}
inline void GLEAB::copy(/*1Ab*/GLB & src, /*1Ab*/uint srcStart, /*1Ab*/uint dstStart, /*1Ab*/uint size)
{
   GLB_copy((C(GLB)*)&impl, /*5De*/&src.impl, /*5Ge*/srcStart, /*5Ge*/dstStart, /*5Ge*/size);
}
inline void GLEAB::copy(/*1Ac*/GLB * src, /*1Ac*/uint srcStart, /*1Ac*/uint dstStart, /*1Ac*/uint size)
{
   GLB_copy((C(GLB)*)&impl, /*5Cf*/(C(GLB) *)src, /*5Gf*/srcStart, /*5Gf*/dstStart, /*5Gf*/size);
}
inline void GLEAB::deleteBuffers(/*1Ab*/int count, /*1Ab*/GLB * buffers)
{
   GLB_deleteBuffers(/*5Ge*/count, /*5Ee*/(C(GLB) *)buffers);
}
inline void GLEAB::free()
{
   GLB_free((C(GLB)*)&impl);
}
inline C(bool) GLEAB::resize(/*1Ab*/GLBType type, /*1Ab*/uint oldSize, /*1Ab*/uint newSize, /*1Ab*/GLBufferUsage usage, /*1Ab*/bool keepSameBufferID)
{
   return GLB_resize((C(GLB)*)&impl, /*5Ee*/(C(GLBType))type, /*5Ge*/oldSize, /*5Ge*/newSize, /*5Ee*/(C(GLBufferUsage))usage, /*5Ee*/(C(bool))keepSameBufferID);
}
inline C(bool) GLEAB::allocate(/*1Ab*/uint size, /*1Ab*/const void * data, /*1Ab*/GLBufferUsage usage)
{
   return GLEAB_allocate(&impl, /*5Ge*/size, /*5Ge*/data, /*5Ee*/(C(GLBufferUsage))usage);
}
inline void GLEAB::draw(/*1Ab*/int primType, /*1Ab*/int count, /*1Ab*/int type, /*1Ab*/const void * indices)
{
   GLEAB_draw(&impl, /*5Ge*/primType, /*5Ge*/count, /*5Ge*/type, /*5Ge*/indices);
}
inline void GLEAB::draw2(/*1Ab*/int primType, /*1Ab*/int count, /*1Ab*/int type, /*1Ab*/const void * indices, /*1Ab*/uint baseVertex)
{
   GLEAB_draw2(&impl, /*5Ge*/primType, /*5Ge*/count, /*5Ge*/type, /*5Ge*/indices, /*5Ge*/baseVertex);
}
inline void GLEAB::upload(/*1Ab*/uint offset, /*1Ab*/uint size, /*1Ab*/const void * data)
{
   GLEAB_upload(&impl, /*5Ge*/offset, /*5Ge*/size, /*5Ge*/data);
}


// member accessors: GLEAB::buffer
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLEAB::buffer_Prop::operator= (/*0H*/uint v)
{
   SELF(GLEAB, buffer);
   self->impl.buffer = v;
   return v;
}

/*regSet*/inline GLEAB::buffer_Prop & GLEAB::buffer_Prop::operator= (GLEAB::buffer_Prop & prop)
{
   SELF(GLEAB, buffer);
   /*0H*/uint v = prop;
   self->impl.buffer = v;
   return prop;
}
/*regGet*/inline GLEAB::buffer_Prop::operator /*0I*/uint () const
{
   SELF(GLEAB, buffer);
   return self ? ((C(GLEAB) *)&self->impl)->buffer : 0;
}

inline GLFB::GLFB(int w, int h = 0, uint fbo = 0, uint color = 0, uint depth = 0, uint samples = 0, uint colorRBO = 0, uint depthRBO = 0, int depthFormat = 0, int colorFormat = 0)
{
   impl.w = w;
   impl.h = h;
   impl.fbo = fbo;
   impl.color = color;
   impl.depth = depth;
   impl.samples = samples;
   impl.colorRBO = colorRBO;
   impl.depthRBO = depthRBO;
   impl.depthFormat = depthFormat;
   impl.colorFormat = colorFormat;
}


inline void GLFB::copy(/*1Ab*/const GLFB & src, /*1Ab*/const Box & srcExtent, /*1Ab*/const Box & dstExtent, /*1Ab*/ClearType buffers, /*1Ab*/bool filter)
{
   GLFB_copy(&impl, /*5De*/&src.impl, /*5De*/&srcExtent.impl, /*5De*/&dstExtent.impl, /*5Ee*/(C(ClearType))buffers, /*5Ee*/(C(bool))filter);
}
inline void GLFB::copy(/*1Ac*/const GLFB * src, /*1Ac*/const Box * srcExtent, /*1Ac*/const Box * dstExtent, /*1Ac*/ClearType buffers, /*1Ac*/bool filter)
{
   GLFB_copy(&impl, /*5Cf*/(C(GLFB) *)src, /*5Cf*/(C(Box) *)srcExtent, /*5Cf*/(C(Box) *)dstExtent, /*5Ef*/(C(ClearType))buffers, /*5Ef*/(C(bool))filter);
}
inline void GLFB::copyToTexture()
{
   GLFB_copyToTexture(&impl);
}
inline void GLFB::free()
{
   GLFB_free(&impl);
}
inline void GLFB::read(/*1Ab*/Bitmap & bitmap, /*1Ab*/ClearType buffer, /*1Ab*/bool sRGB)
{
   GLFB_read(&impl, /*5De*/bitmap.impl, /*5Ee*/(C(ClearType))buffer, /*5Ee*/(C(bool))sRGB);
}
inline C(bool) GLFB::setup(/*1Ab*/bool textureFBO, /*1Ab*/bool allocTextures, /*1Ab*/int samples, /*1Ab*/int colorFormat, /*1Ab*/int depthFormat, /*1Ab*/int width, /*1Ab*/int height)
{
   return GLFB_setup(&impl, /*5Ee*/(C(bool))textureFBO, /*5Ee*/(C(bool))allocTextures, /*5Ge*/samples, /*5Ge*/colorFormat, /*5Ge*/depthFormat, /*5Ge*/width, /*5Ge*/height);
}


// member accessors: GLFB::w
// (struct::int)

/*nstSet*/inline /*0H*/int GLFB::w_Prop::operator= (/*0H*/int v)
{
   SELF(GLFB, w);
   self->impl.w = v;
   return v;
}

/*regSet*/inline GLFB::w_Prop & GLFB::w_Prop::operator= (GLFB::w_Prop & prop)
{
   SELF(GLFB, w);
   /*0H*/int v = prop;
   self->impl.w = v;
   return prop;
}
/*regGet*/inline GLFB::w_Prop::operator /*0I*/int () const
{
   SELF(GLFB, w);
   return self ? ((C(GLFB) *)&self->impl)->w : 0;
}

// member accessors: GLFB::h
// (struct::int)

/*nstSet*/inline /*0H*/int GLFB::h_Prop::operator= (/*0H*/int v)
{
   SELF(GLFB, h);
   self->impl.h = v;
   return v;
}

/*regSet*/inline GLFB::h_Prop & GLFB::h_Prop::operator= (GLFB::h_Prop & prop)
{
   SELF(GLFB, h);
   /*0H*/int v = prop;
   self->impl.h = v;
   return prop;
}
/*regGet*/inline GLFB::h_Prop::operator /*0I*/int () const
{
   SELF(GLFB, h);
   return self ? ((C(GLFB) *)&self->impl)->h : 0;
}

// member accessors: GLFB::fbo
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLFB::fbo_Prop::operator= (/*0H*/uint v)
{
   SELF(GLFB, fbo);
   self->impl.fbo = v;
   return v;
}

/*regSet*/inline GLFB::fbo_Prop & GLFB::fbo_Prop::operator= (GLFB::fbo_Prop & prop)
{
   SELF(GLFB, fbo);
   /*0H*/uint v = prop;
   self->impl.fbo = v;
   return prop;
}
/*regGet*/inline GLFB::fbo_Prop::operator /*0I*/uint () const
{
   SELF(GLFB, fbo);
   return self ? ((C(GLFB) *)&self->impl)->fbo : 0;
}

// member accessors: GLFB::color
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLFB::color_Prop::operator= (/*0H*/uint v)
{
   SELF(GLFB, color);
   self->impl.color = v;
   return v;
}

/*regSet*/inline GLFB::color_Prop & GLFB::color_Prop::operator= (GLFB::color_Prop & prop)
{
   SELF(GLFB, color);
   /*0H*/uint v = prop;
   self->impl.color = v;
   return prop;
}
/*regGet*/inline GLFB::color_Prop::operator /*0I*/uint () const
{
   SELF(GLFB, color);
   return self ? ((C(GLFB) *)&self->impl)->color : 0;
}

// member accessors: GLFB::depth
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLFB::depth_Prop::operator= (/*0H*/uint v)
{
   SELF(GLFB, depth);
   self->impl.depth = v;
   return v;
}

/*regSet*/inline GLFB::depth_Prop & GLFB::depth_Prop::operator= (GLFB::depth_Prop & prop)
{
   SELF(GLFB, depth);
   /*0H*/uint v = prop;
   self->impl.depth = v;
   return prop;
}
/*regGet*/inline GLFB::depth_Prop::operator /*0I*/uint () const
{
   SELF(GLFB, depth);
   return self ? ((C(GLFB) *)&self->impl)->depth : 0;
}

// member accessors: GLFB::samples
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLFB::samples_Prop::operator= (/*0H*/uint v)
{
   SELF(GLFB, samples);
   self->impl.samples = v;
   return v;
}

/*regSet*/inline GLFB::samples_Prop & GLFB::samples_Prop::operator= (GLFB::samples_Prop & prop)
{
   SELF(GLFB, samples);
   /*0H*/uint v = prop;
   self->impl.samples = v;
   return prop;
}
/*regGet*/inline GLFB::samples_Prop::operator /*0I*/uint () const
{
   SELF(GLFB, samples);
   return self ? ((C(GLFB) *)&self->impl)->samples : 0;
}

// member accessors: GLFB::colorRBO
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLFB::colorRBO_Prop::operator= (/*0H*/uint v)
{
   SELF(GLFB, colorRBO);
   self->impl.colorRBO = v;
   return v;
}

/*regSet*/inline GLFB::colorRBO_Prop & GLFB::colorRBO_Prop::operator= (GLFB::colorRBO_Prop & prop)
{
   SELF(GLFB, colorRBO);
   /*0H*/uint v = prop;
   self->impl.colorRBO = v;
   return prop;
}
/*regGet*/inline GLFB::colorRBO_Prop::operator /*0I*/uint () const
{
   SELF(GLFB, colorRBO);
   return self ? ((C(GLFB) *)&self->impl)->colorRBO : 0;
}

// member accessors: GLFB::depthRBO
// (struct::uint)

/*nstSet*/inline /*0H*/uint GLFB::depthRBO_Prop::operator= (/*0H*/uint v)
{
   SELF(GLFB, depthRBO);
   self->impl.depthRBO = v;
   return v;
}

/*regSet*/inline GLFB::depthRBO_Prop & GLFB::depthRBO_Prop::operator= (GLFB::depthRBO_Prop & prop)
{
   SELF(GLFB, depthRBO);
   /*0H*/uint v = prop;
   self->impl.depthRBO = v;
   return prop;
}
/*regGet*/inline GLFB::depthRBO_Prop::operator /*0I*/uint () const
{
   SELF(GLFB, depthRBO);
   return self ? ((C(GLFB) *)&self->impl)->depthRBO : 0;
}

// member accessors: GLFB::depthFormat
// (struct::int)

/*nstSet*/inline /*0H*/int GLFB::depthFormat_Prop::operator= (/*0H*/int v)
{
   SELF(GLFB, depthFormat);
   self->impl.depthFormat = v;
   return v;
}

/*regSet*/inline GLFB::depthFormat_Prop & GLFB::depthFormat_Prop::operator= (GLFB::depthFormat_Prop & prop)
{
   SELF(GLFB, depthFormat);
   /*0H*/int v = prop;
   self->impl.depthFormat = v;
   return prop;
}
/*regGet*/inline GLFB::depthFormat_Prop::operator /*0I*/int () const
{
   SELF(GLFB, depthFormat);
   return self ? ((C(GLFB) *)&self->impl)->depthFormat : 0;
}

// member accessors: GLFB::colorFormat
// (struct::int)

/*nstSet*/inline /*0H*/int GLFB::colorFormat_Prop::operator= (/*0H*/int v)
{
   SELF(GLFB, colorFormat);
   self->impl.colorFormat = v;
   return v;
}

/*regSet*/inline GLFB::colorFormat_Prop & GLFB::colorFormat_Prop::operator= (GLFB::colorFormat_Prop & prop)
{
   SELF(GLFB, colorFormat);
   /*0H*/int v = prop;
   self->impl.colorFormat = v;
   return prop;
}
/*regGet*/inline GLFB::colorFormat_Prop::operator /*0I*/int () const
{
   SELF(GLFB, colorFormat);
   return self ? ((C(GLFB) *)&self->impl)->colorFormat : 0;
}



// member accessors: GLMB::ab
// (normal::struct)

/*nstSet*/inline /*0H*/GLB GLMB::ab_Prop::operator= (/*0H*/GLB v)
{
   SELF(GLMB, ab);
   IPTR(self->impl, GLMB)->ab = v.impl;
   return v;
}

/*regSet*/inline GLMB::ab_Prop & GLMB::ab_Prop::operator= (GLMB::ab_Prop & prop)
{
   SELF(GLMB, ab);
   /*0H*/GLB v = prop;
   IPTR(self->impl, GLMB)->ab = v.impl;
   return prop;
}
/*regGet*/inline GLMB::ab_Prop::operator /*0I*/GLB () const
{
   SELF(GLMB, ab);
   GLB value(IPTR(self->impl, GLMB)->ab);
   return value;
}

// member accessors: GLMB::keepSameBufferID
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool GLMB::keepSameBufferID_Prop::operator= (/*0H*/bool v)
{
   SELF(GLMB, keepSameBufferID);
   IPTR(self->impl, GLMB)->keepSameBufferID = (C(bool))v;
   return v;
}

/*regSet*/inline GLMB::keepSameBufferID_Prop & GLMB::keepSameBufferID_Prop::operator= (GLMB::keepSameBufferID_Prop & prop)
{
   SELF(GLMB, keepSameBufferID);
   /*0H*/bool v = prop;
   IPTR(self->impl, GLMB)->keepSameBufferID = (C(bool))v;
   return prop;
}
/*regGet*/inline GLMB::keepSameBufferID_Prop::operator /*0I*/bool () const
{
   SELF(GLMB, keepSameBufferID);
   return self ? (bool)IPTR(self->impl, GLMB)->keepSameBufferID : (bool)0;
}


inline void GLStats::allocBuffer(/*1Ab*/uint buf, /*1Ab*/uint size)
{
   GLStats_allocBuffer(/*5Ge*/buf, /*5Ge*/size);
}
inline void GLStats::allocTexture(/*1Ab*/uint tex, /*1Ab*/uint w, /*1Ab*/uint h, /*1Ab*/bool mipMaps)
{
   GLStats_allocTexture(/*5Ge*/tex, /*5Ge*/w, /*5Ge*/h, /*5Ee*/(C(bool))mipMaps);
}
inline void GLStats::freeBuffers(/*1Ab*/uint count, /*1Ab*/uint * bufs)
{
   GLStats_freeBuffers(/*5Ge*/count, /*5Ge*/bufs);
}
inline void GLStats::freeTextures(/*1Ab*/uint count, /*1Ab*/uint * texs)
{
   GLStats_freeTextures(/*5Ge*/count, /*5Ge*/texs);
}
inline void GLStats::print()
{
   GLStats_print();
}
inline void GLStats::printBuf(/*1Ab*/char * output, /*1Ab*/uint size)
{
   GLStats_printBuf(/*5Ge*/output, /*5Ge*/size);
}



// member accessors: LFBDisplay::bitmap
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Bitmap TLFBDisplay<TC, TCO>::bitmap_Prop::operator= (/*0H*/Bitmap v)
{
   SELF(LFBDisplay, bitmap);
   ((C(LFBDisplay) *)self->impl)->bitmap = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBDisplay<TC, TCO>::bitmap_Prop & TLFBDisplay<TC, TCO>::bitmap_Prop::operator= (typename TLFBDisplay<TC, TCO>::bitmap_Prop & prop)
{
   SELF(LFBDisplay, bitmap);
   /*0H*/Bitmap v = prop;
   ((C(LFBDisplay) *)self->impl)->bitmap = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBDisplay<TC, TCO>::bitmap_Prop::operator /*0I*/Bitmap () const
{
   __attribute__((unused)) TLFBDisplay TCTCO * self = CONTAINER_OF(this, TLFBDisplay TCTCO, bitmap);
   Bitmap value(((C(LFBDisplay) *)self->impl)->bitmap);
   return value;
}

// member accessors: LFBDisplay::updateBoxes
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/OldList TLFBDisplay<TC, TCO>::updateBoxes_Prop::operator= (/*0H*/OldList v)
{
   SELF(LFBDisplay, updateBoxes);
   ((C(LFBDisplay) *)self->impl)->updateBoxes = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBDisplay<TC, TCO>::updateBoxes_Prop & TLFBDisplay<TC, TCO>::updateBoxes_Prop::operator= (typename TLFBDisplay<TC, TCO>::updateBoxes_Prop & prop)
{
   SELF(LFBDisplay, updateBoxes);
   /*0H*/OldList v = prop;
   ((C(LFBDisplay) *)self->impl)->updateBoxes = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBDisplay<TC, TCO>::updateBoxes_Prop::operator /*0I*/OldList () const
{
   __attribute__((unused)) TLFBDisplay TCTCO * self = CONTAINER_OF(this, TLFBDisplay TCTCO, updateBoxes);
   OldList value(((C(LFBDisplay) *)self->impl)->updateBoxes);
   return value;
}

// member accessors: LFBDisplay::x
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TLFBDisplay<TC, TCO>::x_Prop::operator= (/*0H*/int v)
{
   SELF(LFBDisplay, x);
   ((C(LFBDisplay) *)self->impl)->x = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBDisplay<TC, TCO>::x_Prop & TLFBDisplay<TC, TCO>::x_Prop::operator= (typename TLFBDisplay<TC, TCO>::x_Prop & prop)
{
   SELF(LFBDisplay, x);
   /*0H*/int v = prop;
   ((C(LFBDisplay) *)self->impl)->x = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBDisplay<TC, TCO>::x_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TLFBDisplay TCTCO * self = CONTAINER_OF(this, TLFBDisplay TCTCO, x);
   return self ? ((C(LFBDisplay) *)self->impl)->x : 0;
}

// member accessors: LFBDisplay::y
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TLFBDisplay<TC, TCO>::y_Prop::operator= (/*0H*/int v)
{
   SELF(LFBDisplay, y);
   ((C(LFBDisplay) *)self->impl)->y = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBDisplay<TC, TCO>::y_Prop & TLFBDisplay<TC, TCO>::y_Prop::operator= (typename TLFBDisplay<TC, TCO>::y_Prop & prop)
{
   SELF(LFBDisplay, y);
   /*0H*/int v = prop;
   ((C(LFBDisplay) *)self->impl)->y = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBDisplay<TC, TCO>::y_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TLFBDisplay TCTCO * self = CONTAINER_OF(this, TLFBDisplay TCTCO, y);
   return self ? ((C(LFBDisplay) *)self->impl)->y : 0;
}

// member accessors: LFBDisplay::selfManaged
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TLFBDisplay<TC, TCO>::selfManaged_Prop::operator= (/*0H*/bool v)
{
   SELF(LFBDisplay, selfManaged);
   ((C(LFBDisplay) *)self->impl)->selfManaged = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBDisplay<TC, TCO>::selfManaged_Prop & TLFBDisplay<TC, TCO>::selfManaged_Prop::operator= (typename TLFBDisplay<TC, TCO>::selfManaged_Prop & prop)
{
   SELF(LFBDisplay, selfManaged);
   /*0H*/bool v = prop;
   ((C(LFBDisplay) *)self->impl)->selfManaged = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBDisplay<TC, TCO>::selfManaged_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TLFBDisplay TCTCO * self = CONTAINER_OF(this, TLFBDisplay TCTCO, selfManaged);
   return self ? ((C(LFBDisplay) *)self->impl)->selfManaged : (bool)0;
}




// member accessors: LFBSurface::font
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Font TLFBSurface<TC, TCO>::font_Prop::operator= (/*0H*/Font & v)
{
   SELF(LFBSurface, font);
   ((C(LFBSurface) *)self->impl)->font = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::font_Prop & TLFBSurface<TC, TCO>::font_Prop::operator= (typename TLFBSurface<TC, TCO>::font_Prop & prop)
{
   SELF(LFBSurface, font);
   /*0H*/Font v = prop;
   ((C(LFBSurface) *)self->impl)->font = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::font_Prop::operator /*0I*/Font () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, font);
   Font value(((C(LFBSurface) *)self->impl)->font);
   return value;
}

// member accessors: LFBSurface::opaqueText
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TLFBSurface<TC, TCO>::opaqueText_Prop::operator= (/*0H*/bool v)
{
   SELF(LFBSurface, opaqueText);
   ((C(LFBSurface) *)self->impl)->opaqueText = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::opaqueText_Prop & TLFBSurface<TC, TCO>::opaqueText_Prop::operator= (typename TLFBSurface<TC, TCO>::opaqueText_Prop & prop)
{
   SELF(LFBSurface, opaqueText);
   /*0H*/bool v = prop;
   ((C(LFBSurface) *)self->impl)->opaqueText = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::opaqueText_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, opaqueText);
   return self ? ((C(LFBSurface) *)self->impl)->opaqueText : (bool)0;
}

// member accessors: LFBSurface::xOffset
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TLFBSurface<TC, TCO>::xOffset_Prop::operator= (/*0H*/int v)
{
   SELF(LFBSurface, xOffset);
   ((C(LFBSurface) *)self->impl)->xOffset = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::xOffset_Prop & TLFBSurface<TC, TCO>::xOffset_Prop::operator= (typename TLFBSurface<TC, TCO>::xOffset_Prop & prop)
{
   SELF(LFBSurface, xOffset);
   /*0H*/int v = prop;
   ((C(LFBSurface) *)self->impl)->xOffset = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::xOffset_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, xOffset);
   return self ? ((C(LFBSurface) *)self->impl)->xOffset : 0;
}

// member accessors: LFBSurface::writingText
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TLFBSurface<TC, TCO>::writingText_Prop::operator= (/*0H*/bool v)
{
   SELF(LFBSurface, writingText);
   ((C(LFBSurface) *)self->impl)->writingText = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::writingText_Prop & TLFBSurface<TC, TCO>::writingText_Prop::operator= (typename TLFBSurface<TC, TCO>::writingText_Prop & prop)
{
   SELF(LFBSurface, writingText);
   /*0H*/bool v = prop;
   ((C(LFBSurface) *)self->impl)->writingText = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::writingText_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, writingText);
   return self ? ((C(LFBSurface) *)self->impl)->writingText : (bool)0;
}

// member accessors: LFBSurface::writingOutline
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TLFBSurface<TC, TCO>::writingOutline_Prop::operator= (/*0H*/bool v)
{
   SELF(LFBSurface, writingOutline);
   ((C(LFBSurface) *)self->impl)->writingOutline = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::writingOutline_Prop & TLFBSurface<TC, TCO>::writingOutline_Prop::operator= (typename TLFBSurface<TC, TCO>::writingOutline_Prop & prop)
{
   SELF(LFBSurface, writingOutline);
   /*0H*/bool v = prop;
   ((C(LFBSurface) *)self->impl)->writingOutline = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::writingOutline_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, writingOutline);
   return self ? ((C(LFBSurface) *)self->impl)->writingOutline : (bool)0;
}

// member accessors: LFBSurface::bitmap
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Bitmap TLFBSurface<TC, TCO>::bitmap_Prop::operator= (/*0H*/Bitmap v)
{
   SELF(LFBSurface, bitmap);
   ((C(LFBSurface) *)self->impl)->bitmap = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::bitmap_Prop & TLFBSurface<TC, TCO>::bitmap_Prop::operator= (typename TLFBSurface<TC, TCO>::bitmap_Prop & prop)
{
   SELF(LFBSurface, bitmap);
   /*0H*/Bitmap v = prop;
   ((C(LFBSurface) *)self->impl)->bitmap = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::bitmap_Prop::operator /*0I*/Bitmap () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, bitmap);
   Bitmap value(((C(LFBSurface) *)self->impl)->bitmap);
   return value;
}

// member accessors: LFBSurface::foreground
// (nohead::uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint TLFBSurface<TC, TCO>::foreground_Prop::operator= (/*0H*/uint v)
{
   SELF(LFBSurface, foreground);
   ((C(LFBSurface) *)self->impl)->foreground = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::foreground_Prop & TLFBSurface<TC, TCO>::foreground_Prop::operator= (typename TLFBSurface<TC, TCO>::foreground_Prop & prop)
{
   SELF(LFBSurface, foreground);
   /*0H*/uint v = prop;
   ((C(LFBSurface) *)self->impl)->foreground = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::foreground_Prop::operator /*0I*/uint () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, foreground);
   return self ? ((C(LFBSurface) *)self->impl)->foreground : 0;
}

// member accessors: LFBSurface::background
// (nohead::uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint TLFBSurface<TC, TCO>::background_Prop::operator= (/*0H*/uint v)
{
   SELF(LFBSurface, background);
   ((C(LFBSurface) *)self->impl)->background = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::background_Prop & TLFBSurface<TC, TCO>::background_Prop::operator= (typename TLFBSurface<TC, TCO>::background_Prop & prop)
{
   SELF(LFBSurface, background);
   /*0H*/uint v = prop;
   ((C(LFBSurface) *)self->impl)->background = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::background_Prop::operator /*0I*/uint () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, background);
   return self ? ((C(LFBSurface) *)self->impl)->background : 0;
}

// member accessors: LFBSurface::foregroundRgb
// (nohead::bits|unsigned int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/ColorAlpha TLFBSurface<TC, TCO>::foregroundRgb_Prop::operator= (/*0H*/ColorAlpha v)
{
   SELF(LFBSurface, foregroundRgb);
   ((C(LFBSurface) *)self->impl)->foregroundRgb = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::foregroundRgb_Prop & TLFBSurface<TC, TCO>::foregroundRgb_Prop::operator= (typename TLFBSurface<TC, TCO>::foregroundRgb_Prop & prop)
{
   SELF(LFBSurface, foregroundRgb);
   /*0H*/ColorAlpha v = prop;
   ((C(LFBSurface) *)self->impl)->foregroundRgb = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::foregroundRgb_Prop::operator /*0I*/ColorAlpha () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, foregroundRgb);
   return self ? ((C(LFBSurface) *)self->impl)->foregroundRgb : ColorAlpha();
}

// member accessors: LFBSurface::stipple
// (nohead::uint16)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint16 TLFBSurface<TC, TCO>::stipple_Prop::operator= (/*0H*/uint16 v)
{
   SELF(LFBSurface, stipple);
   ((C(LFBSurface) *)self->impl)->stipple = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::stipple_Prop & TLFBSurface<TC, TCO>::stipple_Prop::operator= (typename TLFBSurface<TC, TCO>::stipple_Prop & prop)
{
   SELF(LFBSurface, stipple);
   /*0H*/uint16 v = prop;
   ((C(LFBSurface) *)self->impl)->stipple = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::stipple_Prop::operator /*0I*/uint16 () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, stipple);
   return self ? ((C(LFBSurface) *)self->impl)->stipple : 0;
}

// member accessors: LFBSurface::drawingChar
// (nohead::byte)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/unsigned char TLFBSurface<TC, TCO>::drawingChar_Prop::operator= (/*0H*/unsigned char v)
{
   SELF(LFBSurface, drawingChar);
   ((C(LFBSurface) *)self->impl)->drawingChar = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::drawingChar_Prop & TLFBSurface<TC, TCO>::drawingChar_Prop::operator= (typename TLFBSurface<TC, TCO>::drawingChar_Prop & prop)
{
   SELF(LFBSurface, drawingChar);
   /*0H*/unsigned char v = prop;
   ((C(LFBSurface) *)self->impl)->drawingChar = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::drawingChar_Prop::operator /*0I*/unsigned char () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, drawingChar);
   return self ? ((C(LFBSurface) *)self->impl)->drawingChar : 0;
}

// member accessors: LFBSurface::paletteShades
// (nohead::byte *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/unsigned char * TLFBSurface<TC, TCO>::paletteShades_Prop::operator= (/*0H*/unsigned char * v)
{
   SELF(LFBSurface, paletteShades);
   ((C(LFBSurface) *)self->impl)->paletteShades = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::paletteShades_Prop & TLFBSurface<TC, TCO>::paletteShades_Prop::operator= (typename TLFBSurface<TC, TCO>::paletteShades_Prop & prop)
{
   SELF(LFBSurface, paletteShades);
   /*0H*/unsigned char * v = prop;
   ((C(LFBSurface) *)self->impl)->paletteShades = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::paletteShades_Prop::operator /*0I*/unsigned char * () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, paletteShades);
   return self ? ((C(LFBSurface) *)self->impl)->paletteShades : null;
}

// member accessors: LFBSurface::clearing
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TLFBSurface<TC, TCO>::clearing_Prop::operator= (/*0H*/bool v)
{
   SELF(LFBSurface, clearing);
   ((C(LFBSurface) *)self->impl)->clearing = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSurface<TC, TCO>::clearing_Prop & TLFBSurface<TC, TCO>::clearing_Prop::operator= (typename TLFBSurface<TC, TCO>::clearing_Prop & prop)
{
   SELF(LFBSurface, clearing);
   /*0H*/bool v = prop;
   ((C(LFBSurface) *)self->impl)->clearing = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSurface<TC, TCO>::clearing_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TLFBSurface TCTCO * self = CONTAINER_OF(this, TLFBSurface TCTCO, clearing);
   return self ? ((C(LFBSurface) *)self->impl)->clearing : (bool)0;
}



// member accessors: LFBSystem::format
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TLFBSystem<TC, TCO>::format_Prop::operator= (/*0H*/int v)
{
   SELF(LFBSystem, format);
   ((C(LFBSystem) *)self->impl)->format = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSystem<TC, TCO>::format_Prop & TLFBSystem<TC, TCO>::format_Prop::operator= (typename TLFBSystem<TC, TCO>::format_Prop & prop)
{
   SELF(LFBSystem, format);
   /*0H*/int v = prop;
   ((C(LFBSystem) *)self->impl)->format = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSystem<TC, TCO>::format_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TLFBSystem TCTCO * self = CONTAINER_OF(this, TLFBSystem TCTCO, format);
   return self ? ((C(LFBSystem) *)self->impl)->format : 0;
}

// member accessors: LFBSystem::palette
// (nohead::bits|unsigned int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/ColorAlpha * TLFBSystem<TC, TCO>::palette_Prop::operator= (/*0H*/ColorAlpha * v)
{
   SELF(LFBSystem, palette);
   ((C(LFBSystem) *)self->impl)->palette = (C(ColorAlpha))v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TLFBSystem<TC, TCO>::palette_Prop & TLFBSystem<TC, TCO>::palette_Prop::operator= (typename TLFBSystem<TC, TCO>::palette_Prop & prop)
{
   SELF(LFBSystem, palette);
   /*0H*/ColorAlpha * v = prop;
   ((C(LFBSystem) *)self->impl)->palette = (C(ColorAlpha))v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TLFBSystem<TC, TCO>::palette_Prop::operator /*0I*/ColorAlpha * () const
{
   __attribute__((unused)) TLFBSystem TCTCO * self = CONTAINER_OF(this, TLFBSystem TCTCO, palette);
   return self ? ((C(LFBSystem) *)self->impl)->palette : null;
}

inline Shader::Shader(/*CT-D*/constString vertexShaderFile, /*CT-D*/constString fragmentShaderFile = 0, /*CT-D*/constString vertexShader = 0, /*CT-D*/constString fragmentShader = 0, uint64 state = 0, ShaderModifiedUniforms modifiedUniforms = ShaderModifiedUniforms()) : Shader()
{
   this->vertexShaderFile = vertexShaderFile;
   this->fragmentShaderFile = fragmentShaderFile;
   this->vertexShader = vertexShader;
   this->fragmentShader = fragmentShader;
   this->state = state;
   this->modifiedUniforms = modifiedUniforms;
}

inline Shader::Shader_bindAttribs_Functor::FunctionType Shader::Shader_bindAttribs_Functor::operator= (FunctionType func)
{
   SELF(Shader, bindAttribs);
   if(self->vTbl == Shader::_cpp_class.vTbl)
   {
      uint size = Shader::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Shader::Shader_bindAttribs_Functor::FunctionType, size);
      memcpy(self->vTbl, Shader::_cpp_class.vTbl, sizeof(Shader::Shader_bindAttribs_Functor::FunctionType) * size);
   }
   ((Shader::Shader_bindAttribs_Functor::FunctionType *)self->vTbl)[M_VTBLID(Shader, bindAttribs)] = func;
   return func;
}
inline void Shader::Shader_bindAttribs_Functor::operator()( /*6Fj*/int program)
{
   SELF(Shader, bindAttribs);
   Shader_bindAttribs(self ? self->impl : (C(Shader))null, /*7Al*/program);
}
// inline void Shader::register_bindAttribs(CPPClass & cl, Shader::Shader_bindAttribs_Functor::FunctionType func)
// {
//    ((Shader::Shader_bindAttribs_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Shader, bindAttribs)] = func;
// }

inline Shader::Shader_getDefinitions_Functor::FunctionType Shader::Shader_getDefinitions_Functor::operator= (FunctionType func)
{
   SELF(Shader, getDefinitions);
   if(self->vTbl == Shader::_cpp_class.vTbl)
   {
      uint size = Shader::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Shader::Shader_getDefinitions_Functor::FunctionType, size);
      memcpy(self->vTbl, Shader::_cpp_class.vTbl, sizeof(Shader::Shader_getDefinitions_Functor::FunctionType) * size);
   }
   ((Shader::Shader_getDefinitions_Functor::FunctionType *)self->vTbl)[M_VTBLID(Shader, getDefinitions)] = func;
   return func;
}
inline ZString * Shader::Shader_getDefinitions_Functor::operator()( /*6Fj*/uint64 state)
{
   SELF(Shader, getDefinitions);
   C(ZString) retZString = Shader_getDefinitions(self ? self->impl : (C(Shader))null, /*7Al*/state);
      return BINDINGS_CLASS(retZString) ? (ZString *)INSTANCEL(retZString, retZString->_class) : (ZString *)0;
}
// inline void Shader::register_getDefinitions(CPPClass & cl, Shader::Shader_getDefinitions_Functor::FunctionType func)
// {
//    ((Shader::Shader_getDefinitions_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Shader, getDefinitions)] = func;
// }

inline Shader::Shader_registerShader_Functor::FunctionType Shader::Shader_registerShader_Functor::operator= (FunctionType func)
{
   SELF(Shader, registerShader);
   if(self->vTbl == Shader::_cpp_class.vTbl)
   {
      uint size = Shader::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Shader::Shader_registerShader_Functor::FunctionType, size);
      memcpy(self->vTbl, Shader::_cpp_class.vTbl, sizeof(Shader::Shader_registerShader_Functor::FunctionType) * size);
   }
   ((Shader::Shader_registerShader_Functor::FunctionType *)self->vTbl)[M_VTBLID(Shader, registerShader)] = func;
   return func;
}
inline CompiledShader Shader::Shader_registerShader_Functor::operator()( /*6Fj*/int program, /*6Fj*/uint64 state)
{
   SELF(Shader, registerShader);
   C(CompiledShader) * retCompiledShader = Shader_registerShader(self ? self->impl : (C(Shader))null, /*7Al*/program, /*7Al*/state);
      return retCompiledShader;
}
// inline void Shader::register_registerShader(CPPClass & cl, Shader::Shader_registerShader_Functor::FunctionType func)
// {
//    ((Shader::Shader_registerShader_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Shader, registerShader)] = func;
// }

inline Shader::Shader_setMaterial_Functor::FunctionType Shader::Shader_setMaterial_Functor::operator= (FunctionType func)
{
   SELF(Shader, setMaterial);
   if(self->vTbl == Shader::_cpp_class.vTbl)
   {
      uint size = Shader::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Shader::Shader_setMaterial_Functor::FunctionType, size);
      memcpy(self->vTbl, Shader::_cpp_class.vTbl, sizeof(Shader::Shader_setMaterial_Functor::FunctionType) * size);
   }
   ((Shader::Shader_setMaterial_Functor::FunctionType *)self->vTbl)[M_VTBLID(Shader, setMaterial)] = func;
   return func;
}
inline void Shader::Shader_setMaterial_Functor::operator()( /*6Fj*/Material material, /*6Fj*/MeshFeatures flags)
{
   SELF(Shader, setMaterial);
   Shader_setMaterial(self ? self->impl : (C(Shader))null, /*7Al*/material.impl, /*7Al*/(C(MeshFeatures))flags);
}
// inline void Shader::register_setMaterial(CPPClass & cl, Shader::Shader_setMaterial_Functor::FunctionType func)
// {
//    ((Shader::Shader_setMaterial_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Shader, setMaterial)] = func;
// }

inline Shader::Shader_setupDrawCommand_Functor::FunctionType Shader::Shader_setupDrawCommand_Functor::operator= (FunctionType func)
{
   SELF(Shader, setupDrawCommand);
   if(self->vTbl == Shader::_cpp_class.vTbl)
   {
      uint size = Shader::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Shader::Shader_setupDrawCommand_Functor::FunctionType, size);
      memcpy(self->vTbl, Shader::_cpp_class.vTbl, sizeof(Shader::Shader_setupDrawCommand_Functor::FunctionType) * size);
   }
   ((Shader::Shader_setupDrawCommand_Functor::FunctionType *)self->vTbl)[M_VTBLID(Shader, setupDrawCommand)] = func;
   return func;
}
inline void Shader::Shader_setupDrawCommand_Functor::operator()( /*6Fj*/GLAB & ab, /*6Fj*/uint vertexStride, /*6Fj*/uint baseVertex, /*6Fj*/uint drawID, /*6Fj*/void * transform)
{
   SELF(Shader, setupDrawCommand);
   Shader_setupDrawCommand(self ? self->impl : (C(Shader))null, /*7Al*/&ab.impl, /*7Al*/vertexStride, /*7Al*/baseVertex, /*7Al*/drawID, /*7Al*/transform);
}
// inline void Shader::register_setupDrawCommand(CPPClass & cl, Shader::Shader_setupDrawCommand_Functor::FunctionType func)
// {
//    ((Shader::Shader_setupDrawCommand_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Shader, setupDrawCommand)] = func;
// }

inline Shader::Shader_updateMatrix_Functor::FunctionType Shader::Shader_updateMatrix_Functor::operator= (FunctionType func)
{
   SELF(Shader, updateMatrix);
   if(self->vTbl == Shader::_cpp_class.vTbl)
   {
      uint size = Shader::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Shader::Shader_updateMatrix_Functor::FunctionType, size);
      memcpy(self->vTbl, Shader::_cpp_class.vTbl, sizeof(Shader::Shader_updateMatrix_Functor::FunctionType) * size);
   }
   ((Shader::Shader_updateMatrix_Functor::FunctionType *)self->vTbl)[M_VTBLID(Shader, updateMatrix)] = func;
   return func;
}
inline void Shader::Shader_updateMatrix_Functor::operator()( /*6Fj*/MatrixMode mode, /*6Fj*/float * matrix, /*6Fj*/bool isIdentity)
{
   SELF(Shader, updateMatrix);
   Shader_updateMatrix(self ? self->impl : (C(Shader))null, /*7Al*/(C(MatrixMode))mode, /*7Al*/matrix, /*7Al*/(C(bool))isIdentity);
}
// inline void Shader::register_updateMatrix(CPPClass & cl, Shader::Shader_updateMatrix_Functor::FunctionType func)
// {
//    ((Shader::Shader_updateMatrix_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Shader, updateMatrix)] = func;
// }

inline Shader::Shader_uploadUniforms_Functor::FunctionType Shader::Shader_uploadUniforms_Functor::operator= (FunctionType func)
{
   SELF(Shader, uploadUniforms);
   if(self->vTbl == Shader::_cpp_class.vTbl)
   {
      uint size = Shader::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Shader::Shader_uploadUniforms_Functor::FunctionType, size);
      memcpy(self->vTbl, Shader::_cpp_class.vTbl, sizeof(Shader::Shader_uploadUniforms_Functor::FunctionType) * size);
   }
   ((Shader::Shader_uploadUniforms_Functor::FunctionType *)self->vTbl)[M_VTBLID(Shader, uploadUniforms)] = func;
   return func;
}
inline void Shader::Shader_uploadUniforms_Functor::operator()( /*6Fj*/CompiledShader shader)
{
   SELF(Shader, uploadUniforms);
   Shader_uploadUniforms(self ? self->impl : (C(Shader))null, /*7Al*/shader.impl);
}
// inline void Shader::register_uploadUniforms(CPPClass & cl, Shader::Shader_uploadUniforms_Functor::FunctionType func)
// {
//    ((Shader::Shader_uploadUniforms_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Shader, uploadUniforms)] = func;
// }


inline C(bool) Shader::activate()
{
   return Shader_activate(impl);
}
inline void Shader::free()
{
   Shader_free(impl);
}
inline C(CompiledShader) * Shader::load(/*1Ab*/uint64 state)
{
   return Shader_load(impl, /*5Ge*/state);
}
inline void Shader::select()
{
   Shader_select(impl);
}


// property callers: Shader::vertexShaderFile   // set only
// (normal::string)

/*nstSet*/inline /*0G*//*CT-D*/constString Shader::vertexShaderFile_Prop::operator= (/*0G*//*CT-D*/constString v)
{
   SELF(Shader, vertexShaderFile);
   Shader_set_vertexShaderFile(self->impl, v);
   return v;
}


// property callers: Shader::fragmentShaderFile   // set only
// (normal::string)

/*nstSet*/inline /*0G*//*CT-D*/constString Shader::fragmentShaderFile_Prop::operator= (/*0G*//*CT-D*/constString v)
{
   SELF(Shader, fragmentShaderFile);
   Shader_set_fragmentShaderFile(self->impl, v);
   return v;
}


// property callers: Shader::vertexShader   // set only
// (normal::string)

/*nstSet*/inline /*0G*//*CT-D*/constString Shader::vertexShader_Prop::operator= (/*0G*//*CT-D*/constString v)
{
   SELF(Shader, vertexShader);
   Shader_set_vertexShader(self->impl, v);
   return v;
}


// property callers: Shader::fragmentShader   // set only
// (normal::string)

/*nstSet*/inline /*0G*//*CT-D*/constString Shader::fragmentShader_Prop::operator= (/*0G*//*CT-D*/constString v)
{
   SELF(Shader, fragmentShader);
   Shader_set_fragmentShader(self->impl, v);
   return v;
}


// property callers: Shader::activeCompiledShader   // get only
// (normal::nohead)

/*regGet*/inline Shader::activeCompiledShader_Prop::operator /*0I*/CompiledShader () const
{
   SELF(Shader, activeCompiledShader);
   CompiledShader value(Shader_get_activeCompiledShader(self->impl));
   return value;
}


// member accessors: Shader::state
// (normal::uint64)

/*nstSet*/inline /*0H*/uint64 Shader::state_Prop::operator= (/*0H*/uint64 v)
{
   SELF(Shader, state);
   IPTR(self->impl, Shader)->state = v;
   return v;
}

/*regSet*/inline Shader::state_Prop & Shader::state_Prop::operator= (Shader::state_Prop & prop)
{
   SELF(Shader, state);
   /*0H*/uint64 v = prop;
   IPTR(self->impl, Shader)->state = v;
   return prop;
}
/*regGet*/inline Shader::state_Prop::operator /*0I*/uint64 () const
{
   SELF(Shader, state);
   return self ? IPTR(self->impl, Shader)->state : 0;
}

// member accessors: Shader::modifiedUniforms
// (normal::bits|uint)

/*nstSet*/inline /*0H*/ShaderModifiedUniforms Shader::modifiedUniforms_Prop::operator= (/*0H*/ShaderModifiedUniforms v)
{
   SELF(Shader, modifiedUniforms);
   IPTR(self->impl, Shader)->modifiedUniforms = v;
   return v;
}

/*regSet*/inline Shader::modifiedUniforms_Prop & Shader::modifiedUniforms_Prop::operator= (Shader::modifiedUniforms_Prop & prop)
{
   SELF(Shader, modifiedUniforms);
   /*0H*/ShaderModifiedUniforms v = prop;
   IPTR(self->impl, Shader)->modifiedUniforms = v;
   return prop;
}
/*regGet*/inline Shader::modifiedUniforms_Prop::operator /*0I*/ShaderModifiedUniforms () const
{
   SELF(Shader, modifiedUniforms);
   return self ? ShaderModifiedUniforms(IPTR(self->impl, Shader)->modifiedUniforms) : ShaderModifiedUniforms();
}



// member accessors: ShaderModifiedUniforms::matMV
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ShaderModifiedUniforms::matMV_Prop::operator= (/*0H*/bool v)
{
   SELF(ShaderModifiedUniforms, matMV);
   SHADERMODIFIEDUNIFORMS_SET_matMV(self->impl, v);
   return v;
}

/*regSet*/inline ShaderModifiedUniforms::matMV_Prop & ShaderModifiedUniforms::matMV_Prop::operator= (ShaderModifiedUniforms::matMV_Prop & prop)
{
   SELF(ShaderModifiedUniforms, matMV);
   /*0H*/bool v = prop;
   SHADERMODIFIEDUNIFORMS_SET_matMV(self->impl, v);
   return prop;
}
/*regGet*/inline ShaderModifiedUniforms::matMV_Prop::operator /*0I*/bool () const
{
   SELF(ShaderModifiedUniforms, matMV);
   return (bool)SHADERMODIFIEDUNIFORMS_matMV(self->impl);
}

// member accessors: ShaderModifiedUniforms::light
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ShaderModifiedUniforms::light_Prop::operator= (/*0H*/bool v)
{
   SELF(ShaderModifiedUniforms, light);
   SHADERMODIFIEDUNIFORMS_SET_light(self->impl, v);
   return v;
}

/*regSet*/inline ShaderModifiedUniforms::light_Prop & ShaderModifiedUniforms::light_Prop::operator= (ShaderModifiedUniforms::light_Prop & prop)
{
   SELF(ShaderModifiedUniforms, light);
   /*0H*/bool v = prop;
   SHADERMODIFIEDUNIFORMS_SET_light(self->impl, v);
   return prop;
}
/*regGet*/inline ShaderModifiedUniforms::light_Prop::operator /*0I*/bool () const
{
   SELF(ShaderModifiedUniforms, light);
   return (bool)SHADERMODIFIEDUNIFORMS_light(self->impl);
}

// member accessors: ShaderModifiedUniforms::material
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ShaderModifiedUniforms::material_Prop::operator= (/*0H*/bool v)
{
   SELF(ShaderModifiedUniforms, material);
   SHADERMODIFIEDUNIFORMS_SET_material(self->impl, v);
   return v;
}

/*regSet*/inline ShaderModifiedUniforms::material_Prop & ShaderModifiedUniforms::material_Prop::operator= (ShaderModifiedUniforms::material_Prop & prop)
{
   SELF(ShaderModifiedUniforms, material);
   /*0H*/bool v = prop;
   SHADERMODIFIEDUNIFORMS_SET_material(self->impl, v);
   return prop;
}
/*regGet*/inline ShaderModifiedUniforms::material_Prop::operator /*0I*/bool () const
{
   SELF(ShaderModifiedUniforms, material);
   return (bool)SHADERMODIFIEDUNIFORMS_material(self->impl);
}

// member accessors: ShaderModifiedUniforms::matPrj
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ShaderModifiedUniforms::matPrj_Prop::operator= (/*0H*/bool v)
{
   SELF(ShaderModifiedUniforms, matPrj);
   SHADERMODIFIEDUNIFORMS_SET_matPrj(self->impl, v);
   return v;
}

/*regSet*/inline ShaderModifiedUniforms::matPrj_Prop & ShaderModifiedUniforms::matPrj_Prop::operator= (ShaderModifiedUniforms::matPrj_Prop & prop)
{
   SELF(ShaderModifiedUniforms, matPrj);
   /*0H*/bool v = prop;
   SHADERMODIFIEDUNIFORMS_SET_matPrj(self->impl, v);
   return prop;
}
/*regGet*/inline ShaderModifiedUniforms::matPrj_Prop::operator /*0I*/bool () const
{
   SELF(ShaderModifiedUniforms, matPrj);
   return (bool)SHADERMODIFIEDUNIFORMS_matPrj(self->impl);
}

// member accessors: ShaderModifiedUniforms::matTex
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ShaderModifiedUniforms::matTex_Prop::operator= (/*0H*/bool v)
{
   SELF(ShaderModifiedUniforms, matTex);
   SHADERMODIFIEDUNIFORMS_SET_matTex(self->impl, v);
   return v;
}

/*regSet*/inline ShaderModifiedUniforms::matTex_Prop & ShaderModifiedUniforms::matTex_Prop::operator= (ShaderModifiedUniforms::matTex_Prop & prop)
{
   SELF(ShaderModifiedUniforms, matTex);
   /*0H*/bool v = prop;
   SHADERMODIFIEDUNIFORMS_SET_matTex(self->impl, v);
   return prop;
}
/*regGet*/inline ShaderModifiedUniforms::matTex_Prop::operator /*0I*/bool () const
{
   SELF(ShaderModifiedUniforms, matTex);
   return (bool)SHADERMODIFIEDUNIFORMS_matTex(self->impl);
}

// member accessors: ShaderModifiedUniforms::pos
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ShaderModifiedUniforms::pos_Prop::operator= (/*0H*/bool v)
{
   SELF(ShaderModifiedUniforms, pos);
   SHADERMODIFIEDUNIFORMS_SET_pos(self->impl, v);
   return v;
}

/*regSet*/inline ShaderModifiedUniforms::pos_Prop & ShaderModifiedUniforms::pos_Prop::operator= (ShaderModifiedUniforms::pos_Prop & prop)
{
   SELF(ShaderModifiedUniforms, pos);
   /*0H*/bool v = prop;
   SHADERMODIFIEDUNIFORMS_SET_pos(self->impl, v);
   return prop;
}
/*regGet*/inline ShaderModifiedUniforms::pos_Prop::operator /*0I*/bool () const
{
   SELF(ShaderModifiedUniforms, pos);
   return (bool)SHADERMODIFIEDUNIFORMS_pos(self->impl);
}

// member accessors: ShaderModifiedUniforms::layer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ShaderModifiedUniforms::layer_Prop::operator= (/*0H*/bool v)
{
   SELF(ShaderModifiedUniforms, layer);
   SHADERMODIFIEDUNIFORMS_SET_layer(self->impl, v);
   return v;
}

/*regSet*/inline ShaderModifiedUniforms::layer_Prop & ShaderModifiedUniforms::layer_Prop::operator= (ShaderModifiedUniforms::layer_Prop & prop)
{
   SELF(ShaderModifiedUniforms, layer);
   /*0H*/bool v = prop;
   SHADERMODIFIEDUNIFORMS_SET_layer(self->impl, v);
   return prop;
}
/*regGet*/inline ShaderModifiedUniforms::layer_Prop::operator /*0I*/bool () const
{
   SELF(ShaderModifiedUniforms, layer);
   return (bool)SHADERMODIFIEDUNIFORMS_layer(self->impl);
}

////////////////////////////////////////////////// [ecere]/ecere::gfx3D //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


inline Camera::Camera(CameraType type, Vector3D position = Vector3D(), Quaternion orientation = Quaternion(), Euler eulerOrientation = Euler(), Degrees fov = 0, float zMin = 0, float zMax = 0) : Camera()
{
   this->type = type;
   this->position = position.impl;
   this->orientation = orientation.impl;
   this->eulerOrientation = eulerOrientation.impl;
   this->fov = fov.impl;
   this->zMin = zMin;
   this->zMax = zMax;
}


inline void Camera::adjustAngle(/*1Ab*/Quaternion & angle)
{
   Camera_adjustAngle(impl, /*5De*/&angle.impl);
}
inline void Camera::adjustAngle(/*1Ac*/Quaternion * angle)
{
   Camera_adjustAngle(impl, /*5Cf*/(C(Quaternion) *)angle);
}
inline void Camera::adjustPosition(/*1Ab*/Vector3D & position)
{
   Camera_adjustPosition(impl, /*5De*/&position.impl);
}
inline void Camera::adjustPosition(/*1Ac*/Vector3D * position)
{
   Camera_adjustPosition(impl, /*5Cf*/(C(Vector3D) *)position);
}
inline void Camera::move(/*1Ab*/Vector3D & direction)
{
   Camera_move(impl, /*5De*/&direction.impl);
}
inline void Camera::move(/*1Ac*/Vector3D * direction)
{
   Camera_move(impl, /*5Cf*/(C(Vector3D) *)direction);
}
inline C(bool) Camera::pointsVisible(/*1Ab*/Vector3D * points, /*1Ab*/int numPoints, /*1Ab*/double threshold)
{
   return Camera_pointsVisible(impl, /*5Ee*/(C(Vector3D) *)points, /*5Ge*/numPoints, /*5Ge*/threshold);
}
inline C(bool) Camera::project(/*1Ab*/Vector3D & vector, /*1Ab*/Vector3D & point)
{
   return Camera_project(impl, /*5De*/&vector.impl, /*5De*/&point.impl);
}
inline C(bool) Camera::project(/*1Ac*/Vector3D * vector, /*1Ac*/Vector3D * point)
{
   return Camera_project(impl, /*5Cf*/(C(Vector3D) *)vector, /*5Cf*/(C(Vector3D) *)point);
}
inline C(bool) Camera::projectSize(/*1Ab*/Vector3D & vector, /*1Ab*/Point & point)
{
   return Camera_projectSize(impl, /*5De*/&vector.impl, /*5De*/&point.impl);
}
inline C(bool) Camera::projectSize(/*1Ac*/Vector3D * vector, /*1Ac*/Point * point)
{
   return Camera_projectSize(impl, /*5Cf*/(C(Vector3D) *)vector, /*5Cf*/(C(Point) *)point);
}
inline void Camera::rotatePitch(/*1Ab*/Angle amount, /*1Ab*/Angle min, /*1Ab*/Angle max)
{
   Camera_rotatePitch(impl, /*5Ee*/(C(Angle))amount.impl, /*5Ee*/(C(Angle))min.impl, /*5Ee*/(C(Angle))max.impl);
}
inline void Camera::rotateRoll(/*1Ab*/Angle amount, /*1Ab*/Angle min, /*1Ab*/Angle max)
{
   Camera_rotateRoll(impl, /*5Ee*/(C(Angle))amount.impl, /*5Ee*/(C(Angle))min.impl, /*5Ee*/(C(Angle))max.impl);
}
inline void Camera::rotateYaw(/*1Ab*/Angle amount, /*1Ab*/Angle min, /*1Ab*/Angle max)
{
   Camera_rotateYaw(impl, /*5Ee*/(C(Angle))amount.impl, /*5Ee*/(C(Angle))min.impl, /*5Ee*/(C(Angle))max.impl);
}
inline void Camera::setup(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/const Point & origin)
{
   Camera_setup(impl, /*5Ge*/width, /*5Ge*/height, /*5De*/&origin.impl);
}
inline void Camera::setup(/*1Ac*/int width, /*1Ac*/int height, /*1Ac*/const Point * origin)
{
   Camera_setup(impl, /*5Gf*/width, /*5Gf*/height, /*5Cf*/(C(Point) *)origin);
}
inline void Camera::setupVR(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/const Matrix & prjMatrix)
{
   Camera_setupVR(impl, /*5Ge*/width, /*5Ge*/height, /*5De*/&prjMatrix.impl);
}
inline void Camera::setupVR(/*1Ac*/int width, /*1Ac*/int height, /*1Ac*/const Matrix * prjMatrix)
{
   Camera_setupVR(impl, /*5Gf*/width, /*5Gf*/height, /*5Cf*/(C(Matrix) *)prjMatrix);
}
inline void Camera::slerp(/*1Ab*/float amount)
{
   Camera_slerp(impl, /*5Ge*/amount);
}
inline C(bool) Camera::sphereVisible(/*1Ab*/Vector3D & center, /*1Ab*/float radius)
{
   return Camera_sphereVisible(impl, /*5De*/&center.impl, /*5Ge*/radius);
}
inline C(bool) Camera::sphereVisible(/*1Ac*/Vector3D * center, /*1Ac*/float radius)
{
   return Camera_sphereVisible(impl, /*5Cf*/(C(Vector3D) *)center, /*5Gf*/radius);
}
inline void Camera::transformMatrix(/*1Ab*/Matrix & dest, /*1Ab*/Matrix & src)
{
   Camera_transformMatrix(impl, /*5De*/&dest.impl, /*5De*/&src.impl);
}
inline void Camera::transformMatrix(/*1Ac*/Matrix * dest, /*1Ac*/Matrix * src)
{
   Camera_transformMatrix(impl, /*5Cf*/(C(Matrix) *)dest, /*5Cf*/(C(Matrix) *)src);
}
inline void Camera::transformNormal(/*1Ab*/Vector3D & dest, /*1Ab*/Vector3D & src)
{
   Camera_transformNormal(impl, /*5De*/&dest.impl, /*5De*/&src.impl);
}
inline void Camera::transformNormal(/*1Ac*/Vector3D * dest, /*1Ac*/Vector3D * src)
{
   Camera_transformNormal(impl, /*5Cf*/(C(Vector3D) *)dest, /*5Cf*/(C(Vector3D) *)src);
}
inline void Camera::transformPoint(/*1Ab*/Vector3D & dest, /*1Ab*/Vector3D & src)
{
   Camera_transformPoint(impl, /*5De*/&dest.impl, /*5De*/&src.impl);
}
inline void Camera::transformPoint(/*1Ac*/Vector3D * dest, /*1Ac*/Vector3D * src)
{
   Camera_transformPoint(impl, /*5Cf*/(C(Vector3D) *)dest, /*5Cf*/(C(Vector3D) *)src);
}
inline void Camera::unproject(/*1Ab*/Vector3D & point, /*1Ab*/Vector3D & vector)
{
   Camera_unproject(impl, /*5De*/&point.impl, /*5De*/&vector.impl);
}
inline void Camera::unproject(/*1Ac*/Vector3D * point, /*1Ac*/Vector3D * vector)
{
   Camera_unproject(impl, /*5Cf*/(C(Vector3D) *)point, /*5Cf*/(C(Vector3D) *)vector);
}
inline void Camera::untransform(/*1Ab*/Vector3D & src, /*1Ab*/Vector3D & result)
{
   Camera_untransform(impl, /*5De*/&src.impl, /*5De*/&result.impl);
}
inline void Camera::untransform(/*1Ac*/Vector3D * src, /*1Ac*/Vector3D * result)
{
   Camera_untransform(impl, /*5Cf*/(C(Vector3D) *)src, /*5Cf*/(C(Vector3D) *)result);
}
inline C(bool) Camera::update()
{
   return Camera_update(impl);
}
inline void Camera::setCPosition(/*1Ab*/Vector3D & value)
{
   Camera_setCPosition(impl, /*5De*/&value.impl);
}
inline void Camera::setCPosition(/*1Ac*/Vector3D * value)
{
   Camera_setCPosition(impl, /*5Cf*/(C(Vector3D) *)value);
}
inline void Camera::setViewMatrix(/*1Ab*/Matrix & value)
{
   Camera_setViewMatrix(impl, /*5De*/&value.impl);
}
inline void Camera::setViewMatrix(/*1Ac*/Matrix * value)
{
   Camera_setViewMatrix(impl, /*5Cf*/(C(Matrix) *)value);
}


// property callers: Camera::type
// (normal::enum|int)

/*nstSet*/inline /*0H*/CameraType Camera::type_Prop::operator= (/*0H*/CameraType v)
{
   SELF(Camera, type);
   Camera_set_type(self ? self->impl : null, (C(CameraType))v);
   return v;
}

/*regSet*/inline Camera::type_Prop & Camera::type_Prop::operator= (Camera::type_Prop & prop)
{
   SELF(Camera, type);
   /*0H*/CameraType v = prop;
   Camera_set_type(self ? self->impl : null, (C(CameraType))v);
   return prop;
}
/*regGet*/inline Camera::type_Prop::operator /*0I*/CameraType () const
{
   SELF(Camera, type);
   return (CameraType)Camera_get_type(self ? self->impl : null);
}

// property callers: Camera::position
// (normal::struct)

/*nstSet*/inline /*0H*/Vector3D Camera::position_Prop::operator= (/*0H*/Vector3D v)
{
   SELF(Camera, position);
   Camera_set_position(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Camera::position_Prop & Camera::position_Prop::operator= (Camera::position_Prop & prop)
{
   SELF(Camera, position);
   /*0H*/Vector3D v = prop;
   Camera_set_position(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Camera::position_Prop::operator /*0I*/Vector3D () const
{
   SELF(Camera, position);
   Vector3D value(IPTR(self->impl, Camera)->position);
   return value;
}

// property callers: Camera::orientation
// (normal::struct)

/*nstSet*/inline /*0H*/Quaternion Camera::orientation_Prop::operator= (/*0H*/Quaternion v)
{
   SELF(Camera, orientation);
   Camera_set_orientation(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Camera::orientation_Prop & Camera::orientation_Prop::operator= (Camera::orientation_Prop & prop)
{
   SELF(Camera, orientation);
   /*0H*/Quaternion v = prop;
   Camera_set_orientation(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Camera::orientation_Prop::operator /*0I*/Quaternion () const
{
   SELF(Camera, orientation);
   Quaternion value;Camera_get_orientation(self->impl, &value.impl);
   return value;
}

// property callers: Camera::eulerOrientation
// (normal::struct)

/*nstSet*/inline /*0H*/Euler Camera::eulerOrientation_Prop::operator= (/*0H*/Euler v)
{
   SELF(Camera, eulerOrientation);
   Camera_set_eulerOrientation(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Camera::eulerOrientation_Prop & Camera::eulerOrientation_Prop::operator= (Camera::eulerOrientation_Prop & prop)
{
   SELF(Camera, eulerOrientation);
   /*0H*/Euler v = prop;
   Camera_set_eulerOrientation(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Camera::eulerOrientation_Prop::operator /*0I*/Euler () const
{
   SELF(Camera, eulerOrientation);
   Euler value;Camera_get_eulerOrientation(self->impl, &value.impl);
   return value;
}

// property callers: Camera::cPosition   // get only
// (normal::struct)

/*regGet*/inline Camera::cPosition_Prop::operator /*0I*/Vector3D () const
{
   SELF(Camera, cPosition);
   Vector3D value;Camera_get_cPosition(self->impl, &value.impl);
   return value;
}

// property callers: Camera::cOrientation   // get only
// (normal::struct)

/*regGet*/inline Camera::cOrientation_Prop::operator /*0I*/Quaternion () const
{
   SELF(Camera, cOrientation);
   Quaternion value;Camera_get_cOrientation(self->impl, &value.impl);
   return value;
}

// property callers: Camera::fov
// (normal::unit|double)

/*nstSet*/inline /*0H*/Degrees Camera::fov_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Camera, fov);
   Camera_set_fov(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Camera::fov_Prop & Camera::fov_Prop::operator= (Camera::fov_Prop & prop)
{
   SELF(Camera, fov);
   /*0H*/Degrees v = prop;
   Camera_set_fov(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline Camera::fov_Prop::operator /*0I*/Degrees () const
{
   SELF(Camera, fov);
   Degrees value(Camera_get_fov(self->impl));
   return value;
}
/*regGet*/inline Camera::fov_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Camera, fov);
   return Degrees(self->fov);
}

// property callers: Camera::zMin
// (normal::float)

/*nstSet*/inline /*0H*/float Camera::zMin_Prop::operator= (/*0H*/float v)
{
   SELF(Camera, zMin);
   Camera_set_zMin(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Camera::zMin_Prop & Camera::zMin_Prop::operator= (Camera::zMin_Prop & prop)
{
   SELF(Camera, zMin);
   /*0H*/float v = prop;
   Camera_set_zMin(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Camera::zMin_Prop::operator /*0I*/float () const
{
   SELF(Camera, zMin);
   return Camera_get_zMin(self ? self->impl : null);
}

// property callers: Camera::zMax
// (normal::float)

/*nstSet*/inline /*0H*/float Camera::zMax_Prop::operator= (/*0H*/float v)
{
   SELF(Camera, zMax);
   Camera_set_zMax(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Camera::zMax_Prop & Camera::zMax_Prop::operator= (Camera::zMax_Prop & prop)
{
   SELF(Camera, zMax);
   /*0H*/float v = prop;
   Camera_set_zMax(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Camera::zMax_Prop::operator /*0I*/float () const
{
   SELF(Camera, zMax);
   return Camera_get_zMax(self ? self->impl : null);
}

// property callers: Camera::target
// (normal::nohead)

/*nstSet*/inline /*0H*/Object Camera::target_Prop::operator= (/*0H*/Object & v)
{
   SELF(Camera, target);
   Camera_set_target(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Camera::target_Prop & Camera::target_Prop::operator= (Camera::target_Prop & prop)
{
   SELF(Camera, target);
   /*0H*/Object v = prop;
   Camera_set_target(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline Camera::target_Prop::operator /*0I*/Object () const
{
   SELF(Camera, target);
   Object value(Camera_get_target(self->impl));
   return value;
}

// property callers: Camera::fovDirection
// (normal::enum|int)

/*nstSet*/inline /*0H*/FovDirection Camera::fovDirection_Prop::operator= (/*0H*/FovDirection v)
{
   SELF(Camera, fovDirection);
   Camera_set_fovDirection(self ? self->impl : null, (C(FovDirection))v);
   return v;
}

/*regSet*/inline Camera::fovDirection_Prop & Camera::fovDirection_Prop::operator= (Camera::fovDirection_Prop & prop)
{
   SELF(Camera, fovDirection);
   /*0H*/FovDirection v = prop;
   Camera_set_fovDirection(self ? self->impl : null, (C(FovDirection))v);
   return prop;
}
/*regGet*/inline Camera::fovDirection_Prop::operator /*0I*/FovDirection () const
{
   SELF(Camera, fovDirection);
   return (FovDirection)Camera_get_fovDirection(self ? self->impl : null);
}

// property callers: Camera::aspectRatio
// (normal::float)

/*nstSet*/inline /*0H*/float Camera::aspectRatio_Prop::operator= (/*0H*/float v)
{
   SELF(Camera, aspectRatio);
   Camera_set_aspectRatio(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Camera::aspectRatio_Prop & Camera::aspectRatio_Prop::operator= (Camera::aspectRatio_Prop & prop)
{
   SELF(Camera, aspectRatio);
   /*0H*/float v = prop;
   Camera_set_aspectRatio(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Camera::aspectRatio_Prop::operator /*0I*/float () const
{
   SELF(Camera, aspectRatio);
   return Camera_get_aspectRatio(self ? self->impl : null);
}

// property callers: Camera::focal
// (normal::struct)

/*nstSet*/inline /*0H*/Size Camera::focal_Prop::operator= (/*0H*/Size v)
{
   SELF(Camera, focal);
   Camera_set_focal(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Camera::focal_Prop & Camera::focal_Prop::operator= (Camera::focal_Prop & prop)
{
   SELF(Camera, focal);
   /*0H*/Size v = prop;
   Camera_set_focal(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Camera::focal_Prop::operator /*0I*/Size () const
{
   SELF(Camera, focal);
   Size value;Camera_get_focal(self->impl, &value.impl);
   return value;
}
// A (struct:struct)
inline Euler::operator Quaternion() const { Quaternion q; Euler_to_Quaternion(&impl, &q.impl); return q; }
inline Euler::Euler(const Quaternion & q) { Euler_from_Quaternion(&impl, &q.impl); }
inline Euler & Euler::operator =(const Quaternion & q) { Euler_from_Quaternion(&impl, &q.impl); return *this; }

inline Euler::Euler(Degrees yaw, Degrees pitch = 0, Degrees roll = 0)
{
   impl.yaw = yaw.impl;
   impl.pitch = pitch.impl;
   impl.roll = roll.impl;
}


inline void Euler::add(/*1Ab*/const Euler & e1, /*1Ab*/const Euler & e2)
{
   Euler_add(&impl, /*5De*/&e1.impl, /*5De*/&e2.impl);
}
inline void Euler::add(/*1Ac*/const Euler * e1, /*1Ac*/const Euler * e2)
{
   Euler_add(&impl, /*5Cf*/(C(Euler) *)e1, /*5Cf*/(C(Euler) *)e2);
}
inline void Euler::fromMatrix(/*1Ab*/const Matrix & m, /*1Ab*/EulerRotationOrder order)
{
   Euler_fromMatrix(&impl, /*5De*/&m.impl, /*5Ee*/(C(EulerRotationOrder))order);
}
inline void Euler::fromMatrix(/*1Ac*/const Matrix * m, /*1Ac*/EulerRotationOrder order)
{
   Euler_fromMatrix(&impl, /*5Cf*/(C(Matrix) *)m, /*5Ef*/(C(EulerRotationOrder))order);
}
inline void Euler::fromQuaternion(/*1Ab*/const Quaternion & q, /*1Ab*/EulerRotationOrder order)
{
   Euler_fromQuaternion(&impl, /*5De*/&q.impl, /*5Ee*/(C(EulerRotationOrder))order);
}
inline void Euler::fromQuaternion(/*1Ac*/const Quaternion * q, /*1Ac*/EulerRotationOrder order)
{
   Euler_fromQuaternion(&impl, /*5Cf*/(C(Quaternion) *)q, /*5Ef*/(C(EulerRotationOrder))order);
}


// member accessors: Euler::yaw
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees Euler::yaw_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Euler, yaw);
   self->impl.yaw = (double)v.impl;
   return v;
}

/*regSet*/inline Euler::yaw_Prop & Euler::yaw_Prop::operator= (Euler::yaw_Prop & prop)
{
   SELF(Euler, yaw);
   /*0H*/Degrees v = prop;
   self->impl.yaw = (double)v.impl;
   return prop;
}
/*regGet*/inline Euler::yaw_Prop::operator /*0I*/Degrees () const
{
   SELF(Euler, yaw);
   return Degrees(Angle(self->impl.yaw));
}
/*regGet*/inline Euler::yaw_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Euler, yaw);
   return Degrees(self->yaw);
}

// member accessors: Euler::pitch
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees Euler::pitch_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Euler, pitch);
   self->impl.pitch = (double)v.impl;
   return v;
}

/*regSet*/inline Euler::pitch_Prop & Euler::pitch_Prop::operator= (Euler::pitch_Prop & prop)
{
   SELF(Euler, pitch);
   /*0H*/Degrees v = prop;
   self->impl.pitch = (double)v.impl;
   return prop;
}
/*regGet*/inline Euler::pitch_Prop::operator /*0I*/Degrees () const
{
   SELF(Euler, pitch);
   return Degrees(Angle(self->impl.pitch));
}
/*regGet*/inline Euler::pitch_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Euler, pitch);
   return Degrees(self->pitch);
}

// member accessors: Euler::roll
// (struct::unit|double)

/*nstSet*/inline /*0H*/Degrees Euler::roll_Prop::operator= (/*0H*/Degrees v)
{
   SELF(Euler, roll);
   self->impl.roll = (double)v.impl;
   return v;
}

/*regSet*/inline Euler::roll_Prop & Euler::roll_Prop::operator= (Euler::roll_Prop & prop)
{
   SELF(Euler, roll);
   /*0H*/Degrees v = prop;
   self->impl.roll = (double)v.impl;
   return prop;
}
/*regGet*/inline Euler::roll_Prop::operator /*0I*/Degrees () const
{
   SELF(Euler, roll);
   return Degrees(Angle(self->impl.roll));
}
/*regGet*/inline Euler::roll_Prop::operator /*0J*/C(Angle) () const
{
   SELF(Euler, roll);
   return Degrees(self->roll);
}

inline FrameKey::FrameKey(uint frame, float tension = 0, float continuity = 0, float bias = 0, float easeFrom = 0, float easeTo = 0, Vector3Df position = Vector3Df(), Quaternion orientation = Quaternion(), Vector3Df scaling = Vector3Df(), float roll = 0, float fov = 0, ColorRGB color = ColorRGB(), float hotSpot = 0, float fallOff = 0, float weight = 0, bool hide = (bool)0)
{
   impl.frame = frame;
   impl.tension = tension;
   impl.continuity = continuity;
   impl.bias = bias;
   impl.easeFrom = easeFrom;
   impl.easeTo = easeTo;
   impl.position = position.impl;
   impl.orientation = orientation.impl;
   impl.scaling = scaling.impl;
   impl.roll = roll;
   impl.fov = fov;
   impl.color = color.impl;
   impl.hotSpot = hotSpot;
   impl.fallOff = fallOff;
   impl.weight = weight;
   impl.hide = (C(bool))hide;
}



// member accessors: FrameKey::frame
// (struct::uint)

/*nstSet*/inline /*0H*/uint FrameKey::frame_Prop::operator= (/*0H*/uint v)
{
   SELF(FrameKey, frame);
   self->impl.frame = v;
   return v;
}

/*regSet*/inline FrameKey::frame_Prop & FrameKey::frame_Prop::operator= (FrameKey::frame_Prop & prop)
{
   SELF(FrameKey, frame);
   /*0H*/uint v = prop;
   self->impl.frame = v;
   return prop;
}
/*regGet*/inline FrameKey::frame_Prop::operator /*0I*/uint () const
{
   SELF(FrameKey, frame);
   return self ? ((C(FrameKey) *)&self->impl)->frame : 0;
}

// member accessors: FrameKey::tension
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::tension_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, tension);
   self->impl.tension = v;
   return v;
}

/*regSet*/inline FrameKey::tension_Prop & FrameKey::tension_Prop::operator= (FrameKey::tension_Prop & prop)
{
   SELF(FrameKey, tension);
   /*0H*/float v = prop;
   self->impl.tension = v;
   return prop;
}
/*regGet*/inline FrameKey::tension_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, tension);
   return self ? ((C(FrameKey) *)&self->impl)->tension : 0;
}

// member accessors: FrameKey::continuity
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::continuity_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, continuity);
   self->impl.continuity = v;
   return v;
}

/*regSet*/inline FrameKey::continuity_Prop & FrameKey::continuity_Prop::operator= (FrameKey::continuity_Prop & prop)
{
   SELF(FrameKey, continuity);
   /*0H*/float v = prop;
   self->impl.continuity = v;
   return prop;
}
/*regGet*/inline FrameKey::continuity_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, continuity);
   return self ? ((C(FrameKey) *)&self->impl)->continuity : 0;
}

// member accessors: FrameKey::bias
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::bias_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, bias);
   self->impl.bias = v;
   return v;
}

/*regSet*/inline FrameKey::bias_Prop & FrameKey::bias_Prop::operator= (FrameKey::bias_Prop & prop)
{
   SELF(FrameKey, bias);
   /*0H*/float v = prop;
   self->impl.bias = v;
   return prop;
}
/*regGet*/inline FrameKey::bias_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, bias);
   return self ? ((C(FrameKey) *)&self->impl)->bias : 0;
}

// member accessors: FrameKey::easeFrom
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::easeFrom_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, easeFrom);
   self->impl.easeFrom = v;
   return v;
}

/*regSet*/inline FrameKey::easeFrom_Prop & FrameKey::easeFrom_Prop::operator= (FrameKey::easeFrom_Prop & prop)
{
   SELF(FrameKey, easeFrom);
   /*0H*/float v = prop;
   self->impl.easeFrom = v;
   return prop;
}
/*regGet*/inline FrameKey::easeFrom_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, easeFrom);
   return self ? ((C(FrameKey) *)&self->impl)->easeFrom : 0;
}

// member accessors: FrameKey::easeTo
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::easeTo_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, easeTo);
   self->impl.easeTo = v;
   return v;
}

/*regSet*/inline FrameKey::easeTo_Prop & FrameKey::easeTo_Prop::operator= (FrameKey::easeTo_Prop & prop)
{
   SELF(FrameKey, easeTo);
   /*0H*/float v = prop;
   self->impl.easeTo = v;
   return prop;
}
/*regGet*/inline FrameKey::easeTo_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, easeTo);
   return self ? ((C(FrameKey) *)&self->impl)->easeTo : 0;
}

// member accessors: FrameKey::position
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3Df FrameKey::position_Prop::operator= (/*0H*/Vector3Df v)
{
   SELF(FrameKey, position);
   self->impl.position = v.impl;
   return v;
}

/*regSet*/inline FrameKey::position_Prop & FrameKey::position_Prop::operator= (FrameKey::position_Prop & prop)
{
   SELF(FrameKey, position);
   /*0H*/Vector3Df v = prop;
   self->impl.position = v.impl;
   return prop;
}
/*regGet*/inline FrameKey::position_Prop::operator /*0I*/Vector3Df () const
{
   SELF(FrameKey, position);
   Vector3Df value(((C(FrameKey) *)&self->impl)->position);
   return value;
}

// member accessors: FrameKey::orientation
// (struct::struct)

/*nstSet*/inline /*0H*/Quaternion FrameKey::orientation_Prop::operator= (/*0H*/Quaternion v)
{
   SELF(FrameKey, orientation);
   self->impl.orientation = v.impl;
   return v;
}

/*regSet*/inline FrameKey::orientation_Prop & FrameKey::orientation_Prop::operator= (FrameKey::orientation_Prop & prop)
{
   SELF(FrameKey, orientation);
   /*0H*/Quaternion v = prop;
   self->impl.orientation = v.impl;
   return prop;
}
/*regGet*/inline FrameKey::orientation_Prop::operator /*0I*/Quaternion () const
{
   SELF(FrameKey, orientation);
   Quaternion value(((C(FrameKey) *)&self->impl)->orientation);
   return value;
}

// member accessors: FrameKey::scaling
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3Df FrameKey::scaling_Prop::operator= (/*0H*/Vector3Df v)
{
   SELF(FrameKey, scaling);
   self->impl.scaling = v.impl;
   return v;
}

/*regSet*/inline FrameKey::scaling_Prop & FrameKey::scaling_Prop::operator= (FrameKey::scaling_Prop & prop)
{
   SELF(FrameKey, scaling);
   /*0H*/Vector3Df v = prop;
   self->impl.scaling = v.impl;
   return prop;
}
/*regGet*/inline FrameKey::scaling_Prop::operator /*0I*/Vector3Df () const
{
   SELF(FrameKey, scaling);
   Vector3Df value(((C(FrameKey) *)&self->impl)->scaling);
   return value;
}

// member accessors: FrameKey::roll
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::roll_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, roll);
   self->impl.roll = v;
   return v;
}

/*regSet*/inline FrameKey::roll_Prop & FrameKey::roll_Prop::operator= (FrameKey::roll_Prop & prop)
{
   SELF(FrameKey, roll);
   /*0H*/float v = prop;
   self->impl.roll = v;
   return prop;
}
/*regGet*/inline FrameKey::roll_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, roll);
   return self ? ((C(FrameKey) *)&self->impl)->roll : 0;
}

// member accessors: FrameKey::fov
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::fov_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, fov);
   self->impl.fov = v;
   return v;
}

/*regSet*/inline FrameKey::fov_Prop & FrameKey::fov_Prop::operator= (FrameKey::fov_Prop & prop)
{
   SELF(FrameKey, fov);
   /*0H*/float v = prop;
   self->impl.fov = v;
   return prop;
}
/*regGet*/inline FrameKey::fov_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, fov);
   return self ? ((C(FrameKey) *)&self->impl)->fov : 0;
}

// member accessors: FrameKey::color
// (struct::struct)

/*nstSet*/inline /*0H*/ColorRGB FrameKey::color_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(FrameKey, color);
   self->impl.color = v.impl;
   return v;
}

/*regSet*/inline FrameKey::color_Prop & FrameKey::color_Prop::operator= (FrameKey::color_Prop & prop)
{
   SELF(FrameKey, color);
   /*0H*/ColorRGB v = prop;
   self->impl.color = v.impl;
   return prop;
}
/*regGet*/inline FrameKey::color_Prop::operator /*0I*/ColorRGB () const
{
   SELF(FrameKey, color);
   ColorRGB value(((C(FrameKey) *)&self->impl)->color);
   return value;
}

// member accessors: FrameKey::hotSpot
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::hotSpot_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, hotSpot);
   self->impl.hotSpot = v;
   return v;
}

/*regSet*/inline FrameKey::hotSpot_Prop & FrameKey::hotSpot_Prop::operator= (FrameKey::hotSpot_Prop & prop)
{
   SELF(FrameKey, hotSpot);
   /*0H*/float v = prop;
   self->impl.hotSpot = v;
   return prop;
}
/*regGet*/inline FrameKey::hotSpot_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, hotSpot);
   return self ? ((C(FrameKey) *)&self->impl)->hotSpot : 0;
}

// member accessors: FrameKey::fallOff
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::fallOff_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, fallOff);
   self->impl.fallOff = v;
   return v;
}

/*regSet*/inline FrameKey::fallOff_Prop & FrameKey::fallOff_Prop::operator= (FrameKey::fallOff_Prop & prop)
{
   SELF(FrameKey, fallOff);
   /*0H*/float v = prop;
   self->impl.fallOff = v;
   return prop;
}
/*regGet*/inline FrameKey::fallOff_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, fallOff);
   return self ? ((C(FrameKey) *)&self->impl)->fallOff : 0;
}

// member accessors: FrameKey::weight
// (struct::float)

/*nstSet*/inline /*0H*/float FrameKey::weight_Prop::operator= (/*0H*/float v)
{
   SELF(FrameKey, weight);
   self->impl.weight = v;
   return v;
}

/*regSet*/inline FrameKey::weight_Prop & FrameKey::weight_Prop::operator= (FrameKey::weight_Prop & prop)
{
   SELF(FrameKey, weight);
   /*0H*/float v = prop;
   self->impl.weight = v;
   return prop;
}
/*regGet*/inline FrameKey::weight_Prop::operator /*0I*/float () const
{
   SELF(FrameKey, weight);
   return self ? ((C(FrameKey) *)&self->impl)->weight : 0;
}

// member accessors: FrameKey::hide
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool FrameKey::hide_Prop::operator= (/*0H*/bool v)
{
   SELF(FrameKey, hide);
   self->impl.hide = (C(bool))v;
   return v;
}

/*regSet*/inline FrameKey::hide_Prop & FrameKey::hide_Prop::operator= (FrameKey::hide_Prop & prop)
{
   SELF(FrameKey, hide);
   /*0H*/bool v = prop;
   self->impl.hide = (C(bool))v;
   return prop;
}
/*regGet*/inline FrameKey::hide_Prop::operator /*0I*/bool () const
{
   SELF(FrameKey, hide);
   return self ? (bool)((C(FrameKey) *)&self->impl)->hide : (bool)0;
}



// member accessors: FrameTrack::type
// (nohead::bits|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/FrameTrackBits TFrameTrack<TC, TCO>::type_Prop::operator= (/*0H*/FrameTrackBits v)
{
   SELF(FrameTrack, type);
   ((C(FrameTrack) *)self->impl)->type = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TFrameTrack<TC, TCO>::type_Prop & TFrameTrack<TC, TCO>::type_Prop::operator= (typename TFrameTrack<TC, TCO>::type_Prop & prop)
{
   SELF(FrameTrack, type);
   /*0H*/FrameTrackBits v = prop;
   ((C(FrameTrack) *)self->impl)->type = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TFrameTrack<TC, TCO>::type_Prop::operator /*0I*/FrameTrackBits () const
{
   __attribute__((unused)) TFrameTrack TCTCO * self = CONTAINER_OF(this, TFrameTrack TCTCO, type);
   return self ? ((C(FrameTrack) *)self->impl)->type : FrameTrackBits();
}

// member accessors: FrameTrack::numKeys
// (nohead::uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint TFrameTrack<TC, TCO>::numKeys_Prop::operator= (/*0H*/uint v)
{
   SELF(FrameTrack, numKeys);
   ((C(FrameTrack) *)self->impl)->numKeys = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TFrameTrack<TC, TCO>::numKeys_Prop & TFrameTrack<TC, TCO>::numKeys_Prop::operator= (typename TFrameTrack<TC, TCO>::numKeys_Prop & prop)
{
   SELF(FrameTrack, numKeys);
   /*0H*/uint v = prop;
   ((C(FrameTrack) *)self->impl)->numKeys = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TFrameTrack<TC, TCO>::numKeys_Prop::operator /*0I*/uint () const
{
   __attribute__((unused)) TFrameTrack TCTCO * self = CONTAINER_OF(this, TFrameTrack TCTCO, numKeys);
   return self ? ((C(FrameTrack) *)self->impl)->numKeys : 0;
}

// member accessors: FrameTrack::morphIndex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TFrameTrack<TC, TCO>::morphIndex_Prop::operator= (/*0H*/int v)
{
   SELF(FrameTrack, morphIndex);
   ((C(FrameTrack) *)self->impl)->morphIndex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TFrameTrack<TC, TCO>::morphIndex_Prop & TFrameTrack<TC, TCO>::morphIndex_Prop::operator= (typename TFrameTrack<TC, TCO>::morphIndex_Prop & prop)
{
   SELF(FrameTrack, morphIndex);
   /*0H*/int v = prop;
   ((C(FrameTrack) *)self->impl)->morphIndex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TFrameTrack<TC, TCO>::morphIndex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TFrameTrack TCTCO * self = CONTAINER_OF(this, TFrameTrack TCTCO, morphIndex);
   return self ? ((C(FrameTrack) *)self->impl)->morphIndex : 0;
}



// member accessors: FrameTrackBits::type
// (bits::enum|uint16)

/*nstSet*/inline /*0H*/FrameTrackType FrameTrackBits::type_Prop::operator= (/*0H*/FrameTrackType v)
{
   SELF(FrameTrackBits, type);
   FRAMETRACKBITS_SET_type(self->impl, v);
   return v;
}

/*regSet*/inline FrameTrackBits::type_Prop & FrameTrackBits::type_Prop::operator= (FrameTrackBits::type_Prop & prop)
{
   SELF(FrameTrackBits, type);
   /*0H*/FrameTrackType v = prop;
   FRAMETRACKBITS_SET_type(self->impl, v);
   return prop;
}
/*regGet*/inline FrameTrackBits::type_Prop::operator /*0I*/FrameTrackType () const
{
   SELF(FrameTrackBits, type);
   return (FrameTrackType)FRAMETRACKBITS_type(self->impl);
}

// member accessors: FrameTrackBits::loop
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FrameTrackBits::loop_Prop::operator= (/*0H*/bool v)
{
   SELF(FrameTrackBits, loop);
   FRAMETRACKBITS_SET_loop(self->impl, v);
   return v;
}

/*regSet*/inline FrameTrackBits::loop_Prop & FrameTrackBits::loop_Prop::operator= (FrameTrackBits::loop_Prop & prop)
{
   SELF(FrameTrackBits, loop);
   /*0H*/bool v = prop;
   FRAMETRACKBITS_SET_loop(self->impl, v);
   return prop;
}
/*regGet*/inline FrameTrackBits::loop_Prop::operator /*0I*/bool () const
{
   SELF(FrameTrackBits, loop);
   return (bool)FRAMETRACKBITS_loop(self->impl);
}

// member accessors: FrameTrackBits::rotationOrder
// (bits::enum|int)

/*nstSet*/inline /*0H*/EulerRotationOrder FrameTrackBits::rotationOrder_Prop::operator= (/*0H*/EulerRotationOrder v)
{
   SELF(FrameTrackBits, rotationOrder);
   FRAMETRACKBITS_SET_rotationOrder(self->impl, v);
   return v;
}

/*regSet*/inline FrameTrackBits::rotationOrder_Prop & FrameTrackBits::rotationOrder_Prop::operator= (FrameTrackBits::rotationOrder_Prop & prop)
{
   SELF(FrameTrackBits, rotationOrder);
   /*0H*/EulerRotationOrder v = prop;
   FRAMETRACKBITS_SET_rotationOrder(self->impl, v);
   return prop;
}
/*regGet*/inline FrameTrackBits::rotationOrder_Prop::operator /*0I*/EulerRotationOrder () const
{
   SELF(FrameTrackBits, rotationOrder);
   return (EulerRotationOrder)FRAMETRACKBITS_rotationOrder(self->impl);
}

inline Line::Line(Vector3D p0, Vector3D delta = Vector3D())
{
   impl.p0 = p0.impl;
   impl.delta = delta.impl;
}


inline C(bool) Line::intersectSphere(/*1Ab*/double radius, /*1Ab*/double * t)
{
   return Line_intersectSphere(&impl, /*5Ge*/radius, /*5Ge*/t);
}


// member accessors: Line::p0
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3D Line::p0_Prop::operator= (/*0H*/Vector3D v)
{
   SELF(Line, p0);
   self->impl.p0 = v.impl;
   return v;
}

/*regSet*/inline Line::p0_Prop & Line::p0_Prop::operator= (Line::p0_Prop & prop)
{
   SELF(Line, p0);
   /*0H*/Vector3D v = prop;
   self->impl.p0 = v.impl;
   return prop;
}
/*regGet*/inline Line::p0_Prop::operator /*0I*/Vector3D () const
{
   SELF(Line, p0);
   Vector3D value(((C(Line) *)&self->impl)->p0);
   return value;
}

// member accessors: Line::delta
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3D Line::delta_Prop::operator= (/*0H*/Vector3D v)
{
   SELF(Line, delta);
   self->impl.delta = v.impl;
   return v;
}

/*regSet*/inline Line::delta_Prop & Line::delta_Prop::operator= (Line::delta_Prop & prop)
{
   SELF(Line, delta);
   /*0H*/Vector3D v = prop;
   self->impl.delta = v.impl;
   return prop;
}
/*regGet*/inline Line::delta_Prop::operator /*0I*/Vector3D () const
{
   SELF(Line, delta);
   Vector3D value(((C(Line) *)&self->impl)->delta);
   return value;
}


template <class TC, C(Class) ** TCO> inline void TMaterial<TC, TCO>::free()
{
   Material_free((C(Material)*)this->impl);
}


// property callers: Material::shader
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const Shader & TMaterial<TC, TCO>::shader_Prop::operator= (/*0A*/const Shader & v)
{
   SELF(Material, shader);
   Material_set_shader(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::shader_Prop & TMaterial<TC, TCO>::shader_Prop::operator= (typename TMaterial<TC, TCO>::shader_Prop & prop)
{
   SELF(Material, shader);
   /*0A*/const Shader & v = prop;
   Material_set_shader(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const Shader * TMaterial<TC, TCO>::shader_Prop::operator= (/*0C*/const Shader * v)
{
   SELF(Material, shader);
   Material_set_shader(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::shader_Prop::operator /*0B*/TIH<Shader> () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, shader);
   C(Instance) i = Material_get_shader(self ? self->impl : null);
   TIH<Shader> cppi(i);
   return *cppi;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TIH<Shader> TMaterial<TC, TCO>::shader_Prop::operator /*0D*/-> () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, shader);
   C(Instance) i = Material_get_shader(self ? self->impl : null);
   TIH<Shader> holder(i);
   return holder;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::shader_Prop::operator /*0E*/Shader () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, shader);
   C(Instance) i = Material_get_shader(self ? self->impl : null);
   return Shader(i);
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::shader_Prop::operator /*0F*/Shader* () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, shader);
   C(Instance) i = Material_get_shader(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Shader *)INSTANCEL(i, i->_class) : (Shader *)0;
}


// member accessors: Material::prev
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Material TMaterial<TC, TCO>::prev_Prop::operator= (/*0H*/Material & v)
{
   SELF(Material, prev);
   ((C(Material) *)self->impl)->prev = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::prev_Prop & TMaterial<TC, TCO>::prev_Prop::operator= (typename TMaterial<TC, TCO>::prev_Prop & prop)
{
   SELF(Material, prev);
   /*0H*/Material v = prop;
   ((C(Material) *)self->impl)->prev = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::prev_Prop::operator /*0I*/Material () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, prev);
   Material value(((C(Material) *)self->impl)->prev);
   return value;
}

// member accessors: Material::next
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Material TMaterial<TC, TCO>::next_Prop::operator= (/*0H*/Material & v)
{
   SELF(Material, next);
   ((C(Material) *)self->impl)->next = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::next_Prop & TMaterial<TC, TCO>::next_Prop::operator= (typename TMaterial<TC, TCO>::next_Prop & prop)
{
   SELF(Material, next);
   /*0H*/Material v = prop;
   ((C(Material) *)self->impl)->next = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::next_Prop::operator /*0I*/Material () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, next);
   Material value(((C(Material) *)self->impl)->next);
   return value;
}

// member accessors: Material::name
// (nohead::char *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/char * TMaterial<TC, TCO>::name_Prop::operator= (/*0H*/char * v)
{
   SELF(Material, name);
   ((C(Material) *)self->impl)->name = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::name_Prop & TMaterial<TC, TCO>::name_Prop::operator= (typename TMaterial<TC, TCO>::name_Prop & prop)
{
   SELF(Material, name);
   /*0H*/char * v = prop;
   ((C(Material) *)self->impl)->name = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::name_Prop::operator /*0I*/char * () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, name);
   return self ? ((C(Material) *)self->impl)->name : null;
}

// member accessors: Material::opacity
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/float TMaterial<TC, TCO>::opacity_Prop::operator= (/*0H*/float v)
{
   SELF(Material, opacity);
   ((C(Material) *)self->impl)->opacity = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::opacity_Prop & TMaterial<TC, TCO>::opacity_Prop::operator= (typename TMaterial<TC, TCO>::opacity_Prop & prop)
{
   SELF(Material, opacity);
   /*0H*/float v = prop;
   ((C(Material) *)self->impl)->opacity = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::opacity_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, opacity);
   return self ? ((C(Material) *)self->impl)->opacity : 0;
}

// member accessors: Material::diffuse
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/ColorRGB TMaterial<TC, TCO>::diffuse_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(Material, diffuse);
   ((C(Material) *)self->impl)->diffuse = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::diffuse_Prop & TMaterial<TC, TCO>::diffuse_Prop::operator= (typename TMaterial<TC, TCO>::diffuse_Prop & prop)
{
   SELF(Material, diffuse);
   /*0H*/ColorRGB v = prop;
   ((C(Material) *)self->impl)->diffuse = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::diffuse_Prop::operator /*0I*/ColorRGB () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, diffuse);
   ColorRGB value(((C(Material) *)self->impl)->diffuse);
   return value;
}

// member accessors: Material::ambient
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/ColorRGB TMaterial<TC, TCO>::ambient_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(Material, ambient);
   ((C(Material) *)self->impl)->ambient = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::ambient_Prop & TMaterial<TC, TCO>::ambient_Prop::operator= (typename TMaterial<TC, TCO>::ambient_Prop & prop)
{
   SELF(Material, ambient);
   /*0H*/ColorRGB v = prop;
   ((C(Material) *)self->impl)->ambient = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::ambient_Prop::operator /*0I*/ColorRGB () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, ambient);
   ColorRGB value(((C(Material) *)self->impl)->ambient);
   return value;
}

// member accessors: Material::specular
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/ColorRGB TMaterial<TC, TCO>::specular_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(Material, specular);
   ((C(Material) *)self->impl)->specular = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::specular_Prop & TMaterial<TC, TCO>::specular_Prop::operator= (typename TMaterial<TC, TCO>::specular_Prop & prop)
{
   SELF(Material, specular);
   /*0H*/ColorRGB v = prop;
   ((C(Material) *)self->impl)->specular = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::specular_Prop::operator /*0I*/ColorRGB () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, specular);
   ColorRGB value(((C(Material) *)self->impl)->specular);
   return value;
}

// member accessors: Material::emissive
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/ColorRGB TMaterial<TC, TCO>::emissive_Prop::operator= (/*0H*/ColorRGB v)
{
   SELF(Material, emissive);
   ((C(Material) *)self->impl)->emissive = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::emissive_Prop & TMaterial<TC, TCO>::emissive_Prop::operator= (typename TMaterial<TC, TCO>::emissive_Prop & prop)
{
   SELF(Material, emissive);
   /*0H*/ColorRGB v = prop;
   ((C(Material) *)self->impl)->emissive = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::emissive_Prop::operator /*0I*/ColorRGB () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, emissive);
   ColorRGB value(((C(Material) *)self->impl)->emissive);
   return value;
}

// member accessors: Material::power
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/float TMaterial<TC, TCO>::power_Prop::operator= (/*0H*/float v)
{
   SELF(Material, power);
   ((C(Material) *)self->impl)->power = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::power_Prop & TMaterial<TC, TCO>::power_Prop::operator= (typename TMaterial<TC, TCO>::power_Prop & prop)
{
   SELF(Material, power);
   /*0H*/float v = prop;
   ((C(Material) *)self->impl)->power = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::power_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, power);
   return self ? ((C(Material) *)self->impl)->power : 0;
}

// member accessors: Material::baseMap
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Bitmap TMaterial<TC, TCO>::baseMap_Prop::operator= (/*0H*/Bitmap v)
{
   SELF(Material, baseMap);
   ((C(Material) *)self->impl)->baseMap = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::baseMap_Prop & TMaterial<TC, TCO>::baseMap_Prop::operator= (typename TMaterial<TC, TCO>::baseMap_Prop & prop)
{
   SELF(Material, baseMap);
   /*0H*/Bitmap v = prop;
   ((C(Material) *)self->impl)->baseMap = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::baseMap_Prop::operator /*0I*/Bitmap () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, baseMap);
   Bitmap value(((C(Material) *)self->impl)->baseMap);
   return value;
}

// member accessors: Material::bumpMap
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Bitmap TMaterial<TC, TCO>::bumpMap_Prop::operator= (/*0H*/Bitmap v)
{
   SELF(Material, bumpMap);
   ((C(Material) *)self->impl)->bumpMap = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::bumpMap_Prop & TMaterial<TC, TCO>::bumpMap_Prop::operator= (typename TMaterial<TC, TCO>::bumpMap_Prop & prop)
{
   SELF(Material, bumpMap);
   /*0H*/Bitmap v = prop;
   ((C(Material) *)self->impl)->bumpMap = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::bumpMap_Prop::operator /*0I*/Bitmap () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, bumpMap);
   Bitmap value(((C(Material) *)self->impl)->bumpMap);
   return value;
}

// member accessors: Material::specularMap
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Bitmap TMaterial<TC, TCO>::specularMap_Prop::operator= (/*0H*/Bitmap v)
{
   SELF(Material, specularMap);
   ((C(Material) *)self->impl)->specularMap = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::specularMap_Prop & TMaterial<TC, TCO>::specularMap_Prop::operator= (typename TMaterial<TC, TCO>::specularMap_Prop & prop)
{
   SELF(Material, specularMap);
   /*0H*/Bitmap v = prop;
   ((C(Material) *)self->impl)->specularMap = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::specularMap_Prop::operator /*0I*/Bitmap () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, specularMap);
   Bitmap value(((C(Material) *)self->impl)->specularMap);
   return value;
}

// member accessors: Material::reflectMap
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Bitmap TMaterial<TC, TCO>::reflectMap_Prop::operator= (/*0H*/Bitmap v)
{
   SELF(Material, reflectMap);
   ((C(Material) *)self->impl)->reflectMap = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::reflectMap_Prop & TMaterial<TC, TCO>::reflectMap_Prop::operator= (typename TMaterial<TC, TCO>::reflectMap_Prop & prop)
{
   SELF(Material, reflectMap);
   /*0H*/Bitmap v = prop;
   ((C(Material) *)self->impl)->reflectMap = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::reflectMap_Prop::operator /*0I*/Bitmap () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, reflectMap);
   Bitmap value(((C(Material) *)self->impl)->reflectMap);
   return value;
}

// member accessors: Material::envMap
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/CubeMap TMaterial<TC, TCO>::envMap_Prop::operator= (/*0H*/CubeMap v)
{
   SELF(Material, envMap);
   ((C(Material) *)self->impl)->envMap = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::envMap_Prop & TMaterial<TC, TCO>::envMap_Prop::operator= (typename TMaterial<TC, TCO>::envMap_Prop & prop)
{
   SELF(Material, envMap);
   /*0H*/CubeMap v = prop;
   ((C(Material) *)self->impl)->envMap = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::envMap_Prop::operator /*0I*/CubeMap () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, envMap);
   CubeMap value(((C(Material) *)self->impl)->envMap);
   return value;
}

// member accessors: Material::reflectivity
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/float TMaterial<TC, TCO>::reflectivity_Prop::operator= (/*0H*/float v)
{
   SELF(Material, reflectivity);
   ((C(Material) *)self->impl)->reflectivity = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::reflectivity_Prop & TMaterial<TC, TCO>::reflectivity_Prop::operator= (typename TMaterial<TC, TCO>::reflectivity_Prop & prop)
{
   SELF(Material, reflectivity);
   /*0H*/float v = prop;
   ((C(Material) *)self->impl)->reflectivity = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::reflectivity_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, reflectivity);
   return self ? ((C(Material) *)self->impl)->reflectivity : 0;
}

// member accessors: Material::refractiveIndex
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/float TMaterial<TC, TCO>::refractiveIndex_Prop::operator= (/*0H*/float v)
{
   SELF(Material, refractiveIndex);
   ((C(Material) *)self->impl)->refractiveIndex = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::refractiveIndex_Prop & TMaterial<TC, TCO>::refractiveIndex_Prop::operator= (typename TMaterial<TC, TCO>::refractiveIndex_Prop & prop)
{
   SELF(Material, refractiveIndex);
   /*0H*/float v = prop;
   ((C(Material) *)self->impl)->refractiveIndex = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::refractiveIndex_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, refractiveIndex);
   return self ? ((C(Material) *)self->impl)->refractiveIndex : 0;
}

// member accessors: Material::refractiveIndexContainer
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/float TMaterial<TC, TCO>::refractiveIndexContainer_Prop::operator= (/*0H*/float v)
{
   SELF(Material, refractiveIndexContainer);
   ((C(Material) *)self->impl)->refractiveIndexContainer = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::refractiveIndexContainer_Prop & TMaterial<TC, TCO>::refractiveIndexContainer_Prop::operator= (typename TMaterial<TC, TCO>::refractiveIndexContainer_Prop & prop)
{
   SELF(Material, refractiveIndexContainer);
   /*0H*/float v = prop;
   ((C(Material) *)self->impl)->refractiveIndexContainer = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::refractiveIndexContainer_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, refractiveIndexContainer);
   return self ? ((C(Material) *)self->impl)->refractiveIndexContainer : 0;
}

// member accessors: Material::flags
// (nohead::bits|unsigned int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/MaterialFlags TMaterial<TC, TCO>::flags_Prop::operator= (/*0H*/MaterialFlags v)
{
   SELF(Material, flags);
   ((C(Material) *)self->impl)->flags = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::flags_Prop & TMaterial<TC, TCO>::flags_Prop::operator= (typename TMaterial<TC, TCO>::flags_Prop & prop)
{
   SELF(Material, flags);
   /*0H*/MaterialFlags v = prop;
   ((C(Material) *)self->impl)->flags = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::flags_Prop::operator /*0I*/MaterialFlags () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, flags);
   return self ? ((C(Material) *)self->impl)->flags : MaterialFlags();
}

// member accessors: Material::uScale
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/float TMaterial<TC, TCO>::uScale_Prop::operator= (/*0H*/float v)
{
   SELF(Material, uScale);
   ((C(Material) *)self->impl)->uScale = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::uScale_Prop & TMaterial<TC, TCO>::uScale_Prop::operator= (typename TMaterial<TC, TCO>::uScale_Prop & prop)
{
   SELF(Material, uScale);
   /*0H*/float v = prop;
   ((C(Material) *)self->impl)->uScale = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::uScale_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, uScale);
   return self ? ((C(Material) *)self->impl)->uScale : 0;
}

// member accessors: Material::vScale
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/float TMaterial<TC, TCO>::vScale_Prop::operator= (/*0H*/float v)
{
   SELF(Material, vScale);
   ((C(Material) *)self->impl)->vScale = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMaterial<TC, TCO>::vScale_Prop & TMaterial<TC, TCO>::vScale_Prop::operator= (typename TMaterial<TC, TCO>::vScale_Prop & prop)
{
   SELF(Material, vScale);
   /*0H*/float v = prop;
   ((C(Material) *)self->impl)->vScale = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMaterial<TC, TCO>::vScale_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TMaterial TCTCO * self = CONTAINER_OF(this, TMaterial TCTCO, vScale);
   return self ? ((C(Material) *)self->impl)->vScale : 0;
}



// member accessors: MaterialFlags::doubleSided
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::doubleSided_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, doubleSided);
   MATERIALFLAGS_SET_doubleSided(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::doubleSided_Prop & MaterialFlags::doubleSided_Prop::operator= (MaterialFlags::doubleSided_Prop & prop)
{
   SELF(MaterialFlags, doubleSided);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_doubleSided(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::doubleSided_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, doubleSided);
   return (bool)MATERIALFLAGS_doubleSided(self->impl);
}

// member accessors: MaterialFlags::translucent
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::translucent_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, translucent);
   MATERIALFLAGS_SET_translucent(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::translucent_Prop & MaterialFlags::translucent_Prop::operator= (MaterialFlags::translucent_Prop & prop)
{
   SELF(MaterialFlags, translucent);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_translucent(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::translucent_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, translucent);
   return (bool)MATERIALFLAGS_translucent(self->impl);
}

// member accessors: MaterialFlags::tile
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::tile_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, tile);
   MATERIALFLAGS_SET_tile(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::tile_Prop & MaterialFlags::tile_Prop::operator= (MaterialFlags::tile_Prop & prop)
{
   SELF(MaterialFlags, tile);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_tile(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::tile_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, tile);
   return (bool)MATERIALFLAGS_tile(self->impl);
}

// member accessors: MaterialFlags::noFog
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::noFog_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, noFog);
   MATERIALFLAGS_SET_noFog(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::noFog_Prop & MaterialFlags::noFog_Prop::operator= (MaterialFlags::noFog_Prop & prop)
{
   SELF(MaterialFlags, noFog);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_noFog(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::noFog_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, noFog);
   return (bool)MATERIALFLAGS_noFog(self->impl);
}

// member accessors: MaterialFlags::singleSideLight
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::singleSideLight_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, singleSideLight);
   MATERIALFLAGS_SET_singleSideLight(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::singleSideLight_Prop & MaterialFlags::singleSideLight_Prop::operator= (MaterialFlags::singleSideLight_Prop & prop)
{
   SELF(MaterialFlags, singleSideLight);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_singleSideLight(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::singleSideLight_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, singleSideLight);
   return (bool)MATERIALFLAGS_singleSideLight(self->impl);
}

// member accessors: MaterialFlags::separateSpecular
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::separateSpecular_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, separateSpecular);
   MATERIALFLAGS_SET_separateSpecular(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::separateSpecular_Prop & MaterialFlags::separateSpecular_Prop::operator= (MaterialFlags::separateSpecular_Prop & prop)
{
   SELF(MaterialFlags, separateSpecular);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_separateSpecular(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::separateSpecular_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, separateSpecular);
   return (bool)MATERIALFLAGS_separateSpecular(self->impl);
}

// member accessors: MaterialFlags::cubeMap
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::cubeMap_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, cubeMap);
   MATERIALFLAGS_SET_cubeMap(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::cubeMap_Prop & MaterialFlags::cubeMap_Prop::operator= (MaterialFlags::cubeMap_Prop & prop)
{
   SELF(MaterialFlags, cubeMap);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_cubeMap(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::cubeMap_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, cubeMap);
   return (bool)MATERIALFLAGS_cubeMap(self->impl);
}

// member accessors: MaterialFlags::noLighting
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::noLighting_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, noLighting);
   MATERIALFLAGS_SET_noLighting(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::noLighting_Prop & MaterialFlags::noLighting_Prop::operator= (MaterialFlags::noLighting_Prop & prop)
{
   SELF(MaterialFlags, noLighting);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_noLighting(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::noLighting_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, noLighting);
   return (bool)MATERIALFLAGS_noLighting(self->impl);
}

// member accessors: MaterialFlags::partlyTransparent
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::partlyTransparent_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, partlyTransparent);
   MATERIALFLAGS_SET_partlyTransparent(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::partlyTransparent_Prop & MaterialFlags::partlyTransparent_Prop::operator= (MaterialFlags::partlyTransparent_Prop & prop)
{
   SELF(MaterialFlags, partlyTransparent);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_partlyTransparent(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::partlyTransparent_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, partlyTransparent);
   return (bool)MATERIALFLAGS_partlyTransparent(self->impl);
}

// member accessors: MaterialFlags::setupTextures
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::setupTextures_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, setupTextures);
   MATERIALFLAGS_SET_setupTextures(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::setupTextures_Prop & MaterialFlags::setupTextures_Prop::operator= (MaterialFlags::setupTextures_Prop & prop)
{
   SELF(MaterialFlags, setupTextures);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_setupTextures(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::setupTextures_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, setupTextures);
   return (bool)MATERIALFLAGS_setupTextures(self->impl);
}

// member accessors: MaterialFlags::update
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::update_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, update);
   MATERIALFLAGS_SET_update(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::update_Prop & MaterialFlags::update_Prop::operator= (MaterialFlags::update_Prop & prop)
{
   SELF(MaterialFlags, update);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_update(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::update_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, update);
   return (bool)MATERIALFLAGS_update(self->impl);
}

// member accessors: MaterialFlags::constantColor
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MaterialFlags::constantColor_Prop::operator= (/*0H*/bool v)
{
   SELF(MaterialFlags, constantColor);
   MATERIALFLAGS_SET_constantColor(self->impl, v);
   return v;
}

/*regSet*/inline MaterialFlags::constantColor_Prop & MaterialFlags::constantColor_Prop::operator= (MaterialFlags::constantColor_Prop & prop)
{
   SELF(MaterialFlags, constantColor);
   /*0H*/bool v = prop;
   MATERIALFLAGS_SET_constantColor(self->impl, v);
   return prop;
}
/*regGet*/inline MaterialFlags::constantColor_Prop::operator /*0I*/bool () const
{
   SELF(MaterialFlags, constantColor);
   return (bool)MATERIALFLAGS_constantColor(self->impl);
}
// A (struct:struct)
inline Matrix::operator Quaternion() const { Quaternion q; Matrix_to_Quaternion(&impl, &q.impl); return q; }
inline Matrix::Matrix(const Quaternion & q) { Matrix_from_Quaternion(&impl, &q.impl); }
inline Matrix & Matrix::operator =(const Quaternion & q) { Matrix_from_Quaternion(&impl, &q.impl); return *this; }


inline double Matrix::determinant()
{
   return Matrix_determinant(&impl);
}
inline void Matrix::identity()
{
   Matrix_identity(&impl);
}
inline void Matrix::inverse(/*1Ab*/const Matrix & source)
{
   Matrix_inverse(&impl, /*5De*/&source.impl);
}
inline void Matrix::inverse(/*1Ac*/const Matrix * source)
{
   Matrix_inverse(&impl, /*5Cf*/(C(Matrix) *)source);
}
inline void Matrix::inverseTransposeTransform(/*1Ab*/const Matrix & source)
{
   Matrix_inverseTransposeTransform(&impl, /*5De*/&source.impl);
}
inline void Matrix::inverseTransposeTransform(/*1Ac*/const Matrix * source)
{
   Matrix_inverseTransposeTransform(&impl, /*5Cf*/(C(Matrix) *)source);
}
inline void Matrix::multiply(/*1Ab*/const Matrix & a, /*1Ab*/const Matrix & b)
{
   Matrix_multiply(&impl, /*5De*/&a.impl, /*5De*/&b.impl);
}
inline void Matrix::multiply(/*1Ac*/const Matrix * a, /*1Ac*/const Matrix * b)
{
   Matrix_multiply(&impl, /*5Cf*/(C(Matrix) *)a, /*5Cf*/(C(Matrix) *)b);
}
inline void Matrix::multiply3x4(/*1Ab*/const Matrix & a, /*1Ab*/const Matrix & b)
{
   Matrix_multiply3x4(&impl, /*5De*/&a.impl, /*5De*/&b.impl);
}
inline void Matrix::multiply3x4(/*1Ac*/const Matrix * a, /*1Ac*/const Matrix * b)
{
   Matrix_multiply3x4(&impl, /*5Cf*/(C(Matrix) *)a, /*5Cf*/(C(Matrix) *)b);
}
inline void Matrix::rotate(/*1Ab*/const Quaternion & quat)
{
   Matrix_rotate(&impl, /*5De*/&quat.impl);
}
inline void Matrix::rotate(/*1Ac*/const Quaternion * quat)
{
   Matrix_rotate(&impl, /*5Cf*/(C(Quaternion) *)quat);
}
inline void Matrix::rotationQuaternion(/*1Ab*/const Quaternion & quat)
{
   Matrix_rotationQuaternion(&impl, /*5De*/&quat.impl);
}
inline void Matrix::rotationQuaternion(/*1Ac*/const Quaternion * quat)
{
   Matrix_rotationQuaternion(&impl, /*5Cf*/(C(Quaternion) *)quat);
}
inline void Matrix::scale(/*1Ab*/double sx, /*1Ab*/double sy, /*1Ab*/double sz)
{
   Matrix_scale(&impl, /*5Ge*/sx, /*5Ge*/sy, /*5Ge*/sz);
}
inline void Matrix::toEuler(/*1Ab*/Euler & euler)
{
   Matrix_toEuler(&impl, /*5De*/&euler.impl);
}
inline void Matrix::toEuler(/*1Ac*/Euler * euler)
{
   Matrix_toEuler(&impl, /*5Cf*/(C(Euler) *)euler);
}
inline void Matrix::translate(/*1Ab*/double tx, /*1Ab*/double ty, /*1Ab*/double tz)
{
   Matrix_translate(&impl, /*5Ge*/tx, /*5Ge*/ty, /*5Ge*/tz);
}
inline void Matrix::transpose(/*1Ab*/const Matrix & source)
{
   Matrix_transpose(&impl, /*5De*/&source.impl);
}
inline void Matrix::transpose(/*1Ac*/const Matrix * source)
{
   Matrix_transpose(&impl, /*5Cf*/(C(Matrix) *)source);
}
inline C(bool) Matrix::isIdentity()
{
   return Matrix_isIdentity(&impl);
}
// A (struct:struct)
inline Matrixf::operator Matrix() const { Matrix m; Matrixf_to_Matrix(&impl, &m.impl); return m; }
inline Matrixf::Matrixf(const Matrix & m) { Matrixf_from_Matrix(&impl, &m.impl); }
inline Matrixf & Matrixf::operator =(const Matrix & m) { Matrixf_from_Matrix(&impl, &m.impl); return *this; }


inline void Matrixf::identity()
{
   Matrixf_identity(&impl);
}
inline void Matrixf::fromMatrix(/*1Ab*/Matrix & m)
{
   Matrixf_fromMatrix(&impl, /*5De*/&m.impl);
}
inline void Matrixf::fromMatrix(/*1Ac*/Matrix * m)
{
   Matrixf_fromMatrix(&impl, /*5Cf*/(C(Matrix) *)m);
}


template <class TC, C(Class) ** TCO> inline C(PrimitiveGroup) * TMesh<TC, TCO>::addPrimitiveGroup(/*1Ab*/PrimitiveGroupType flags, /*1Ab*/int nIndices)
{
   return Mesh_addPrimitiveGroup((C(Mesh)*)this->impl, /*5Ee*/(C(PrimitiveGroupType))flags.impl, /*5Ge*/nIndices);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::allocate(/*1Ab*/MeshFeatures what, /*1Ab*/int nVertices, /*1Ab*/DisplaySystem & displaySystem)
{
   return Mesh_allocate((C(Mesh)*)this->impl, /*5Ee*/(C(MeshFeatures))what.impl, /*5Ge*/nVertices, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::allocatePrimitive(/*1Ab*/PrimitiveSingle & primitive, /*1Ab*/PrimitiveGroupType flags, /*1Ab*/int nIndices)
{
   return Mesh_allocatePrimitive((C(Mesh)*)this->impl, /*5De*/&primitive.impl, /*5Ee*/(C(PrimitiveGroupType))flags.impl, /*5Ge*/nIndices);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::allocatePrimitive(/*1Ac*/PrimitiveSingle * primitive, /*1Ac*/PrimitiveGroupType flags, /*1Ac*/int nIndices)
{
   return Mesh_allocatePrimitive((C(Mesh)*)this->impl, /*5Cf*/(C(PrimitiveSingle) *)primitive, /*5Ef*/(C(PrimitiveGroupType))flags.impl, /*5Gf*/nIndices);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::applyMaterial(/*1Ab*/Material material)
{
   Mesh_applyMaterial((C(Mesh)*)this->impl, /*5De*/material.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::applyMorphs(/*1Ab*/bool recomputeNormals)
{
   Mesh_applyMorphs((C(Mesh)*)this->impl, /*5Ee*/(C(bool))recomputeNormals);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::applySkin()
{
   Mesh_applySkin((C(Mesh)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::applyTranslucency(/*1Ab*/Object object)
{
   return Mesh_applyTranslucency((C(Mesh)*)this->impl, /*5De*/object.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::combineMorphs(/*1Ab*/TArray<C(bool) _ARG int _ARG C(bool)> & combined)
{
   Mesh_combineMorphs((C(Mesh)*)this->impl, /*5De*/((Instance&&)combined).impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::computeNormals()
{
   Mesh_computeNormals((C(Mesh)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::computeNormals2(/*1Ab*/bool computeNormals, /*1Ab*/bool computeTangents)
{
   Mesh_computeNormals2((C(Mesh)*)this->impl, /*5Ee*/(C(bool))computeNormals, /*5Ee*/(C(bool))computeTangents);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::computeNormals3(/*1Ab*/bool computeNormals, /*1Ab*/bool computeTangents, /*1Ab*/bool unlock)
{
   Mesh_computeNormals3((C(Mesh)*)this->impl, /*5Ee*/(C(bool))computeNormals, /*5Ee*/(C(bool))computeTangents, /*5Ee*/(C(bool))unlock);
}
template <class TC, C(Class) ** TCO> inline C(Mesh) * TMesh<TC, TCO>::copy()
{
   return Mesh_copy((C(Mesh)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline int TMesh<TC, TCO>::findClosestVertex(/*1Ab*/const Vector3D & local, /*1Ab*/Vector3Df & actual)
{
   return Mesh_findClosestVertex((C(Mesh)*)this->impl, /*5De*/&local.impl, /*5De*/&actual.impl);
}
template <class TC, C(Class) ** TCO> inline int TMesh<TC, TCO>::findClosestVertex(/*1Ac*/const Vector3D * local, /*1Ac*/Vector3Df * actual)
{
   return Mesh_findClosestVertex((C(Mesh)*)this->impl, /*5Cf*/(C(Vector3D) *)local, /*5Cf*/(C(Vector3Df) *)actual);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::free(/*1Ab*/MeshFeatures what)
{
   Mesh_free((C(Mesh)*)this->impl, /*5Ee*/(C(MeshFeatures))what.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::freeCPUVertexAttributes(/*1Ab*/MeshFeatures what)
{
   Mesh_freeCPUVertexAttributes((C(Mesh)*)this->impl, /*5Ee*/(C(MeshFeatures))what.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::freePrimitive(/*1Ab*/PrimitiveSingle & primitive)
{
   Mesh_freePrimitive((C(Mesh)*)this->impl, /*5De*/&primitive.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::freePrimitive(/*1Ac*/PrimitiveSingle * primitive)
{
   Mesh_freePrimitive((C(Mesh)*)this->impl, /*5Cf*/(C(PrimitiveSingle) *)primitive);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::freePrimitiveGroup(/*1Ab*/PrimitiveGroup group)
{
   Mesh_freePrimitiveGroup((C(Mesh)*)this->impl, /*5De*/group.impl);
}
template <class TC, C(Class) ** TCO> inline void * TMesh<TC, TCO>::getData()
{
   return Mesh_getData((C(Mesh)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::lock(/*1Ab*/MeshFeatures flags)
{
   return Mesh_lock((C(Mesh)*)this->impl, /*5Ee*/(C(MeshFeatures))flags.impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::lockPrimitive(/*1Ab*/PrimitiveSingle & primitive)
{
   return Mesh_lockPrimitive((C(Mesh)*)this->impl, /*5De*/&primitive.impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::lockPrimitive(/*1Ac*/PrimitiveSingle * primitive)
{
   return Mesh_lockPrimitive((C(Mesh)*)this->impl, /*5Cf*/(C(PrimitiveSingle) *)primitive);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::lockPrimitiveGroup(/*1Ab*/PrimitiveGroup group)
{
   return Mesh_lockPrimitiveGroup((C(Mesh)*)this->impl, /*5De*/group.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::setData(/*1Ab*/void * value)
{
   Mesh_setData((C(Mesh)*)this->impl, /*5Ge*/value);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::unapplySkin()
{
   Mesh_unapplySkin((C(Mesh)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::unapplyTranslucency(/*1Ab*/Object object)
{
   return Mesh_unapplyTranslucency((C(Mesh)*)this->impl, /*5De*/object.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::unlock(/*1Ab*/MeshFeatures flags)
{
   Mesh_unlock((C(Mesh)*)this->impl, /*5Ee*/(C(MeshFeatures))flags.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::unlockPrimitive(/*1Ab*/PrimitiveSingle & primitive)
{
   Mesh_unlockPrimitive((C(Mesh)*)this->impl, /*5De*/&primitive.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::unlockPrimitive(/*1Ac*/PrimitiveSingle * primitive)
{
   Mesh_unlockPrimitive((C(Mesh)*)this->impl, /*5Cf*/(C(PrimitiveSingle) *)primitive);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::unlockPrimitiveGroup(/*1Ab*/PrimitiveGroup group)
{
   Mesh_unlockPrimitiveGroup((C(Mesh)*)this->impl, /*5De*/group.impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TMesh<TC, TCO>::upload(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/bool uploadTextures, /*1Ab*/GLMB & mab, /*1Ab*/GLMB & meab, /*1Ab*/int nAT, /*1Ab*/GLArrayTexture * mAT)
{
   return Mesh_upload((C(Mesh)*)this->impl, /*5De*/displaySystem.impl, /*5Ee*/(C(bool))uploadTextures, /*5De*/((Instance&&)mab).impl, /*5De*/((Instance&&)meab).impl, /*5Ge*/nAT, /*5Ee*/(C(GLArrayTexture) *)mAT);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::uploadPrimitive(/*1Ab*/PrimitiveSingle & g, /*1Ab*/DisplaySystem & displaySystem, /*1Ab*/bool uploadTextures, /*1Ab*/int nAT, /*1Ab*/GLArrayTexture * mAT, /*1Ab*/bool clearData, /*1Ab*/bool unlockAndDelete)
{
   Mesh_uploadPrimitive((C(Mesh)*)this->impl, /*5De*/&g.impl, /*5De*/displaySystem.impl, /*5Ee*/(C(bool))uploadTextures, /*5Ge*/nAT, /*5Ee*/(C(GLArrayTexture) *)mAT, /*5Ee*/(C(bool))clearData, /*5Ee*/(C(bool))unlockAndDelete);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::uploadPrimitive(/*1Ac*/PrimitiveSingle * g, /*1Ac*/DisplaySystem & displaySystem, /*1Ac*/bool uploadTextures, /*1Ac*/int nAT, /*1Ac*/GLArrayTexture * mAT, /*1Ac*/bool clearData, /*1Ac*/bool unlockAndDelete)
{
   Mesh_uploadPrimitive((C(Mesh)*)this->impl, /*5Cf*/(C(PrimitiveSingle) *)g, /*5Df*/displaySystem.impl, /*5Ef*/(C(bool))uploadTextures, /*5Gf*/nAT, /*5Ef*/(C(GLArrayTexture) *)mAT, /*5Ef*/(C(bool))clearData, /*5Ef*/(C(bool))unlockAndDelete);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::uploadTexture(/*1Ab*/Bitmap & bitmap, /*1Ab*/DisplaySystem & displaySystem, /*1Ab*/GLArrayTexture & at)
{
   Mesh_uploadTexture((C(Mesh)*)this->impl, /*5De*/bitmap.impl, /*5De*/displaySystem.impl, /*5De*/&at.impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::uploadTexture(/*1Ac*/Bitmap & bitmap, /*1Ac*/DisplaySystem & displaySystem, /*1Ac*/GLArrayTexture * at)
{
   Mesh_uploadTexture((C(Mesh)*)this->impl, /*5Df*/bitmap.impl, /*5Df*/displaySystem.impl, /*5Cf*/(C(GLArrayTexture) *)at);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::fixMorphSkin()
{
   Mesh_fixMorphSkin((C(Mesh)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TMesh<TC, TCO>::fixSkeletonBones(/*1Ab*/SkinBone * bone, /*1Ab*/int boneIx)
{
   Mesh_fixSkeletonBones((C(Mesh)*)this->impl, /*5Ee*/(C(SkinBone) *)bone, /*5Ge*/boneIx);
}


// property callers: Mesh::nVertices
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TMesh<TC, TCO>::nVertices_Prop::operator= (/*0H*/int v)
{
   SELF(Mesh, nVertices);
   Mesh_set_nVertices(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::nVertices_Prop & TMesh<TC, TCO>::nVertices_Prop::operator= (typename TMesh<TC, TCO>::nVertices_Prop & prop)
{
   SELF(Mesh, nVertices);
   /*0H*/int v = prop;
   Mesh_set_nVertices(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::nVertices_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, nVertices);
   return Mesh_get_nVertices(self ? self->impl : null);
}

// property callers: Mesh::nIndices
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TMesh<TC, TCO>::nIndices_Prop::operator= (/*0H*/int v)
{
   SELF(Mesh, nIndices);
   Mesh_set_nIndices(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::nIndices_Prop & TMesh<TC, TCO>::nIndices_Prop::operator= (typename TMesh<TC, TCO>::nIndices_Prop & prop)
{
   SELF(Mesh, nIndices);
   /*0H*/int v = prop;
   Mesh_set_nIndices(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::nIndices_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, nIndices);
   return Mesh_get_nIndices(self ? self->impl : null);
}

// property callers: Mesh::meab
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const GLMB & TMesh<TC, TCO>::meab_Prop::operator= (/*0A*/const GLMB & v)
{
   SELF(Mesh, meab);
   Mesh_set_meab(self ? self->impl : null, ((Instance *)&v)->impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::meab_Prop & TMesh<TC, TCO>::meab_Prop::operator= (typename TMesh<TC, TCO>::meab_Prop & prop)
{
   SELF(Mesh, meab);
   /*0A*/const GLMB * v = prop;
   Mesh_set_meab(self ? self->impl : null, ((Instance *)v)->impl);
   return prop;
}
/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const GLMB * TMesh<TC, TCO>::meab_Prop::operator= (/*0C*/const GLMB * v)
{
   SELF(Mesh, meab);
   Mesh_set_meab(self ? self->impl : null, v ? ((Instance *)v)->impl : null);
   return v;
}

/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::meab_Prop::operator /*0F*/GLMB* () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, meab);
   C(Instance) i = Mesh_get_meab(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (GLMB *)INSTANCEL(i, i->_class) : (GLMB *)0;
}

// property callers: Mesh::baseIndex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TMesh<TC, TCO>::baseIndex_Prop::operator= (/*0H*/int v)
{
   SELF(Mesh, baseIndex);
   Mesh_set_baseIndex(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::baseIndex_Prop & TMesh<TC, TCO>::baseIndex_Prop::operator= (typename TMesh<TC, TCO>::baseIndex_Prop & prop)
{
   SELF(Mesh, baseIndex);
   /*0H*/int v = prop;
   Mesh_set_baseIndex(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::baseIndex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, baseIndex);
   return Mesh_get_baseIndex(self ? self->impl : null);
}

// property callers: Mesh::baseVertex
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TMesh<TC, TCO>::baseVertex_Prop::operator= (/*0H*/int v)
{
   SELF(Mesh, baseVertex);
   Mesh_set_baseVertex(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::baseVertex_Prop & TMesh<TC, TCO>::baseVertex_Prop::operator= (typename TMesh<TC, TCO>::baseVertex_Prop & prop)
{
   SELF(Mesh, baseVertex);
   /*0H*/int v = prop;
   Mesh_set_baseVertex(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::baseVertex_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, baseVertex);
   return Mesh_get_baseVertex(self ? self->impl : null);
}

// property callers: Mesh::indices
// (nohead::uint32 *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint * TMesh<TC, TCO>::indices_Prop::operator= (/*0H*/uint * v)
{
   SELF(Mesh, indices);
   Mesh_set_indices(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::indices_Prop & TMesh<TC, TCO>::indices_Prop::operator= (typename TMesh<TC, TCO>::indices_Prop & prop)
{
   SELF(Mesh, indices);
   /*0H*/uint * v = prop;
   Mesh_set_indices(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::indices_Prop::operator /*0I*/uint * () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, indices);
   return Mesh_get_indices(self ? self->impl : null);
}

// property callers: Mesh::groups   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::groups_Prop::operator /*0I*/OldList () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, groups);
   OldList value(((C(Mesh) *)self->impl)->groups);
   return value;
}

// property callers: Mesh::flags
// (nohead::bits|unsigned int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/MeshFeatures TMesh<TC, TCO>::flags_Prop::operator= (/*0H*/MeshFeatures v)
{
   SELF(Mesh, flags);
   Mesh_set_flags(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::flags_Prop & TMesh<TC, TCO>::flags_Prop::operator= (typename TMesh<TC, TCO>::flags_Prop & prop)
{
   SELF(Mesh, flags);
   /*0H*/MeshFeatures v = prop;
   Mesh_set_flags(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::flags_Prop::operator /*0I*/MeshFeatures () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, flags);
   return Mesh_get_flags(self ? self->impl : null);
}

// property callers: Mesh::skin
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const MeshSkin & TMesh<TC, TCO>::skin_Prop::operator= (/*0A*/const MeshSkin & v)
{
   SELF(Mesh, skin);
   Mesh_set_skin(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::skin_Prop & TMesh<TC, TCO>::skin_Prop::operator= (typename TMesh<TC, TCO>::skin_Prop & prop)
{
   SELF(Mesh, skin);
   /*0A*/const MeshSkin & v = prop;
   Mesh_set_skin(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const MeshSkin * TMesh<TC, TCO>::skin_Prop::operator= (/*0C*/const MeshSkin * v)
{
   SELF(Mesh, skin);
   Mesh_set_skin(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::skin_Prop::operator /*0B*/TIH<MeshSkin> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, skin);
   C(Instance) i = Mesh_get_skin(self ? self->impl : null);
   TIH<MeshSkin> cppi(i);
   return *cppi;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TIH<MeshSkin> TMesh<TC, TCO>::skin_Prop::operator /*0D*/-> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, skin);
   C(Instance) i = Mesh_get_skin(self ? self->impl : null);
   TIH<MeshSkin> holder(i);
   return holder;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::skin_Prop::operator /*0E*/MeshSkin () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, skin);
   C(Instance) i = Mesh_get_skin(self ? self->impl : null);
   return MeshSkin(i);
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::skin_Prop::operator /*0F*/MeshSkin* () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, skin);
   C(Instance) i = Mesh_get_skin(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (MeshSkin *)INSTANCEL(i, i->_class) : (MeshSkin *)0;
}

// property callers: Mesh::dupVerts
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const TArray<int _ARG int _ARG int> & TMesh<TC, TCO>::dupVerts_Prop::operator= (/*0A*/const TArray<int _ARG int _ARG int> & v)
{
   SELF(Mesh, dupVerts);
   Mesh_set_dupVerts(self ? self->impl : null, ((Instance *)&v)->impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::dupVerts_Prop & TMesh<TC, TCO>::dupVerts_Prop::operator= (typename TMesh<TC, TCO>::dupVerts_Prop & prop)
{
   SELF(Mesh, dupVerts);
   /*0A*/const TArray<int _ARG int _ARG int> & v = prop;
   Mesh_set_dupVerts(self ? self->impl : null, ((Instance *)&v)->impl);
   return prop;
}
/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const TArray<int _ARG int _ARG int> * TMesh<TC, TCO>::dupVerts_Prop::operator= (/*0C*/const TArray<int _ARG int _ARG int> * v)
{
   SELF(Mesh, dupVerts);
   Mesh_set_dupVerts(self ? self->impl : null, v ? ((Instance *)v)->impl : null);
   return v;
}

/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::dupVerts_Prop::operator /*0B*/TIH<TArray<int _ARG int _ARG int>> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, dupVerts);
   C(Instance) i = Mesh_get_dupVerts(self ? self->impl : null);
   TIH<TArray<int _ARG int _ARG int>> cppi(i);
   return *cppi;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TIH<TArray<int _ARG int _ARG int>> TMesh<TC, TCO>::dupVerts_Prop::operator /*0D*/-> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, dupVerts);
   C(Instance) i = Mesh_get_dupVerts(self ? self->impl : null);
   TIH<TArray<int _ARG int _ARG int>> holder(i);
   return holder;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::dupVerts_Prop::operator /*0E*/TArray<int _ARG int _ARG int> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, dupVerts);
   C(Instance) i = Mesh_get_dupVerts(self ? self->impl : null);
   return TArray<int _ARG int _ARG int>(i);
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::dupVerts_Prop::operator /*0F*/TArray<int _ARG int _ARG int>* () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, dupVerts);
   C(Instance) i = Mesh_get_dupVerts(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (TArray<int _ARG int _ARG int> *)INSTANCEL(i, i->_class) : (TArray<int _ARG int _ARG int> *)0;
}

// property callers: Mesh::morphs
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const TArray<MeshMorph _ARG int _ARG MeshMorph> & TMesh<TC, TCO>::morphs_Prop::operator= (/*0A*/const TArray<MeshMorph _ARG int _ARG MeshMorph> & v)
{
   SELF(Mesh, morphs);
   Mesh_set_morphs(self ? self->impl : null, ((Instance *)&v)->impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::morphs_Prop & TMesh<TC, TCO>::morphs_Prop::operator= (typename TMesh<TC, TCO>::morphs_Prop & prop)
{
   SELF(Mesh, morphs);
   /*0A*/const TArray<MeshMorph _ARG int _ARG MeshMorph> & v = prop;
   Mesh_set_morphs(self ? self->impl : null, ((Instance *)&v)->impl);
   return prop;
}
/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const TArray<MeshMorph _ARG int _ARG MeshMorph> * TMesh<TC, TCO>::morphs_Prop::operator= (/*0C*/const TArray<MeshMorph _ARG int _ARG MeshMorph> * v)
{
   SELF(Mesh, morphs);
   Mesh_set_morphs(self ? self->impl : null, v ? ((Instance *)v)->impl : null);
   return v;
}

/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::morphs_Prop::operator /*0B*/TIH<TArray<MeshMorph _ARG int _ARG MeshMorph>> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, morphs);
   C(Instance) i = Mesh_get_morphs(self ? self->impl : null);
   TIH<TArray<MeshMorph _ARG int _ARG MeshMorph>> cppi(i);
   return *cppi;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TIH<TArray<MeshMorph _ARG int _ARG MeshMorph>> TMesh<TC, TCO>::morphs_Prop::operator /*0D*/-> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, morphs);
   C(Instance) i = Mesh_get_morphs(self ? self->impl : null);
   TIH<TArray<MeshMorph _ARG int _ARG MeshMorph>> holder(i);
   return holder;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::morphs_Prop::operator /*0E*/TArray<MeshMorph _ARG int _ARG MeshMorph> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, morphs);
   C(Instance) i = Mesh_get_morphs(self ? self->impl : null);
   return TArray<MeshMorph _ARG int _ARG MeshMorph>(i);
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::morphs_Prop::operator /*0F*/TArray<MeshMorph _ARG int _ARG MeshMorph>* () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, morphs);
   C(Instance) i = Mesh_get_morphs(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (TArray<MeshMorph _ARG int _ARG MeshMorph> *)INSTANCEL(i, i->_class) : (TArray<MeshMorph _ARG int _ARG MeshMorph> *)0;
}

// property callers: Mesh::unmorphedMesh
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Mesh TMesh<TC, TCO>::unmorphedMesh_Prop::operator= (/*0H*/Mesh & v)
{
   SELF(Mesh, unmorphedMesh);
   Mesh_set_unmorphedMesh(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::unmorphedMesh_Prop & TMesh<TC, TCO>::unmorphedMesh_Prop::operator= (typename TMesh<TC, TCO>::unmorphedMesh_Prop & prop)
{
   SELF(Mesh, unmorphedMesh);
   /*0H*/Mesh v = prop;
   Mesh_set_unmorphedMesh(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::unmorphedMesh_Prop::operator /*0I*/Mesh () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, unmorphedMesh);
   Mesh value(Mesh_get_unmorphedMesh(self->impl));
   return value;
}

// property callers: Mesh::nTranslucentPrimitives   // get only
// (nohead::int)

/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::nTranslucentPrimitives_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, nTranslucentPrimitives);
   return Mesh_get_nTranslucentPrimitives(self ? self->impl : null);
}

// property callers: Mesh::parts
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const TArray<MeshPart _ARG int _ARG MeshPart> & TMesh<TC, TCO>::parts_Prop::operator= (/*0A*/const TArray<MeshPart _ARG int _ARG MeshPart> & v)
{
   SELF(Mesh, parts);
   Mesh_set_parts(self ? self->impl : null, ((Instance *)&v)->impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TMesh<TC, TCO>::parts_Prop & TMesh<TC, TCO>::parts_Prop::operator= (typename TMesh<TC, TCO>::parts_Prop & prop)
{
   SELF(Mesh, parts);
   /*0A*/const TArray<MeshPart _ARG int _ARG MeshPart> & v = prop;
   Mesh_set_parts(self ? self->impl : null, ((Instance *)&v)->impl);
   return prop;
}
/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const TArray<MeshPart _ARG int _ARG MeshPart> * TMesh<TC, TCO>::parts_Prop::operator= (/*0C*/const TArray<MeshPart _ARG int _ARG MeshPart> * v)
{
   SELF(Mesh, parts);
   Mesh_set_parts(self ? self->impl : null, v ? ((Instance *)v)->impl : null);
   return v;
}

/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::parts_Prop::operator /*0B*/TIH<TArray<MeshPart _ARG int _ARG MeshPart>> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, parts);
   C(Instance) i = Mesh_get_parts(self ? self->impl : null);
   TIH<TArray<MeshPart _ARG int _ARG MeshPart>> cppi(i);
   return *cppi;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TIH<TArray<MeshPart _ARG int _ARG MeshPart>> TMesh<TC, TCO>::parts_Prop::operator /*0D*/-> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, parts);
   C(Instance) i = Mesh_get_parts(self ? self->impl : null);
   TIH<TArray<MeshPart _ARG int _ARG MeshPart>> holder(i);
   return holder;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::parts_Prop::operator /*0E*/TArray<MeshPart _ARG int _ARG MeshPart> () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, parts);
   C(Instance) i = Mesh_get_parts(self ? self->impl : null);
   return TArray<MeshPart _ARG int _ARG MeshPart>(i);
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TMesh<TC, TCO>::parts_Prop::operator /*0F*/TArray<MeshPart _ARG int _ARG MeshPart>* () const
{
   __attribute__((unused)) TMesh TCTCO * self = CONTAINER_OF(this, TMesh TCTCO, parts);
   C(Instance) i = Mesh_get_parts(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (TArray<MeshPart _ARG int _ARG MeshPart> *)INSTANCEL(i, i->_class) : (TArray<MeshPart _ARG int _ARG MeshPart> *)0;
}



// member accessors: MeshFeatures::vertices
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::vertices_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, vertices);
   MESHFEATURES_SET_vertices(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::vertices_Prop & MeshFeatures::vertices_Prop::operator= (MeshFeatures::vertices_Prop & prop)
{
   SELF(MeshFeatures, vertices);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_vertices(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::vertices_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, vertices);
   return (bool)MESHFEATURES_vertices(self->impl);
}

// member accessors: MeshFeatures::normals
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::normals_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, normals);
   MESHFEATURES_SET_normals(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::normals_Prop & MeshFeatures::normals_Prop::operator= (MeshFeatures::normals_Prop & prop)
{
   SELF(MeshFeatures, normals);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_normals(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::normals_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, normals);
   return (bool)MESHFEATURES_normals(self->impl);
}

// member accessors: MeshFeatures::texCoords1
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::texCoords1_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, texCoords1);
   MESHFEATURES_SET_texCoords1(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::texCoords1_Prop & MeshFeatures::texCoords1_Prop::operator= (MeshFeatures::texCoords1_Prop & prop)
{
   SELF(MeshFeatures, texCoords1);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_texCoords1(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::texCoords1_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, texCoords1);
   return (bool)MESHFEATURES_texCoords1(self->impl);
}

// member accessors: MeshFeatures::texCoords2
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::texCoords2_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, texCoords2);
   MESHFEATURES_SET_texCoords2(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::texCoords2_Prop & MeshFeatures::texCoords2_Prop::operator= (MeshFeatures::texCoords2_Prop & prop)
{
   SELF(MeshFeatures, texCoords2);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_texCoords2(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::texCoords2_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, texCoords2);
   return (bool)MESHFEATURES_texCoords2(self->impl);
}

// member accessors: MeshFeatures::doubleNormals
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::doubleNormals_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, doubleNormals);
   MESHFEATURES_SET_doubleNormals(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::doubleNormals_Prop & MeshFeatures::doubleNormals_Prop::operator= (MeshFeatures::doubleNormals_Prop & prop)
{
   SELF(MeshFeatures, doubleNormals);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_doubleNormals(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::doubleNormals_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, doubleNormals);
   return (bool)MESHFEATURES_doubleNormals(self->impl);
}

// member accessors: MeshFeatures::doubleVertices
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::doubleVertices_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, doubleVertices);
   MESHFEATURES_SET_doubleVertices(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::doubleVertices_Prop & MeshFeatures::doubleVertices_Prop::operator= (MeshFeatures::doubleVertices_Prop & prop)
{
   SELF(MeshFeatures, doubleVertices);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_doubleVertices(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::doubleVertices_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, doubleVertices);
   return (bool)MESHFEATURES_doubleVertices(self->impl);
}

// member accessors: MeshFeatures::colors
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::colors_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, colors);
   MESHFEATURES_SET_colors(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::colors_Prop & MeshFeatures::colors_Prop::operator= (MeshFeatures::colors_Prop & prop)
{
   SELF(MeshFeatures, colors);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_colors(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::colors_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, colors);
   return (bool)MESHFEATURES_colors(self->impl);
}

// member accessors: MeshFeatures::lightVectors
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::lightVectors_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, lightVectors);
   MESHFEATURES_SET_lightVectors(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::lightVectors_Prop & MeshFeatures::lightVectors_Prop::operator= (MeshFeatures::lightVectors_Prop & prop)
{
   SELF(MeshFeatures, lightVectors);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_lightVectors(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::lightVectors_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, lightVectors);
   return (bool)MESHFEATURES_lightVectors(self->impl);
}

// member accessors: MeshFeatures::tangents
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::tangents_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, tangents);
   MESHFEATURES_SET_tangents(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::tangents_Prop & MeshFeatures::tangents_Prop::operator= (MeshFeatures::tangents_Prop & prop)
{
   SELF(MeshFeatures, tangents);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_tangents(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::tangents_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, tangents);
   return (bool)MESHFEATURES_tangents(self->impl);
}

// member accessors: MeshFeatures::intVertices
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::intVertices_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, intVertices);
   MESHFEATURES_SET_intVertices(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::intVertices_Prop & MeshFeatures::intVertices_Prop::operator= (MeshFeatures::intVertices_Prop & prop)
{
   SELF(MeshFeatures, intVertices);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_intVertices(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::intVertices_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, intVertices);
   return (bool)MESHFEATURES_intVertices(self->impl);
}

// member accessors: MeshFeatures::memAllocOnly
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::memAllocOnly_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, memAllocOnly);
   MESHFEATURES_SET_memAllocOnly(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::memAllocOnly_Prop & MeshFeatures::memAllocOnly_Prop::operator= (MeshFeatures::memAllocOnly_Prop & prop)
{
   SELF(MeshFeatures, memAllocOnly);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_memAllocOnly(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::memAllocOnly_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, memAllocOnly);
   return (bool)MESHFEATURES_memAllocOnly(self->impl);
}

// member accessors: MeshFeatures::interleaved
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::interleaved_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, interleaved);
   MESHFEATURES_SET_interleaved(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::interleaved_Prop & MeshFeatures::interleaved_Prop::operator= (MeshFeatures::interleaved_Prop & prop)
{
   SELF(MeshFeatures, interleaved);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_interleaved(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::interleaved_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, interleaved);
   return (bool)MESHFEATURES_interleaved(self->impl);
}

// member accessors: MeshFeatures::ownMEAB
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::ownMEAB_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, ownMEAB);
   MESHFEATURES_SET_ownMEAB(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::ownMEAB_Prop & MeshFeatures::ownMEAB_Prop::operator= (MeshFeatures::ownMEAB_Prop & prop)
{
   SELF(MeshFeatures, ownMEAB);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_ownMEAB(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::ownMEAB_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, ownMEAB);
   return (bool)MESHFEATURES_ownMEAB(self->impl);
}

// member accessors: MeshFeatures::bones
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MeshFeatures::bones_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshFeatures, bones);
   MESHFEATURES_SET_bones(self->impl, v);
   return v;
}

/*regSet*/inline MeshFeatures::bones_Prop & MeshFeatures::bones_Prop::operator= (MeshFeatures::bones_Prop & prop)
{
   SELF(MeshFeatures, bones);
   /*0H*/bool v = prop;
   MESHFEATURES_SET_bones(self->impl, v);
   return prop;
}
/*regGet*/inline MeshFeatures::bones_Prop::operator /*0I*/bool () const
{
   SELF(MeshFeatures, bones);
   return (bool)MESHFEATURES_bones(self->impl);
}



// member accessors: MeshMorph::target
// (struct::nohead)

/*nstSet*/inline /*0H*/Mesh MeshMorph::target_Prop::operator= (/*0H*/Mesh & v)
{
   SELF(MeshMorph, target);
   self->impl.target = v.impl;
   return v;
}

/*regSet*/inline MeshMorph::target_Prop & MeshMorph::target_Prop::operator= (MeshMorph::target_Prop & prop)
{
   SELF(MeshMorph, target);
   /*0H*/Mesh v = prop;
   self->impl.target = v.impl;
   return prop;
}
/*regGet*/inline MeshMorph::target_Prop::operator /*0I*/Mesh () const
{
   SELF(MeshMorph, target);
   Mesh value(((C(MeshMorph) *)&self->impl)->target);
   return value;
}

// member accessors: MeshMorph::weight
// (struct::float)

/*nstSet*/inline /*0H*/float MeshMorph::weight_Prop::operator= (/*0H*/float v)
{
   SELF(MeshMorph, weight);
   self->impl.weight = v;
   return v;
}

/*regSet*/inline MeshMorph::weight_Prop & MeshMorph::weight_Prop::operator= (MeshMorph::weight_Prop & prop)
{
   SELF(MeshMorph, weight);
   /*0H*/float v = prop;
   self->impl.weight = v;
   return prop;
}
/*regGet*/inline MeshMorph::weight_Prop::operator /*0I*/float () const
{
   SELF(MeshMorph, weight);
   return self ? ((C(MeshMorph) *)&self->impl)->weight : 0;
}

// member accessors: MeshMorph::name
// (struct::string)

/*nstSet*/inline /*0H*/char * MeshMorph::name_Prop::operator= (/*0H*/char * v)
{
   SELF(MeshMorph, name);
   self->impl.name = v;
   return v;
}

/*regSet*/inline MeshMorph::name_Prop & MeshMorph::name_Prop::operator= (MeshMorph::name_Prop & prop)
{
   SELF(MeshMorph, name);
   /*0H*/char * v = prop;
   self->impl.name = v;
   return prop;
}
/*regGet*/inline MeshMorph::name_Prop::operator /*0I*/char * () const
{
   SELF(MeshMorph, name);
   return self ? ((C(MeshMorph) *)&self->impl)->name : 0;
}

// member accessors: MeshMorph::updated
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool MeshMorph::updated_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshMorph, updated);
   self->impl.updated = (C(bool))v;
   return v;
}

/*regSet*/inline MeshMorph::updated_Prop & MeshMorph::updated_Prop::operator= (MeshMorph::updated_Prop & prop)
{
   SELF(MeshMorph, updated);
   /*0H*/bool v = prop;
   self->impl.updated = (C(bool))v;
   return prop;
}
/*regGet*/inline MeshMorph::updated_Prop::operator /*0I*/bool () const
{
   SELF(MeshMorph, updated);
   return self ? (bool)((C(MeshMorph) *)&self->impl)->updated : (bool)0;
}

// member accessors: MeshMorph::firstV
// (struct::int)

/*nstSet*/inline /*0H*/int MeshMorph::firstV_Prop::operator= (/*0H*/int v)
{
   SELF(MeshMorph, firstV);
   self->impl.firstV = v;
   return v;
}

/*regSet*/inline MeshMorph::firstV_Prop & MeshMorph::firstV_Prop::operator= (MeshMorph::firstV_Prop & prop)
{
   SELF(MeshMorph, firstV);
   /*0H*/int v = prop;
   self->impl.firstV = v;
   return prop;
}
/*regGet*/inline MeshMorph::firstV_Prop::operator /*0I*/int () const
{
   SELF(MeshMorph, firstV);
   return self ? ((C(MeshMorph) *)&self->impl)->firstV : 0;
}

// member accessors: MeshMorph::lastV
// (struct::int)

/*nstSet*/inline /*0H*/int MeshMorph::lastV_Prop::operator= (/*0H*/int v)
{
   SELF(MeshMorph, lastV);
   self->impl.lastV = v;
   return v;
}

/*regSet*/inline MeshMorph::lastV_Prop & MeshMorph::lastV_Prop::operator= (MeshMorph::lastV_Prop & prop)
{
   SELF(MeshMorph, lastV);
   /*0H*/int v = prop;
   self->impl.lastV = v;
   return prop;
}
/*regGet*/inline MeshMorph::lastV_Prop::operator /*0I*/int () const
{
   SELF(MeshMorph, lastV);
   return self ? ((C(MeshMorph) *)&self->impl)->lastV : 0;
}

inline MeshPart::MeshPart(uint64 id, uint start = 0, uint count = 0)
{
   impl.id = id;
   impl.start = start;
   impl.count = count;
}



// member accessors: MeshPart::id
// (struct::uint64)

/*nstSet*/inline /*0H*/uint64 MeshPart::id_Prop::operator= (/*0H*/uint64 v)
{
   SELF(MeshPart, id);
   self->impl.id = v;
   return v;
}

/*regSet*/inline MeshPart::id_Prop & MeshPart::id_Prop::operator= (MeshPart::id_Prop & prop)
{
   SELF(MeshPart, id);
   /*0H*/uint64 v = prop;
   self->impl.id = v;
   return prop;
}
/*regGet*/inline MeshPart::id_Prop::operator /*0I*/uint64 () const
{
   SELF(MeshPart, id);
   return self ? ((C(MeshPart) *)&self->impl)->id : 0;
}

// member accessors: MeshPart::start
// (struct::uint)

/*nstSet*/inline /*0H*/uint MeshPart::start_Prop::operator= (/*0H*/uint v)
{
   SELF(MeshPart, start);
   self->impl.start = v;
   return v;
}

/*regSet*/inline MeshPart::start_Prop & MeshPart::start_Prop::operator= (MeshPart::start_Prop & prop)
{
   SELF(MeshPart, start);
   /*0H*/uint v = prop;
   self->impl.start = v;
   return prop;
}
/*regGet*/inline MeshPart::start_Prop::operator /*0I*/uint () const
{
   SELF(MeshPart, start);
   return self ? ((C(MeshPart) *)&self->impl)->start : 0;
}

// member accessors: MeshPart::count
// (struct::uint)

/*nstSet*/inline /*0H*/uint MeshPart::count_Prop::operator= (/*0H*/uint v)
{
   SELF(MeshPart, count);
   self->impl.count = v;
   return v;
}

/*regSet*/inline MeshPart::count_Prop & MeshPart::count_Prop::operator= (MeshPart::count_Prop & prop)
{
   SELF(MeshPart, count);
   /*0H*/uint v = prop;
   self->impl.count = v;
   return prop;
}
/*regGet*/inline MeshPart::count_Prop::operator /*0I*/uint () const
{
   SELF(MeshPart, count);
   return self ? ((C(MeshPart) *)&self->impl)->count : 0;
}

inline MeshSkin::MeshSkin(Matrix bindShapeMatrix) : MeshSkin()
{
   this->bindShapeMatrix = bindShapeMatrix.impl;
}



// member accessors: MeshSkin::bindShapeMatrix
// (normal::struct)

/*nstSet*/inline /*0H*/Matrix MeshSkin::bindShapeMatrix_Prop::operator= (/*0H*/Matrix v)
{
   SELF(MeshSkin, bindShapeMatrix);
   IPTR(self->impl, MeshSkin)->bindShapeMatrix = v.impl;
   return v;
}

/*regSet*/inline MeshSkin::bindShapeMatrix_Prop & MeshSkin::bindShapeMatrix_Prop::operator= (MeshSkin::bindShapeMatrix_Prop & prop)
{
   SELF(MeshSkin, bindShapeMatrix);
   /*0H*/Matrix v = prop;
   IPTR(self->impl, MeshSkin)->bindShapeMatrix = v.impl;
   return prop;
}
/*regGet*/inline MeshSkin::bindShapeMatrix_Prop::operator /*0I*/Matrix () const
{
   SELF(MeshSkin, bindShapeMatrix);
   Matrix value(IPTR(self->impl, MeshSkin)->bindShapeMatrix);
   return value;
}

// member accessors: MeshSkin::bones
// (normal::normal)

/*nstSet*/inline /*0H*/TArray<SkinBone _ARG int _ARG SkinBone> MeshSkin::bones_Prop::operator= (/*0H*/TArray<SkinBone _ARG int _ARG SkinBone> v)
{
   SELF(MeshSkin, bones);
   IPTR(self->impl, MeshSkin)->bones = ((Instance *)&v)->impl;
   return v;
}

/*regSet*/inline MeshSkin::bones_Prop & MeshSkin::bones_Prop::operator= (MeshSkin::bones_Prop & prop)
{
   SELF(MeshSkin, bones);
   /*0H*/TArray<SkinBone _ARG int _ARG SkinBone> v = prop;
   IPTR(self->impl, MeshSkin)->bones = ((Instance *)&v)->impl;
   return prop;
}
/*regGet*/inline MeshSkin::bones_Prop::operator /*0I*/TArray<SkinBone _ARG int _ARG SkinBone> () const
{
   SELF(MeshSkin, bones);
   TArray<SkinBone _ARG int _ARG SkinBone> value(IPTR(self->impl, MeshSkin)->bones, MeshSkin::_cpp_class);
   return value;
}

// member accessors: MeshSkin::skinVerts
// (normal::normal)

/*nstSet*/inline /*0H*/TArray<SkinVert _ARG int _ARG SkinVert> MeshSkin::skinVerts_Prop::operator= (/*0H*/TArray<SkinVert _ARG int _ARG SkinVert> v)
{
   SELF(MeshSkin, skinVerts);
   IPTR(self->impl, MeshSkin)->skinVerts = ((Instance *)&v)->impl;
   return v;
}

/*regSet*/inline MeshSkin::skinVerts_Prop & MeshSkin::skinVerts_Prop::operator= (MeshSkin::skinVerts_Prop & prop)
{
   SELF(MeshSkin, skinVerts);
   /*0H*/TArray<SkinVert _ARG int _ARG SkinVert> v = prop;
   IPTR(self->impl, MeshSkin)->skinVerts = ((Instance *)&v)->impl;
   return prop;
}
/*regGet*/inline MeshSkin::skinVerts_Prop::operator /*0I*/TArray<SkinVert _ARG int _ARG SkinVert> () const
{
   SELF(MeshSkin, skinVerts);
   TArray<SkinVert _ARG int _ARG SkinVert> value(IPTR(self->impl, MeshSkin)->skinVerts, MeshSkin::_cpp_class);
   return value;
}

// member accessors: MeshSkin::invShape
// (normal::struct)

/*nstSet*/inline /*0H*/Matrix MeshSkin::invShape_Prop::operator= (/*0H*/Matrix v)
{
   SELF(MeshSkin, invShape);
   IPTR(self->impl, MeshSkin)->invShape = v.impl;
   return v;
}

/*regSet*/inline MeshSkin::invShape_Prop & MeshSkin::invShape_Prop::operator= (MeshSkin::invShape_Prop & prop)
{
   SELF(MeshSkin, invShape);
   /*0H*/Matrix v = prop;
   IPTR(self->impl, MeshSkin)->invShape = v.impl;
   return prop;
}
/*regGet*/inline MeshSkin::invShape_Prop::operator /*0I*/Matrix () const
{
   SELF(MeshSkin, invShape);
   Matrix value(IPTR(self->impl, MeshSkin)->invShape);
   return value;
}

// member accessors: MeshSkin::bsIsIdentity
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool MeshSkin::bsIsIdentity_Prop::operator= (/*0H*/bool v)
{
   SELF(MeshSkin, bsIsIdentity);
   IPTR(self->impl, MeshSkin)->bsIsIdentity = (C(bool))v;
   return v;
}

/*regSet*/inline MeshSkin::bsIsIdentity_Prop & MeshSkin::bsIsIdentity_Prop::operator= (MeshSkin::bsIsIdentity_Prop & prop)
{
   SELF(MeshSkin, bsIsIdentity);
   /*0H*/bool v = prop;
   IPTR(self->impl, MeshSkin)->bsIsIdentity = (C(bool))v;
   return prop;
}
/*regGet*/inline MeshSkin::bsIsIdentity_Prop::operator /*0I*/bool () const
{
   SELF(MeshSkin, bsIsIdentity);
   return self ? (bool)IPTR(self->impl, MeshSkin)->bsIsIdentity : (bool)0;
}


template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::add(/*1Ab*/TObject<TC, TCO> object)
{
   Object_add((C(Object)*)this->impl, /*5De*/object.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::addFrameTrack(/*1Ab*/FrameTrack track)
{
   Object_addFrameTrack((C(Object)*)this->impl, /*5De*/track.impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::addName(/*1Ab*/TObject<TC, TCO> object, /*1Ab*/const char * name)
{
   return Object_addName((C(Object)*)this->impl, /*5De*/object.impl, /*5Ge*/name);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::animate(/*1Ab*/int frame)
{
   Object_animate((C(Object)*)this->impl, /*5Ge*/frame);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::applyMorphs(/*1Ab*/bool recomputeNormals)
{
   Object_applyMorphs((C(Object)*)this->impl, /*5Ee*/(C(bool))recomputeNormals);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::applySkins()
{
   Object_applySkins((C(Object)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::combineMorphs()
{
   Object_combineMorphs((C(Object)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::_delete(/*1Ab*/TObject<TC, TCO> child, /*1Ab*/DisplaySystem & displaySystem)
{
   Object_delete((C(Object)*)this->impl, /*5De*/child.impl, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::doubleSided(/*1Ab*/bool flag)
{
   Object_doubleSided((C(Object)*)this->impl, /*5Ee*/(C(bool))flag);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::duplicate(/*1Ab*/TObject<TC, TCO> model)
{
   Object_duplicate((C(Object)*)this->impl, /*5De*/model.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::duplicate2(/*1Ab*/TObject<TC, TCO> model, /*1Ab*/bool takeOwnership)
{
   Object_duplicate2((C(Object)*)this->impl, /*5De*/model.impl, /*5Ee*/(C(bool))takeOwnership);
}
template <class TC, C(Class) ** TCO> inline C(Object) * TObject<TC, TCO>::find(/*1Ab*/const char * name)
{
   return Object_find((C(Object)*)this->impl, /*5Ge*/name);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::free(/*1Ab*/const DisplaySystem & displaySystem)
{
   Object_free((C(Object)*)this->impl, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::freeMesh(/*1Ab*/DisplaySystem & displaySystem)
{
   Object_freeMesh((C(Object)*)this->impl, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::initialize()
{
   Object_initialize((C(Object)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline C(Mesh) * TObject<TC, TCO>::initializeMesh(/*1Ab*/DisplaySystem & displaySystem)
{
   return Object_initializeMesh((C(Object)*)this->impl, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline C(FrustumPlacement) TObject<TC, TCO>::insideFrustum(/*1Ab*/Plane * planes)
{
   return Object_insideFrustum((C(Object)*)this->impl, /*5Ee*/(C(Plane) *)planes);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::intersectsGroundPolygon(/*1Ab*/int count, /*1Ab*/Pointf * pointfs)
{
   return Object_intersectsGroundPolygon((C(Object)*)this->impl, /*5Ge*/count, /*5Ee*/(C(Pointf) *)pointfs);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::inverseKinematics(/*1Ab*/int boneIX, /*1Ab*/TArray<Euler _ARG int _ARG Euler> & limits, /*1Ab*/int vertex, /*1Ab*/const Vector3D & target, /*1Ab*/int maxDepth)
{
   Object_inverseKinematics((C(Object)*)this->impl, /*5Ge*/boneIX, /*5De*/((Instance&&)limits).impl, /*5Ge*/vertex, /*5De*/&target.impl, /*5Ge*/maxDepth);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::inverseKinematics(/*1Ac*/int boneIX, /*1Ac*/TArray<Euler _ARG int _ARG Euler> & limits, /*1Ac*/int vertex, /*1Ac*/const Vector3D * target, /*1Ac*/int maxDepth)
{
   Object_inverseKinematics((C(Object)*)this->impl, /*5Gf*/boneIX, /*5Df*/((Instance&)limits).impl, /*5Gf*/vertex, /*5Cf*/(C(Vector3D) *)target, /*5Gf*/maxDepth);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::load(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem)
{
   return Object_load((C(Object)*)this->impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::loadEx(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/DisplaySystem & displaySystem, /*1Ab*/void * options)
{
   return Object_loadEx((C(Object)*)this->impl, /*5Ge*/fileName, /*5Ge*/type, /*5De*/displaySystem.impl, /*5Ge*/options);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::merge(/*1Ab*/DisplaySystem & displaySystem)
{
   return Object_merge((C(Object)*)this->impl, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::mergeEx(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/MeshFeatures deleteCPUAttrOptions)
{
   return Object_mergeEx((C(Object)*)this->impl, /*5De*/displaySystem.impl, /*5Ee*/(C(MeshFeatures))deleteCPUAttrOptions.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::move(/*1Ab*/Vector3D & direction)
{
   Object_move((C(Object)*)this->impl, /*5De*/&direction.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::move(/*1Ac*/Vector3D * direction)
{
   Object_move((C(Object)*)this->impl, /*5Cf*/(C(Vector3D) *)direction);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::remove(/*1Ab*/TObject<TC, TCO> child)
{
   Object_remove((C(Object)*)this->impl, /*5De*/child.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::resetPose()
{
   Object_resetPose((C(Object)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::rotateEuler(/*1Ab*/Euler & rotation, /*1Ab*/Euler & min, /*1Ab*/Euler & max)
{
   Object_rotateEuler((C(Object)*)this->impl, /*5De*/&rotation.impl, /*5De*/&min.impl, /*5De*/&max.impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::rotateEuler(/*1Ac*/Euler * rotation, /*1Ac*/Euler * min, /*1Ac*/Euler * max)
{
   Object_rotateEuler((C(Object)*)this->impl, /*5Cf*/(C(Euler) *)rotation, /*5Cf*/(C(Euler) *)min, /*5Cf*/(C(Euler) *)max);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::save(/*1Ab*/const char * fileName, /*1Ab*/const char * type)
{
   return Object_save((C(Object)*)this->impl, /*5Ge*/fileName, /*5Ge*/type);
}
template <class TC, C(Class) ** TCO> inline C(bool) TObject<TC, TCO>::saveEx(/*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/void * options)
{
   return Object_saveEx((C(Object)*)this->impl, /*5Ge*/fileName, /*5Ge*/type, /*5Ge*/options);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::setMinMaxRadius(/*1Ab*/bool processMesh)
{
   Object_setMinMaxRadius((C(Object)*)this->impl, /*5Ee*/(C(bool))processMesh);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::updateTransform()
{
   Object_updateTransform((C(Object)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TObject<TC, TCO>::upload(/*1Ab*/DisplaySystem & displaySystem, /*1Ab*/GLMB & mab, /*1Ab*/GLMB & meab, /*1Ab*/int nAT, /*1Ab*/GLArrayTexture * mAT)
{
   Object_upload((C(Object)*)this->impl, /*5De*/displaySystem.impl, /*5De*/((Instance&&)mab).impl, /*5De*/((Instance&&)meab).impl, /*5Ge*/nAT, /*5Ee*/(C(GLArrayTexture) *)mAT);
}
template <class TC, C(Class) ** TCO> inline TArray<C(String) _ARG int _ARG C(String)> TObject<TC, TCO>::listTextures(/*1Ab*/File & file, /*1Ab*/const char * fileName, /*1Ab*/const char * type, /*1Ab*/void * options)
{
   return TArray<C(String) _ARG int _ARG C(String)>(Object_listTextures(/*5De*/file.impl, /*5Ge*/fileName, /*5Ge*/type, /*5Ge*/options));
}


// property callers: Object::transform
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Transform TObject<TC, TCO>::transform_Prop::operator= (/*0H*/Transform v)
{
   SELF(Object, transform);
   Object_set_transform(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::transform_Prop & TObject<TC, TCO>::transform_Prop::operator= (typename TObject<TC, TCO>::transform_Prop & prop)
{
   SELF(Object, transform);
   /*0H*/Transform v = prop;
   Object_set_transform(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::transform_Prop::operator /*0I*/Transform () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, transform);
   Transform value(((C(Object) *)self->impl)->transform);
   return value;
}

// property callers: Object::eulerOrientation
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Euler TObject<TC, TCO>::eulerOrientation_Prop::operator= (/*0H*/Euler v)
{
   SELF(Object, eulerOrientation);
   Object_set_eulerOrientation(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::eulerOrientation_Prop & TObject<TC, TCO>::eulerOrientation_Prop::operator= (typename TObject<TC, TCO>::eulerOrientation_Prop & prop)
{
   SELF(Object, eulerOrientation);
   /*0H*/Euler v = prop;
   Object_set_eulerOrientation(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::eulerOrientation_Prop::operator /*0I*/Euler () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, eulerOrientation);
   Euler value;Object_get_eulerOrientation(self->impl, &value.impl);
   return value;
}

// property callers: Object::material
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Material TObject<TC, TCO>::material_Prop::operator= (/*0H*/Material & v)
{
   SELF(Object, material);
   Object_set_material(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::material_Prop & TObject<TC, TCO>::material_Prop::operator= (typename TObject<TC, TCO>::material_Prop & prop)
{
   SELF(Object, material);
   /*0H*/Material v = prop;
   Object_set_material(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::material_Prop::operator /*0I*/Material () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, material);
   Material value(Object_get_material(self->impl));
   return value;
}

// property callers: Object::max   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::max_Prop::operator /*0I*/Vector3Df () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, max);
   Vector3Df value;Object_get_max(self->impl, &value.impl);
   return value;
}

// property callers: Object::min   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::min_Prop::operator /*0I*/Vector3Df () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, min);
   Vector3Df value;Object_get_min(self->impl, &value.impl);
   return value;
}

// property callers: Object::center   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::center_Prop::operator /*0I*/Vector3Df () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, center);
   Vector3Df value;Object_get_center(self->impl, &value.impl);
   return value;
}

// property callers: Object::radius   // get only
// (nohead::float)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::radius_Prop::operator /*0I*/float () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, radius);
   return Object_get_radius(self ? self->impl : null);
}

// property callers: Object::wmax   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::wmax_Prop::operator /*0I*/Vector3D () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, wmax);
   Vector3D value;Object_get_wmax(self->impl, &value.impl);
   return value;
}

// property callers: Object::wmin   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::wmin_Prop::operator /*0I*/Vector3D () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, wmin);
   Vector3D value;Object_get_wmin(self->impl, &value.impl);
   return value;
}

// property callers: Object::wcenter   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::wcenter_Prop::operator /*0I*/Vector3D () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, wcenter);
   Vector3D value;Object_get_wcenter(self->impl, &value.impl);
   return value;
}

// property callers: Object::wradius   // get only
// (nohead::double)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::wradius_Prop::operator /*0I*/double () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, wradius);
   return Object_get_wradius(self ? self->impl : null);
}

// property callers: Object::tag
// (nohead::void *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/void * TObject<TC, TCO>::tag_Prop::operator= (/*0H*/void * v)
{
   SELF(Object, tag);
   Object_set_tag(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::tag_Prop & TObject<TC, TCO>::tag_Prop::operator= (typename TObject<TC, TCO>::tag_Prop & prop)
{
   SELF(Object, tag);
   /*0H*/void * v = prop;
   Object_set_tag(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::tag_Prop::operator /*0I*/void * () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, tag);
   return Object_get_tag(self ? self->impl : null);
}

// property callers: Object::frame
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TObject<TC, TCO>::frame_Prop::operator= (/*0H*/int v)
{
   SELF(Object, frame);
   Object_set_frame(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::frame_Prop & TObject<TC, TCO>::frame_Prop::operator= (typename TObject<TC, TCO>::frame_Prop & prop)
{
   SELF(Object, frame);
   /*0H*/int v = prop;
   Object_set_frame(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::frame_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, frame);
   return Object_get_frame(self ? self->impl : null);
}

// property callers: Object::startFrame
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TObject<TC, TCO>::startFrame_Prop::operator= (/*0H*/int v)
{
   SELF(Object, startFrame);
   Object_set_startFrame(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::startFrame_Prop & TObject<TC, TCO>::startFrame_Prop::operator= (typename TObject<TC, TCO>::startFrame_Prop & prop)
{
   SELF(Object, startFrame);
   /*0H*/int v = prop;
   Object_set_startFrame(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::startFrame_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, startFrame);
   return Object_get_startFrame(self ? self->impl : null);
}

// property callers: Object::endFrame
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TObject<TC, TCO>::endFrame_Prop::operator= (/*0H*/int v)
{
   SELF(Object, endFrame);
   Object_set_endFrame(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::endFrame_Prop & TObject<TC, TCO>::endFrame_Prop::operator= (typename TObject<TC, TCO>::endFrame_Prop & prop)
{
   SELF(Object, endFrame);
   /*0H*/int v = prop;
   Object_set_endFrame(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::endFrame_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, endFrame);
   return Object_get_endFrame(self ? self->impl : null);
}

// property callers: Object::mesh
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Mesh TObject<TC, TCO>::mesh_Prop::operator= (/*0H*/Mesh & v)
{
   SELF(Object, mesh);
   Object_set_mesh(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::mesh_Prop & TObject<TC, TCO>::mesh_Prop::operator= (typename TObject<TC, TCO>::mesh_Prop & prop)
{
   SELF(Object, mesh);
   /*0H*/Mesh v = prop;
   Object_set_mesh(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::mesh_Prop::operator /*0I*/Mesh () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, mesh);
   Mesh value(Object_get_mesh(self->impl));
   return value;
}

// property callers: Object::camera   // get only
// (nohead::normal)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::camera_Prop::operator /*0B*/TIH<Camera> () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, camera);
   C(Instance) i = Object_get_camera(self ? self->impl : null);
   TIH<Camera> cppi(i);
   return *cppi;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TIH<Camera> TObject<TC, TCO>::camera_Prop::operator /*0D*/-> () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, camera);
   C(Instance) i = Object_get_camera(self ? self->impl : null);
   TIH<Camera> holder(i);
   return holder;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::camera_Prop::operator /*0E*/Camera () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, camera);
   C(Instance) i = Object_get_camera(self ? self->impl : null);
   return Camera(i);
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::camera_Prop::operator /*0F*/Camera* () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, camera);
   C(Instance) i = Object_get_camera(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Camera *)INSTANCEL(i, i->_class) : (Camera *)0;
}

// property callers: Object::firstChild   // get only
// (nohead::nohead)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::firstChild_Prop::operator /*0I*/Object () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, firstChild);
   Object value(Object_get_firstChild(self->impl));
   return value;
}

// property callers: Object::next   // get only
// (nohead::nohead)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::next_Prop::operator /*0I*/Object () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, next);
   Object value(Object_get_next(self->impl));
   return value;
}

// property callers: Object::name
// (nohead::const char *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/const char * TObject<TC, TCO>::name_Prop::operator= (/*0H*/const char * v)
{
   SELF(Object, name);
   Object_set_name(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::name_Prop & TObject<TC, TCO>::name_Prop::operator= (typename TObject<TC, TCO>::name_Prop & prop)
{
   SELF(Object, name);
   /*0H*/const char * v = prop;
   Object_set_name(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::name_Prop::operator /*0I*/const char * () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, name);
   return Object_get_name(self ? self->impl : null);
}

// property callers: Object::matrix   // get only
// (nohead::struct)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::matrix_Prop::operator /*0I*/Matrix () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, matrix);
   Matrix value;Object_get_matrix(self->impl, &value.impl);
   return value;
}

// property callers: Object::cameraTarget
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Object TObject<TC, TCO>::cameraTarget_Prop::operator= (/*0H*/Object & v)
{
   SELF(Object, cameraTarget);
   Object_set_cameraTarget(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::cameraTarget_Prop & TObject<TC, TCO>::cameraTarget_Prop::operator= (typename TObject<TC, TCO>::cameraTarget_Prop & prop)
{
   SELF(Object, cameraTarget);
   /*0H*/Object v = prop;
   Object_set_cameraTarget(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::cameraTarget_Prop::operator /*0I*/Object () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, cameraTarget);
   Object value(Object_get_cameraTarget(self->impl));
   return value;
}

// property callers: Object::flags
// (nohead::bits|unsigned int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/ObjectFlags TObject<TC, TCO>::flags_Prop::operator= (/*0H*/ObjectFlags v)
{
   SELF(Object, flags);
   Object_set_flags(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::flags_Prop & TObject<TC, TCO>::flags_Prop::operator= (typename TObject<TC, TCO>::flags_Prop & prop)
{
   SELF(Object, flags);
   /*0H*/ObjectFlags v = prop;
   Object_set_flags(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::flags_Prop::operator /*0I*/ObjectFlags () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, flags);
   return Object_get_flags(self ? self->impl : null);
}

// property callers: Object::parent   // get only
// (nohead::nohead)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::parent_Prop::operator /*0I*/Object () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, parent);
   Object value(Object_get_parent(self->impl));
   return value;
}

// property callers: Object::numChildren   // get only
// (nohead::uint)

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::numChildren_Prop::operator /*0I*/uint () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, numChildren);
   return Object_get_numChildren(self ? self->impl : null);
}

// property callers: Object::light
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Light TObject<TC, TCO>::light_Prop::operator= (/*0H*/Light v)
{
   SELF(Object, light);
   Object_set_light(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::light_Prop & TObject<TC, TCO>::light_Prop::operator= (typename TObject<TC, TCO>::light_Prop & prop)
{
   SELF(Object, light);
   /*0H*/Light v = prop;
   Object_set_light(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::light_Prop::operator /*0I*/Light () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, light);
   Light value;Object_get_light(self->impl, &value.impl);
   return value;
}

// property callers: Object::rotationOrder
// (nohead::enum|int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/EulerRotationOrder TObject<TC, TCO>::rotationOrder_Prop::operator= (/*0H*/EulerRotationOrder v)
{
   SELF(Object, rotationOrder);
   Object_set_rotationOrder(self ? self->impl : null, (C(EulerRotationOrder))v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::rotationOrder_Prop & TObject<TC, TCO>::rotationOrder_Prop::operator= (typename TObject<TC, TCO>::rotationOrder_Prop & prop)
{
   SELF(Object, rotationOrder);
   /*0H*/EulerRotationOrder v = prop;
   Object_set_rotationOrder(self ? self->impl : null, (C(EulerRotationOrder))v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::rotationOrder_Prop::operator /*0I*/EulerRotationOrder () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, rotationOrder);
   return (EulerRotationOrder)Object_get_rotationOrder(self ? self->impl : null);
}

// property callers: Object::displaySystem
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const DisplaySystem & TObject<TC, TCO>::displaySystem_Prop::operator= (/*0A*/const DisplaySystem & v)
{
   SELF(Object, displaySystem);
   Object_set_displaySystem(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TObject<TC, TCO>::displaySystem_Prop & TObject<TC, TCO>::displaySystem_Prop::operator= (typename TObject<TC, TCO>::displaySystem_Prop & prop)
{
   SELF(Object, displaySystem);
   /*0A*/const DisplaySystem & v = prop;
   Object_set_displaySystem(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const DisplaySystem * TObject<TC, TCO>::displaySystem_Prop::operator= (/*0C*/const DisplaySystem * v)
{
   SELF(Object, displaySystem);
   Object_set_displaySystem(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::displaySystem_Prop::operator /*0B*/TIH<DisplaySystem> () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, displaySystem);
   C(Instance) i = Object_get_displaySystem(self ? self->impl : null);
   TIH<DisplaySystem> cppi(i);
   return *cppi;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TIH<DisplaySystem> TObject<TC, TCO>::displaySystem_Prop::operator /*0D*/-> () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, displaySystem);
   C(Instance) i = Object_get_displaySystem(self ? self->impl : null);
   TIH<DisplaySystem> holder(i);
   return holder;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::displaySystem_Prop::operator /*0E*/DisplaySystem () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, displaySystem);
   C(Instance) i = Object_get_displaySystem(self ? self->impl : null);
   return DisplaySystem(i);
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TObject<TC, TCO>::displaySystem_Prop::operator /*0F*/DisplaySystem* () const
{
   __attribute__((unused)) TObject TCTCO * self = CONTAINER_OF(this, TObject TCTCO, displaySystem);
   C(Instance) i = Object_get_displaySystem(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DisplaySystem *)INSTANCEL(i, i->_class) : (DisplaySystem *)0;
}



// member accessors: ObjectFlags::root
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::root_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, root);
   OBJECTFLAGS_SET_root(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::root_Prop & ObjectFlags::root_Prop::operator= (ObjectFlags::root_Prop & prop)
{
   SELF(ObjectFlags, root);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_root(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::root_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, root);
   return (bool)OBJECTFLAGS_root(self->impl);
}

// member accessors: ObjectFlags::viewSpace
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::viewSpace_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, viewSpace);
   OBJECTFLAGS_SET_viewSpace(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::viewSpace_Prop & ObjectFlags::viewSpace_Prop::operator= (ObjectFlags::viewSpace_Prop & prop)
{
   SELF(ObjectFlags, viewSpace);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_viewSpace(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::viewSpace_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, viewSpace);
   return (bool)OBJECTFLAGS_viewSpace(self->impl);
}

// member accessors: ObjectFlags::ownMesh
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::ownMesh_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, ownMesh);
   OBJECTFLAGS_SET_ownMesh(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::ownMesh_Prop & ObjectFlags::ownMesh_Prop::operator= (ObjectFlags::ownMesh_Prop & prop)
{
   SELF(ObjectFlags, ownMesh);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_ownMesh(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::ownMesh_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, ownMesh);
   return (bool)OBJECTFLAGS_ownMesh(self->impl);
}

// member accessors: ObjectFlags::translucent
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::translucent_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, translucent);
   OBJECTFLAGS_SET_translucent(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::translucent_Prop & ObjectFlags::translucent_Prop::operator= (ObjectFlags::translucent_Prop & prop)
{
   SELF(ObjectFlags, translucent);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_translucent(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::translucent_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, translucent);
   return (bool)OBJECTFLAGS_translucent(self->impl);
}

// member accessors: ObjectFlags::flipWindings
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::flipWindings_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, flipWindings);
   OBJECTFLAGS_SET_flipWindings(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::flipWindings_Prop & ObjectFlags::flipWindings_Prop::operator= (ObjectFlags::flipWindings_Prop & prop)
{
   SELF(ObjectFlags, flipWindings);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_flipWindings(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::flipWindings_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, flipWindings);
   return (bool)OBJECTFLAGS_flipWindings(self->impl);
}

// member accessors: ObjectFlags::keysLoaded
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::keysLoaded_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, keysLoaded);
   OBJECTFLAGS_SET_keysLoaded(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::keysLoaded_Prop & ObjectFlags::keysLoaded_Prop::operator= (ObjectFlags::keysLoaded_Prop & prop)
{
   SELF(ObjectFlags, keysLoaded);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_keysLoaded(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::keysLoaded_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, keysLoaded);
   return (bool)OBJECTFLAGS_keysLoaded(self->impl);
}

// member accessors: ObjectFlags::transform
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::transform_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, transform);
   OBJECTFLAGS_SET_transform(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::transform_Prop & ObjectFlags::transform_Prop::operator= (ObjectFlags::transform_Prop & prop)
{
   SELF(ObjectFlags, transform);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_transform(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::transform_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, transform);
   return (bool)OBJECTFLAGS_transform(self->impl);
}

// member accessors: ObjectFlags::mesh
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::mesh_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, mesh);
   OBJECTFLAGS_SET_mesh(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::mesh_Prop & ObjectFlags::mesh_Prop::operator= (ObjectFlags::mesh_Prop & prop)
{
   SELF(ObjectFlags, mesh);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_mesh(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::mesh_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, mesh);
   return (bool)OBJECTFLAGS_mesh(self->impl);
}

// member accessors: ObjectFlags::light
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::light_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, light);
   OBJECTFLAGS_SET_light(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::light_Prop & ObjectFlags::light_Prop::operator= (ObjectFlags::light_Prop & prop)
{
   SELF(ObjectFlags, light);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_light(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::light_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, light);
   return (bool)OBJECTFLAGS_light(self->impl);
}

// member accessors: ObjectFlags::camera
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::camera_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, camera);
   OBJECTFLAGS_SET_camera(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::camera_Prop & ObjectFlags::camera_Prop::operator= (ObjectFlags::camera_Prop & prop)
{
   SELF(ObjectFlags, camera);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_camera(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::camera_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, camera);
   return (bool)OBJECTFLAGS_camera(self->impl);
}

// member accessors: ObjectFlags::localMatrixSet
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::localMatrixSet_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, localMatrixSet);
   OBJECTFLAGS_SET_localMatrixSet(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::localMatrixSet_Prop & ObjectFlags::localMatrixSet_Prop::operator= (ObjectFlags::localMatrixSet_Prop & prop)
{
   SELF(ObjectFlags, localMatrixSet);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_localMatrixSet(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::localMatrixSet_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, localMatrixSet);
   return (bool)OBJECTFLAGS_localMatrixSet(self->impl);
}

// member accessors: ObjectFlags::computeLightVectors
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::computeLightVectors_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, computeLightVectors);
   OBJECTFLAGS_SET_computeLightVectors(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::computeLightVectors_Prop & ObjectFlags::computeLightVectors_Prop::operator= (ObjectFlags::computeLightVectors_Prop & prop)
{
   SELF(ObjectFlags, computeLightVectors);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_computeLightVectors(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::computeLightVectors_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, computeLightVectors);
   return (bool)OBJECTFLAGS_computeLightVectors(self->impl);
}

// member accessors: ObjectFlags::skinApplied
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::skinApplied_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, skinApplied);
   OBJECTFLAGS_SET_skinApplied(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::skinApplied_Prop & ObjectFlags::skinApplied_Prop::operator= (ObjectFlags::skinApplied_Prop & prop)
{
   SELF(ObjectFlags, skinApplied);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_skinApplied(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::skinApplied_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, skinApplied);
   return (bool)OBJECTFLAGS_skinApplied(self->impl);
}

// member accessors: ObjectFlags::hide
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::hide_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, hide);
   OBJECTFLAGS_SET_hide(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::hide_Prop & ObjectFlags::hide_Prop::operator= (ObjectFlags::hide_Prop & prop)
{
   SELF(ObjectFlags, hide);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_hide(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::hide_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, hide);
   return (bool)OBJECTFLAGS_hide(self->impl);
}

// member accessors: ObjectFlags::skeleton
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::skeleton_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, skeleton);
   OBJECTFLAGS_SET_skeleton(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::skeleton_Prop & ObjectFlags::skeleton_Prop::operator= (ObjectFlags::skeleton_Prop & prop)
{
   SELF(ObjectFlags, skeleton);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_skeleton(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::skeleton_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, skeleton);
   return (bool)OBJECTFLAGS_skeleton(self->impl);
}

// member accessors: ObjectFlags::bone
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ObjectFlags::bone_Prop::operator= (/*0H*/bool v)
{
   SELF(ObjectFlags, bone);
   OBJECTFLAGS_SET_bone(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::bone_Prop & ObjectFlags::bone_Prop::operator= (ObjectFlags::bone_Prop & prop)
{
   SELF(ObjectFlags, bone);
   /*0H*/bool v = prop;
   OBJECTFLAGS_SET_bone(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::bone_Prop::operator /*0I*/bool () const
{
   SELF(ObjectFlags, bone);
   return (bool)OBJECTFLAGS_bone(self->impl);
}

// member accessors: ObjectFlags::hierarchy
// (bits::int)

/*nstSet*/inline /*0H*/int ObjectFlags::hierarchy_Prop::operator= (/*0H*/int v)
{
   SELF(ObjectFlags, hierarchy);
   OBJECTFLAGS_SET_hierarchy(self->impl, v);
   return v;
}

/*regSet*/inline ObjectFlags::hierarchy_Prop & ObjectFlags::hierarchy_Prop::operator= (ObjectFlags::hierarchy_Prop & prop)
{
   SELF(ObjectFlags, hierarchy);
   /*0H*/int v = prop;
   OBJECTFLAGS_SET_hierarchy(self->impl, v);
   return prop;
}
/*regGet*/inline ObjectFlags::hierarchy_Prop::operator /*0I*/int () const
{
   SELF(ObjectFlags, hierarchy);
   return OBJECTFLAGS_hierarchy(self->impl);
}

inline ObjectFormat::ObjectFormat_load_Functor::FunctionType ObjectFormat::ObjectFormat_load_Functor::operator= (FunctionType func)
{
   SELF(ObjectFormat, load);
   if(self->vTbl == ObjectFormat::_cpp_class.vTbl)
   {
      uint size = ObjectFormat::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ObjectFormat::ObjectFormat_load_Functor::FunctionType, size);
      memcpy(self->vTbl, ObjectFormat::_cpp_class.vTbl, sizeof(ObjectFormat::ObjectFormat_load_Functor::FunctionType) * size);
   }
   ((ObjectFormat::ObjectFormat_load_Functor::FunctionType *)self->vTbl)[M_VTBLID(ObjectFormat, load)] = func;
   return func;
}
inline bool ObjectFormat::ObjectFormat_load_Functor::operator()( /*6Fj*/Object object, /*6Fj*/const char * fileName, /*6Fj*/DisplaySystem & displaySystem, /*6Fj*/void * options)
{
   SELF(ObjectFormat, load);
   return (bool)ObjectFormat_load(self ? self->impl : (C(ObjectFormat))null, /*7Al*/object.impl, /*7Al*/fileName, /*7Al*/displaySystem.impl, /*7Al*/options);
}
// inline void ObjectFormat::register_load(CPPClass & cl, ObjectFormat::ObjectFormat_load_Functor::FunctionType func)
// {
//    ((ObjectFormat::ObjectFormat_load_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ObjectFormat, load)] = func;
// }

inline ObjectFormat::ObjectFormat_save_Functor::FunctionType ObjectFormat::ObjectFormat_save_Functor::operator= (FunctionType func)
{
   SELF(ObjectFormat, save);
   if(self->vTbl == ObjectFormat::_cpp_class.vTbl)
   {
      uint size = ObjectFormat::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ObjectFormat::ObjectFormat_save_Functor::FunctionType, size);
      memcpy(self->vTbl, ObjectFormat::_cpp_class.vTbl, sizeof(ObjectFormat::ObjectFormat_save_Functor::FunctionType) * size);
   }
   ((ObjectFormat::ObjectFormat_save_Functor::FunctionType *)self->vTbl)[M_VTBLID(ObjectFormat, save)] = func;
   return func;
}
inline bool ObjectFormat::ObjectFormat_save_Functor::operator()( /*6Fj*/Object object, /*6Fj*/const char * fileName, /*6Fj*/void * options)
{
   SELF(ObjectFormat, save);
   return (bool)ObjectFormat_save(self ? self->impl : (C(ObjectFormat))null, /*7Al*/object.impl, /*7Al*/fileName, /*7Al*/options);
}
// inline void ObjectFormat::register_save(CPPClass & cl, ObjectFormat::ObjectFormat_save_Functor::FunctionType func)
// {
//    ((ObjectFormat::ObjectFormat_save_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ObjectFormat, save)] = func;
// }

inline ObjectFormat::ObjectFormat_listTextures_Functor::FunctionType ObjectFormat::ObjectFormat_listTextures_Functor::operator= (FunctionType func)
{
   SELF(ObjectFormat, listTextures);
   if(self->vTbl == ObjectFormat::_cpp_class.vTbl)
   {
      uint size = ObjectFormat::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ObjectFormat::ObjectFormat_listTextures_Functor::FunctionType, size);
      memcpy(self->vTbl, ObjectFormat::_cpp_class.vTbl, sizeof(ObjectFormat::ObjectFormat_listTextures_Functor::FunctionType) * size);
   }
   ((ObjectFormat::ObjectFormat_listTextures_Functor::FunctionType *)self->vTbl)[M_VTBLID(ObjectFormat, listTextures)] = func;
   return func;
}
inline TArray<C(String) _ARG int _ARG C(String)> ObjectFormat::ObjectFormat_listTextures_Functor::operator()( /*6Fj*/File & f, /*6Fj*/const char * fileName, /*6Fj*/void * options)
{
   SELF(ObjectFormat, listTextures);
   C(Array) retArray = ObjectFormat_listTextures(self ? self->impl : (C(ObjectFormat))null, /*7Al*/f.impl, /*7Al*/fileName, /*7Al*/options);
      return TArray<C(String) _ARG int _ARG C(String)>(retArray);
}
// inline void ObjectFormat::register_listTextures(CPPClass & cl, ObjectFormat::ObjectFormat_listTextures_Functor::FunctionType func)
// {
//    ((ObjectFormat::ObjectFormat_listTextures_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ObjectFormat, listTextures)] = func;
// }


inline Plane::Plane(double a, double b = 0, double c = 0, Vector3D normal = Vector3D(), double d = 0)
{
   impl.a = a;
   impl.b = b;
   impl.c = c;
   impl.normal = normal.impl;
   impl.d = d;
}


inline void Plane::fromPointNormal(/*1Ab*/const Vector3D & normal, /*1Ab*/const Vector3D & point)
{
   Plane_fromPointNormal(&impl, /*5De*/&normal.impl, /*5De*/&point.impl);
}
inline void Plane::fromPointNormal(/*1Ac*/const Vector3D * normal, /*1Ac*/const Vector3D * point)
{
   Plane_fromPointNormal(&impl, /*5Cf*/(C(Vector3D) *)normal, /*5Cf*/(C(Vector3D) *)point);
}
inline void Plane::fromPoints(/*1Ab*/const Vector3D & v1, /*1Ab*/const Vector3D & v2, /*1Ab*/const Vector3D & v3)
{
   Plane_fromPoints(&impl, /*5De*/&v1.impl, /*5De*/&v2.impl, /*5De*/&v3.impl);
}
inline void Plane::fromPoints(/*1Ac*/const Vector3D * v1, /*1Ac*/const Vector3D * v2, /*1Ac*/const Vector3D * v3)
{
   Plane_fromPoints(&impl, /*5Cf*/(C(Vector3D) *)v1, /*5Cf*/(C(Vector3D) *)v2, /*5Cf*/(C(Vector3D) *)v3);
}
inline void Plane::fromPointsf(/*1Ab*/const Vector3Df & v1, /*1Ab*/const Vector3Df & v2, /*1Ab*/const Vector3Df & v3)
{
   Plane_fromPointsf(&impl, /*5De*/&v1.impl, /*5De*/&v2.impl, /*5De*/&v3.impl);
}
inline void Plane::fromPointsf(/*1Ac*/const Vector3Df * v1, /*1Ac*/const Vector3Df * v2, /*1Ac*/const Vector3Df * v3)
{
   Plane_fromPointsf(&impl, /*5Cf*/(C(Vector3Df) *)v1, /*5Cf*/(C(Vector3Df) *)v2, /*5Cf*/(C(Vector3Df) *)v3);
}
inline void Plane::intersectLine(/*1Ab*/const Line & line, /*1Ab*/Vector3D & result)
{
   Plane_intersectLine(&impl, /*5De*/&line.impl, /*5De*/&result.impl);
}
inline void Plane::intersectLine(/*1Ac*/const Line * line, /*1Ac*/Vector3D * result)
{
   Plane_intersectLine(&impl, /*5Cf*/(C(Line) *)line, /*5Cf*/(C(Vector3D) *)result);
}
inline void Plane::intersectLinef(/*1Ab*/const Line & line, /*1Ab*/Vector3Df & result)
{
   Plane_intersectLinef(&impl, /*5De*/&line.impl, /*5De*/&result.impl);
}
inline void Plane::intersectLinef(/*1Ac*/const Line * line, /*1Ac*/Vector3Df * result)
{
   Plane_intersectLinef(&impl, /*5Cf*/(C(Line) *)line, /*5Cf*/(C(Vector3Df) *)result);
}
inline int Plane::intersectLinefT(/*1Ab*/const Line & line, /*1Ab*/Vector3Df & result, /*1Ab*/double * rt)
{
   return Plane_intersectLinefT(&impl, /*5De*/&line.impl, /*5De*/&result.impl, /*5Ge*/rt);
}
inline int Plane::intersectLinefT(/*1Ac*/const Line * line, /*1Ac*/Vector3Df * result, /*1Ac*/double * rt)
{
   return Plane_intersectLinefT(&impl, /*5Cf*/(C(Line) *)line, /*5Cf*/(C(Vector3Df) *)result, /*5Gf*/rt);
}
inline void Plane::multMatrix(/*1Ab*/const Plane & source, /*1Ab*/const Matrix & inverseTranspose)
{
   Plane_multMatrix(&impl, /*5De*/&source.impl, /*5De*/&inverseTranspose.impl);
}
inline void Plane::multMatrix(/*1Ac*/const Plane * source, /*1Ac*/const Matrix * inverseTranspose)
{
   Plane_multMatrix(&impl, /*5Cf*/(C(Plane) *)source, /*5Cf*/(C(Matrix) *)inverseTranspose);
}


// member accessors: Plane::a
// (struct::double)

/*nstSet*/inline /*0H*/double Plane::a_Prop::operator= (/*0H*/double v)
{
   SELF(Plane, a);
   self->impl.a = v;
   return v;
}

/*regSet*/inline Plane::a_Prop & Plane::a_Prop::operator= (Plane::a_Prop & prop)
{
   SELF(Plane, a);
   /*0H*/double v = prop;
   self->impl.a = v;
   return prop;
}
/*regGet*/inline Plane::a_Prop::operator /*0I*/double () const
{
   SELF(Plane, a);
   return self ? ((C(Plane) *)&self->impl)->a : 0;
}

// member accessors: Plane::b
// (struct::double)

/*nstSet*/inline /*0H*/double Plane::b_Prop::operator= (/*0H*/double v)
{
   SELF(Plane, b);
   self->impl.b = v;
   return v;
}

/*regSet*/inline Plane::b_Prop & Plane::b_Prop::operator= (Plane::b_Prop & prop)
{
   SELF(Plane, b);
   /*0H*/double v = prop;
   self->impl.b = v;
   return prop;
}
/*regGet*/inline Plane::b_Prop::operator /*0I*/double () const
{
   SELF(Plane, b);
   return self ? ((C(Plane) *)&self->impl)->b : 0;
}

// member accessors: Plane::c
// (struct::double)

/*nstSet*/inline /*0H*/double Plane::c_Prop::operator= (/*0H*/double v)
{
   SELF(Plane, c);
   self->impl.c = v;
   return v;
}

/*regSet*/inline Plane::c_Prop & Plane::c_Prop::operator= (Plane::c_Prop & prop)
{
   SELF(Plane, c);
   /*0H*/double v = prop;
   self->impl.c = v;
   return prop;
}
/*regGet*/inline Plane::c_Prop::operator /*0I*/double () const
{
   SELF(Plane, c);
   return self ? ((C(Plane) *)&self->impl)->c : 0;
}

// member accessors: Plane::normal
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3D Plane::normal_Prop::operator= (/*0H*/Vector3D v)
{
   SELF(Plane, normal);
   self->impl.normal = v.impl;
   return v;
}

/*regSet*/inline Plane::normal_Prop & Plane::normal_Prop::operator= (Plane::normal_Prop & prop)
{
   SELF(Plane, normal);
   /*0H*/Vector3D v = prop;
   self->impl.normal = v.impl;
   return prop;
}
/*regGet*/inline Plane::normal_Prop::operator /*0I*/Vector3D () const
{
   SELF(Plane, normal);
   Vector3D value(((C(Plane) *)&self->impl)->normal);
   return value;
}

// member accessors: Plane::d
// (struct::double)

/*nstSet*/inline /*0H*/double Plane::d_Prop::operator= (/*0H*/double v)
{
   SELF(Plane, d);
   self->impl.d = v;
   return v;
}

/*regSet*/inline Plane::d_Prop & Plane::d_Prop::operator= (Plane::d_Prop & prop)
{
   SELF(Plane, d);
   /*0H*/double v = prop;
   self->impl.d = v;
   return prop;
}
/*regGet*/inline Plane::d_Prop::operator /*0I*/double () const
{
   SELF(Plane, d);
   return self ? ((C(Plane) *)&self->impl)->d : 0;
}



// member accessors: PrimitiveGroup::prev
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/PrimitiveGroup TPrimitiveGroup<TC, TCO>::prev_Prop::operator= (/*0H*/PrimitiveGroup & v)
{
   SELF(PrimitiveGroup, prev);
   ((C(PrimitiveGroup) *)self->impl)->prev = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::prev_Prop & TPrimitiveGroup<TC, TCO>::prev_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::prev_Prop & prop)
{
   SELF(PrimitiveGroup, prev);
   /*0H*/PrimitiveGroup v = prop;
   ((C(PrimitiveGroup) *)self->impl)->prev = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::prev_Prop::operator /*0I*/PrimitiveGroup () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, prev);
   PrimitiveGroup value(((C(PrimitiveGroup) *)self->impl)->prev);
   return value;
}

// member accessors: PrimitiveGroup::next
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/PrimitiveGroup TPrimitiveGroup<TC, TCO>::next_Prop::operator= (/*0H*/PrimitiveGroup & v)
{
   SELF(PrimitiveGroup, next);
   ((C(PrimitiveGroup) *)self->impl)->next = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::next_Prop & TPrimitiveGroup<TC, TCO>::next_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::next_Prop & prop)
{
   SELF(PrimitiveGroup, next);
   /*0H*/PrimitiveGroup v = prop;
   ((C(PrimitiveGroup) *)self->impl)->next = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::next_Prop::operator /*0I*/PrimitiveGroup () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, next);
   PrimitiveGroup value(((C(PrimitiveGroup) *)self->impl)->next);
   return value;
}

// member accessors: PrimitiveGroup::type
// (nohead::bits|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/PrimitiveGroupType TPrimitiveGroup<TC, TCO>::type_Prop::operator= (/*0H*/PrimitiveGroupType v)
{
   SELF(PrimitiveGroup, type);
   ((C(PrimitiveGroup) *)self->impl)->type = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::type_Prop & TPrimitiveGroup<TC, TCO>::type_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::type_Prop & prop)
{
   SELF(PrimitiveGroup, type);
   /*0H*/PrimitiveGroupType v = prop;
   ((C(PrimitiveGroup) *)self->impl)->type = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::type_Prop::operator /*0I*/PrimitiveGroupType () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, type);
   return self ? ((C(PrimitiveGroup) *)self->impl)->type : PrimitiveGroupType();
}

// member accessors: PrimitiveGroup::baseIndexMesh
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TPrimitiveGroup<TC, TCO>::baseIndexMesh_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveGroup, baseIndexMesh);
   ((C(PrimitiveGroup) *)self->impl)->baseIndexMesh = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::baseIndexMesh_Prop & TPrimitiveGroup<TC, TCO>::baseIndexMesh_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::baseIndexMesh_Prop & prop)
{
   SELF(PrimitiveGroup, baseIndexMesh);
   /*0H*/int v = prop;
   ((C(PrimitiveGroup) *)self->impl)->baseIndexMesh = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::baseIndexMesh_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, baseIndexMesh);
   return self ? ((C(PrimitiveGroup) *)self->impl)->baseIndexMesh : 0;
}

// member accessors: PrimitiveGroup::baseIndexBuffer
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TPrimitiveGroup<TC, TCO>::baseIndexBuffer_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveGroup, baseIndexBuffer);
   ((C(PrimitiveGroup) *)self->impl)->baseIndexBuffer = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::baseIndexBuffer_Prop & TPrimitiveGroup<TC, TCO>::baseIndexBuffer_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::baseIndexBuffer_Prop & prop)
{
   SELF(PrimitiveGroup, baseIndexBuffer);
   /*0H*/int v = prop;
   ((C(PrimitiveGroup) *)self->impl)->baseIndexBuffer = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::baseIndexBuffer_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, baseIndexBuffer);
   return self ? ((C(PrimitiveGroup) *)self->impl)->baseIndexBuffer : 0;
}

// member accessors: PrimitiveGroup::indices
// (nohead::uint16 *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint16 * TPrimitiveGroup<TC, TCO>::indices_Prop::operator= (/*0H*/uint16 * v)
{
   SELF(PrimitiveGroup, indices);
   ((C(PrimitiveGroup) *)self->impl)->indices = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::indices_Prop & TPrimitiveGroup<TC, TCO>::indices_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::indices_Prop & prop)
{
   SELF(PrimitiveGroup, indices);
   /*0H*/uint16 * v = prop;
   ((C(PrimitiveGroup) *)self->impl)->indices = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::indices_Prop::operator /*0I*/uint16 * () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, indices);
   return self ? ((C(PrimitiveGroup) *)self->impl)->indices : null;
}

// member accessors: PrimitiveGroup::indices32
// (nohead::uint *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint * TPrimitiveGroup<TC, TCO>::indices32_Prop::operator= (/*0H*/uint * v)
{
   SELF(PrimitiveGroup, indices32);
   ((C(PrimitiveGroup) *)self->impl)->indices32 = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::indices32_Prop & TPrimitiveGroup<TC, TCO>::indices32_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::indices32_Prop & prop)
{
   SELF(PrimitiveGroup, indices32);
   /*0H*/uint * v = prop;
   ((C(PrimitiveGroup) *)self->impl)->indices32 = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::indices32_Prop::operator /*0I*/uint * () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, indices32);
   return self ? ((C(PrimitiveGroup) *)self->impl)->indices32 : null;
}

// member accessors: PrimitiveGroup::nIndices
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TPrimitiveGroup<TC, TCO>::nIndices_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveGroup, nIndices);
   ((C(PrimitiveGroup) *)self->impl)->nIndices = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::nIndices_Prop & TPrimitiveGroup<TC, TCO>::nIndices_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::nIndices_Prop & prop)
{
   SELF(PrimitiveGroup, nIndices);
   /*0H*/int v = prop;
   ((C(PrimitiveGroup) *)self->impl)->nIndices = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::nIndices_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, nIndices);
   return self ? ((C(PrimitiveGroup) *)self->impl)->nIndices : 0;
}

// member accessors: PrimitiveGroup::first
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TPrimitiveGroup<TC, TCO>::first_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveGroup, first);
   ((C(PrimitiveGroup) *)self->impl)->first = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::first_Prop & TPrimitiveGroup<TC, TCO>::first_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::first_Prop & prop)
{
   SELF(PrimitiveGroup, first);
   /*0H*/int v = prop;
   ((C(PrimitiveGroup) *)self->impl)->first = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::first_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, first);
   return self ? ((C(PrimitiveGroup) *)self->impl)->first : 0;
}

// member accessors: PrimitiveGroup::nVertices
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TPrimitiveGroup<TC, TCO>::nVertices_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveGroup, nVertices);
   ((C(PrimitiveGroup) *)self->impl)->nVertices = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::nVertices_Prop & TPrimitiveGroup<TC, TCO>::nVertices_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::nVertices_Prop & prop)
{
   SELF(PrimitiveGroup, nVertices);
   /*0H*/int v = prop;
   ((C(PrimitiveGroup) *)self->impl)->nVertices = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::nVertices_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, nVertices);
   return self ? ((C(PrimitiveGroup) *)self->impl)->nVertices : 0;
}

// member accessors: PrimitiveGroup::material
// (nohead::nohead)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/Material TPrimitiveGroup<TC, TCO>::material_Prop::operator= (/*0H*/Material & v)
{
   SELF(PrimitiveGroup, material);
   ((C(PrimitiveGroup) *)self->impl)->material = v.impl;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPrimitiveGroup<TC, TCO>::material_Prop & TPrimitiveGroup<TC, TCO>::material_Prop::operator= (typename TPrimitiveGroup<TC, TCO>::material_Prop & prop)
{
   SELF(PrimitiveGroup, material);
   /*0H*/Material v = prop;
   ((C(PrimitiveGroup) *)self->impl)->material = v.impl;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPrimitiveGroup<TC, TCO>::material_Prop::operator /*0I*/Material () const
{
   __attribute__((unused)) TPrimitiveGroup TCTCO * self = CONTAINER_OF(this, TPrimitiveGroup TCTCO, material);
   Material value(((C(PrimitiveGroup) *)self->impl)->material);
   return value;
}



// member accessors: PrimitiveGroupType::primitiveType
// (bits::enum|uint)

/*nstSet*/inline /*0H*/RenderPrimitiveType PrimitiveGroupType::primitiveType_Prop::operator= (/*0H*/RenderPrimitiveType v)
{
   SELF(PrimitiveGroupType, primitiveType);
   PRIMITIVEGROUPTYPE_SET_primitiveType(self->impl, v);
   return v;
}

/*regSet*/inline PrimitiveGroupType::primitiveType_Prop & PrimitiveGroupType::primitiveType_Prop::operator= (PrimitiveGroupType::primitiveType_Prop & prop)
{
   SELF(PrimitiveGroupType, primitiveType);
   /*0H*/RenderPrimitiveType v = prop;
   PRIMITIVEGROUPTYPE_SET_primitiveType(self->impl, v);
   return prop;
}
/*regGet*/inline PrimitiveGroupType::primitiveType_Prop::operator /*0I*/RenderPrimitiveType () const
{
   SELF(PrimitiveGroupType, primitiveType);
   return (RenderPrimitiveType)PRIMITIVEGROUPTYPE_primitiveType(self->impl);
}

// member accessors: PrimitiveGroupType::vertexRange
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PrimitiveGroupType::vertexRange_Prop::operator= (/*0H*/bool v)
{
   SELF(PrimitiveGroupType, vertexRange);
   PRIMITIVEGROUPTYPE_SET_vertexRange(self->impl, v);
   return v;
}

/*regSet*/inline PrimitiveGroupType::vertexRange_Prop & PrimitiveGroupType::vertexRange_Prop::operator= (PrimitiveGroupType::vertexRange_Prop & prop)
{
   SELF(PrimitiveGroupType, vertexRange);
   /*0H*/bool v = prop;
   PRIMITIVEGROUPTYPE_SET_vertexRange(self->impl, v);
   return prop;
}
/*regGet*/inline PrimitiveGroupType::vertexRange_Prop::operator /*0I*/bool () const
{
   SELF(PrimitiveGroupType, vertexRange);
   return (bool)PRIMITIVEGROUPTYPE_vertexRange(self->impl);
}

// member accessors: PrimitiveGroupType::indices32bit
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PrimitiveGroupType::indices32bit_Prop::operator= (/*0H*/bool v)
{
   SELF(PrimitiveGroupType, indices32bit);
   PRIMITIVEGROUPTYPE_SET_indices32bit(self->impl, v);
   return v;
}

/*regSet*/inline PrimitiveGroupType::indices32bit_Prop & PrimitiveGroupType::indices32bit_Prop::operator= (PrimitiveGroupType::indices32bit_Prop & prop)
{
   SELF(PrimitiveGroupType, indices32bit);
   /*0H*/bool v = prop;
   PRIMITIVEGROUPTYPE_SET_indices32bit(self->impl, v);
   return prop;
}
/*regGet*/inline PrimitiveGroupType::indices32bit_Prop::operator /*0I*/bool () const
{
   SELF(PrimitiveGroupType, indices32bit);
   return (bool)PRIMITIVEGROUPTYPE_indices32bit(self->impl);
}

// member accessors: PrimitiveGroupType::sharedIndices
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PrimitiveGroupType::sharedIndices_Prop::operator= (/*0H*/bool v)
{
   SELF(PrimitiveGroupType, sharedIndices);
   PRIMITIVEGROUPTYPE_SET_sharedIndices(self->impl, v);
   return v;
}

/*regSet*/inline PrimitiveGroupType::sharedIndices_Prop & PrimitiveGroupType::sharedIndices_Prop::operator= (PrimitiveGroupType::sharedIndices_Prop & prop)
{
   SELF(PrimitiveGroupType, sharedIndices);
   /*0H*/bool v = prop;
   PRIMITIVEGROUPTYPE_SET_sharedIndices(self->impl, v);
   return prop;
}
/*regGet*/inline PrimitiveGroupType::sharedIndices_Prop::operator /*0I*/bool () const
{
   SELF(PrimitiveGroupType, sharedIndices);
   return (bool)PRIMITIVEGROUPTYPE_sharedIndices(self->impl);
}

// member accessors: PrimitiveGroupType::hide
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PrimitiveGroupType::hide_Prop::operator= (/*0H*/bool v)
{
   SELF(PrimitiveGroupType, hide);
   PRIMITIVEGROUPTYPE_SET_hide(self->impl, v);
   return v;
}

/*regSet*/inline PrimitiveGroupType::hide_Prop & PrimitiveGroupType::hide_Prop::operator= (PrimitiveGroupType::hide_Prop & prop)
{
   SELF(PrimitiveGroupType, hide);
   /*0H*/bool v = prop;
   PRIMITIVEGROUPTYPE_SET_hide(self->impl, v);
   return prop;
}
/*regGet*/inline PrimitiveGroupType::hide_Prop::operator /*0I*/bool () const
{
   SELF(PrimitiveGroupType, hide);
   return (bool)PRIMITIVEGROUPTYPE_hide(self->impl);
}

inline PrimitiveSingle::PrimitiveSingle(PrimitiveGroupType type, int baseIndexMesh = 0, int baseIndexBuffer = 0, uint16 * indices = null, uint * indices32 = null, int nIndices = 0, int first = 0, int nVertices = 0)
{
   impl.type = type;
   impl.baseIndexMesh = baseIndexMesh;
   impl.baseIndexBuffer = baseIndexBuffer;
   impl.indices = indices;
   impl.indices32 = indices32;
   impl.nIndices = nIndices;
   impl.first = first;
   impl.nVertices = nVertices;
}



// member accessors: PrimitiveSingle::type
// (struct::bits|uint)

/*nstSet*/inline /*0H*/PrimitiveGroupType PrimitiveSingle::type_Prop::operator= (/*0H*/PrimitiveGroupType v)
{
   SELF(PrimitiveSingle, type);
   self->impl.type = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::type_Prop & PrimitiveSingle::type_Prop::operator= (PrimitiveSingle::type_Prop & prop)
{
   SELF(PrimitiveSingle, type);
   /*0H*/PrimitiveGroupType v = prop;
   self->impl.type = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::type_Prop::operator /*0I*/PrimitiveGroupType () const
{
   SELF(PrimitiveSingle, type);
   return self ? PrimitiveGroupType(((C(PrimitiveSingle) *)&self->impl)->type) : PrimitiveGroupType();
}

// member accessors: PrimitiveSingle::baseIndexMesh
// (struct::int)

/*nstSet*/inline /*0H*/int PrimitiveSingle::baseIndexMesh_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveSingle, baseIndexMesh);
   self->impl.baseIndexMesh = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::baseIndexMesh_Prop & PrimitiveSingle::baseIndexMesh_Prop::operator= (PrimitiveSingle::baseIndexMesh_Prop & prop)
{
   SELF(PrimitiveSingle, baseIndexMesh);
   /*0H*/int v = prop;
   self->impl.baseIndexMesh = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::baseIndexMesh_Prop::operator /*0I*/int () const
{
   SELF(PrimitiveSingle, baseIndexMesh);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->baseIndexMesh : 0;
}

// member accessors: PrimitiveSingle::baseIndexBuffer
// (struct::int)

/*nstSet*/inline /*0H*/int PrimitiveSingle::baseIndexBuffer_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveSingle, baseIndexBuffer);
   self->impl.baseIndexBuffer = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::baseIndexBuffer_Prop & PrimitiveSingle::baseIndexBuffer_Prop::operator= (PrimitiveSingle::baseIndexBuffer_Prop & prop)
{
   SELF(PrimitiveSingle, baseIndexBuffer);
   /*0H*/int v = prop;
   self->impl.baseIndexBuffer = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::baseIndexBuffer_Prop::operator /*0I*/int () const
{
   SELF(PrimitiveSingle, baseIndexBuffer);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->baseIndexBuffer : 0;
}

// member accessors: PrimitiveSingle::indices
// (struct::uint16 *)

/*nstSet*/inline /*0H*/uint16 * PrimitiveSingle::indices_Prop::operator= (/*0H*/uint16 * v)
{
   SELF(PrimitiveSingle, indices);
   self->impl.indices = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::indices_Prop & PrimitiveSingle::indices_Prop::operator= (PrimitiveSingle::indices_Prop & prop)
{
   SELF(PrimitiveSingle, indices);
   /*0H*/uint16 * v = prop;
   self->impl.indices = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::indices_Prop::operator /*0I*/uint16 * () const
{
   SELF(PrimitiveSingle, indices);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->indices : null;
}

// member accessors: PrimitiveSingle::indices32
// (struct::uint *)

/*nstSet*/inline /*0H*/uint * PrimitiveSingle::indices32_Prop::operator= (/*0H*/uint * v)
{
   SELF(PrimitiveSingle, indices32);
   self->impl.indices32 = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::indices32_Prop & PrimitiveSingle::indices32_Prop::operator= (PrimitiveSingle::indices32_Prop & prop)
{
   SELF(PrimitiveSingle, indices32);
   /*0H*/uint * v = prop;
   self->impl.indices32 = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::indices32_Prop::operator /*0I*/uint * () const
{
   SELF(PrimitiveSingle, indices32);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->indices32 : null;
}

// member accessors: PrimitiveSingle::nIndices
// (struct::int)

/*nstSet*/inline /*0H*/int PrimitiveSingle::nIndices_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveSingle, nIndices);
   self->impl.nIndices = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::nIndices_Prop & PrimitiveSingle::nIndices_Prop::operator= (PrimitiveSingle::nIndices_Prop & prop)
{
   SELF(PrimitiveSingle, nIndices);
   /*0H*/int v = prop;
   self->impl.nIndices = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::nIndices_Prop::operator /*0I*/int () const
{
   SELF(PrimitiveSingle, nIndices);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->nIndices : 0;
}

// member accessors: PrimitiveSingle::first
// (struct::int)

/*nstSet*/inline /*0H*/int PrimitiveSingle::first_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveSingle, first);
   self->impl.first = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::first_Prop & PrimitiveSingle::first_Prop::operator= (PrimitiveSingle::first_Prop & prop)
{
   SELF(PrimitiveSingle, first);
   /*0H*/int v = prop;
   self->impl.first = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::first_Prop::operator /*0I*/int () const
{
   SELF(PrimitiveSingle, first);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->first : 0;
}

// member accessors: PrimitiveSingle::nVertices
// (struct::int)

/*nstSet*/inline /*0H*/int PrimitiveSingle::nVertices_Prop::operator= (/*0H*/int v)
{
   SELF(PrimitiveSingle, nVertices);
   self->impl.nVertices = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::nVertices_Prop & PrimitiveSingle::nVertices_Prop::operator= (PrimitiveSingle::nVertices_Prop & prop)
{
   SELF(PrimitiveSingle, nVertices);
   /*0H*/int v = prop;
   self->impl.nVertices = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::nVertices_Prop::operator /*0I*/int () const
{
   SELF(PrimitiveSingle, nVertices);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->nVertices : 0;
}

// member accessors: PrimitiveSingle::material
// (struct::nohead)

/*nstSet*/inline /*0H*/Material PrimitiveSingle::material_Prop::operator= (/*0H*/Material & v)
{
   SELF(PrimitiveSingle, material);
   self->impl.material = v.impl;
   return v;
}

/*regSet*/inline PrimitiveSingle::material_Prop & PrimitiveSingle::material_Prop::operator= (PrimitiveSingle::material_Prop & prop)
{
   SELF(PrimitiveSingle, material);
   /*0H*/Material v = prop;
   self->impl.material = v.impl;
   return prop;
}
/*regGet*/inline PrimitiveSingle::material_Prop::operator /*0I*/Material () const
{
   SELF(PrimitiveSingle, material);
   Material value(((C(PrimitiveSingle) *)&self->impl)->material);
   return value;
}

// member accessors: PrimitiveSingle::data
// (struct::void *)

/*nstSet*/inline /*0H*/void * PrimitiveSingle::data_Prop::operator= (/*0H*/void * v)
{
   SELF(PrimitiveSingle, data);
   self->impl.data = v;
   return v;
}

/*regSet*/inline PrimitiveSingle::data_Prop & PrimitiveSingle::data_Prop::operator= (PrimitiveSingle::data_Prop & prop)
{
   SELF(PrimitiveSingle, data);
   /*0H*/void * v = prop;
   self->impl.data = v;
   return prop;
}
/*regGet*/inline PrimitiveSingle::data_Prop::operator /*0I*/void * () const
{
   SELF(PrimitiveSingle, data);
   return self ? ((C(PrimitiveSingle) *)&self->impl)->data : null;
}

// member accessors: PrimitiveSingle::middle
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3Df PrimitiveSingle::middle_Prop::operator= (/*0H*/Vector3Df v)
{
   SELF(PrimitiveSingle, middle);
   self->impl.middle = v.impl;
   return v;
}

/*regSet*/inline PrimitiveSingle::middle_Prop & PrimitiveSingle::middle_Prop::operator= (PrimitiveSingle::middle_Prop & prop)
{
   SELF(PrimitiveSingle, middle);
   /*0H*/Vector3Df v = prop;
   self->impl.middle = v.impl;
   return prop;
}
/*regGet*/inline PrimitiveSingle::middle_Prop::operator /*0I*/Vector3Df () const
{
   SELF(PrimitiveSingle, middle);
   Vector3Df value(((C(PrimitiveSingle) *)&self->impl)->middle);
   return value;
}

// member accessors: PrimitiveSingle::plane
// (struct::struct)

/*nstSet*/inline /*0H*/Plane PrimitiveSingle::plane_Prop::operator= (/*0H*/Plane v)
{
   SELF(PrimitiveSingle, plane);
   self->impl.plane = v.impl;
   return v;
}

/*regSet*/inline PrimitiveSingle::plane_Prop & PrimitiveSingle::plane_Prop::operator= (PrimitiveSingle::plane_Prop & prop)
{
   SELF(PrimitiveSingle, plane);
   /*0H*/Plane v = prop;
   self->impl.plane = v.impl;
   return prop;
}
/*regGet*/inline PrimitiveSingle::plane_Prop::operator /*0I*/Plane () const
{
   SELF(PrimitiveSingle, plane);
   Plane value(((C(PrimitiveSingle) *)&self->impl)->plane);
   return value;
}

inline Quaternion::Quaternion(double w, double x = 0, double y = 0, double z = 0)
{
   impl.w = w;
   impl.x = x;
   impl.y = y;
   impl.z = z;
}


inline void Quaternion::divide(/*1Ab*/const Quaternion & q1, /*1Ab*/const Quaternion & q2)
{
   Quaternion_divide(&impl, /*5De*/&q1.impl, /*5De*/&q2.impl);
}
inline void Quaternion::divide(/*1Ac*/const Quaternion * q1, /*1Ac*/const Quaternion * q2)
{
   Quaternion_divide(&impl, /*5Cf*/(C(Quaternion) *)q1, /*5Cf*/(C(Quaternion) *)q2);
}
inline void Quaternion::identity()
{
   Quaternion_identity(&impl);
}
inline void Quaternion::inverse(/*1Ab*/const Quaternion & source)
{
   Quaternion_inverse(&impl, /*5De*/&source.impl);
}
inline void Quaternion::inverse(/*1Ac*/const Quaternion * source)
{
   Quaternion_inverse(&impl, /*5Cf*/(C(Quaternion) *)source);
}
inline void Quaternion::multiply(/*1Ab*/const Quaternion & q1, /*1Ab*/const Quaternion & q2)
{
   Quaternion_multiply(&impl, /*5De*/&q1.impl, /*5De*/&q2.impl);
}
inline void Quaternion::multiply(/*1Ac*/const Quaternion * q1, /*1Ac*/const Quaternion * q2)
{
   Quaternion_multiply(&impl, /*5Cf*/(C(Quaternion) *)q1, /*5Cf*/(C(Quaternion) *)q2);
}
inline void Quaternion::normalize(/*1Ab*/const Quaternion & source)
{
   Quaternion_normalize(&impl, /*5De*/&source.impl);
}
inline void Quaternion::normalize(/*1Ac*/const Quaternion * source)
{
   Quaternion_normalize(&impl, /*5Cf*/(C(Quaternion) *)source);
}
inline void Quaternion::pitch(/*1Ab*/Angle angle)
{
   Quaternion_pitch(&impl, /*5Ee*/(C(Angle))angle.impl);
}
inline void Quaternion::roll(/*1Ab*/Angle angle)
{
   Quaternion_roll(&impl, /*5Ee*/(C(Angle))angle.impl);
}
inline void Quaternion::rotatePitch(/*1Ab*/Angle pitch)
{
   Quaternion_rotatePitch(&impl, /*5Ee*/(C(Angle))pitch.impl);
}
inline void Quaternion::rotateRoll(/*1Ab*/Angle roll)
{
   Quaternion_rotateRoll(&impl, /*5Ee*/(C(Angle))roll.impl);
}
inline void Quaternion::rotateYaw(/*1Ab*/Angle yaw)
{
   Quaternion_rotateYaw(&impl, /*5Ee*/(C(Angle))yaw.impl);
}
inline void Quaternion::rotateYawPitch(/*1Ab*/Angle yaw, /*1Ab*/Angle pitch)
{
   Quaternion_rotateYawPitch(&impl, /*5Ee*/(C(Angle))yaw.impl, /*5Ee*/(C(Angle))pitch.impl);
}
inline void Quaternion::rotationAxis(/*1Ab*/const Vector3D & axis, /*1Ab*/Angle angle)
{
   Quaternion_rotationAxis(&impl, /*5De*/&axis.impl, /*5Ee*/(C(Angle))angle.impl);
}
inline void Quaternion::rotationAxis(/*1Ac*/const Vector3D * axis, /*1Ac*/Angle angle)
{
   Quaternion_rotationAxis(&impl, /*5Cf*/(C(Vector3D) *)axis, /*5Ef*/(C(Angle))angle.impl);
}
inline void Quaternion::rotationDirection(/*1Ab*/const Vector3D & direction)
{
   Quaternion_rotationDirection(&impl, /*5De*/&direction.impl);
}
inline void Quaternion::rotationDirection(/*1Ac*/const Vector3D * direction)
{
   Quaternion_rotationDirection(&impl, /*5Cf*/(C(Vector3D) *)direction);
}
inline void Quaternion::rotationEuler(/*1Ab*/const Euler & euler, /*1Ab*/EulerRotationOrder rotationOrder)
{
   Quaternion_rotationEuler(&impl, /*5De*/&euler.impl, /*5Ee*/(C(EulerRotationOrder))rotationOrder);
}
inline void Quaternion::rotationEuler(/*1Ac*/const Euler * euler, /*1Ac*/EulerRotationOrder rotationOrder)
{
   Quaternion_rotationEuler(&impl, /*5Cf*/(C(Euler) *)euler, /*5Ef*/(C(EulerRotationOrder))rotationOrder);
}
inline void Quaternion::rotationMatrix(/*1Ab*/const Matrix & m)
{
   Quaternion_rotationMatrix(&impl, /*5De*/&m.impl);
}
inline void Quaternion::rotationMatrix(/*1Ac*/const Matrix * m)
{
   Quaternion_rotationMatrix(&impl, /*5Cf*/(C(Matrix) *)m);
}
inline void Quaternion::rotationYawPitchRoll(/*1Ab*/const Euler & euler)
{
   Quaternion_rotationYawPitchRoll(&impl, /*5De*/&euler.impl);
}
inline void Quaternion::rotationYawPitchRoll(/*1Ac*/const Euler * euler)
{
   Quaternion_rotationYawPitchRoll(&impl, /*5Cf*/(C(Euler) *)euler);
}
inline void Quaternion::slerp(/*1Ab*/const Quaternion & from, /*1Ab*/const Quaternion & to, /*1Ab*/float t)
{
   Quaternion_slerp(&impl, /*5De*/&from.impl, /*5De*/&to.impl, /*5Ge*/t);
}
inline void Quaternion::slerp(/*1Ac*/const Quaternion * from, /*1Ac*/const Quaternion * to, /*1Ac*/float t)
{
   Quaternion_slerp(&impl, /*5Cf*/(C(Quaternion) *)from, /*5Cf*/(C(Quaternion) *)to, /*5Gf*/t);
}
inline void Quaternion::toDirection(/*1Ab*/Vector3D & direction)
{
   Quaternion_toDirection(&impl, /*5De*/&direction.impl);
}
inline void Quaternion::toDirection(/*1Ac*/Vector3D * direction)
{
   Quaternion_toDirection(&impl, /*5Cf*/(C(Vector3D) *)direction);
}
inline void Quaternion::yaw(/*1Ab*/Angle angle)
{
   Quaternion_yaw(&impl, /*5Ee*/(C(Angle))angle.impl);
}
inline void Quaternion::yawPitch(/*1Ab*/Angle yaw, /*1Ab*/Angle pitch)
{
   Quaternion_yawPitch(&impl, /*5Ee*/(C(Angle))yaw.impl, /*5Ee*/(C(Angle))pitch.impl);
}
inline void Quaternion::rotateQuats(/*1Ab*/const Quaternion & qPitch, /*1Ab*/const Quaternion & qYaw, /*1Ab*/const Quaternion & qRoll, /*1Ab*/EulerRotationOrder rotationOrder)
{
   Quaternion_rotateQuats(&impl, /*5De*/&qPitch.impl, /*5De*/&qYaw.impl, /*5De*/&qRoll.impl, /*5Ee*/(C(EulerRotationOrder))rotationOrder);
}
inline void Quaternion::rotateQuats(/*1Ac*/const Quaternion * qPitch, /*1Ac*/const Quaternion * qYaw, /*1Ac*/const Quaternion * qRoll, /*1Ac*/EulerRotationOrder rotationOrder)
{
   Quaternion_rotateQuats(&impl, /*5Cf*/(C(Quaternion) *)qPitch, /*5Cf*/(C(Quaternion) *)qYaw, /*5Cf*/(C(Quaternion) *)qRoll, /*5Ef*/(C(EulerRotationOrder))rotationOrder);
}


// member accessors: Quaternion::w
// (struct::double)

/*nstSet*/inline /*0H*/double Quaternion::w_Prop::operator= (/*0H*/double v)
{
   SELF(Quaternion, w);
   self->impl.w = v;
   return v;
}

/*regSet*/inline Quaternion::w_Prop & Quaternion::w_Prop::operator= (Quaternion::w_Prop & prop)
{
   SELF(Quaternion, w);
   /*0H*/double v = prop;
   self->impl.w = v;
   return prop;
}
/*regGet*/inline Quaternion::w_Prop::operator /*0I*/double () const
{
   SELF(Quaternion, w);
   return self ? ((C(Quaternion) *)&self->impl)->w : 0;
}

// member accessors: Quaternion::x
// (struct::double)

/*nstSet*/inline /*0H*/double Quaternion::x_Prop::operator= (/*0H*/double v)
{
   SELF(Quaternion, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline Quaternion::x_Prop & Quaternion::x_Prop::operator= (Quaternion::x_Prop & prop)
{
   SELF(Quaternion, x);
   /*0H*/double v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline Quaternion::x_Prop::operator /*0I*/double () const
{
   SELF(Quaternion, x);
   return self ? ((C(Quaternion) *)&self->impl)->x : 0;
}

// member accessors: Quaternion::y
// (struct::double)

/*nstSet*/inline /*0H*/double Quaternion::y_Prop::operator= (/*0H*/double v)
{
   SELF(Quaternion, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline Quaternion::y_Prop & Quaternion::y_Prop::operator= (Quaternion::y_Prop & prop)
{
   SELF(Quaternion, y);
   /*0H*/double v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline Quaternion::y_Prop::operator /*0I*/double () const
{
   SELF(Quaternion, y);
   return self ? ((C(Quaternion) *)&self->impl)->y : 0;
}

// member accessors: Quaternion::z
// (struct::double)

/*nstSet*/inline /*0H*/double Quaternion::z_Prop::operator= (/*0H*/double v)
{
   SELF(Quaternion, z);
   self->impl.z = v;
   return v;
}

/*regSet*/inline Quaternion::z_Prop & Quaternion::z_Prop::operator= (Quaternion::z_Prop & prop)
{
   SELF(Quaternion, z);
   /*0H*/double v = prop;
   self->impl.z = v;
   return prop;
}
/*regGet*/inline Quaternion::z_Prop::operator /*0I*/double () const
{
   SELF(Quaternion, z);
   return self ? ((C(Quaternion) *)&self->impl)->z : 0;
}

inline SkinBone::SkinBone(char * name, Matrix invBindMatrix = Matrix(), Matrix bsInvBindMatrix = Matrix())
{
   impl.name = name;
   impl.invBindMatrix = invBindMatrix.impl;
   impl.bsInvBindMatrix = bsInvBindMatrix.impl;
}



// member accessors: SkinBone::name
// (struct::string)

/*nstSet*/inline /*0H*/char * SkinBone::name_Prop::operator= (/*0H*/char * v)
{
   SELF(SkinBone, name);
   self->impl.name = v;
   return v;
}

/*regSet*/inline SkinBone::name_Prop & SkinBone::name_Prop::operator= (SkinBone::name_Prop & prop)
{
   SELF(SkinBone, name);
   /*0H*/char * v = prop;
   self->impl.name = v;
   return prop;
}
/*regGet*/inline SkinBone::name_Prop::operator /*0I*/char * () const
{
   SELF(SkinBone, name);
   return self ? ((C(SkinBone) *)&self->impl)->name : 0;
}

// member accessors: SkinBone::invBindMatrix
// (struct::struct)

/*nstSet*/inline /*0H*/Matrix SkinBone::invBindMatrix_Prop::operator= (/*0H*/Matrix v)
{
   SELF(SkinBone, invBindMatrix);
   self->impl.invBindMatrix = v.impl;
   return v;
}

/*regSet*/inline SkinBone::invBindMatrix_Prop & SkinBone::invBindMatrix_Prop::operator= (SkinBone::invBindMatrix_Prop & prop)
{
   SELF(SkinBone, invBindMatrix);
   /*0H*/Matrix v = prop;
   self->impl.invBindMatrix = v.impl;
   return prop;
}
/*regGet*/inline SkinBone::invBindMatrix_Prop::operator /*0I*/Matrix () const
{
   SELF(SkinBone, invBindMatrix);
   Matrix value(((C(SkinBone) *)&self->impl)->invBindMatrix);
   return value;
}

// member accessors: SkinBone::bsInvBindMatrix
// (struct::struct)

/*nstSet*/inline /*0H*/Matrix SkinBone::bsInvBindMatrix_Prop::operator= (/*0H*/Matrix v)
{
   SELF(SkinBone, bsInvBindMatrix);
   self->impl.bsInvBindMatrix = v.impl;
   return v;
}

/*regSet*/inline SkinBone::bsInvBindMatrix_Prop & SkinBone::bsInvBindMatrix_Prop::operator= (SkinBone::bsInvBindMatrix_Prop & prop)
{
   SELF(SkinBone, bsInvBindMatrix);
   /*0H*/Matrix v = prop;
   self->impl.bsInvBindMatrix = v.impl;
   return prop;
}
/*regGet*/inline SkinBone::bsInvBindMatrix_Prop::operator /*0I*/Matrix () const
{
   SELF(SkinBone, bsInvBindMatrix);
   Matrix value(((C(SkinBone) *)&self->impl)->bsInvBindMatrix);
   return value;
}

// member accessors: SkinBone::object
// (struct::nohead)

/*nstSet*/inline /*0H*/Object SkinBone::object_Prop::operator= (/*0H*/Object & v)
{
   SELF(SkinBone, object);
   self->impl.object = v.impl;
   return v;
}

/*regSet*/inline SkinBone::object_Prop & SkinBone::object_Prop::operator= (SkinBone::object_Prop & prop)
{
   SELF(SkinBone, object);
   /*0H*/Object v = prop;
   self->impl.object = v.impl;
   return prop;
}
/*regGet*/inline SkinBone::object_Prop::operator /*0I*/Object () const
{
   SELF(SkinBone, object);
   Object value(((C(SkinBone) *)&self->impl)->object);
   return value;
}

// member accessors: SkinBone::min
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3Df SkinBone::min_Prop::operator= (/*0H*/Vector3Df v)
{
   SELF(SkinBone, min);
   self->impl.min = v.impl;
   return v;
}

/*regSet*/inline SkinBone::min_Prop & SkinBone::min_Prop::operator= (SkinBone::min_Prop & prop)
{
   SELF(SkinBone, min);
   /*0H*/Vector3Df v = prop;
   self->impl.min = v.impl;
   return prop;
}
/*regGet*/inline SkinBone::min_Prop::operator /*0I*/Vector3Df () const
{
   SELF(SkinBone, min);
   Vector3Df value(((C(SkinBone) *)&self->impl)->min);
   return value;
}

// member accessors: SkinBone::max
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3Df SkinBone::max_Prop::operator= (/*0H*/Vector3Df v)
{
   SELF(SkinBone, max);
   self->impl.max = v.impl;
   return v;
}

/*regSet*/inline SkinBone::max_Prop & SkinBone::max_Prop::operator= (SkinBone::max_Prop & prop)
{
   SELF(SkinBone, max);
   /*0H*/Vector3Df v = prop;
   self->impl.max = v.impl;
   return prop;
}
/*regGet*/inline SkinBone::max_Prop::operator /*0I*/Vector3Df () const
{
   SELF(SkinBone, max);
   Vector3Df value(((C(SkinBone) *)&self->impl)->max);
   return value;
}

// member accessors: SkinBone::origTransform
// (struct::struct)

/*nstSet*/inline /*0H*/Transform SkinBone::origTransform_Prop::operator= (/*0H*/Transform v)
{
   SELF(SkinBone, origTransform);
   self->impl.origTransform = v.impl;
   return v;
}

/*regSet*/inline SkinBone::origTransform_Prop & SkinBone::origTransform_Prop::operator= (SkinBone::origTransform_Prop & prop)
{
   SELF(SkinBone, origTransform);
   /*0H*/Transform v = prop;
   self->impl.origTransform = v.impl;
   return prop;
}
/*regGet*/inline SkinBone::origTransform_Prop::operator /*0I*/Transform () const
{
   SELF(SkinBone, origTransform);
   Transform value(((C(SkinBone) *)&self->impl)->origTransform);
   return value;
}

// A (struct:struct)
inline Transform::operator Matrix() const { Matrix m; Transform_to_Matrix(&impl, &m.impl); return m; }
inline Transform::Transform(const Matrix & m) { Transform_from_Matrix(&impl, &m.impl); }
inline Transform & Transform::operator =(const Matrix & m) { Transform_from_Matrix(&impl, &m.impl); return *this; }

inline Transform::Transform(Vector3D position, Quaternion orientation = Quaternion(), Vector3Df scaling = Vector3Df())
{
   impl.position = position.impl;
   impl.orientation = orientation.impl;
   impl.scaling = scaling.impl;
}


inline void Transform::getMatrix3x4f(/*1Ab*/float m[12])
{
   Transform_getMatrix3x4f(&impl, /*5Ge*/m);
}


// member accessors: Transform::position
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3D Transform::position_Prop::operator= (/*0H*/Vector3D v)
{
   SELF(Transform, position);
   self->impl.position = v.impl;
   return v;
}

/*regSet*/inline Transform::position_Prop & Transform::position_Prop::operator= (Transform::position_Prop & prop)
{
   SELF(Transform, position);
   /*0H*/Vector3D v = prop;
   self->impl.position = v.impl;
   return prop;
}
/*regGet*/inline Transform::position_Prop::operator /*0I*/Vector3D () const
{
   SELF(Transform, position);
   Vector3D value(((C(Transform) *)&self->impl)->position);
   return value;
}

// member accessors: Transform::orientation
// (struct::struct)

/*nstSet*/inline /*0H*/Quaternion Transform::orientation_Prop::operator= (/*0H*/Quaternion v)
{
   SELF(Transform, orientation);
   self->impl.orientation = v.impl;
   return v;
}

/*regSet*/inline Transform::orientation_Prop & Transform::orientation_Prop::operator= (Transform::orientation_Prop & prop)
{
   SELF(Transform, orientation);
   /*0H*/Quaternion v = prop;
   self->impl.orientation = v.impl;
   return prop;
}
/*regGet*/inline Transform::orientation_Prop::operator /*0I*/Quaternion () const
{
   SELF(Transform, orientation);
   Quaternion value(((C(Transform) *)&self->impl)->orientation);
   return value;
}

// member accessors: Transform::scaling
// (struct::struct)

/*nstSet*/inline /*0H*/Vector3Df Transform::scaling_Prop::operator= (/*0H*/Vector3Df v)
{
   SELF(Transform, scaling);
   self->impl.scaling = v.impl;
   return v;
}

/*regSet*/inline Transform::scaling_Prop & Transform::scaling_Prop::operator= (Transform::scaling_Prop & prop)
{
   SELF(Transform, scaling);
   /*0H*/Vector3Df v = prop;
   self->impl.scaling = v.impl;
   return prop;
}
/*regGet*/inline Transform::scaling_Prop::operator /*0I*/Vector3Df () const
{
   SELF(Transform, scaling);
   Vector3Df value(((C(Transform) *)&self->impl)->scaling);
   return value;
}

inline Vector3D::Vector3D(double x, double y = 0, double z = 0)
{
   impl.x = x;
   impl.y = y;
   impl.z = z;
}


inline void Vector3D::add(/*1Ab*/const Vector3D & vector1, /*1Ab*/const Vector3D & vector2)
{
   Vector3D_add(&impl, /*5De*/&vector1.impl, /*5De*/&vector2.impl);
}
inline void Vector3D::add(/*1Ac*/const Vector3D * vector1, /*1Ac*/const Vector3D * vector2)
{
   Vector3D_add(&impl, /*5Cf*/(C(Vector3D) *)vector1, /*5Cf*/(C(Vector3D) *)vector2);
}
inline void Vector3D::crossProduct(/*1Ab*/const Vector3D & vector1, /*1Ab*/const Vector3D & vector2)
{
   Vector3D_crossProduct(&impl, /*5De*/&vector1.impl, /*5De*/&vector2.impl);
}
inline void Vector3D::crossProduct(/*1Ac*/const Vector3D * vector1, /*1Ac*/const Vector3D * vector2)
{
   Vector3D_crossProduct(&impl, /*5Cf*/(C(Vector3D) *)vector1, /*5Cf*/(C(Vector3D) *)vector2);
}
inline void Vector3D::divideMatrix(/*1Ab*/const Vector3D & v, /*1Ab*/const Matrix & m)
{
   Vector3D_divideMatrix(&impl, /*5De*/&v.impl, /*5De*/&m.impl);
}
inline void Vector3D::divideMatrix(/*1Ac*/const Vector3D * v, /*1Ac*/const Matrix * m)
{
   Vector3D_divideMatrix(&impl, /*5Cf*/(C(Vector3D) *)v, /*5Cf*/(C(Matrix) *)m);
}
inline double Vector3D::dotProduct(/*1Ab*/const Vector3D & vector2)
{
   return Vector3D_dotProduct(&impl, /*5De*/&vector2.impl);
}
inline double Vector3D::dotProduct(/*1Ac*/const Vector3D * vector2)
{
   return Vector3D_dotProduct(&impl, /*5Cf*/(C(Vector3D) *)vector2);
}
inline double Vector3D::dotProductf(/*1Ab*/const Vector3Df & vector2)
{
   return Vector3D_dotProductf(&impl, /*5De*/&vector2.impl);
}
inline double Vector3D::dotProductf(/*1Ac*/const Vector3Df * vector2)
{
   return Vector3D_dotProductf(&impl, /*5Cf*/(C(Vector3Df) *)vector2);
}
inline void Vector3D::multMatrix(/*1Ab*/const Vector3D & source, /*1Ab*/const Matrix & matrix)
{
   Vector3D_multMatrix(&impl, /*5De*/&source.impl, /*5De*/&matrix.impl);
}
inline void Vector3D::multMatrix(/*1Ac*/const Vector3D * source, /*1Ac*/const Matrix * matrix)
{
   Vector3D_multMatrix(&impl, /*5Cf*/(C(Vector3D) *)source, /*5Cf*/(C(Matrix) *)matrix);
}
inline void Vector3D::multMatrixf(/*1Ab*/const Vector3Df & source, /*1Ab*/const Matrix & matrix)
{
   Vector3D_multMatrixf(&impl, /*5De*/&source.impl, /*5De*/&matrix.impl);
}
inline void Vector3D::multMatrixf(/*1Ac*/const Vector3Df * source, /*1Ac*/const Matrix * matrix)
{
   Vector3D_multMatrixf(&impl, /*5Cf*/(C(Vector3Df) *)source, /*5Cf*/(C(Matrix) *)matrix);
}
inline void Vector3D::multQuaternion(/*1Ab*/const Vector3D & s, /*1Ab*/const Quaternion & quat)
{
   Vector3D_multQuaternion(&impl, /*5De*/&s.impl, /*5De*/&quat.impl);
}
inline void Vector3D::multQuaternion(/*1Ac*/const Vector3D * s, /*1Ac*/const Quaternion * quat)
{
   Vector3D_multQuaternion(&impl, /*5Cf*/(C(Vector3D) *)s, /*5Cf*/(C(Quaternion) *)quat);
}
inline void Vector3D::normalize(/*1Ab*/const Vector3D & source)
{
   Vector3D_normalize(&impl, /*5De*/&source.impl);
}
inline void Vector3D::normalize(/*1Ac*/const Vector3D * source)
{
   Vector3D_normalize(&impl, /*5Cf*/(C(Vector3D) *)source);
}
inline void Vector3D::scale(/*1Ab*/const Vector3D & vector1, /*1Ab*/double s)
{
   Vector3D_scale(&impl, /*5De*/&vector1.impl, /*5Ge*/s);
}
inline void Vector3D::scale(/*1Ac*/const Vector3D * vector1, /*1Ac*/double s)
{
   Vector3D_scale(&impl, /*5Cf*/(C(Vector3D) *)vector1, /*5Gf*/s);
}
inline void Vector3D::subtract(/*1Ab*/const Vector3D & vector1, /*1Ab*/const Vector3D & vector2)
{
   Vector3D_subtract(&impl, /*5De*/&vector1.impl, /*5De*/&vector2.impl);
}
inline void Vector3D::subtract(/*1Ac*/const Vector3D * vector1, /*1Ac*/const Vector3D * vector2)
{
   Vector3D_subtract(&impl, /*5Cf*/(C(Vector3D) *)vector1, /*5Cf*/(C(Vector3D) *)vector2);
}


// property callers: Vector3D::length   // get only
// (struct::double)

/*regGet*/inline Vector3D::length_Prop::operator /*0I*/double () const
{
   SELF(Vector3D, length);
   return Vector3D_get_length(self ? &self->impl : null);
}

// property callers: Vector3D::lengthApprox   // get only
// (struct::double)

/*regGet*/inline Vector3D::lengthApprox_Prop::operator /*0I*/double () const
{
   SELF(Vector3D, lengthApprox);
   return Vector3D_get_lengthApprox(self ? &self->impl : null);
}


// member accessors: Vector3D::x
// (struct::double)

/*nstSet*/inline /*0H*/double Vector3D::x_Prop::operator= (/*0H*/double v)
{
   SELF(Vector3D, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline Vector3D::x_Prop & Vector3D::x_Prop::operator= (Vector3D::x_Prop & prop)
{
   SELF(Vector3D, x);
   /*0H*/double v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline Vector3D::x_Prop::operator /*0I*/double () const
{
   SELF(Vector3D, x);
   return self ? ((C(Vector3D) *)&self->impl)->x : 0;
}

// member accessors: Vector3D::y
// (struct::double)

/*nstSet*/inline /*0H*/double Vector3D::y_Prop::operator= (/*0H*/double v)
{
   SELF(Vector3D, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline Vector3D::y_Prop & Vector3D::y_Prop::operator= (Vector3D::y_Prop & prop)
{
   SELF(Vector3D, y);
   /*0H*/double v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline Vector3D::y_Prop::operator /*0I*/double () const
{
   SELF(Vector3D, y);
   return self ? ((C(Vector3D) *)&self->impl)->y : 0;
}

// member accessors: Vector3D::z
// (struct::double)

/*nstSet*/inline /*0H*/double Vector3D::z_Prop::operator= (/*0H*/double v)
{
   SELF(Vector3D, z);
   self->impl.z = v;
   return v;
}

/*regSet*/inline Vector3D::z_Prop & Vector3D::z_Prop::operator= (Vector3D::z_Prop & prop)
{
   SELF(Vector3D, z);
   /*0H*/double v = prop;
   self->impl.z = v;
   return prop;
}
/*regGet*/inline Vector3D::z_Prop::operator /*0I*/double () const
{
   SELF(Vector3D, z);
   return self ? ((C(Vector3D) *)&self->impl)->z : 0;
}

inline Vector3Df::Vector3Df(float x, float y = 0, float z = 0)
{
   impl.x = x;
   impl.y = y;
   impl.z = z;
}


inline void Vector3Df::add(/*1Ab*/const Vector3Df & vector1, /*1Ab*/const Vector3Df & vector2)
{
   Vector3Df_add(&impl, /*5De*/&vector1.impl, /*5De*/&vector2.impl);
}
inline void Vector3Df::add(/*1Ac*/const Vector3Df * vector1, /*1Ac*/const Vector3Df * vector2)
{
   Vector3Df_add(&impl, /*5Cf*/(C(Vector3Df) *)vector1, /*5Cf*/(C(Vector3Df) *)vector2);
}
inline void Vector3Df::crossProduct(/*1Ab*/const Vector3Df & vector1, /*1Ab*/const Vector3Df & vector2)
{
   Vector3Df_crossProduct(&impl, /*5De*/&vector1.impl, /*5De*/&vector2.impl);
}
inline void Vector3Df::crossProduct(/*1Ac*/const Vector3Df * vector1, /*1Ac*/const Vector3Df * vector2)
{
   Vector3Df_crossProduct(&impl, /*5Cf*/(C(Vector3Df) *)vector1, /*5Cf*/(C(Vector3Df) *)vector2);
}
inline void Vector3Df::divideMatrix(/*1Ab*/const Vector3Df & source, /*1Ab*/const Matrix & matrix)
{
   Vector3Df_divideMatrix(&impl, /*5De*/&source.impl, /*5De*/&matrix.impl);
}
inline void Vector3Df::divideMatrix(/*1Ac*/const Vector3Df * source, /*1Ac*/const Matrix * matrix)
{
   Vector3Df_divideMatrix(&impl, /*5Cf*/(C(Vector3Df) *)source, /*5Cf*/(C(Matrix) *)matrix);
}
inline double Vector3Df::dotProduct(/*1Ab*/const Vector3Df & vector2)
{
   return Vector3Df_dotProduct(&impl, /*5De*/&vector2.impl);
}
inline double Vector3Df::dotProduct(/*1Ac*/const Vector3Df * vector2)
{
   return Vector3Df_dotProduct(&impl, /*5Cf*/(C(Vector3Df) *)vector2);
}
inline void Vector3Df::multMatrix(/*1Ab*/const Vector3Df & source, /*1Ab*/const Matrix & matrix)
{
   Vector3Df_multMatrix(&impl, /*5De*/&source.impl, /*5De*/&matrix.impl);
}
inline void Vector3Df::multMatrix(/*1Ac*/const Vector3Df * source, /*1Ac*/const Matrix * matrix)
{
   Vector3Df_multMatrix(&impl, /*5Cf*/(C(Vector3Df) *)source, /*5Cf*/(C(Matrix) *)matrix);
}
inline void Vector3Df::multQuaternion(/*1Ab*/const Vector3Df & source, /*1Ab*/const Quaternion & quat)
{
   Vector3Df_multQuaternion(&impl, /*5De*/&source.impl, /*5De*/&quat.impl);
}
inline void Vector3Df::multQuaternion(/*1Ac*/const Vector3Df * source, /*1Ac*/const Quaternion * quat)
{
   Vector3Df_multQuaternion(&impl, /*5Cf*/(C(Vector3Df) *)source, /*5Cf*/(C(Quaternion) *)quat);
}
inline void Vector3Df::normalize(/*1Ab*/const Vector3Df & source)
{
   Vector3Df_normalize(&impl, /*5De*/&source.impl);
}
inline void Vector3Df::normalize(/*1Ac*/const Vector3Df * source)
{
   Vector3Df_normalize(&impl, /*5Cf*/(C(Vector3Df) *)source);
}
inline void Vector3Df::scale(/*1Ab*/const Vector3Df & vector1, /*1Ab*/float s)
{
   Vector3Df_scale(&impl, /*5De*/&vector1.impl, /*5Ge*/s);
}
inline void Vector3Df::scale(/*1Ac*/const Vector3Df * vector1, /*1Ac*/float s)
{
   Vector3Df_scale(&impl, /*5Cf*/(C(Vector3Df) *)vector1, /*5Gf*/s);
}
inline void Vector3Df::subtract(/*1Ab*/const Vector3Df & vector1, /*1Ab*/const Vector3Df & vector2)
{
   Vector3Df_subtract(&impl, /*5De*/&vector1.impl, /*5De*/&vector2.impl);
}
inline void Vector3Df::subtract(/*1Ac*/const Vector3Df * vector1, /*1Ac*/const Vector3Df * vector2)
{
   Vector3Df_subtract(&impl, /*5Cf*/(C(Vector3Df) *)vector1, /*5Cf*/(C(Vector3Df) *)vector2);
}


// property callers: Vector3Df::length   // get only
// (struct::float)

/*regGet*/inline Vector3Df::length_Prop::operator /*0I*/float () const
{
   SELF(Vector3Df, length);
   return Vector3Df_get_length(self ? &self->impl : null);
}

// property callers: Vector3Df::lengthApprox   // get only
// (struct::float)

/*regGet*/inline Vector3Df::lengthApprox_Prop::operator /*0I*/float () const
{
   SELF(Vector3Df, lengthApprox);
   return Vector3Df_get_lengthApprox(self ? &self->impl : null);
}


// member accessors: Vector3Df::x
// (struct::float)

/*nstSet*/inline /*0H*/float Vector3Df::x_Prop::operator= (/*0H*/float v)
{
   SELF(Vector3Df, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline Vector3Df::x_Prop & Vector3Df::x_Prop::operator= (Vector3Df::x_Prop & prop)
{
   SELF(Vector3Df, x);
   /*0H*/float v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline Vector3Df::x_Prop::operator /*0I*/float () const
{
   SELF(Vector3Df, x);
   return self ? ((C(Vector3Df) *)&self->impl)->x : 0;
}

// member accessors: Vector3Df::y
// (struct::float)

/*nstSet*/inline /*0H*/float Vector3Df::y_Prop::operator= (/*0H*/float v)
{
   SELF(Vector3Df, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline Vector3Df::y_Prop & Vector3Df::y_Prop::operator= (Vector3Df::y_Prop & prop)
{
   SELF(Vector3Df, y);
   /*0H*/float v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline Vector3Df::y_Prop::operator /*0I*/float () const
{
   SELF(Vector3Df, y);
   return self ? ((C(Vector3Df) *)&self->impl)->y : 0;
}

// member accessors: Vector3Df::z
// (struct::float)

/*nstSet*/inline /*0H*/float Vector3Df::z_Prop::operator= (/*0H*/float v)
{
   SELF(Vector3Df, z);
   self->impl.z = v;
   return v;
}

/*regSet*/inline Vector3Df::z_Prop & Vector3Df::z_Prop::operator= (Vector3Df::z_Prop & prop)
{
   SELF(Vector3Df, z);
   /*0H*/float v = prop;
   self->impl.z = v;
   return prop;
}
/*regGet*/inline Vector3Df::z_Prop::operator /*0I*/float () const
{
   SELF(Vector3Df, z);
   return self ? ((C(Vector3Df) *)&self->impl)->z : 0;
}

////////////////////////////////////////// [ecere]/ecere::gfx3D::meshes //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////



template <class TC, C(Class) ** TCO> inline C(bool) TCube<TC, TCO>::create(/*1Ab*/const DisplaySystem & displaySystem)
{
   return Cube_create((C(Cube)*)this->impl, /*5De*/displaySystem.impl);
}


// property callers: Cube::size   // set only
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/Vector3Df TCube<TC, TCO>::size_Prop::operator= (/*0G*/Vector3Df v)
{
   SELF(Cube, size);
   Cube_set_size(self->impl, &v.impl);
   return v;
}



template <class TC, C(Class) ** TCO> inline C(bool) TSkyBox<TC, TCO>::create(/*1Ab*/DisplaySystem & displaySystem)
{
   return SkyBox_create((C(SkyBox)*)this->impl, /*5De*/displaySystem.impl);
}
template <class TC, C(Class) ** TCO> inline void TSkyBox<TC, TCO>::render(/*1Ab*/Camera & camera, /*1Ab*/Display & display)
{
   SkyBox_render((C(SkyBox)*)this->impl, /*5De*/camera.impl, /*5De*/display.impl);
}


// property callers: SkyBox::size   // set only
// (nohead::struct)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/Vector3Df TSkyBox<TC, TCO>::size_Prop::operator= (/*0G*/Vector3Df v)
{
   SELF(SkyBox, size);
   SkyBox_set_size(self->impl, &v.impl);
   return v;
}


// property callers: SkyBox::folder   // set only
// (nohead::const char *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/const char * TSkyBox<TC, TCO>::folder_Prop::operator= (/*0G*/const char * v)
{
   SELF(SkyBox, folder);
   SkyBox_set_folder(self->impl, v);
   return v;
}


// property callers: SkyBox::extension   // set only
// (nohead::const char *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/const char * TSkyBox<TC, TCO>::extension_Prop::operator= (/*0G*/const char * v)
{
   SELF(SkyBox, extension);
   SkyBox_set_extension(self->impl, v);
   return v;
}


// property callers: SkyBox::newStyle   // set only
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/bool TSkyBox<TC, TCO>::newStyle_Prop::operator= (/*0G*/bool v)
{
   SELF(SkyBox, newStyle);
   SkyBox_set_newStyle(self->impl, (C(bool))v);
   return v;
}


// property callers: SkyBox::cubeMap   // set only
// (nohead::normal)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0A*/const CubeMap & TSkyBox<TC, TCO>::cubeMap_Prop::operator= (/*0A*/const CubeMap & v)
{
   SELF(SkyBox, cubeMap);
   SkyBox_set_cubeMap(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0C*/const CubeMap * TSkyBox<TC, TCO>::cubeMap_Prop::operator= (/*0C*/const CubeMap * v)
{
   SELF(SkyBox, cubeMap);
   SkyBox_set_cubeMap(self ? self->impl : null, v ? v->impl : null);
   return v;
}



template <class TC, C(Class) ** TCO> inline C(bool) TSphere<TC, TCO>::create(/*1Ab*/DisplaySystem & displaySystem)
{
   return Sphere_create((C(Sphere)*)this->impl, /*5De*/displaySystem.impl);
}


// property callers: Sphere::numLat   // set only
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/int TSphere<TC, TCO>::numLat_Prop::operator= (/*0G*/int v)
{
   SELF(Sphere, numLat);
   Sphere_set_numLat(self->impl, v);
   return v;
}


// property callers: Sphere::numLon   // set only
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/int TSphere<TC, TCO>::numLon_Prop::operator= (/*0G*/int v)
{
   SELF(Sphere, numLon);
   Sphere_set_numLon(self->impl, v);
   return v;
}


// property callers: Sphere::flattenedBody   // set only
// (nohead::float)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0G*/float TSphere<TC, TCO>::flattenedBody_Prop::operator= (/*0G*/float v)
{
   SELF(Sphere, flattenedBody);
   Sphere_set_flattenedBody(self->impl, v);
   return v;
}


//////////////////////////////////////////////////// [ecere]/ecere::gui //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////




// member accessors: Anchor::left
// (struct::struct)

/*nstSet*/inline /*0H*/AnchorValue Anchor::left_Prop::operator= (/*0H*/AnchorValue v)
{
   SELF(Anchor, left);
   self->impl.left = v.impl;
   return v;
}

/*regSet*/inline Anchor::left_Prop & Anchor::left_Prop::operator= (Anchor::left_Prop & prop)
{
   SELF(Anchor, left);
   /*0H*/AnchorValue v = prop;
   self->impl.left = v.impl;
   return prop;
}
/*regGet*/inline Anchor::left_Prop::operator /*0I*/AnchorValue () const
{
   SELF(Anchor, left);
   AnchorValue value(((C(Anchor) *)&self->impl)->left);
   return value;
}

// member accessors: Anchor::horz
// (struct::struct)

/*nstSet*/inline /*0H*/MiddleAnchorValue Anchor::horz_Prop::operator= (/*0H*/MiddleAnchorValue v)
{
   SELF(Anchor, horz);
   self->impl.horz = v.impl;
   return v;
}

/*regSet*/inline Anchor::horz_Prop & Anchor::horz_Prop::operator= (Anchor::horz_Prop & prop)
{
   SELF(Anchor, horz);
   /*0H*/MiddleAnchorValue v = prop;
   self->impl.horz = v.impl;
   return prop;
}
/*regGet*/inline Anchor::horz_Prop::operator /*0I*/MiddleAnchorValue () const
{
   SELF(Anchor, horz);
   MiddleAnchorValue value(((C(Anchor) *)&self->impl)->horz);
   return value;
}

// member accessors: Anchor::top
// (struct::struct)

/*nstSet*/inline /*0H*/AnchorValue Anchor::top_Prop::operator= (/*0H*/AnchorValue v)
{
   SELF(Anchor, top);
   self->impl.top = v.impl;
   return v;
}

/*regSet*/inline Anchor::top_Prop & Anchor::top_Prop::operator= (Anchor::top_Prop & prop)
{
   SELF(Anchor, top);
   /*0H*/AnchorValue v = prop;
   self->impl.top = v.impl;
   return prop;
}
/*regGet*/inline Anchor::top_Prop::operator /*0I*/AnchorValue () const
{
   SELF(Anchor, top);
   AnchorValue value(((C(Anchor) *)&self->impl)->top);
   return value;
}

// member accessors: Anchor::vert
// (struct::struct)

/*nstSet*/inline /*0H*/MiddleAnchorValue Anchor::vert_Prop::operator= (/*0H*/MiddleAnchorValue v)
{
   SELF(Anchor, vert);
   self->impl.vert = v.impl;
   return v;
}

/*regSet*/inline Anchor::vert_Prop & Anchor::vert_Prop::operator= (Anchor::vert_Prop & prop)
{
   SELF(Anchor, vert);
   /*0H*/MiddleAnchorValue v = prop;
   self->impl.vert = v.impl;
   return prop;
}
/*regGet*/inline Anchor::vert_Prop::operator /*0I*/MiddleAnchorValue () const
{
   SELF(Anchor, vert);
   MiddleAnchorValue value(((C(Anchor) *)&self->impl)->vert);
   return value;
}

// member accessors: Anchor::right
// (struct::struct)

/*nstSet*/inline /*0H*/AnchorValue Anchor::right_Prop::operator= (/*0H*/AnchorValue v)
{
   SELF(Anchor, right);
   self->impl.right = v.impl;
   return v;
}

/*regSet*/inline Anchor::right_Prop & Anchor::right_Prop::operator= (Anchor::right_Prop & prop)
{
   SELF(Anchor, right);
   /*0H*/AnchorValue v = prop;
   self->impl.right = v.impl;
   return prop;
}
/*regGet*/inline Anchor::right_Prop::operator /*0I*/AnchorValue () const
{
   SELF(Anchor, right);
   AnchorValue value(((C(Anchor) *)&self->impl)->right);
   return value;
}

// member accessors: Anchor::bottom
// (struct::struct)

/*nstSet*/inline /*0H*/AnchorValue Anchor::bottom_Prop::operator= (/*0H*/AnchorValue v)
{
   SELF(Anchor, bottom);
   self->impl.bottom = v.impl;
   return v;
}

/*regSet*/inline Anchor::bottom_Prop & Anchor::bottom_Prop::operator= (Anchor::bottom_Prop & prop)
{
   SELF(Anchor, bottom);
   /*0H*/AnchorValue v = prop;
   self->impl.bottom = v.impl;
   return prop;
}
/*regGet*/inline Anchor::bottom_Prop::operator /*0I*/AnchorValue () const
{
   SELF(Anchor, bottom);
   AnchorValue value(((C(Anchor) *)&self->impl)->bottom);
   return value;
}
// A (struct:unit)
inline AnchorValue::operator MinMaxValue() const { MinMaxValue m = AnchorValue_to_MinMaxValue(&impl); return m; }
inline AnchorValue::AnchorValue(const MinMaxValue & m) { AnchorValue_from_MinMaxValue(&impl, m.impl); }
inline AnchorValue & AnchorValue::operator =(const MinMaxValue & m) { AnchorValue_from_MinMaxValue(&impl, m.impl); return *this; }

inline AnchorValue::AnchorValue(AnchorValueType type, int distance = 0, float percent = 0)
{
   impl.type = (C(AnchorValueType))type;
   impl.distance = distance;
   impl.percent = percent;
}



// member accessors: AnchorValue::type
// (struct::enum|int)

/*nstSet*/inline /*0H*/AnchorValueType AnchorValue::type_Prop::operator= (/*0H*/AnchorValueType v)
{
   SELF(AnchorValue, type);
   self->impl.type = (C(AnchorValueType))v;
   return v;
}

/*regSet*/inline AnchorValue::type_Prop & AnchorValue::type_Prop::operator= (AnchorValue::type_Prop & prop)
{
   SELF(AnchorValue, type);
   /*0H*/AnchorValueType v = prop;
   self->impl.type = (C(AnchorValueType))v;
   return prop;
}
/*regGet*/inline AnchorValue::type_Prop::operator /*0I*/AnchorValueType () const
{
   SELF(AnchorValue, type);
   return self ? (AnchorValueType)((C(AnchorValue) *)&self->impl)->type : (AnchorValueType)0;
}

// member accessors: AnchorValue::distance
// (struct::int)

/*nstSet*/inline /*0H*/int AnchorValue::distance_Prop::operator= (/*0H*/int v)
{
   SELF(AnchorValue, distance);
   self->impl.distance = v;
   return v;
}

/*regSet*/inline AnchorValue::distance_Prop & AnchorValue::distance_Prop::operator= (AnchorValue::distance_Prop & prop)
{
   SELF(AnchorValue, distance);
   /*0H*/int v = prop;
   self->impl.distance = v;
   return prop;
}
/*regGet*/inline AnchorValue::distance_Prop::operator /*0I*/int () const
{
   SELF(AnchorValue, distance);
   return self ? ((C(AnchorValue) *)&self->impl)->distance : 0;
}

// member accessors: AnchorValue::percent
// (struct::float)

/*nstSet*/inline /*0H*/float AnchorValue::percent_Prop::operator= (/*0H*/float v)
{
   SELF(AnchorValue, percent);
   self->impl.percent = v;
   return v;
}

/*regSet*/inline AnchorValue::percent_Prop & AnchorValue::percent_Prop::operator= (AnchorValue::percent_Prop & prop)
{
   SELF(AnchorValue, percent);
   /*0H*/float v = prop;
   self->impl.percent = v;
   return prop;
}
/*regGet*/inline AnchorValue::percent_Prop::operator /*0I*/float () const
{
   SELF(AnchorValue, percent);
   return self ? ((C(AnchorValue) *)&self->impl)->percent : 0;
}



// member accessors: BorderBits::contour
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool BorderBits::contour_Prop::operator= (/*0H*/bool v)
{
   SELF(BorderBits, contour);
   BORDERBITS_SET_contour(self->impl, v);
   return v;
}

/*regSet*/inline BorderBits::contour_Prop & BorderBits::contour_Prop::operator= (BorderBits::contour_Prop & prop)
{
   SELF(BorderBits, contour);
   /*0H*/bool v = prop;
   BORDERBITS_SET_contour(self->impl, v);
   return prop;
}
/*regGet*/inline BorderBits::contour_Prop::operator /*0I*/bool () const
{
   SELF(BorderBits, contour);
   return (bool)BORDERBITS_contour(self->impl);
}

// member accessors: BorderBits::fixed
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool BorderBits::fixed_Prop::operator= (/*0H*/bool v)
{
   SELF(BorderBits, fixed);
   BORDERBITS_SET_fixed(self->impl, v);
   return v;
}

/*regSet*/inline BorderBits::fixed_Prop & BorderBits::fixed_Prop::operator= (BorderBits::fixed_Prop & prop)
{
   SELF(BorderBits, fixed);
   /*0H*/bool v = prop;
   BORDERBITS_SET_fixed(self->impl, v);
   return prop;
}
/*regGet*/inline BorderBits::fixed_Prop::operator /*0I*/bool () const
{
   SELF(BorderBits, fixed);
   return (bool)BORDERBITS_fixed(self->impl);
}

// member accessors: BorderBits::sizable
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool BorderBits::sizable_Prop::operator= (/*0H*/bool v)
{
   SELF(BorderBits, sizable);
   BORDERBITS_SET_sizable(self->impl, v);
   return v;
}

/*regSet*/inline BorderBits::sizable_Prop & BorderBits::sizable_Prop::operator= (BorderBits::sizable_Prop & prop)
{
   SELF(BorderBits, sizable);
   /*0H*/bool v = prop;
   BORDERBITS_SET_sizable(self->impl, v);
   return prop;
}
/*regGet*/inline BorderBits::sizable_Prop::operator /*0I*/bool () const
{
   SELF(BorderBits, sizable);
   return (bool)BORDERBITS_sizable(self->impl);
}

// member accessors: BorderBits::deep
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool BorderBits::deep_Prop::operator= (/*0H*/bool v)
{
   SELF(BorderBits, deep);
   BORDERBITS_SET_deep(self->impl, v);
   return v;
}

/*regSet*/inline BorderBits::deep_Prop & BorderBits::deep_Prop::operator= (BorderBits::deep_Prop & prop)
{
   SELF(BorderBits, deep);
   /*0H*/bool v = prop;
   BORDERBITS_SET_deep(self->impl, v);
   return prop;
}
/*regGet*/inline BorderBits::deep_Prop::operator /*0I*/bool () const
{
   SELF(BorderBits, deep);
   return (bool)BORDERBITS_deep(self->impl);
}

// member accessors: BorderBits::bevel
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool BorderBits::bevel_Prop::operator= (/*0H*/bool v)
{
   SELF(BorderBits, bevel);
   BORDERBITS_SET_bevel(self->impl, v);
   return v;
}

/*regSet*/inline BorderBits::bevel_Prop & BorderBits::bevel_Prop::operator= (BorderBits::bevel_Prop & prop)
{
   SELF(BorderBits, bevel);
   /*0H*/bool v = prop;
   BORDERBITS_SET_bevel(self->impl, v);
   return prop;
}
/*regGet*/inline BorderBits::bevel_Prop::operator /*0I*/bool () const
{
   SELF(BorderBits, bevel);
   return (bool)BORDERBITS_bevel(self->impl);
}

// member accessors: BorderBits::thin
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool BorderBits::thin_Prop::operator= (/*0H*/bool v)
{
   SELF(BorderBits, thin);
   BORDERBITS_SET_thin(self->impl, v);
   return v;
}

/*regSet*/inline BorderBits::thin_Prop & BorderBits::thin_Prop::operator= (BorderBits::thin_Prop & prop)
{
   SELF(BorderBits, thin);
   /*0H*/bool v = prop;
   BORDERBITS_SET_thin(self->impl, v);
   return prop;
}
/*regGet*/inline BorderBits::thin_Prop::operator /*0I*/bool () const
{
   SELF(BorderBits, thin);
   return (bool)BORDERBITS_thin(self->impl);
}


template <class TC, C(Class) ** TCO> inline C(bool) TClipBoard<TC, TCO>::allocate(/*1Ab*/uint size)
{
   return ClipBoard_allocate((C(ClipBoard)*)this->impl, /*5Ge*/size);
}
template <class TC, C(Class) ** TCO> inline void TClipBoard<TC, TCO>::clear()
{
   ClipBoard_clear((C(ClipBoard)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TClipBoard<TC, TCO>::load()
{
   return ClipBoard_load((C(ClipBoard)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TClipBoard<TC, TCO>::save()
{
   return ClipBoard_save((C(ClipBoard)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TClipBoard<TC, TCO>::unload()
{
   ClipBoard_unload((C(ClipBoard)*)this->impl);
}


// property callers: ClipBoard::memory   // get only
// (nohead::char *)

/*regGet*/template <class TC, C(Class) ** TCO> inline TClipBoard<TC, TCO>::memory_Prop::operator /*0I*/char * () const
{
   __attribute__((unused)) TClipBoard TCTCO * self = CONTAINER_OF(this, TClipBoard TCTCO, memory);
   return ClipBoard_get_memory(self ? self->impl : null);
}


// member accessors: ClipBoard::text
// (nohead::char *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/char * TClipBoard<TC, TCO>::text_Prop::operator= (/*0H*/char * v)
{
   SELF(ClipBoard, text);
   ((C(ClipBoard) *)self->impl)->text = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TClipBoard<TC, TCO>::text_Prop & TClipBoard<TC, TCO>::text_Prop::operator= (typename TClipBoard<TC, TCO>::text_Prop & prop)
{
   SELF(ClipBoard, text);
   /*0H*/char * v = prop;
   ((C(ClipBoard) *)self->impl)->text = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TClipBoard<TC, TCO>::text_Prop::operator /*0I*/char * () const
{
   __attribute__((unused)) TClipBoard TCTCO * self = CONTAINER_OF(this, TClipBoard TCTCO, text);
   return self ? ((C(ClipBoard) *)self->impl)->text : null;
}

// member accessors: ClipBoard::handle
// (nohead::void *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/void * TClipBoard<TC, TCO>::handle_Prop::operator= (/*0H*/void * v)
{
   SELF(ClipBoard, handle);
   ((C(ClipBoard) *)self->impl)->handle = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TClipBoard<TC, TCO>::handle_Prop & TClipBoard<TC, TCO>::handle_Prop::operator= (typename TClipBoard<TC, TCO>::handle_Prop & prop)
{
   SELF(ClipBoard, handle);
   /*0H*/void * v = prop;
   ((C(ClipBoard) *)self->impl)->handle = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TClipBoard<TC, TCO>::handle_Prop::operator /*0I*/void * () const
{
   __attribute__((unused)) TClipBoard TCTCO * self = CONTAINER_OF(this, TClipBoard TCTCO, handle);
   return self ? ((C(ClipBoard) *)self->impl)->handle : null;
}

inline CommonControl::CommonControl(/*CT-D*/constString toolTip) : CommonControl()
{
   this->toolTip = toolTip;
}



// property callers: CommonControl::toolTip
// (normal::string)

/*nstSet*/inline /*0H*//*CT-D*/constString CommonControl::toolTip_Prop::operator= (/*0H*//*CT-D*/constString v)
{
   SELF(CommonControl, toolTip);
   CommonControl_set_toolTip(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline CommonControl::toolTip_Prop & CommonControl::toolTip_Prop::operator= (CommonControl::toolTip_Prop & prop)
{
   SELF(CommonControl, toolTip);
   /*0H*//*CT-D*/constString v = prop;
   CommonControl_set_toolTip(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline CommonControl::toolTip_Prop::operator /*0I*//*CT-D*/constString () const
{
   SELF(CommonControl, toolTip);
   return CommonControl_get_toolTip(self ? self->impl : null);
}


inline Cursor::Cursor(SystemCursor systemCursor) : Cursor()
{
   this->systemCursor = systemCursor;
}


inline void Cursor::free()
{
   Cursor_free(impl);
}
inline C(bool) Cursor::load(/*1Ab*/const char * name, /*1Ab*/int hotSpotX, /*1Ab*/int hotSpotY, /*1Ab*/byte * paletteShades, /*1Ab*/DisplaySystem & ds)
{
   return Cursor_load(impl, /*5Ge*/name, /*5Ge*/hotSpotX, /*5Ge*/hotSpotY, /*5Ge*/paletteShades, /*5De*/ds.impl);
}


// property callers: Cursor::systemCursor   // set only
// (normal::enum|int)

/*nstSet*/inline /*0G*/SystemCursor Cursor::systemCursor_Prop::operator= (/*0G*/SystemCursor v)
{
   SELF(Cursor, systemCursor);
   Cursor_set_systemCursor(self->impl, (C(SystemCursor))v);
   return v;
}


inline Extent::Extent(void * first, void * last = null, int count = 0, uint offset = 0, bool circ = (bool)0)
{
   impl.first = first;
   impl.last = last;
   impl.count = count;
   impl.offset = offset;
   impl.circ = (C(bool))circ;
}


inline void Extent::add(/*1Ab*/void * item)
{
   OldList_add((C(OldList)*)&impl, /*5Ge*/item);
}
inline C(bool) Extent::addName(/*1Ab*/void * item)
{
   return OldList_addName((C(OldList)*)&impl, /*5Ge*/item);
}
inline void Extent::clear()
{
   OldList_clear((C(OldList)*)&impl);
}
inline void Extent::_delete(/*1Ab*/void * item)
{
   OldList_delete((C(OldList)*)&impl, /*5Ge*/item);
}
inline C(OldLink) * Extent::findLink(/*1Ab*/void * data)
{
   return OldList_findLink((C(OldList)*)&impl, /*5Ge*/data);
}
inline void * Extent::findName(/*1Ab*/const char * name, /*1Ab*/bool warn)
{
   return OldList_findName((C(OldList)*)&impl, /*5Ge*/name, /*5Ee*/(C(bool))warn);
}
inline void * Extent::findNamedLink(/*1Ab*/const char * name, /*1Ab*/bool warn)
{
   return OldList_findNamedLink((C(OldList)*)&impl, /*5Ge*/name, /*5Ee*/(C(bool))warn);
}
inline void Extent::free(void (* freeFn)(void *))
{
   OldList_free((C(OldList)*)&impl, /*5Ge*/freeFn);
}
inline C(bool) Extent::insert(/*1Ab*/void * prevItem, /*1Ab*/void * item)
{
   return OldList_insert((C(OldList)*)&impl, /*5Ge*/prevItem, /*5Ge*/item);
}
inline void Extent::move(/*1Ab*/void * item, /*1Ab*/void * prevItem)
{
   OldList_move((C(OldList)*)&impl, /*5Ge*/item, /*5Ge*/prevItem);
}
inline C(bool) Extent::placeName(/*1Ab*/const char * name, /*1Ab*/void ** place)
{
   return OldList_placeName((C(OldList)*)&impl, /*5Ge*/name, /*5Ge*/place);
}
inline void Extent::remove(/*1Ab*/void * item)
{
   OldList_remove((C(OldList)*)&impl, /*5Ge*/item);
}
inline void Extent::removeAll(void (* freeFn)(void *))
{
   OldList_removeAll((C(OldList)*)&impl, /*5Ge*/freeFn);
}
inline void Extent::sort(int (* compare)(void *, void *, void *), /*1Ab*/void * data)
{
   OldList_sort((C(OldList)*)&impl, /*5Ge*/compare, /*5Ge*/data);
}
inline void Extent::swap(/*1Ab*/void * item1, /*1Ab*/void * item2)
{
   OldList_swap((C(OldList)*)&impl, /*5Ge*/item1, /*5Ge*/item2);
}
inline void Extent::addBox(/*1Ab*/Box & box)
{
   Extent_addBox(&impl, /*5De*/&box.impl);
}
inline void Extent::addBox(/*1Ac*/Box * box)
{
   Extent_addBox(&impl, /*5Cf*/(C(Box) *)box);
}
inline void Extent::copy(/*1Ab*/Extent & source)
{
   Extent_copy(&impl, /*5De*/&source.impl);
}
inline void Extent::copy(/*1Ac*/Extent * source)
{
   Extent_copy(&impl, /*5Cf*/(C(Extent) *)source);
}
inline void Extent::empty()
{
   Extent_empty(&impl);
}
inline void Extent::excludeBox(/*1Ab*/Box & box, /*1Ab*/Extent & temp)
{
   Extent_excludeBox(&impl, /*5De*/&box.impl, /*5De*/&temp.impl);
}
inline void Extent::excludeBox(/*1Ac*/Box * box, /*1Ac*/Extent * temp)
{
   Extent_excludeBox(&impl, /*5Cf*/(C(Box) *)box, /*5Cf*/(C(Extent) *)temp);
}
inline void Extent::exclusion(/*1Ab*/Extent & b, /*1Ab*/Extent & temp)
{
   Extent_exclusion(&impl, /*5De*/&b.impl, /*5De*/&temp.impl);
}
inline void Extent::exclusion(/*1Ac*/Extent * b, /*1Ac*/Extent * temp)
{
   Extent_exclusion(&impl, /*5Cf*/(C(Extent) *)b, /*5Cf*/(C(Extent) *)temp);
}
inline void Extent::intersectBox(/*1Ab*/Box & box)
{
   Extent_intersectBox(&impl, /*5De*/&box.impl);
}
inline void Extent::intersectBox(/*1Ac*/Box * box)
{
   Extent_intersectBox(&impl, /*5Cf*/(C(Box) *)box);
}
inline void Extent::intersection(/*1Ab*/Extent & b, /*1Ab*/Extent & temp, /*1Ab*/Extent & temp2, /*1Ab*/Extent & temp3)
{
   Extent_intersection(&impl, /*5De*/&b.impl, /*5De*/&temp.impl, /*5De*/&temp2.impl, /*5De*/&temp3.impl);
}
inline void Extent::intersection(/*1Ac*/Extent * b, /*1Ac*/Extent * temp, /*1Ac*/Extent * temp2, /*1Ac*/Extent * temp3)
{
   Extent_intersection(&impl, /*5Cf*/(C(Extent) *)b, /*5Cf*/(C(Extent) *)temp, /*5Cf*/(C(Extent) *)temp2, /*5Cf*/(C(Extent) *)temp3);
}
inline void Extent::_offset(/*1Ab*/int x, /*1Ab*/int y)
{
   Extent_offset(&impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Extent::_union(/*1Ab*/Extent & b, /*1Ab*/Extent & temp)
{
   Extent_union(&impl, /*5De*/&b.impl, /*5De*/&temp.impl);
}
inline void Extent::_union(/*1Ac*/Extent * b, /*1Ac*/Extent * temp)
{
   Extent_union(&impl, /*5Cf*/(C(Extent) *)b, /*5Cf*/(C(Extent) *)temp);
}
inline void Extent::unionBox(/*1Ab*/Box & box, /*1Ab*/Extent & temp)
{
   Extent_unionBox(&impl, /*5De*/&box.impl, /*5De*/&temp.impl);
}
inline void Extent::unionBox(/*1Ac*/Box * box, /*1Ac*/Extent * temp)
{
   Extent_unionBox(&impl, /*5Cf*/(C(Box) *)box, /*5Cf*/(C(Extent) *)temp);
}


// member accessors: Extent::first
// (struct::void *)

/*nstSet*/inline /*0H*/void * Extent::first_Prop::operator= (/*0H*/void * v)
{
   SELF(Extent, first);
   self->impl.first = v;
   return v;
}

/*regSet*/inline Extent::first_Prop & Extent::first_Prop::operator= (Extent::first_Prop & prop)
{
   SELF(Extent, first);
   /*0H*/void * v = prop;
   self->impl.first = v;
   return prop;
}
/*regGet*/inline Extent::first_Prop::operator /*0I*/void * () const
{
   SELF(Extent, first);
   return self ? ((C(Extent) *)&self->impl)->first : null;
}

// member accessors: Extent::last
// (struct::void *)

/*nstSet*/inline /*0H*/void * Extent::last_Prop::operator= (/*0H*/void * v)
{
   SELF(Extent, last);
   self->impl.last = v;
   return v;
}

/*regSet*/inline Extent::last_Prop & Extent::last_Prop::operator= (Extent::last_Prop & prop)
{
   SELF(Extent, last);
   /*0H*/void * v = prop;
   self->impl.last = v;
   return prop;
}
/*regGet*/inline Extent::last_Prop::operator /*0I*/void * () const
{
   SELF(Extent, last);
   return self ? ((C(Extent) *)&self->impl)->last : null;
}

// member accessors: Extent::count
// (struct::int)

/*nstSet*/inline /*0H*/int Extent::count_Prop::operator= (/*0H*/int v)
{
   SELF(Extent, count);
   self->impl.count = v;
   return v;
}

/*regSet*/inline Extent::count_Prop & Extent::count_Prop::operator= (Extent::count_Prop & prop)
{
   SELF(Extent, count);
   /*0H*/int v = prop;
   self->impl.count = v;
   return prop;
}
/*regGet*/inline Extent::count_Prop::operator /*0I*/int () const
{
   SELF(Extent, count);
   return self ? ((C(Extent) *)&self->impl)->count : 0;
}

// member accessors: Extent::offset
// (struct::uint)

/*nstSet*/inline /*0H*/uint Extent::offset_Prop::operator= (/*0H*/uint v)
{
   SELF(Extent, offset);
   self->impl.offset = v;
   return v;
}

/*regSet*/inline Extent::offset_Prop & Extent::offset_Prop::operator= (Extent::offset_Prop & prop)
{
   SELF(Extent, offset);
   /*0H*/uint v = prop;
   self->impl.offset = v;
   return prop;
}
/*regGet*/inline Extent::offset_Prop::operator /*0I*/uint () const
{
   SELF(Extent, offset);
   return self ? ((C(Extent) *)&self->impl)->offset : 0;
}

// member accessors: Extent::circ
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool Extent::circ_Prop::operator= (/*0H*/bool v)
{
   SELF(Extent, circ);
   self->impl.circ = (C(bool))v;
   return v;
}

/*regSet*/inline Extent::circ_Prop & Extent::circ_Prop::operator= (Extent::circ_Prop & prop)
{
   SELF(Extent, circ);
   /*0H*/bool v = prop;
   self->impl.circ = (C(bool))v;
   return prop;
}
/*regGet*/inline Extent::circ_Prop::operator /*0I*/bool () const
{
   SELF(Extent, circ);
   return self ? (bool)((C(Extent) *)&self->impl)->circ : (bool)0;
}

inline GuiApplication::GuiApplication(const char * appName, bool alwaysEmptyInput = (bool)0, bool fullScreen = (bool)0, const char * driver = null, Resolution resolution = (Resolution)0, PixelFormat pixelFormat = (PixelFormat)0, int refreshRate = 0, const char * skin = null, bool textMode = (bool)0, uint timerResolution = 0) : GuiApplication()
{
   this->appName = appName;
   this->alwaysEmptyInput = alwaysEmptyInput;
   this->fullScreen = fullScreen;
   this->driver = driver;
   this->resolution = resolution;
   this->pixelFormat = pixelFormat;
   this->refreshRate = refreshRate;
   this->skin = skin;
   this->textMode = textMode;
   this->timerResolution = timerResolution;
}

inline GuiApplication::GuiApplication_cycle_Functor::FunctionType GuiApplication::GuiApplication_cycle_Functor::operator= (FunctionType func)
{
   SELF(GuiApplication, cycle);
   if(self->vTbl == GuiApplication::_cpp_class.vTbl)
   {
      uint size = GuiApplication::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GuiApplication::GuiApplication_cycle_Functor::FunctionType, size);
      memcpy(self->vTbl, GuiApplication::_cpp_class.vTbl, sizeof(GuiApplication::GuiApplication_cycle_Functor::FunctionType) * size);
   }
   ((GuiApplication::GuiApplication_cycle_Functor::FunctionType *)self->vTbl)[M_VTBLID(GuiApplication, cycle)] = func;
   return func;
}
inline bool GuiApplication::GuiApplication_cycle_Functor::operator()( /*6Fj*/bool idle)
{
   SELF(GuiApplication, cycle);
   return (bool)GuiApplication_cycle(self ? self->impl : (C(GuiApplication))null, /*7Al*/(C(bool))idle);
}
// inline void GuiApplication::register_cycle(CPPClass & cl, GuiApplication::GuiApplication_cycle_Functor::FunctionType func)
// {
//    ((GuiApplication::GuiApplication_cycle_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GuiApplication, cycle)] = func;
// }

inline GuiApplication::GuiApplication_init_Functor::FunctionType GuiApplication::GuiApplication_init_Functor::operator= (FunctionType func)
{
   SELF(GuiApplication, init);
   if(self->vTbl == GuiApplication::_cpp_class.vTbl)
   {
      uint size = GuiApplication::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GuiApplication::GuiApplication_init_Functor::FunctionType, size);
      memcpy(self->vTbl, GuiApplication::_cpp_class.vTbl, sizeof(GuiApplication::GuiApplication_init_Functor::FunctionType) * size);
   }
   ((GuiApplication::GuiApplication_init_Functor::FunctionType *)self->vTbl)[M_VTBLID(GuiApplication, init)] = func;
   return func;
}
inline bool GuiApplication::GuiApplication_init_Functor::operator()( )
{
   SELF(GuiApplication, init);
   return (bool)GuiApplication_init(self ? self->impl : (C(GuiApplication))null);
}
// inline void GuiApplication::register_init(CPPClass & cl, GuiApplication::GuiApplication_init_Functor::FunctionType func)
// {
//    ((GuiApplication::GuiApplication_init_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GuiApplication, init)] = func;
// }

inline GuiApplication::GuiApplication_terminate_Functor::FunctionType GuiApplication::GuiApplication_terminate_Functor::operator= (FunctionType func)
{
   SELF(GuiApplication, terminate);
   if(self->vTbl == GuiApplication::_cpp_class.vTbl)
   {
      uint size = GuiApplication::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GuiApplication::GuiApplication_terminate_Functor::FunctionType, size);
      memcpy(self->vTbl, GuiApplication::_cpp_class.vTbl, sizeof(GuiApplication::GuiApplication_terminate_Functor::FunctionType) * size);
   }
   ((GuiApplication::GuiApplication_terminate_Functor::FunctionType *)self->vTbl)[M_VTBLID(GuiApplication, terminate)] = func;
   return func;
}
inline void GuiApplication::GuiApplication_terminate_Functor::operator()( )
{
   SELF(GuiApplication, terminate);
   GuiApplication_terminate(self ? self->impl : (C(GuiApplication))null);
}
// inline void GuiApplication::register_terminate(CPPClass & cl, GuiApplication::GuiApplication_terminate_Functor::FunctionType func)
// {
//    ((GuiApplication::GuiApplication_terminate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GuiApplication, terminate)] = func;
// }


inline Cursor GuiApplication::getCursor(/*1Ab*/SystemCursor cursor)
{
   return Cursor(GuiApplication_getCursor(impl, /*5Ee*/(C(SystemCursor))cursor));
}
inline C(bool) GuiApplication::getKeyState(/*1Ab*/Key key)
{
   return GuiApplication_getKeyState(impl, /*5Ee*/(C(Key))key.impl);
}
inline C(bool) GuiApplication::getMouseState(/*1Ab*/MouseButtons * buttons, /*1Ab*/int * x, /*1Ab*/int * y)
{
   return GuiApplication_getMouseState(impl, /*5Ee*/(C(MouseButtons) *)buttons, /*5Ge*/x, /*5Ge*/y);
}
inline void GuiApplication::lock()
{
   GuiApplication_lock(impl);
}
inline void GuiApplication::lockEx(/*1Ab*/int count)
{
   GuiApplication_lockEx(impl, /*5Ge*/count);
}
inline void GuiApplication::pauseNetworkEvents()
{
   GuiApplication_pauseNetworkEvents(impl);
}
inline C(bool) GuiApplication::processFileNotifications()
{
   return GuiApplication_processFileNotifications(impl);
}
inline C(bool) GuiApplication::processInput(/*1Ab*/bool useProcessAll)
{
   return GuiApplication_processInput(impl, /*5Ee*/(C(bool))useProcessAll);
}
inline C(bool) GuiApplication::processNetworkEvents()
{
   return GuiApplication_processNetworkEvents(impl);
}
inline void GuiApplication::resumeNetworkEvents()
{
   GuiApplication_resumeNetworkEvents(impl);
}
inline C(bool) GuiApplication::setDesktopPosition(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h, /*1Ab*/bool moveChildren)
{
   return GuiApplication_setDesktopPosition(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/w, /*5Ge*/h, /*5Ee*/(C(bool))moveChildren);
}
inline void GuiApplication::signalEvent()
{
   GuiApplication_signalEvent(impl);
}
inline C(bool) GuiApplication::switchMode(/*1Ab*/bool fullScreen, /*1Ab*/const char * driverName, /*1Ab*/Resolution resolution, /*1Ab*/PixelFormat colorDepth, /*1Ab*/int refreshRate, /*1Ab*/const char * skinName, /*1Ab*/bool fallBack)
{
   return GuiApplication_switchMode(impl, /*5Ee*/(C(bool))fullScreen, /*5Ge*/driverName, /*5Ee*/(C(Resolution))resolution, /*5Ee*/(C(PixelFormat))colorDepth, /*5Ge*/refreshRate, /*5Ge*/skinName, /*5Ee*/(C(bool))fallBack);
}
inline void GuiApplication::unlock()
{
   GuiApplication_unlock(impl);
}
inline int GuiApplication::unlockEx()
{
   return GuiApplication_unlockEx(impl);
}
inline void GuiApplication::updateDisplay()
{
   GuiApplication_updateDisplay(impl);
}
inline void GuiApplication::wait()
{
   GuiApplication_wait(impl);
}
inline void GuiApplication::waitEvent()
{
   GuiApplication_waitEvent(impl);
}
inline void GuiApplication::waitNetworkEvent()
{
   GuiApplication_waitNetworkEvent(impl);
}


// property callers: GuiApplication::appName
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GuiApplication::appName_Prop::operator= (/*0H*/const char * v)
{
   SELF(GuiApplication, appName);
   GuiApplication_set_appName(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GuiApplication::appName_Prop & GuiApplication::appName_Prop::operator= (GuiApplication::appName_Prop & prop)
{
   SELF(GuiApplication, appName);
   /*0H*/const char * v = prop;
   GuiApplication_set_appName(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GuiApplication::appName_Prop::operator /*0I*/const char * () const
{
   SELF(GuiApplication, appName);
   return GuiApplication_get_appName(self ? self->impl : null);
}

// property callers: GuiApplication::semaphore   // get only
// (normal::nohead)

/*regGet*/inline GuiApplication::semaphore_Prop::operator /*0I*/Semaphore () const
{
   SELF(GuiApplication, semaphore);
   Semaphore value(GuiApplication_get_semaphore(self->impl));
   return value;
}

// property callers: GuiApplication::alwaysEmptyInput
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool GuiApplication::alwaysEmptyInput_Prop::operator= (/*0H*/bool v)
{
   SELF(GuiApplication, alwaysEmptyInput);
   GuiApplication_set_alwaysEmptyInput(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline GuiApplication::alwaysEmptyInput_Prop & GuiApplication::alwaysEmptyInput_Prop::operator= (GuiApplication::alwaysEmptyInput_Prop & prop)
{
   SELF(GuiApplication, alwaysEmptyInput);
   /*0H*/bool v = prop;
   GuiApplication_set_alwaysEmptyInput(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline GuiApplication::alwaysEmptyInput_Prop::operator /*0I*/bool () const
{
   SELF(GuiApplication, alwaysEmptyInput);
   return (bool)GuiApplication_get_alwaysEmptyInput(self ? self->impl : null);
}

// property callers: GuiApplication::fullScreen
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool GuiApplication::fullScreen_Prop::operator= (/*0H*/bool v)
{
   SELF(GuiApplication, fullScreen);
   GuiApplication_set_fullScreen(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline GuiApplication::fullScreen_Prop & GuiApplication::fullScreen_Prop::operator= (GuiApplication::fullScreen_Prop & prop)
{
   SELF(GuiApplication, fullScreen);
   /*0H*/bool v = prop;
   GuiApplication_set_fullScreen(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline GuiApplication::fullScreen_Prop::operator /*0I*/bool () const
{
   SELF(GuiApplication, fullScreen);
   return (bool)GuiApplication_get_fullScreen(self ? self->impl : null);
}

// property callers: GuiApplication::driver
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GuiApplication::driver_Prop::operator= (/*0H*/const char * v)
{
   SELF(GuiApplication, driver);
   GuiApplication_set_driver(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GuiApplication::driver_Prop & GuiApplication::driver_Prop::operator= (GuiApplication::driver_Prop & prop)
{
   SELF(GuiApplication, driver);
   /*0H*/const char * v = prop;
   GuiApplication_set_driver(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GuiApplication::driver_Prop::operator /*0I*/const char * () const
{
   SELF(GuiApplication, driver);
   return GuiApplication_get_driver(self ? self->impl : null);
}

// property callers: GuiApplication::resolution
// (normal::enum|int)

/*nstSet*/inline /*0H*/Resolution GuiApplication::resolution_Prop::operator= (/*0H*/Resolution v)
{
   SELF(GuiApplication, resolution);
   GuiApplication_set_resolution(self ? self->impl : null, (C(Resolution))v);
   return v;
}

/*regSet*/inline GuiApplication::resolution_Prop & GuiApplication::resolution_Prop::operator= (GuiApplication::resolution_Prop & prop)
{
   SELF(GuiApplication, resolution);
   /*0H*/Resolution v = prop;
   GuiApplication_set_resolution(self ? self->impl : null, (C(Resolution))v);
   return prop;
}
/*regGet*/inline GuiApplication::resolution_Prop::operator /*0I*/Resolution () const
{
   SELF(GuiApplication, resolution);
   return (Resolution)GuiApplication_get_resolution(self ? self->impl : null);
}

// property callers: GuiApplication::pixelFormat
// (normal::enum|int)

/*nstSet*/inline /*0H*/PixelFormat GuiApplication::pixelFormat_Prop::operator= (/*0H*/PixelFormat v)
{
   SELF(GuiApplication, pixelFormat);
   GuiApplication_set_pixelFormat(self ? self->impl : null, (C(PixelFormat))v);
   return v;
}

/*regSet*/inline GuiApplication::pixelFormat_Prop & GuiApplication::pixelFormat_Prop::operator= (GuiApplication::pixelFormat_Prop & prop)
{
   SELF(GuiApplication, pixelFormat);
   /*0H*/PixelFormat v = prop;
   GuiApplication_set_pixelFormat(self ? self->impl : null, (C(PixelFormat))v);
   return prop;
}
/*regGet*/inline GuiApplication::pixelFormat_Prop::operator /*0I*/PixelFormat () const
{
   SELF(GuiApplication, pixelFormat);
   return (PixelFormat)GuiApplication_get_pixelFormat(self ? self->impl : null);
}

// property callers: GuiApplication::refreshRate
// (normal::int)

/*nstSet*/inline /*0H*/int GuiApplication::refreshRate_Prop::operator= (/*0H*/int v)
{
   SELF(GuiApplication, refreshRate);
   GuiApplication_set_refreshRate(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GuiApplication::refreshRate_Prop & GuiApplication::refreshRate_Prop::operator= (GuiApplication::refreshRate_Prop & prop)
{
   SELF(GuiApplication, refreshRate);
   /*0H*/int v = prop;
   GuiApplication_set_refreshRate(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GuiApplication::refreshRate_Prop::operator /*0I*/int () const
{
   SELF(GuiApplication, refreshRate);
   return GuiApplication_get_refreshRate(self ? self->impl : null);
}

// property callers: GuiApplication::skin
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GuiApplication::skin_Prop::operator= (/*0H*/const char * v)
{
   SELF(GuiApplication, skin);
   GuiApplication_set_skin(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GuiApplication::skin_Prop & GuiApplication::skin_Prop::operator= (GuiApplication::skin_Prop & prop)
{
   SELF(GuiApplication, skin);
   /*0H*/const char * v = prop;
   GuiApplication_set_skin(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GuiApplication::skin_Prop::operator /*0I*/const char * () const
{
   SELF(GuiApplication, skin);
   return GuiApplication_get_skin(self ? self->impl : null);
}

// property callers: GuiApplication::textMode
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool GuiApplication::textMode_Prop::operator= (/*0H*/bool v)
{
   SELF(GuiApplication, textMode);
   GuiApplication_set_textMode(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline GuiApplication::textMode_Prop & GuiApplication::textMode_Prop::operator= (GuiApplication::textMode_Prop & prop)
{
   SELF(GuiApplication, textMode);
   /*0H*/bool v = prop;
   GuiApplication_set_textMode(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline GuiApplication::textMode_Prop::operator /*0I*/bool () const
{
   SELF(GuiApplication, textMode);
   return (bool)GuiApplication_get_textMode(self ? self->impl : null);
}

// property callers: GuiApplication::desktop   // get only
// (normal::normal)

/*regGet*/inline GuiApplication::desktop_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(GuiApplication, desktop);
   C(Instance) i = GuiApplication_get_desktop(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> GuiApplication::desktop_Prop::operator /*0D*/-> () const
{
   SELF(GuiApplication, desktop);
   C(Instance) i = GuiApplication_get_desktop(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline GuiApplication::desktop_Prop::operator /*0E*/Window () const
{
   SELF(GuiApplication, desktop);
   C(Instance) i = GuiApplication_get_desktop(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline GuiApplication::desktop_Prop::operator /*0F*/Window* () const
{
   SELF(GuiApplication, desktop);
   C(Instance) i = GuiApplication_get_desktop(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: GuiApplication::drivers   // get only
// (normal::const char **)

/*regGet*/inline GuiApplication::drivers_Prop::operator /*0I*/const char ** () const
{
   SELF(GuiApplication, drivers);
   return GuiApplication_get_drivers(self ? self->impl : null);
}

// property callers: GuiApplication::skins   // get only
// (normal::const char * const*)

/*regGet*/inline GuiApplication::skins_Prop::operator /*0I*/const char ** () const
{
   SELF(GuiApplication, skins);
   return GuiApplication_get_skins(self ? self->impl : null);
}

// property callers: GuiApplication::currentSkin   // get only
// (normal::subclass(ecere::gui::Skin))

/*regGet*/inline GuiApplication::currentSkin_Prop::operator /*0I*/C(Class) * () const
{
   SELF(GuiApplication, currentSkin);
   return GuiApplication_get_currentSkin(self ? self->impl : null);
}

// property callers: GuiApplication::numDrivers   // get only
// (normal::int)

/*regGet*/inline GuiApplication::numDrivers_Prop::operator /*0I*/int () const
{
   SELF(GuiApplication, numDrivers);
   return GuiApplication_get_numDrivers(self ? self->impl : null);
}

// property callers: GuiApplication::numSkins   // get only
// (normal::int)

/*regGet*/inline GuiApplication::numSkins_Prop::operator /*0I*/int () const
{
   SELF(GuiApplication, numSkins);
   return GuiApplication_get_numSkins(self ? self->impl : null);
}

// property callers: GuiApplication::timerResolution   // set only
// (normal::uint)

/*nstSet*/inline /*0G*/uint GuiApplication::timerResolution_Prop::operator= (/*0G*/uint v)
{
   SELF(GuiApplication, timerResolution);
   GuiApplication_set_timerResolution(self->impl, v);
   return v;
}


// property callers: GuiApplication::acquiredWindow   // get only
// (normal::normal)

/*regGet*/inline GuiApplication::acquiredWindow_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(GuiApplication, acquiredWindow);
   C(Instance) i = GuiApplication_get_acquiredWindow(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> GuiApplication::acquiredWindow_Prop::operator /*0D*/-> () const
{
   SELF(GuiApplication, acquiredWindow);
   C(Instance) i = GuiApplication_get_acquiredWindow(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline GuiApplication::acquiredWindow_Prop::operator /*0E*/Window () const
{
   SELF(GuiApplication, acquiredWindow);
   C(Instance) i = GuiApplication_get_acquiredWindow(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline GuiApplication::acquiredWindow_Prop::operator /*0F*/Window* () const
{
   SELF(GuiApplication, acquiredWindow);
   C(Instance) i = GuiApplication_get_acquiredWindow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

inline Interface::Interface_acquireInput_Functor::FunctionType Interface::Interface_acquireInput_Functor::operator= (FunctionType func)
{
   SELF(Interface, acquireInput);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_acquireInput_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_acquireInput_Functor::FunctionType) * size);
   }
   ((Interface::Interface_acquireInput_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, acquireInput)] = func;
   return func;
}
inline bool Interface::Interface_acquireInput_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/bool state)
{
   SELF(Interface, acquireInput);
   return (bool)Interface_acquireInput(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(bool))state);
}
// inline void Interface::register_acquireInput(CPPClass & cl, Interface::Interface_acquireInput_Functor::FunctionType func)
// {
//    ((Interface::Interface_acquireInput_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, acquireInput)] = func;
// }

inline Interface::Interface_activateRootWindow_Functor::FunctionType Interface::Interface_activateRootWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, activateRootWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_activateRootWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_activateRootWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_activateRootWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, activateRootWindow)] = func;
   return func;
}
inline void Interface::Interface_activateRootWindow_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, activateRootWindow);
   Interface_activateRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_activateRootWindow(CPPClass & cl, Interface::Interface_activateRootWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_activateRootWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, activateRootWindow)] = func;
// }

inline Interface::Interface_allocateClipboard_Functor::FunctionType Interface::Interface_allocateClipboard_Functor::operator= (FunctionType func)
{
   SELF(Interface, allocateClipboard);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_allocateClipboard_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_allocateClipboard_Functor::FunctionType) * size);
   }
   ((Interface::Interface_allocateClipboard_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, allocateClipboard)] = func;
   return func;
}
inline bool Interface::Interface_allocateClipboard_Functor::operator()( /*6Fj*/ClipBoard clipBoard, /*6Fj*/uint size)
{
   SELF(Interface, allocateClipboard);
   return (bool)Interface_allocateClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl, /*7Al*/size);
}
// inline void Interface::register_allocateClipboard(CPPClass & cl, Interface::Interface_allocateClipboard_Functor::FunctionType func)
// {
//    ((Interface::Interface_allocateClipboard_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, allocateClipboard)] = func;
// }

inline Interface::Interface_clearClipboard_Functor::FunctionType Interface::Interface_clearClipboard_Functor::operator= (FunctionType func)
{
   SELF(Interface, clearClipboard);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_clearClipboard_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_clearClipboard_Functor::FunctionType) * size);
   }
   ((Interface::Interface_clearClipboard_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, clearClipboard)] = func;
   return func;
}
inline void Interface::Interface_clearClipboard_Functor::operator()( )
{
   SELF(Interface, clearClipboard);
   Interface_clearClipboard(self ? self->impl : (C(Interface))null);
}
// inline void Interface::register_clearClipboard(CPPClass & cl, Interface::Interface_clearClipboard_Functor::FunctionType func)
// {
//    ((Interface::Interface_clearClipboard_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, clearClipboard)] = func;
// }

inline Interface::Interface_createRootWindow_Functor::FunctionType Interface::Interface_createRootWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, createRootWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_createRootWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_createRootWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_createRootWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, createRootWindow)] = func;
   return func;
}
inline void * Interface::Interface_createRootWindow_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, createRootWindow);
   return Interface_createRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_createRootWindow(CPPClass & cl, Interface::Interface_createRootWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_createRootWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, createRootWindow)] = func;
// }

inline Interface::Interface_destroyRootWindow_Functor::FunctionType Interface::Interface_destroyRootWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, destroyRootWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_destroyRootWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_destroyRootWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_destroyRootWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, destroyRootWindow)] = func;
   return func;
}
inline void Interface::Interface_destroyRootWindow_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, destroyRootWindow);
   Interface_destroyRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_destroyRootWindow(CPPClass & cl, Interface::Interface_destroyRootWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_destroyRootWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, destroyRootWindow)] = func;
// }

inline Interface::Interface_ensureFullScreen_Functor::FunctionType Interface::Interface_ensureFullScreen_Functor::operator= (FunctionType func)
{
   SELF(Interface, ensureFullScreen);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_ensureFullScreen_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_ensureFullScreen_Functor::FunctionType) * size);
   }
   ((Interface::Interface_ensureFullScreen_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, ensureFullScreen)] = func;
   return func;
}
inline void Interface::Interface_ensureFullScreen_Functor::operator()( /*6Cj*/C(bool) * fullScreen)
{
   SELF(Interface, ensureFullScreen);
   Interface_ensureFullScreen(self ? self->impl : (C(Interface))null, /*7Al*/fullScreen);
}
// inline void Interface::register_ensureFullScreen(CPPClass & cl, Interface::Interface_ensureFullScreen_Functor::FunctionType func)
// {
//    ((Interface::Interface_ensureFullScreen_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, ensureFullScreen)] = func;
// }

inline Interface::Interface_flashRootWindow_Functor::FunctionType Interface::Interface_flashRootWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, flashRootWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_flashRootWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_flashRootWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_flashRootWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, flashRootWindow)] = func;
   return func;
}
inline void Interface::Interface_flashRootWindow_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, flashRootWindow);
   Interface_flashRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_flashRootWindow(CPPClass & cl, Interface::Interface_flashRootWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_flashRootWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, flashRootWindow)] = func;
// }

inline Interface::Interface_getCurrentMode_Functor::FunctionType Interface::Interface_getCurrentMode_Functor::operator= (FunctionType func)
{
   SELF(Interface, getCurrentMode);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_getCurrentMode_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_getCurrentMode_Functor::FunctionType) * size);
   }
   ((Interface::Interface_getCurrentMode_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, getCurrentMode)] = func;
   return func;
}
inline void Interface::Interface_getCurrentMode_Functor::operator()( /*6Cj*/C(bool) * fullScreen, /*6Fj*/Resolution * resolution, /*6Fj*/PixelFormat * colorDepth, /*6Fj*/int * refreshRate)
{
   SELF(Interface, getCurrentMode);
   Interface_getCurrentMode(self ? self->impl : (C(Interface))null, /*7Al*/fullScreen, /*7Al*/(C(Resolution) *)resolution, /*7Al*/(C(PixelFormat) *)colorDepth, /*7Al*/refreshRate);
}
// inline void Interface::register_getCurrentMode(CPPClass & cl, Interface::Interface_getCurrentMode_Functor::FunctionType func)
// {
//    ((Interface::Interface_getCurrentMode_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, getCurrentMode)] = func;
// }

inline Interface::Interface_getJoystickState_Functor::FunctionType Interface::Interface_getJoystickState_Functor::operator= (FunctionType func)
{
   SELF(Interface, getJoystickState);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_getJoystickState_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_getJoystickState_Functor::FunctionType) * size);
   }
   ((Interface::Interface_getJoystickState_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, getJoystickState)] = func;
   return func;
}
inline bool Interface::Interface_getJoystickState_Functor::operator()( /*6Fj*/int device, /*6Fj*/Joystick & joystick)
{
   SELF(Interface, getJoystickState);
   return (bool)Interface_getJoystickState(self ? self->impl : (C(Interface))null, /*7Al*/device, /*7Al*/&joystick.impl);
}
// inline void Interface::register_getJoystickState(CPPClass & cl, Interface::Interface_getJoystickState_Functor::FunctionType func)
// {
//    ((Interface::Interface_getJoystickState_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, getJoystickState)] = func;
// }

inline Interface::Interface_getKeyState_Functor::FunctionType Interface::Interface_getKeyState_Functor::operator= (FunctionType func)
{
   SELF(Interface, getKeyState);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_getKeyState_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_getKeyState_Functor::FunctionType) * size);
   }
   ((Interface::Interface_getKeyState_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, getKeyState)] = func;
   return func;
}
inline bool Interface::Interface_getKeyState_Functor::operator()( /*6Fj*/Key key)
{
   SELF(Interface, getKeyState);
   return (bool)Interface_getKeyState(self ? self->impl : (C(Interface))null, /*7Al*/(C(Key))key);
}
// inline void Interface::register_getKeyState(CPPClass & cl, Interface::Interface_getKeyState_Functor::FunctionType func)
// {
//    ((Interface::Interface_getKeyState_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, getKeyState)] = func;
// }

inline Interface::Interface_getMousePosition_Functor::FunctionType Interface::Interface_getMousePosition_Functor::operator= (FunctionType func)
{
   SELF(Interface, getMousePosition);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_getMousePosition_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_getMousePosition_Functor::FunctionType) * size);
   }
   ((Interface::Interface_getMousePosition_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, getMousePosition)] = func;
   return func;
}
inline void Interface::Interface_getMousePosition_Functor::operator()( /*6Fj*/int * x, /*6Fj*/int * y)
{
   SELF(Interface, getMousePosition);
   Interface_getMousePosition(self ? self->impl : (C(Interface))null, /*7Al*/x, /*7Al*/y);
}
// inline void Interface::register_getMousePosition(CPPClass & cl, Interface::Interface_getMousePosition_Functor::FunctionType func)
// {
//    ((Interface::Interface_getMousePosition_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, getMousePosition)] = func;
// }

inline Interface::Interface_getMouseState_Functor::FunctionType Interface::Interface_getMouseState_Functor::operator= (FunctionType func)
{
   SELF(Interface, getMouseState);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_getMouseState_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_getMouseState_Functor::FunctionType) * size);
   }
   ((Interface::Interface_getMouseState_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, getMouseState)] = func;
   return func;
}
inline bool Interface::Interface_getMouseState_Functor::operator()( /*6Fj*/MouseButtons * buttons, /*6Fj*/int * x, /*6Fj*/int * y)
{
   SELF(Interface, getMouseState);
   return (bool)Interface_getMouseState(self ? self->impl : (C(Interface))null, /*7Al*/(C(MouseButtons) *)buttons, /*7Al*/x, /*7Al*/y);
}
// inline void Interface::register_getMouseState(CPPClass & cl, Interface::Interface_getMouseState_Functor::FunctionType func)
// {
//    ((Interface::Interface_getMouseState_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, getMouseState)] = func;
// }

inline Interface::Interface_getScreenArea_Functor::FunctionType Interface::Interface_getScreenArea_Functor::operator= (FunctionType func)
{
   SELF(Interface, getScreenArea);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_getScreenArea_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_getScreenArea_Functor::FunctionType) * size);
   }
   ((Interface::Interface_getScreenArea_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, getScreenArea)] = func;
   return func;
}
inline void Interface::Interface_getScreenArea_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/Box & box)
{
   SELF(Interface, getScreenArea);
   Interface_getScreenArea(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/&box.impl);
}
// inline void Interface::register_getScreenArea(CPPClass & cl, Interface::Interface_getScreenArea_Functor::FunctionType func)
// {
//    ((Interface::Interface_getScreenArea_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, getScreenArea)] = func;
// }

inline Interface::Interface_graphicsDrivers_Functor::FunctionType Interface::Interface_graphicsDrivers_Functor::operator= (FunctionType func)
{
   SELF(Interface, graphicsDrivers);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_graphicsDrivers_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_graphicsDrivers_Functor::FunctionType) * size);
   }
   ((Interface::Interface_graphicsDrivers_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, graphicsDrivers)] = func;
   return func;
}
inline const char ** Interface::Interface_graphicsDrivers_Functor::operator()( /*6Fj*/int * numDrivers)
{
   SELF(Interface, graphicsDrivers);
   return Interface_graphicsDrivers(self ? self->impl : (C(Interface))null, /*7Al*/numDrivers);
}
// inline void Interface::register_graphicsDrivers(CPPClass & cl, Interface::Interface_graphicsDrivers_Functor::FunctionType func)
// {
//    ((Interface::Interface_graphicsDrivers_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, graphicsDrivers)] = func;
// }

inline Interface::Interface_initialize_Functor::FunctionType Interface::Interface_initialize_Functor::operator= (FunctionType func)
{
   SELF(Interface, initialize);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_initialize_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_initialize_Functor::FunctionType) * size);
   }
   ((Interface::Interface_initialize_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, initialize)] = func;
   return func;
}
inline bool Interface::Interface_initialize_Functor::operator()( )
{
   SELF(Interface, initialize);
   return (bool)Interface_initialize(self ? self->impl : (C(Interface))null);
}
// inline void Interface::register_initialize(CPPClass & cl, Interface::Interface_initialize_Functor::FunctionType func)
// {
//    ((Interface::Interface_initialize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, initialize)] = func;
// }

inline Interface::Interface_loadClipboard_Functor::FunctionType Interface::Interface_loadClipboard_Functor::operator= (FunctionType func)
{
   SELF(Interface, loadClipboard);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_loadClipboard_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_loadClipboard_Functor::FunctionType) * size);
   }
   ((Interface::Interface_loadClipboard_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, loadClipboard)] = func;
   return func;
}
inline bool Interface::Interface_loadClipboard_Functor::operator()( /*6Fj*/ClipBoard clipBoard)
{
   SELF(Interface, loadClipboard);
   return (bool)Interface_loadClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl);
}
// inline void Interface::register_loadClipboard(CPPClass & cl, Interface::Interface_loadClipboard_Functor::FunctionType func)
// {
//    ((Interface::Interface_loadClipboard_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, loadClipboard)] = func;
// }

inline Interface::Interface_lock_Functor::FunctionType Interface::Interface_lock_Functor::operator= (FunctionType func)
{
   SELF(Interface, lock);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_lock_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_lock_Functor::FunctionType) * size);
   }
   ((Interface::Interface_lock_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, lock)] = func;
   return func;
}
inline void Interface::Interface_lock_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, lock);
   Interface_lock(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_lock(CPPClass & cl, Interface::Interface_lock_Functor::FunctionType func)
// {
//    ((Interface::Interface_lock_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, lock)] = func;
// }

inline Interface::Interface_offsetWindow_Functor::FunctionType Interface::Interface_offsetWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, offsetWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_offsetWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_offsetWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_offsetWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, offsetWindow)] = func;
   return func;
}
inline void Interface::Interface_offsetWindow_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/int * x, /*6Fj*/int * y)
{
   SELF(Interface, offsetWindow);
   Interface_offsetWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/x, /*7Al*/y);
}
// inline void Interface::register_offsetWindow(CPPClass & cl, Interface::Interface_offsetWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_offsetWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, offsetWindow)] = func;
// }

inline Interface::Interface_orderRootWindow_Functor::FunctionType Interface::Interface_orderRootWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, orderRootWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_orderRootWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_orderRootWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_orderRootWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, orderRootWindow)] = func;
   return func;
}
inline void Interface::Interface_orderRootWindow_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/bool topMost)
{
   SELF(Interface, orderRootWindow);
   Interface_orderRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(bool))topMost);
}
// inline void Interface::register_orderRootWindow(CPPClass & cl, Interface::Interface_orderRootWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_orderRootWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, orderRootWindow)] = func;
// }

inline Interface::Interface_positionRootWindow_Functor::FunctionType Interface::Interface_positionRootWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, positionRootWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_positionRootWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_positionRootWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_positionRootWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, positionRootWindow)] = func;
   return func;
}
inline void Interface::Interface_positionRootWindow_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Fj*/bool move, /*6Fj*/bool resize)
{
   SELF(Interface, positionRootWindow);
   Interface_positionRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h, /*7Al*/(C(bool))move, /*7Al*/(C(bool))resize);
}
// inline void Interface::register_positionRootWindow(CPPClass & cl, Interface::Interface_positionRootWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_positionRootWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, positionRootWindow)] = func;
// }

inline Interface::Interface_processInput_Functor::FunctionType Interface::Interface_processInput_Functor::operator= (FunctionType func)
{
   SELF(Interface, processInput);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_processInput_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_processInput_Functor::FunctionType) * size);
   }
   ((Interface::Interface_processInput_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, processInput)] = func;
   return func;
}
inline bool Interface::Interface_processInput_Functor::operator()( /*6Fj*/bool processAll)
{
   SELF(Interface, processInput);
   return (bool)Interface_processInput(self ? self->impl : (C(Interface))null, /*7Al*/(C(bool))processAll);
}
// inline void Interface::register_processInput(CPPClass & cl, Interface::Interface_processInput_Functor::FunctionType func)
// {
//    ((Interface::Interface_processInput_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, processInput)] = func;
// }

inline Interface::Interface_saveClipboard_Functor::FunctionType Interface::Interface_saveClipboard_Functor::operator= (FunctionType func)
{
   SELF(Interface, saveClipboard);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_saveClipboard_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_saveClipboard_Functor::FunctionType) * size);
   }
   ((Interface::Interface_saveClipboard_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, saveClipboard)] = func;
   return func;
}
inline bool Interface::Interface_saveClipboard_Functor::operator()( /*6Fj*/ClipBoard clipBoard)
{
   SELF(Interface, saveClipboard);
   return (bool)Interface_saveClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl);
}
// inline void Interface::register_saveClipboard(CPPClass & cl, Interface::Interface_saveClipboard_Functor::FunctionType func)
// {
//    ((Interface::Interface_saveClipboard_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, saveClipboard)] = func;
// }

inline Interface::Interface_screenMode_Functor::FunctionType Interface::Interface_screenMode_Functor::operator= (FunctionType func)
{
   SELF(Interface, screenMode);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_screenMode_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_screenMode_Functor::FunctionType) * size);
   }
   ((Interface::Interface_screenMode_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, screenMode)] = func;
   return func;
}
inline bool Interface::Interface_screenMode_Functor::operator()( /*6Fj*/bool fullScreen, /*6Fj*/Resolution resolution, /*6Fj*/PixelFormat colorDepth, /*6Fj*/int refreshRate, /*6Cj*/C(bool) * textMode)
{
   SELF(Interface, screenMode);
   return (bool)Interface_screenMode(self ? self->impl : (C(Interface))null, /*7Al*/(C(bool))fullScreen, /*7Al*/(C(Resolution))resolution, /*7Al*/(C(PixelFormat))colorDepth, /*7Al*/refreshRate, /*7Al*/textMode);
}
// inline void Interface::register_screenMode(CPPClass & cl, Interface::Interface_screenMode_Functor::FunctionType func)
// {
//    ((Interface::Interface_screenMode_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, screenMode)] = func;
// }

inline Interface::Interface_setCaret_Functor::FunctionType Interface::Interface_setCaret_Functor::operator= (FunctionType func)
{
   SELF(Interface, setCaret);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setCaret_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setCaret_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setCaret_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setCaret)] = func;
   return func;
}
inline void Interface::Interface_setCaret_Functor::operator()( /*6Fj*/int caretX, /*6Fj*/int caretY, /*6Fj*/int size)
{
   SELF(Interface, setCaret);
   Interface_setCaret(self ? self->impl : (C(Interface))null, /*7Al*/caretX, /*7Al*/caretY, /*7Al*/size);
}
// inline void Interface::register_setCaret(CPPClass & cl, Interface::Interface_setCaret_Functor::FunctionType func)
// {
//    ((Interface::Interface_setCaret_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setCaret)] = func;
// }

inline Interface::Interface_setIcon_Functor::FunctionType Interface::Interface_setIcon_Functor::operator= (FunctionType func)
{
   SELF(Interface, setIcon);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setIcon_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setIcon_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setIcon_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setIcon)] = func;
   return func;
}
inline bool Interface::Interface_setIcon_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/BitmapResource & icon)
{
   SELF(Interface, setIcon);
   return (bool)Interface_setIcon(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/icon.impl);
}
// inline void Interface::register_setIcon(CPPClass & cl, Interface::Interface_setIcon_Functor::FunctionType func)
// {
//    ((Interface::Interface_setIcon_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setIcon)] = func;
// }

inline Interface::Interface_setMouseCapture_Functor::FunctionType Interface::Interface_setMouseCapture_Functor::operator= (FunctionType func)
{
   SELF(Interface, setMouseCapture);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setMouseCapture_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setMouseCapture_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setMouseCapture_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setMouseCapture)] = func;
   return func;
}
inline void Interface::Interface_setMouseCapture_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, setMouseCapture);
   Interface_setMouseCapture(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_setMouseCapture(CPPClass & cl, Interface::Interface_setMouseCapture_Functor::FunctionType func)
// {
//    ((Interface::Interface_setMouseCapture_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setMouseCapture)] = func;
// }

inline Interface::Interface_setMouseCursor_Functor::FunctionType Interface::Interface_setMouseCursor_Functor::operator= (FunctionType func)
{
   SELF(Interface, setMouseCursor);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setMouseCursor_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setMouseCursor_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setMouseCursor_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setMouseCursor)] = func;
   return func;
}
inline void Interface::Interface_setMouseCursor_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/SystemCursor cursor)
{
   SELF(Interface, setMouseCursor);
   Interface_setMouseCursor(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(SystemCursor))cursor);
}
// inline void Interface::register_setMouseCursor(CPPClass & cl, Interface::Interface_setMouseCursor_Functor::FunctionType func)
// {
//    ((Interface::Interface_setMouseCursor_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setMouseCursor)] = func;
// }

inline Interface::Interface_setMousePosition_Functor::FunctionType Interface::Interface_setMousePosition_Functor::operator= (FunctionType func)
{
   SELF(Interface, setMousePosition);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setMousePosition_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setMousePosition_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setMousePosition_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setMousePosition)] = func;
   return func;
}
inline void Interface::Interface_setMousePosition_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y)
{
   SELF(Interface, setMousePosition);
   Interface_setMousePosition(self ? self->impl : (C(Interface))null, /*7Al*/x, /*7Al*/y);
}
// inline void Interface::register_setMousePosition(CPPClass & cl, Interface::Interface_setMousePosition_Functor::FunctionType func)
// {
//    ((Interface::Interface_setMousePosition_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setMousePosition)] = func;
// }

inline Interface::Interface_setMouseRange_Functor::FunctionType Interface::Interface_setMouseRange_Functor::operator= (FunctionType func)
{
   SELF(Interface, setMouseRange);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setMouseRange_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setMouseRange_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setMouseRange_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setMouseRange)] = func;
   return func;
}
inline void Interface::Interface_setMouseRange_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/Box & box)
{
   SELF(Interface, setMouseRange);
   Interface_setMouseRange(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/&box.impl);
}
// inline void Interface::register_setMouseRange(CPPClass & cl, Interface::Interface_setMouseRange_Functor::FunctionType func)
// {
//    ((Interface::Interface_setMouseRange_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setMouseRange)] = func;
// }

inline Interface::Interface_setRootWindowCaption_Functor::FunctionType Interface::Interface_setRootWindowCaption_Functor::operator= (FunctionType func)
{
   SELF(Interface, setRootWindowCaption);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setRootWindowCaption_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setRootWindowCaption_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setRootWindowCaption_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setRootWindowCaption)] = func;
   return func;
}
inline void Interface::Interface_setRootWindowCaption_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/const char * name)
{
   SELF(Interface, setRootWindowCaption);
   Interface_setRootWindowCaption(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/name);
}
// inline void Interface::register_setRootWindowCaption(CPPClass & cl, Interface::Interface_setRootWindowCaption_Functor::FunctionType func)
// {
//    ((Interface::Interface_setRootWindowCaption_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setRootWindowCaption)] = func;
// }

inline Interface::Interface_setRootWindowColor_Functor::FunctionType Interface::Interface_setRootWindowColor_Functor::operator= (FunctionType func)
{
   SELF(Interface, setRootWindowColor);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setRootWindowColor_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setRootWindowColor_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setRootWindowColor_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setRootWindowColor)] = func;
   return func;
}
inline void Interface::Interface_setRootWindowColor_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, setRootWindowColor);
   Interface_setRootWindowColor(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_setRootWindowColor(CPPClass & cl, Interface::Interface_setRootWindowColor_Functor::FunctionType func)
// {
//    ((Interface::Interface_setRootWindowColor_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setRootWindowColor)] = func;
// }

inline Interface::Interface_setRootWindowState_Functor::FunctionType Interface::Interface_setRootWindowState_Functor::operator= (FunctionType func)
{
   SELF(Interface, setRootWindowState);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setRootWindowState_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setRootWindowState_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setRootWindowState_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setRootWindowState)] = func;
   return func;
}
inline void Interface::Interface_setRootWindowState_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/WindowState state, /*6Fj*/bool visible)
{
   SELF(Interface, setRootWindowState);
   Interface_setRootWindowState(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/(C(WindowState))state, /*7Al*/(C(bool))visible);
}
// inline void Interface::register_setRootWindowState(CPPClass & cl, Interface::Interface_setRootWindowState_Functor::FunctionType func)
// {
//    ((Interface::Interface_setRootWindowState_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setRootWindowState)] = func;
// }

inline Interface::Interface_setTimerResolution_Functor::FunctionType Interface::Interface_setTimerResolution_Functor::operator= (FunctionType func)
{
   SELF(Interface, setTimerResolution);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_setTimerResolution_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_setTimerResolution_Functor::FunctionType) * size);
   }
   ((Interface::Interface_setTimerResolution_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, setTimerResolution)] = func;
   return func;
}
inline void Interface::Interface_setTimerResolution_Functor::operator()( /*6Fj*/uint hertz)
{
   SELF(Interface, setTimerResolution);
   Interface_setTimerResolution(self ? self->impl : (C(Interface))null, /*7Al*/hertz);
}
// inline void Interface::register_setTimerResolution(CPPClass & cl, Interface::Interface_setTimerResolution_Functor::FunctionType func)
// {
//    ((Interface::Interface_setTimerResolution_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, setTimerResolution)] = func;
// }

inline Interface::Interface_startMoving_Functor::FunctionType Interface::Interface_startMoving_Functor::operator= (FunctionType func)
{
   SELF(Interface, startMoving);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_startMoving_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_startMoving_Functor::FunctionType) * size);
   }
   ((Interface::Interface_startMoving_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, startMoving)] = func;
   return func;
}
inline void Interface::Interface_startMoving_Functor::operator()( /*6Fj*/Window & window, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/bool fromKeyBoard)
{
   SELF(Interface, startMoving);
   Interface_startMoving(self ? self->impl : (C(Interface))null, /*7Al*/window.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(bool))fromKeyBoard);
}
// inline void Interface::register_startMoving(CPPClass & cl, Interface::Interface_startMoving_Functor::FunctionType func)
// {
//    ((Interface::Interface_startMoving_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, startMoving)] = func;
// }

inline Interface::Interface_stopMoving_Functor::FunctionType Interface::Interface_stopMoving_Functor::operator= (FunctionType func)
{
   SELF(Interface, stopMoving);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_stopMoving_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_stopMoving_Functor::FunctionType) * size);
   }
   ((Interface::Interface_stopMoving_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, stopMoving)] = func;
   return func;
}
inline void Interface::Interface_stopMoving_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, stopMoving);
   Interface_stopMoving(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_stopMoving(CPPClass & cl, Interface::Interface_stopMoving_Functor::FunctionType func)
// {
//    ((Interface::Interface_stopMoving_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, stopMoving)] = func;
// }

inline Interface::Interface_terminate_Functor::FunctionType Interface::Interface_terminate_Functor::operator= (FunctionType func)
{
   SELF(Interface, terminate);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_terminate_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_terminate_Functor::FunctionType) * size);
   }
   ((Interface::Interface_terminate_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, terminate)] = func;
   return func;
}
inline void Interface::Interface_terminate_Functor::operator()( )
{
   SELF(Interface, terminate);
   Interface_terminate(self ? self->impl : (C(Interface))null);
}
// inline void Interface::register_terminate(CPPClass & cl, Interface::Interface_terminate_Functor::FunctionType func)
// {
//    ((Interface::Interface_terminate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, terminate)] = func;
// }

inline Interface::Interface_unloadClipboard_Functor::FunctionType Interface::Interface_unloadClipboard_Functor::operator= (FunctionType func)
{
   SELF(Interface, unloadClipboard);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_unloadClipboard_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_unloadClipboard_Functor::FunctionType) * size);
   }
   ((Interface::Interface_unloadClipboard_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, unloadClipboard)] = func;
   return func;
}
inline void Interface::Interface_unloadClipboard_Functor::operator()( /*6Fj*/ClipBoard clipBoard)
{
   SELF(Interface, unloadClipboard);
   Interface_unloadClipboard(self ? self->impl : (C(Interface))null, /*7Al*/clipBoard.impl);
}
// inline void Interface::register_unloadClipboard(CPPClass & cl, Interface::Interface_unloadClipboard_Functor::FunctionType func)
// {
//    ((Interface::Interface_unloadClipboard_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, unloadClipboard)] = func;
// }

inline Interface::Interface_unlock_Functor::FunctionType Interface::Interface_unlock_Functor::operator= (FunctionType func)
{
   SELF(Interface, unlock);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_unlock_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_unlock_Functor::FunctionType) * size);
   }
   ((Interface::Interface_unlock_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, unlock)] = func;
   return func;
}
inline void Interface::Interface_unlock_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, unlock);
   Interface_unlock(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_unlock(CPPClass & cl, Interface::Interface_unlock_Functor::FunctionType func)
// {
//    ((Interface::Interface_unlock_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, unlock)] = func;
// }

inline Interface::Interface_updateRootWindow_Functor::FunctionType Interface::Interface_updateRootWindow_Functor::operator= (FunctionType func)
{
   SELF(Interface, updateRootWindow);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_updateRootWindow_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_updateRootWindow_Functor::FunctionType) * size);
   }
   ((Interface::Interface_updateRootWindow_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, updateRootWindow)] = func;
   return func;
}
inline void Interface::Interface_updateRootWindow_Functor::operator()( /*6Fj*/Window & window)
{
   SELF(Interface, updateRootWindow);
   Interface_updateRootWindow(self ? self->impl : (C(Interface))null, /*7Al*/window.impl);
}
// inline void Interface::register_updateRootWindow(CPPClass & cl, Interface::Interface_updateRootWindow_Functor::FunctionType func)
// {
//    ((Interface::Interface_updateRootWindow_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, updateRootWindow)] = func;
// }

inline Interface::Interface_wait_Functor::FunctionType Interface::Interface_wait_Functor::operator= (FunctionType func)
{
   SELF(Interface, wait);
   if(self->vTbl == Interface::_cpp_class.vTbl)
   {
      uint size = Interface::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Interface::Interface_wait_Functor::FunctionType, size);
      memcpy(self->vTbl, Interface::_cpp_class.vTbl, sizeof(Interface::Interface_wait_Functor::FunctionType) * size);
   }
   ((Interface::Interface_wait_Functor::FunctionType *)self->vTbl)[M_VTBLID(Interface, wait)] = func;
   return func;
}
inline void Interface::Interface_wait_Functor::operator()( )
{
   SELF(Interface, wait);
   Interface_wait(self ? self->impl : (C(Interface))null);
}
// inline void Interface::register_wait(CPPClass & cl, Interface::Interface_wait_Functor::FunctionType func)
// {
//    ((Interface::Interface_wait_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Interface, wait)] = func;
// }


inline C(Key) Interface::getExtendedKey(/*1Ab*/Key key)
{
   return Interface_getExtendedKey(/*5Ee*/(C(Key))key.impl);
}
inline char Interface::translateKey(/*1Ab*/Key key, /*1Ab*/bool shift)
{
   return Interface_translateKey(/*5Ee*/(C(Key))key.impl, /*5Ee*/(C(bool))shift);
}
inline void Interface::writeKeyedText(/*1Ab*/Surface & surface, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/Key hotKey)
{
   Interface_writeKeyedText(/*5De*/surface.impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/text, /*5Ee*/(C(Key))hotKey.impl);
}
inline void Interface::writeKeyedTextDisabled(/*1Ab*/Surface & surface, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/const char * text, /*1Ab*/Key hotKey, /*1Ab*/bool disabled)
{
   Interface_writeKeyedTextDisabled(/*5De*/surface.impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/text, /*5Ee*/(C(Key))hotKey.impl, /*5Ee*/(C(bool))disabled);
}

inline Joystick::Joystick(int x, int y = 0, int z = 0, int rx = 0, int ry = 0, int rz = 0, uint buttons = 0)
{
   impl.x = x;
   impl.y = y;
   impl.z = z;
   impl.rx = rx;
   impl.ry = ry;
   impl.rz = rz;
   impl.buttons = buttons;
}



// member accessors: Joystick::x
// (struct::int)

/*nstSet*/inline /*0H*/int Joystick::x_Prop::operator= (/*0H*/int v)
{
   SELF(Joystick, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline Joystick::x_Prop & Joystick::x_Prop::operator= (Joystick::x_Prop & prop)
{
   SELF(Joystick, x);
   /*0H*/int v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline Joystick::x_Prop::operator /*0I*/int () const
{
   SELF(Joystick, x);
   return self ? ((C(Joystick) *)&self->impl)->x : 0;
}

// member accessors: Joystick::y
// (struct::int)

/*nstSet*/inline /*0H*/int Joystick::y_Prop::operator= (/*0H*/int v)
{
   SELF(Joystick, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline Joystick::y_Prop & Joystick::y_Prop::operator= (Joystick::y_Prop & prop)
{
   SELF(Joystick, y);
   /*0H*/int v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline Joystick::y_Prop::operator /*0I*/int () const
{
   SELF(Joystick, y);
   return self ? ((C(Joystick) *)&self->impl)->y : 0;
}

// member accessors: Joystick::z
// (struct::int)

/*nstSet*/inline /*0H*/int Joystick::z_Prop::operator= (/*0H*/int v)
{
   SELF(Joystick, z);
   self->impl.z = v;
   return v;
}

/*regSet*/inline Joystick::z_Prop & Joystick::z_Prop::operator= (Joystick::z_Prop & prop)
{
   SELF(Joystick, z);
   /*0H*/int v = prop;
   self->impl.z = v;
   return prop;
}
/*regGet*/inline Joystick::z_Prop::operator /*0I*/int () const
{
   SELF(Joystick, z);
   return self ? ((C(Joystick) *)&self->impl)->z : 0;
}

// member accessors: Joystick::rx
// (struct::int)

/*nstSet*/inline /*0H*/int Joystick::rx_Prop::operator= (/*0H*/int v)
{
   SELF(Joystick, rx);
   self->impl.rx = v;
   return v;
}

/*regSet*/inline Joystick::rx_Prop & Joystick::rx_Prop::operator= (Joystick::rx_Prop & prop)
{
   SELF(Joystick, rx);
   /*0H*/int v = prop;
   self->impl.rx = v;
   return prop;
}
/*regGet*/inline Joystick::rx_Prop::operator /*0I*/int () const
{
   SELF(Joystick, rx);
   return self ? ((C(Joystick) *)&self->impl)->rx : 0;
}

// member accessors: Joystick::ry
// (struct::int)

/*nstSet*/inline /*0H*/int Joystick::ry_Prop::operator= (/*0H*/int v)
{
   SELF(Joystick, ry);
   self->impl.ry = v;
   return v;
}

/*regSet*/inline Joystick::ry_Prop & Joystick::ry_Prop::operator= (Joystick::ry_Prop & prop)
{
   SELF(Joystick, ry);
   /*0H*/int v = prop;
   self->impl.ry = v;
   return prop;
}
/*regGet*/inline Joystick::ry_Prop::operator /*0I*/int () const
{
   SELF(Joystick, ry);
   return self ? ((C(Joystick) *)&self->impl)->ry : 0;
}

// member accessors: Joystick::rz
// (struct::int)

/*nstSet*/inline /*0H*/int Joystick::rz_Prop::operator= (/*0H*/int v)
{
   SELF(Joystick, rz);
   self->impl.rz = v;
   return v;
}

/*regSet*/inline Joystick::rz_Prop & Joystick::rz_Prop::operator= (Joystick::rz_Prop & prop)
{
   SELF(Joystick, rz);
   /*0H*/int v = prop;
   self->impl.rz = v;
   return prop;
}
/*regGet*/inline Joystick::rz_Prop::operator /*0I*/int () const
{
   SELF(Joystick, rz);
   return self ? ((C(Joystick) *)&self->impl)->rz : 0;
}

// member accessors: Joystick::buttons
// (struct::uint)

/*nstSet*/inline /*0H*/uint Joystick::buttons_Prop::operator= (/*0H*/uint v)
{
   SELF(Joystick, buttons);
   self->impl.buttons = v;
   return v;
}

/*regSet*/inline Joystick::buttons_Prop & Joystick::buttons_Prop::operator= (Joystick::buttons_Prop & prop)
{
   SELF(Joystick, buttons);
   /*0H*/uint v = prop;
   self->impl.buttons = v;
   return prop;
}
/*regGet*/inline Joystick::buttons_Prop::operator /*0I*/uint () const
{
   SELF(Joystick, buttons);
   return self ? ((C(Joystick) *)&self->impl)->buttons : 0;
}
// A (bits:bits)
inline constexpr Key::operator SmartKey() const { return SmartKey(impl); }



// member accessors: Key::code
// (bits::enum|unsigned int)

/*nstSet*/inline /*0H*/KeyCode Key::code_Prop::operator= (/*0H*/KeyCode v)
{
   SELF(Key, code);
   KEY_SET_code(self->impl, v);
   return v;
}

/*regSet*/inline Key::code_Prop & Key::code_Prop::operator= (Key::code_Prop & prop)
{
   SELF(Key, code);
   /*0H*/KeyCode v = prop;
   KEY_SET_code(self->impl, v);
   return prop;
}
/*regGet*/inline Key::code_Prop::operator /*0I*/KeyCode () const
{
   SELF(Key, code);
   return (KeyCode)KEY_code(self->impl);
}

// member accessors: Key::shift
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Key::shift_Prop::operator= (/*0H*/bool v)
{
   SELF(Key, shift);
   KEY_SET_shift(self->impl, v);
   return v;
}

/*regSet*/inline Key::shift_Prop & Key::shift_Prop::operator= (Key::shift_Prop & prop)
{
   SELF(Key, shift);
   /*0H*/bool v = prop;
   KEY_SET_shift(self->impl, v);
   return prop;
}
/*regGet*/inline Key::shift_Prop::operator /*0I*/bool () const
{
   SELF(Key, shift);
   return (bool)KEY_shift(self->impl);
}

// member accessors: Key::ctrl
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Key::ctrl_Prop::operator= (/*0H*/bool v)
{
   SELF(Key, ctrl);
   KEY_SET_ctrl(self->impl, v);
   return v;
}

/*regSet*/inline Key::ctrl_Prop & Key::ctrl_Prop::operator= (Key::ctrl_Prop & prop)
{
   SELF(Key, ctrl);
   /*0H*/bool v = prop;
   KEY_SET_ctrl(self->impl, v);
   return prop;
}
/*regGet*/inline Key::ctrl_Prop::operator /*0I*/bool () const
{
   SELF(Key, ctrl);
   return (bool)KEY_ctrl(self->impl);
}

// member accessors: Key::alt
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Key::alt_Prop::operator= (/*0H*/bool v)
{
   SELF(Key, alt);
   KEY_SET_alt(self->impl, v);
   return v;
}

/*regSet*/inline Key::alt_Prop & Key::alt_Prop::operator= (Key::alt_Prop & prop)
{
   SELF(Key, alt);
   /*0H*/bool v = prop;
   KEY_SET_alt(self->impl, v);
   return prop;
}
/*regGet*/inline Key::alt_Prop::operator /*0I*/bool () const
{
   SELF(Key, alt);
   return (bool)KEY_alt(self->impl);
}

// member accessors: Key::cmd
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Key::cmd_Prop::operator= (/*0H*/bool v)
{
   SELF(Key, cmd);
   KEY_SET_cmd(self->impl, v);
   return v;
}

/*regSet*/inline Key::cmd_Prop & Key::cmd_Prop::operator= (Key::cmd_Prop & prop)
{
   SELF(Key, cmd);
   /*0H*/bool v = prop;
   KEY_SET_cmd(self->impl, v);
   return prop;
}
/*regGet*/inline Key::cmd_Prop::operator /*0I*/bool () const
{
   SELF(Key, cmd);
   return (bool)KEY_cmd(self->impl);
}

// member accessors: Key::modifiers
// (bits::bits|unsigned int)

/*nstSet*/inline /*0H*/Modifiers Key::modifiers_Prop::operator= (/*0H*/Modifiers v)
{
   SELF(Key, modifiers);
   KEY_SET_modifiers(self->impl, v);
   return v;
}

/*regSet*/inline Key::modifiers_Prop & Key::modifiers_Prop::operator= (Key::modifiers_Prop & prop)
{
   SELF(Key, modifiers);
   /*0H*/Modifiers v = prop;
   KEY_SET_modifiers(self->impl, v);
   return prop;
}
/*regGet*/inline Key::modifiers_Prop::operator /*0I*/Modifiers () const
{
   SELF(Key, modifiers);
   return KEY_modifiers(self->impl);
}
// A (struct:unit)
inline MiddleAnchorValue::operator MinMaxValue() const { MinMaxValue m = MiddleAnchorValue_to_MinMaxValue(&impl); return m; }
inline MiddleAnchorValue::MiddleAnchorValue(const MinMaxValue & m) { MiddleAnchorValue_from_MinMaxValue(&impl, m.impl); }
inline MiddleAnchorValue & MiddleAnchorValue::operator =(const MinMaxValue & m) { MiddleAnchorValue_from_MinMaxValue(&impl, m.impl); return *this; }

inline MiddleAnchorValue::MiddleAnchorValue(AnchorValueType type, int distance = 0, float percent = 0)
{
   impl.type = (C(AnchorValueType))type;
   impl.distance = distance;
   impl.percent = percent;
}



// member accessors: MiddleAnchorValue::type
// (struct::enum|int)

/*nstSet*/inline /*0H*/AnchorValueType MiddleAnchorValue::type_Prop::operator= (/*0H*/AnchorValueType v)
{
   SELF(MiddleAnchorValue, type);
   self->impl.type = (C(AnchorValueType))v;
   return v;
}

/*regSet*/inline MiddleAnchorValue::type_Prop & MiddleAnchorValue::type_Prop::operator= (MiddleAnchorValue::type_Prop & prop)
{
   SELF(MiddleAnchorValue, type);
   /*0H*/AnchorValueType v = prop;
   self->impl.type = (C(AnchorValueType))v;
   return prop;
}
/*regGet*/inline MiddleAnchorValue::type_Prop::operator /*0I*/AnchorValueType () const
{
   SELF(MiddleAnchorValue, type);
   return self ? (AnchorValueType)((C(MiddleAnchorValue) *)&self->impl)->type : (AnchorValueType)0;
}

// member accessors: MiddleAnchorValue::distance
// (struct::int)

/*nstSet*/inline /*0H*/int MiddleAnchorValue::distance_Prop::operator= (/*0H*/int v)
{
   SELF(MiddleAnchorValue, distance);
   self->impl.distance = v;
   return v;
}

/*regSet*/inline MiddleAnchorValue::distance_Prop & MiddleAnchorValue::distance_Prop::operator= (MiddleAnchorValue::distance_Prop & prop)
{
   SELF(MiddleAnchorValue, distance);
   /*0H*/int v = prop;
   self->impl.distance = v;
   return prop;
}
/*regGet*/inline MiddleAnchorValue::distance_Prop::operator /*0I*/int () const
{
   SELF(MiddleAnchorValue, distance);
   return self ? ((C(MiddleAnchorValue) *)&self->impl)->distance : 0;
}

// member accessors: MiddleAnchorValue::percent
// (struct::float)

/*nstSet*/inline /*0H*/float MiddleAnchorValue::percent_Prop::operator= (/*0H*/float v)
{
   SELF(MiddleAnchorValue, percent);
   self->impl.percent = v;
   return v;
}

/*regSet*/inline MiddleAnchorValue::percent_Prop & MiddleAnchorValue::percent_Prop::operator= (MiddleAnchorValue::percent_Prop & prop)
{
   SELF(MiddleAnchorValue, percent);
   /*0H*/float v = prop;
   self->impl.percent = v;
   return prop;
}
/*regGet*/inline MiddleAnchorValue::percent_Prop::operator /*0I*/float () const
{
   SELF(MiddleAnchorValue, percent);
   return self ? ((C(MiddleAnchorValue) *)&self->impl)->percent : 0;
}



// member accessors: Modifiers::shift
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::shift_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, shift);
   MODIFIERS_SET_shift(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::shift_Prop & Modifiers::shift_Prop::operator= (Modifiers::shift_Prop & prop)
{
   SELF(Modifiers, shift);
   /*0H*/bool v = prop;
   MODIFIERS_SET_shift(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::shift_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, shift);
   return (bool)MODIFIERS_shift(self->impl);
}

// member accessors: Modifiers::ctrl
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::ctrl_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, ctrl);
   MODIFIERS_SET_ctrl(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::ctrl_Prop & Modifiers::ctrl_Prop::operator= (Modifiers::ctrl_Prop & prop)
{
   SELF(Modifiers, ctrl);
   /*0H*/bool v = prop;
   MODIFIERS_SET_ctrl(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::ctrl_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, ctrl);
   return (bool)MODIFIERS_ctrl(self->impl);
}

// member accessors: Modifiers::alt
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::alt_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, alt);
   MODIFIERS_SET_alt(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::alt_Prop & Modifiers::alt_Prop::operator= (Modifiers::alt_Prop & prop)
{
   SELF(Modifiers, alt);
   /*0H*/bool v = prop;
   MODIFIERS_SET_alt(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::alt_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, alt);
   return (bool)MODIFIERS_alt(self->impl);
}

// member accessors: Modifiers::cmd
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::cmd_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, cmd);
   MODIFIERS_SET_cmd(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::cmd_Prop & Modifiers::cmd_Prop::operator= (Modifiers::cmd_Prop & prop)
{
   SELF(Modifiers, cmd);
   /*0H*/bool v = prop;
   MODIFIERS_SET_cmd(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::cmd_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, cmd);
   return (bool)MODIFIERS_cmd(self->impl);
}

// member accessors: Modifiers::left
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::left_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, left);
   MODIFIERS_SET_left(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::left_Prop & Modifiers::left_Prop::operator= (Modifiers::left_Prop & prop)
{
   SELF(Modifiers, left);
   /*0H*/bool v = prop;
   MODIFIERS_SET_left(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::left_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, left);
   return (bool)MODIFIERS_left(self->impl);
}

// member accessors: Modifiers::middle
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::middle_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, middle);
   MODIFIERS_SET_middle(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::middle_Prop & Modifiers::middle_Prop::operator= (Modifiers::middle_Prop & prop)
{
   SELF(Modifiers, middle);
   /*0H*/bool v = prop;
   MODIFIERS_SET_middle(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::middle_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, middle);
   return (bool)MODIFIERS_middle(self->impl);
}

// member accessors: Modifiers::right
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::right_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, right);
   MODIFIERS_SET_right(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::right_Prop & Modifiers::right_Prop::operator= (Modifiers::right_Prop & prop)
{
   SELF(Modifiers, right);
   /*0H*/bool v = prop;
   MODIFIERS_SET_right(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::right_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, right);
   return (bool)MODIFIERS_right(self->impl);
}

// member accessors: Modifiers::isActivate
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::isActivate_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, isActivate);
   MODIFIERS_SET_isActivate(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::isActivate_Prop & Modifiers::isActivate_Prop::operator= (Modifiers::isActivate_Prop & prop)
{
   SELF(Modifiers, isActivate);
   /*0H*/bool v = prop;
   MODIFIERS_SET_isActivate(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::isActivate_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, isActivate);
   return (bool)MODIFIERS_isActivate(self->impl);
}

// member accessors: Modifiers::isSideEffect
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::isSideEffect_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, isSideEffect);
   MODIFIERS_SET_isSideEffect(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::isSideEffect_Prop & Modifiers::isSideEffect_Prop::operator= (Modifiers::isSideEffect_Prop & prop)
{
   SELF(Modifiers, isSideEffect);
   /*0H*/bool v = prop;
   MODIFIERS_SET_isSideEffect(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::isSideEffect_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, isSideEffect);
   return (bool)MODIFIERS_isSideEffect(self->impl);
}

// member accessors: Modifiers::closingDropDown
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool Modifiers::closingDropDown_Prop::operator= (/*0H*/bool v)
{
   SELF(Modifiers, closingDropDown);
   MODIFIERS_SET_closingDropDown(self->impl, v);
   return v;
}

/*regSet*/inline Modifiers::closingDropDown_Prop & Modifiers::closingDropDown_Prop::operator= (Modifiers::closingDropDown_Prop & prop)
{
   SELF(Modifiers, closingDropDown);
   /*0H*/bool v = prop;
   MODIFIERS_SET_closingDropDown(self->impl, v);
   return prop;
}
/*regGet*/inline Modifiers::closingDropDown_Prop::operator /*0I*/bool () const
{
   SELF(Modifiers, closingDropDown);
   return (bool)MODIFIERS_closingDropDown(self->impl);
}



// member accessors: MouseButtons::left
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MouseButtons::left_Prop::operator= (/*0H*/bool v)
{
   SELF(MouseButtons, left);
   MOUSEBUTTONS_SET_left(self->impl, v);
   return v;
}

/*regSet*/inline MouseButtons::left_Prop & MouseButtons::left_Prop::operator= (MouseButtons::left_Prop & prop)
{
   SELF(MouseButtons, left);
   /*0H*/bool v = prop;
   MOUSEBUTTONS_SET_left(self->impl, v);
   return prop;
}
/*regGet*/inline MouseButtons::left_Prop::operator /*0I*/bool () const
{
   SELF(MouseButtons, left);
   return (bool)MOUSEBUTTONS_left(self->impl);
}

// member accessors: MouseButtons::right
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MouseButtons::right_Prop::operator= (/*0H*/bool v)
{
   SELF(MouseButtons, right);
   MOUSEBUTTONS_SET_right(self->impl, v);
   return v;
}

/*regSet*/inline MouseButtons::right_Prop & MouseButtons::right_Prop::operator= (MouseButtons::right_Prop & prop)
{
   SELF(MouseButtons, right);
   /*0H*/bool v = prop;
   MOUSEBUTTONS_SET_right(self->impl, v);
   return prop;
}
/*regGet*/inline MouseButtons::right_Prop::operator /*0I*/bool () const
{
   SELF(MouseButtons, right);
   return (bool)MOUSEBUTTONS_right(self->impl);
}

// member accessors: MouseButtons::middle
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MouseButtons::middle_Prop::operator= (/*0H*/bool v)
{
   SELF(MouseButtons, middle);
   MOUSEBUTTONS_SET_middle(self->impl, v);
   return v;
}

/*regSet*/inline MouseButtons::middle_Prop & MouseButtons::middle_Prop::operator= (MouseButtons::middle_Prop & prop)
{
   SELF(MouseButtons, middle);
   /*0H*/bool v = prop;
   MOUSEBUTTONS_SET_middle(self->impl, v);
   return prop;
}
/*regGet*/inline MouseButtons::middle_Prop::operator /*0I*/bool () const
{
   SELF(MouseButtons, middle);
   return (bool)MOUSEBUTTONS_middle(self->impl);
}

inline SizeAnchor::SizeAnchor(Size size, bool isClientW = (bool)0, bool isClientH = (bool)0)
{
   impl.size = size.impl;
   impl.isClientW = (C(bool))isClientW;
   impl.isClientH = (C(bool))isClientH;
}



// member accessors: SizeAnchor::size
// (struct::struct)

/*nstSet*/inline /*0H*/Size SizeAnchor::size_Prop::operator= (/*0H*/Size v)
{
   SELF(SizeAnchor, size);
   self->impl.size = v.impl;
   return v;
}

/*regSet*/inline SizeAnchor::size_Prop & SizeAnchor::size_Prop::operator= (SizeAnchor::size_Prop & prop)
{
   SELF(SizeAnchor, size);
   /*0H*/Size v = prop;
   self->impl.size = v.impl;
   return prop;
}
/*regGet*/inline SizeAnchor::size_Prop::operator /*0I*/Size () const
{
   SELF(SizeAnchor, size);
   Size value(((C(SizeAnchor) *)&self->impl)->size);
   return value;
}

// member accessors: SizeAnchor::isClientW
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool SizeAnchor::isClientW_Prop::operator= (/*0H*/bool v)
{
   SELF(SizeAnchor, isClientW);
   self->impl.isClientW = (C(bool))v;
   return v;
}

/*regSet*/inline SizeAnchor::isClientW_Prop & SizeAnchor::isClientW_Prop::operator= (SizeAnchor::isClientW_Prop & prop)
{
   SELF(SizeAnchor, isClientW);
   /*0H*/bool v = prop;
   self->impl.isClientW = (C(bool))v;
   return prop;
}
/*regGet*/inline SizeAnchor::isClientW_Prop::operator /*0I*/bool () const
{
   SELF(SizeAnchor, isClientW);
   return self ? (bool)((C(SizeAnchor) *)&self->impl)->isClientW : (bool)0;
}

// member accessors: SizeAnchor::isClientH
// (struct::enum|uint)

/*nstSet*/inline /*0H*/bool SizeAnchor::isClientH_Prop::operator= (/*0H*/bool v)
{
   SELF(SizeAnchor, isClientH);
   self->impl.isClientH = (C(bool))v;
   return v;
}

/*regSet*/inline SizeAnchor::isClientH_Prop & SizeAnchor::isClientH_Prop::operator= (SizeAnchor::isClientH_Prop & prop)
{
   SELF(SizeAnchor, isClientH);
   /*0H*/bool v = prop;
   self->impl.isClientH = (C(bool))v;
   return prop;
}
/*regGet*/inline SizeAnchor::isClientH_Prop::operator /*0I*/bool () const
{
   SELF(SizeAnchor, isClientH);
   return self ? (bool)((C(SizeAnchor) *)&self->impl)->isClientH : (bool)0;
}

inline Skin::Skin_captionFont_Functor::FunctionType Skin::Skin_captionFont_Functor::operator= (FunctionType func)
{
   SELF(Skin, captionFont);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_captionFont_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_captionFont_Functor::FunctionType) * size);
   }
   ((Skin::Skin_captionFont_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, captionFont)] = func;
   return func;
}
inline FontResource * Skin::Skin_captionFont_Functor::operator()( )
{
   SELF(Skin, captionFont);
   C(FontResource) retFontResource = Skin_captionFont(self ? self->impl : (C(Skin))null);
      return BINDINGS_CLASS(retFontResource) ? (FontResource *)INSTANCEL(retFontResource, retFontResource->_class) : (FontResource *)0;
}
// inline void Skin::register_captionFont(CPPClass & cl, Skin::Skin_captionFont_Functor::FunctionType func)
// {
//    ((Skin::Skin_captionFont_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, captionFont)] = func;
// }

inline Skin::Skin_cursorsBitmaps_Functor::FunctionType Skin::Skin_cursorsBitmaps_Functor::operator= (FunctionType func)
{
   SELF(Skin, cursorsBitmaps);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_cursorsBitmaps_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_cursorsBitmaps_Functor::FunctionType) * size);
   }
   ((Skin::Skin_cursorsBitmaps_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, cursorsBitmaps)] = func;
   return func;
}
inline const char * Skin::Skin_cursorsBitmaps_Functor::operator()( /*6Fj*/uint id, /*6Fj*/int * hotSpotX, /*6Fj*/int * hotSpotY, /*6Fj*/unsigned char ** paletteShades)
{
   SELF(Skin, cursorsBitmaps);
   return Skin_cursorsBitmaps(self ? self->impl : (C(Skin))null, /*7Al*/id, /*7Al*/hotSpotX, /*7Al*/hotSpotY, /*7Al*/paletteShades);
}
// inline void Skin::register_cursorsBitmaps(CPPClass & cl, Skin::Skin_cursorsBitmaps_Functor::FunctionType func)
// {
//    ((Skin::Skin_cursorsBitmaps_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, cursorsBitmaps)] = func;
// }

inline Skin::Skin_getBitmap_Functor::FunctionType Skin::Skin_getBitmap_Functor::operator= (FunctionType func)
{
   SELF(Skin, getBitmap);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_getBitmap_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_getBitmap_Functor::FunctionType) * size);
   }
   ((Skin::Skin_getBitmap_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, getBitmap)] = func;
   return func;
}
inline BitmapResource * Skin::Skin_getBitmap_Functor::operator()( /*6Fj*/SkinBitmap ap1)
{
   SELF(Skin, getBitmap);
   C(BitmapResource) retBitmapResource = Skin_getBitmap(self ? self->impl : (C(Skin))null, /*7Al*/(C(SkinBitmap))ap1);
      return BINDINGS_CLASS(retBitmapResource) ? (BitmapResource *)INSTANCEL(retBitmapResource, retBitmapResource->_class) : (BitmapResource *)0;
}
// inline void Skin::register_getBitmap(CPPClass & cl, Skin::Skin_getBitmap_Functor::FunctionType func)
// {
//    ((Skin::Skin_getBitmap_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, getBitmap)] = func;
// }

inline Skin::Skin_getDecorationsSize_Functor::FunctionType Skin::Skin_getDecorationsSize_Functor::operator= (FunctionType func)
{
   SELF(Skin, getDecorationsSize);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_getDecorationsSize_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_getDecorationsSize_Functor::FunctionType) * size);
   }
   ((Skin::Skin_getDecorationsSize_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, getDecorationsSize)] = func;
   return func;
}
inline void Skin::Skin_getDecorationsSize_Functor::operator()( /*6Fj*/Window & ap1, /*6Fj*/MinMaxValue * ap2, /*6Fj*/MinMaxValue * ap3)
{
   SELF(Skin, getDecorationsSize);
   Skin_getDecorationsSize(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/&ap2->impl, /*7Al*/&ap3->impl);
}
// inline void Skin::register_getDecorationsSize(CPPClass & cl, Skin::Skin_getDecorationsSize_Functor::FunctionType func)
// {
//    ((Skin::Skin_getDecorationsSize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, getDecorationsSize)] = func;
// }

inline Skin::Skin_horizontalSBH_Functor::FunctionType Skin::Skin_horizontalSBH_Functor::operator= (FunctionType func)
{
   SELF(Skin, horizontalSBH);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_horizontalSBH_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_horizontalSBH_Functor::FunctionType) * size);
   }
   ((Skin::Skin_horizontalSBH_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, horizontalSBH)] = func;
   return func;
}
inline int Skin::Skin_horizontalSBH_Functor::operator()( )
{
   SELF(Skin, horizontalSBH);
   return Skin_horizontalSBH(self ? self->impl : (C(Skin))null);
}
// inline void Skin::register_horizontalSBH(CPPClass & cl, Skin::Skin_horizontalSBH_Functor::FunctionType func)
// {
//    ((Skin::Skin_horizontalSBH_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, horizontalSBH)] = func;
// }

inline Skin::Skin_isMouseMoving_Functor::FunctionType Skin::Skin_isMouseMoving_Functor::operator= (FunctionType func)
{
   SELF(Skin, isMouseMoving);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_isMouseMoving_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_isMouseMoving_Functor::FunctionType) * size);
   }
   ((Skin::Skin_isMouseMoving_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, isMouseMoving)] = func;
   return func;
}
inline bool Skin::Skin_isMouseMoving_Functor::operator()( /*6Fj*/Window & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5)
{
   SELF(Skin, isMouseMoving);
   return (bool)Skin_isMouseMoving(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5);
}
// inline void Skin::register_isMouseMoving(CPPClass & cl, Skin::Skin_isMouseMoving_Functor::FunctionType func)
// {
//    ((Skin::Skin_isMouseMoving_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, isMouseMoving)] = func;
// }

inline Skin::Skin_isMouseResizing_Functor::FunctionType Skin::Skin_isMouseResizing_Functor::operator= (FunctionType func)
{
   SELF(Skin, isMouseResizing);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_isMouseResizing_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_isMouseResizing_Functor::FunctionType) * size);
   }
   ((Skin::Skin_isMouseResizing_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, isMouseResizing)] = func;
   return func;
}
inline bool Skin::Skin_isMouseResizing_Functor::operator()( /*6Fj*/Window & ap1, /*6Fj*/int ap2, /*6Fj*/int ap3, /*6Fj*/int ap4, /*6Fj*/int ap5, /*6Cj*/C(bool) * ap6, /*6Cj*/C(bool) * ap7, /*6Cj*/C(bool) * ap8, /*6Cj*/C(bool) * ap9)
{
   SELF(Skin, isMouseResizing);
   return (bool)Skin_isMouseResizing(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/ap4, /*7Al*/ap5, /*7Al*/ap6, /*7Al*/ap7, /*7Al*/ap8, /*7Al*/ap9);
}
// inline void Skin::register_isMouseResizing(CPPClass & cl, Skin::Skin_isMouseResizing_Functor::FunctionType func)
// {
//    ((Skin::Skin_isMouseResizing_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, isMouseResizing)] = func;
// }

inline Skin::Skin_setWindowArea_Functor::FunctionType Skin::Skin_setWindowArea_Functor::operator= (FunctionType func)
{
   SELF(Skin, setWindowArea);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_setWindowArea_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_setWindowArea_Functor::FunctionType) * size);
   }
   ((Skin::Skin_setWindowArea_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, setWindowArea)] = func;
   return func;
}
inline void Skin::Skin_setWindowArea_Functor::operator()( /*6Fj*/Window & ap1, /*6Fj*/int * ap2, /*6Fj*/int * ap3, /*6Fj*/MinMaxValue * ap4, /*6Fj*/MinMaxValue * ap5, /*6Fj*/MinMaxValue * ap6, /*6Fj*/MinMaxValue * ap7)
{
   SELF(Skin, setWindowArea);
   Skin_setWindowArea(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/ap2, /*7Al*/ap3, /*7Al*/&ap4->impl, /*7Al*/&ap5->impl, /*7Al*/&ap6->impl, /*7Al*/&ap7->impl);
}
// inline void Skin::register_setWindowArea(CPPClass & cl, Skin::Skin_setWindowArea_Functor::FunctionType func)
// {
//    ((Skin::Skin_setWindowArea_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, setWindowArea)] = func;
// }

inline Skin::Skin_setWindowMinimum_Functor::FunctionType Skin::Skin_setWindowMinimum_Functor::operator= (FunctionType func)
{
   SELF(Skin, setWindowMinimum);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_setWindowMinimum_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_setWindowMinimum_Functor::FunctionType) * size);
   }
   ((Skin::Skin_setWindowMinimum_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, setWindowMinimum)] = func;
   return func;
}
inline void Skin::Skin_setWindowMinimum_Functor::operator()( /*6Fj*/Window & ap1, /*6Fj*/MinMaxValue * ap2, /*6Fj*/MinMaxValue * ap3)
{
   SELF(Skin, setWindowMinimum);
   Skin_setWindowMinimum(self ? self->impl : (C(Skin))null, /*7Al*/ap1.impl, /*7Al*/&ap2->impl, /*7Al*/&ap3->impl);
}
// inline void Skin::register_setWindowMinimum(CPPClass & cl, Skin::Skin_setWindowMinimum_Functor::FunctionType func)
// {
//    ((Skin::Skin_setWindowMinimum_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, setWindowMinimum)] = func;
// }

inline Skin::Skin_showDecorations_Functor::FunctionType Skin::Skin_showDecorations_Functor::operator= (FunctionType func)
{
   SELF(Skin, showDecorations);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_showDecorations_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_showDecorations_Functor::FunctionType) * size);
   }
   ((Skin::Skin_showDecorations_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, showDecorations)] = func;
   return func;
}
inline void Skin::Skin_showDecorations_Functor::operator()( /*6Fj*/void * ap1, /*6Fj*/Surface & ap2, /*6Fj*/Window & ap3, /*6Fj*/const char * ap4, /*6Fj*/bool ap5, /*6Fj*/bool ap6)
{
   SELF(Skin, showDecorations);
   Skin_showDecorations(self ? self->impl : (C(Skin))null, /*7Al*/ap1, /*7Al*/ap2.impl, /*7Al*/ap3.impl, /*7Al*/ap4, /*7Al*/(C(bool))ap5, /*7Al*/(C(bool))ap6);
}
// inline void Skin::register_showDecorations(CPPClass & cl, Skin::Skin_showDecorations_Functor::FunctionType func)
// {
//    ((Skin::Skin_showDecorations_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, showDecorations)] = func;
// }

inline Skin::Skin_systemFont_Functor::FunctionType Skin::Skin_systemFont_Functor::operator= (FunctionType func)
{
   SELF(Skin, systemFont);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_systemFont_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_systemFont_Functor::FunctionType) * size);
   }
   ((Skin::Skin_systemFont_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, systemFont)] = func;
   return func;
}
inline FontResource * Skin::Skin_systemFont_Functor::operator()( )
{
   SELF(Skin, systemFont);
   C(FontResource) retFontResource = Skin_systemFont(self ? self->impl : (C(Skin))null);
      return BINDINGS_CLASS(retFontResource) ? (FontResource *)INSTANCEL(retFontResource, retFontResource->_class) : (FontResource *)0;
}
// inline void Skin::register_systemFont(CPPClass & cl, Skin::Skin_systemFont_Functor::FunctionType func)
// {
//    ((Skin::Skin_systemFont_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, systemFont)] = func;
// }

inline Skin::Skin_updateNonClient_Functor::FunctionType Skin::Skin_updateNonClient_Functor::operator= (FunctionType func)
{
   SELF(Skin, updateNonClient);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_updateNonClient_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_updateNonClient_Functor::FunctionType) * size);
   }
   ((Skin::Skin_updateNonClient_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, updateNonClient)] = func;
   return func;
}
inline void Skin::Skin_updateNonClient_Functor::operator()( /*6Fj*/void * ap1)
{
   SELF(Skin, updateNonClient);
   Skin_updateNonClient(self ? self->impl : (C(Skin))null, /*7Al*/ap1);
}
// inline void Skin::register_updateNonClient(CPPClass & cl, Skin::Skin_updateNonClient_Functor::FunctionType func)
// {
//    ((Skin::Skin_updateNonClient_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, updateNonClient)] = func;
// }

inline Skin::Skin_verticalSBW_Functor::FunctionType Skin::Skin_verticalSBW_Functor::operator= (FunctionType func)
{
   SELF(Skin, verticalSBW);
   if(self->vTbl == Skin::_cpp_class.vTbl)
   {
      uint size = Skin::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Skin::Skin_verticalSBW_Functor::FunctionType, size);
      memcpy(self->vTbl, Skin::_cpp_class.vTbl, sizeof(Skin::Skin_verticalSBW_Functor::FunctionType) * size);
   }
   ((Skin::Skin_verticalSBW_Functor::FunctionType *)self->vTbl)[M_VTBLID(Skin, verticalSBW)] = func;
   return func;
}
inline int Skin::Skin_verticalSBW_Functor::operator()( )
{
   SELF(Skin, verticalSBW);
   return Skin_verticalSBW(self ? self->impl : (C(Skin))null);
}
// inline void Skin::register_verticalSBW(CPPClass & cl, Skin::Skin_verticalSBW_Functor::FunctionType func)
// {
//    ((Skin::Skin_verticalSBW_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Skin, verticalSBW)] = func;
// }

// B (bits:bits)
inline SmartKey SmartKey::operator= (Key value) { return Key_to_SmartKey(value.impl); }
inline SmartKey::SmartKey(Key value) { Key_to_SmartKey(value.impl); }
// C (bits:enum)
inline SmartKey SmartKey::operator= (KeyCode value) { return Key_to_SmartKey((C(Key))value); }
inline SmartKey::SmartKey(KeyCode value) { Key_to_SmartKey((C(Key))value); }
// C (bits:enum)
inline SmartKey SmartKey::operator= (PredefinedKey value) { return Key_to_SmartKey((C(Key))value); }
inline SmartKey::SmartKey(PredefinedKey value) { Key_to_SmartKey((C(Key))value); }



// member accessors: SmartKey::code
// (bits::enum|unsigned int)

/*nstSet*/inline /*0H*/KeyCode SmartKey::code_Prop::operator= (/*0H*/KeyCode v)
{
   SELF(SmartKey, code);
   SMARTKEY_SET_code(self->impl, v);
   return v;
}

/*regSet*/inline SmartKey::code_Prop & SmartKey::code_Prop::operator= (SmartKey::code_Prop & prop)
{
   SELF(SmartKey, code);
   /*0H*/KeyCode v = prop;
   SMARTKEY_SET_code(self->impl, v);
   return prop;
}
/*regGet*/inline SmartKey::code_Prop::operator /*0I*/KeyCode () const
{
   SELF(SmartKey, code);
   return (KeyCode)SMARTKEY_code(self->impl);
}

// member accessors: SmartKey::shift
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool SmartKey::shift_Prop::operator= (/*0H*/bool v)
{
   SELF(SmartKey, shift);
   SMARTKEY_SET_shift(self->impl, v);
   return v;
}

/*regSet*/inline SmartKey::shift_Prop & SmartKey::shift_Prop::operator= (SmartKey::shift_Prop & prop)
{
   SELF(SmartKey, shift);
   /*0H*/bool v = prop;
   SMARTKEY_SET_shift(self->impl, v);
   return prop;
}
/*regGet*/inline SmartKey::shift_Prop::operator /*0I*/bool () const
{
   SELF(SmartKey, shift);
   return (bool)SMARTKEY_shift(self->impl);
}

// member accessors: SmartKey::ctrl
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool SmartKey::ctrl_Prop::operator= (/*0H*/bool v)
{
   SELF(SmartKey, ctrl);
   SMARTKEY_SET_ctrl(self->impl, v);
   return v;
}

/*regSet*/inline SmartKey::ctrl_Prop & SmartKey::ctrl_Prop::operator= (SmartKey::ctrl_Prop & prop)
{
   SELF(SmartKey, ctrl);
   /*0H*/bool v = prop;
   SMARTKEY_SET_ctrl(self->impl, v);
   return prop;
}
/*regGet*/inline SmartKey::ctrl_Prop::operator /*0I*/bool () const
{
   SELF(SmartKey, ctrl);
   return (bool)SMARTKEY_ctrl(self->impl);
}

// member accessors: SmartKey::alt
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool SmartKey::alt_Prop::operator= (/*0H*/bool v)
{
   SELF(SmartKey, alt);
   SMARTKEY_SET_alt(self->impl, v);
   return v;
}

/*regSet*/inline SmartKey::alt_Prop & SmartKey::alt_Prop::operator= (SmartKey::alt_Prop & prop)
{
   SELF(SmartKey, alt);
   /*0H*/bool v = prop;
   SMARTKEY_SET_alt(self->impl, v);
   return prop;
}
/*regGet*/inline SmartKey::alt_Prop::operator /*0I*/bool () const
{
   SELF(SmartKey, alt);
   return (bool)SMARTKEY_alt(self->impl);
}

// member accessors: SmartKey::modifiers
// (bits::bits|unsigned int)

/*nstSet*/inline /*0H*/Modifiers SmartKey::modifiers_Prop::operator= (/*0H*/Modifiers v)
{
   SELF(SmartKey, modifiers);
   SMARTKEY_SET_modifiers(self->impl, v);
   return v;
}

/*regSet*/inline SmartKey::modifiers_Prop & SmartKey::modifiers_Prop::operator= (SmartKey::modifiers_Prop & prop)
{
   SELF(SmartKey, modifiers);
   /*0H*/Modifiers v = prop;
   SMARTKEY_SET_modifiers(self->impl, v);
   return prop;
}
/*regGet*/inline SmartKey::modifiers_Prop::operator /*0I*/Modifiers () const
{
   SELF(SmartKey, modifiers);
   return SMARTKEY_modifiers(self->impl);
}

inline Timer::Timer(void * userData, Seconds delay = 0, bool started = (bool)0, Seconds _delay = 0) : Timer()
{
   this->userData = userData;
   this->delay = delay.impl;
   this->started = started;
   this->_delay = _delay.impl;
}

inline Timer::Timer_delayExpired_Functor::FunctionType Timer::Timer_delayExpired_Functor::operator= (FunctionType func)
{
   SELF(Timer, delayExpired);
   if(self->vTbl == Timer::_cpp_class.vTbl)
   {
      uint size = Timer::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Timer::Timer_delayExpired_Functor::FunctionType, size);
      memcpy(self->vTbl, Timer::_cpp_class.vTbl, sizeof(Timer::Timer_delayExpired_Functor::FunctionType) * size);
   }
   ((Timer::Timer_delayExpired_Functor::FunctionType *)self->vTbl)[M_VTBLID(Timer, delayExpired)] = func;
   return func;
}
inline bool Timer::Timer_delayExpired_Functor::operator()(/*6Fk*/any_object o_ )
{
   SELF(Timer, delayExpired);
   return (bool)Timer_delayExpired(self ? self->impl : (C(Timer))null, o_);
}
// inline void Timer::register_delayExpired(CPPClass & cl, Timer::Timer_delayExpired_Functor::FunctionType func)
// {
//    ((Timer::Timer_delayExpired_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Timer, delayExpired)] = func;
// }


inline void Timer::start()
{
   Timer_start(impl);
}
inline void Timer::stop()
{
   Timer_stop(impl);
}


// property callers: Timer::userData
// (normal::void *)

/*nstSet*/inline /*0H*/void * Timer::userData_Prop::operator= (/*0H*/void * v)
{
   SELF(Timer, userData);
   if(self)
      self->_userData = v;
   return v;
}

/*regSet*/inline Timer::userData_Prop & Timer::userData_Prop::operator= (Timer::userData_Prop & prop)
{
   SELF(Timer, userData);
   /*0H*/void * v = prop;
   if(self)
      self->_userData = v;
   return prop;
}
/*regGet*/inline Timer::userData_Prop::operator /*0I*/void * () const
{
   SELF(Timer, userData);
   return self ? self->_userData : null;
}

// property callers: Timer::delay
// (normal::unit|double)

/*nstSet*/inline /*0H*/Seconds Timer::delay_Prop::operator= (/*0H*/Seconds v)
{
   SELF(Timer, delay);
   Timer_set_delay(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Timer::delay_Prop & Timer::delay_Prop::operator= (Timer::delay_Prop & prop)
{
   SELF(Timer, delay);
   /*0H*/Seconds v = prop;
   Timer_set_delay(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline Timer::delay_Prop::operator /*0I*/Seconds () const
{
   SELF(Timer, delay);
   Seconds value(Timer_get_delay(self->impl));
   return value;
}
/*regGet*/inline Timer::delay_Prop::operator /*0J*/C(Time) () const
{
   SELF(Timer, delay);
   return Seconds(self->delay);
}

// property callers: Timer::started
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Timer::started_Prop::operator= (/*0H*/bool v)
{
   SELF(Timer, started);
   Timer_set_started(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Timer::started_Prop & Timer::started_Prop::operator= (Timer::started_Prop & prop)
{
   SELF(Timer, started);
   /*0H*/bool v = prop;
   Timer_set_started(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Timer::started_Prop::operator /*0I*/bool () const
{
   SELF(Timer, started);
   return (bool)Timer_get_started(self ? self->impl : null);
}


// member accessors: Timer::_delay
// (normal::unit|double)

/*nstSet*/inline /*0H*/Seconds Timer::_delay_Prop::operator= (/*0H*/Seconds v)
{
   SELF(Timer, _delay);
   IPTR(self->impl, Timer)->_delay = (C(Time))v.impl;
   return v;
}

/*regSet*/inline Timer::_delay_Prop & Timer::_delay_Prop::operator= (Timer::_delay_Prop & prop)
{
   SELF(Timer, _delay);
   /*0H*/Seconds v = prop;
   IPTR(self->impl, Timer)->_delay = (C(Time))v.impl;
   return prop;
}
/*regGet*/inline Timer::_delay_Prop::operator /*0I*/Seconds () const
{
   SELF(Timer, _delay);
   Seconds value(IPTR(self->impl, Timer)->_delay);
   return value;
}
/*regGet*/inline Timer::_delay_Prop::operator /*0J*/C(Time) () const
{
   SELF(Timer, _delay);
   return Seconds(self->_delay);
}

inline TouchPointerInfo::TouchPointerInfo(int id, Point point = Point(), float size = 0, float pressure = 0)
{
   impl.id = id;
   impl.point = point.impl;
   impl.size = size;
   impl.pressure = pressure;
}



// member accessors: TouchPointerInfo::id
// (struct::int)

/*nstSet*/inline /*0H*/int TouchPointerInfo::id_Prop::operator= (/*0H*/int v)
{
   SELF(TouchPointerInfo, id);
   self->impl.id = v;
   return v;
}

/*regSet*/inline TouchPointerInfo::id_Prop & TouchPointerInfo::id_Prop::operator= (TouchPointerInfo::id_Prop & prop)
{
   SELF(TouchPointerInfo, id);
   /*0H*/int v = prop;
   self->impl.id = v;
   return prop;
}
/*regGet*/inline TouchPointerInfo::id_Prop::operator /*0I*/int () const
{
   SELF(TouchPointerInfo, id);
   return self ? ((C(TouchPointerInfo) *)&self->impl)->id : 0;
}

// member accessors: TouchPointerInfo::point
// (struct::struct)

/*nstSet*/inline /*0H*/Point TouchPointerInfo::point_Prop::operator= (/*0H*/Point v)
{
   SELF(TouchPointerInfo, point);
   self->impl.point = v.impl;
   return v;
}

/*regSet*/inline TouchPointerInfo::point_Prop & TouchPointerInfo::point_Prop::operator= (TouchPointerInfo::point_Prop & prop)
{
   SELF(TouchPointerInfo, point);
   /*0H*/Point v = prop;
   self->impl.point = v.impl;
   return prop;
}
/*regGet*/inline TouchPointerInfo::point_Prop::operator /*0I*/Point () const
{
   SELF(TouchPointerInfo, point);
   Point value(((C(TouchPointerInfo) *)&self->impl)->point);
   return value;
}

// member accessors: TouchPointerInfo::size
// (struct::float)

/*nstSet*/inline /*0H*/float TouchPointerInfo::size_Prop::operator= (/*0H*/float v)
{
   SELF(TouchPointerInfo, size);
   self->impl.size = v;
   return v;
}

/*regSet*/inline TouchPointerInfo::size_Prop & TouchPointerInfo::size_Prop::operator= (TouchPointerInfo::size_Prop & prop)
{
   SELF(TouchPointerInfo, size);
   /*0H*/float v = prop;
   self->impl.size = v;
   return prop;
}
/*regGet*/inline TouchPointerInfo::size_Prop::operator /*0I*/float () const
{
   SELF(TouchPointerInfo, size);
   return self ? ((C(TouchPointerInfo) *)&self->impl)->size : 0;
}

// member accessors: TouchPointerInfo::pressure
// (struct::float)

/*nstSet*/inline /*0H*/float TouchPointerInfo::pressure_Prop::operator= (/*0H*/float v)
{
   SELF(TouchPointerInfo, pressure);
   self->impl.pressure = v;
   return v;
}

/*regSet*/inline TouchPointerInfo::pressure_Prop & TouchPointerInfo::pressure_Prop::operator= (TouchPointerInfo::pressure_Prop & prop)
{
   SELF(TouchPointerInfo, pressure);
   /*0H*/float v = prop;
   self->impl.pressure = v;
   return prop;
}
/*regGet*/inline TouchPointerInfo::pressure_Prop::operator /*0I*/float () const
{
   SELF(TouchPointerInfo, pressure);
   return self ? ((C(TouchPointerInfo) *)&self->impl)->pressure : 0;
}

inline Window::Window_getDecorationsSize_Functor::FunctionType Window::Window_getDecorationsSize_Functor::operator= (FunctionType func)
{
   SELF(Window, getDecorationsSize);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_getDecorationsSize_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_getDecorationsSize_Functor::FunctionType) * size);
   }
   ((Window::Window_getDecorationsSize_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, getDecorationsSize)] = func;
   return func;
}
inline void Window::Window_getDecorationsSize_Functor::operator()( /*6Fj*/MinMaxValue * w, /*6Fj*/MinMaxValue * h)
{
   SELF(Window, getDecorationsSize);
   Window_getDecorationsSize(self ? self->impl : (C(Window))null, /*7Al*/&w->impl, /*7Al*/&h->impl);
}
// inline void Window::register_getDecorationsSize(CPPClass & cl, Window::Window_getDecorationsSize_Functor::FunctionType func)
// {
//    ((Window::Window_getDecorationsSize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, getDecorationsSize)] = func;
// }

inline Window::Window_isInside_Functor::FunctionType Window::Window_isInside_Functor::operator= (FunctionType func)
{
   SELF(Window, isInside);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_isInside_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_isInside_Functor::FunctionType) * size);
   }
   ((Window::Window_isInside_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, isInside)] = func;
   return func;
}
inline bool Window::Window_isInside_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y)
{
   SELF(Window, isInside);
   return (bool)Window_isInside(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y);
}
// inline void Window::register_isInside(CPPClass & cl, Window::Window_isInside_Functor::FunctionType func)
// {
//    ((Window::Window_isInside_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, isInside)] = func;
// }

inline Window::Window_isMouseMoving_Functor::FunctionType Window::Window_isMouseMoving_Functor::operator= (FunctionType func)
{
   SELF(Window, isMouseMoving);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_isMouseMoving_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_isMouseMoving_Functor::FunctionType) * size);
   }
   ((Window::Window_isMouseMoving_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, isMouseMoving)] = func;
   return func;
}
inline bool Window::Window_isMouseMoving_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h)
{
   SELF(Window, isMouseMoving);
   return (bool)Window_isMouseMoving(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h);
}
// inline void Window::register_isMouseMoving(CPPClass & cl, Window::Window_isMouseMoving_Functor::FunctionType func)
// {
//    ((Window::Window_isMouseMoving_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, isMouseMoving)] = func;
// }

inline Window::Window_isMouseResizing_Functor::FunctionType Window::Window_isMouseResizing_Functor::operator= (FunctionType func)
{
   SELF(Window, isMouseResizing);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_isMouseResizing_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_isMouseResizing_Functor::FunctionType) * size);
   }
   ((Window::Window_isMouseResizing_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, isMouseResizing)] = func;
   return func;
}
inline bool Window::Window_isMouseResizing_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h, /*6Cj*/C(bool) * resizeX, /*6Cj*/C(bool) * resizeY, /*6Cj*/C(bool) * resizeEndX, /*6Cj*/C(bool) * resizeEndY)
{
   SELF(Window, isMouseResizing);
   return (bool)Window_isMouseResizing(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h, /*7Al*/resizeX, /*7Al*/resizeY, /*7Al*/resizeEndX, /*7Al*/resizeEndY);
}
// inline void Window::register_isMouseResizing(CPPClass & cl, Window::Window_isMouseResizing_Functor::FunctionType func)
// {
//    ((Window::Window_isMouseResizing_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, isMouseResizing)] = func;
// }

inline Window::Window_isOpaque_Functor::FunctionType Window::Window_isOpaque_Functor::operator= (FunctionType func)
{
   SELF(Window, isOpaque);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_isOpaque_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_isOpaque_Functor::FunctionType) * size);
   }
   ((Window::Window_isOpaque_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, isOpaque)] = func;
   return func;
}
inline bool Window::Window_isOpaque_Functor::operator()( )
{
   SELF(Window, isOpaque);
   return (bool)Window_isOpaque(self ? self->impl : (C(Window))null);
}
// inline void Window::register_isOpaque(CPPClass & cl, Window::Window_isOpaque_Functor::FunctionType func)
// {
//    ((Window::Window_isOpaque_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, isOpaque)] = func;
// }

inline Window::Window_notifyActivate_Functor::FunctionType Window::Window_notifyActivate_Functor::operator= (FunctionType func)
{
   SELF(Window, notifyActivate);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_notifyActivate_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_notifyActivate_Functor::FunctionType) * size);
   }
   ((Window::Window_notifyActivate_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, notifyActivate)] = func;
   return func;
}
inline bool Window::Window_notifyActivate_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Window & window, /*6Fj*/bool active, /*6Fj*/Window & previous)
{
   SELF(Window, notifyActivate);
   return (bool)Window_notifyActivate(self ? self->impl : (C(Window))null, o_.impl, /*7Al*/window.impl, /*7Al*/(C(bool))active, /*7Al*/previous.impl);
}
// inline void Window::register_notifyActivate(CPPClass & cl, Window::Window_notifyActivate_Functor::FunctionType func)
// {
//    ((Window::Window_notifyActivate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, notifyActivate)] = func;
// }

inline Window::Window_notifyDestroyed_Functor::FunctionType Window::Window_notifyDestroyed_Functor::operator= (FunctionType func)
{
   SELF(Window, notifyDestroyed);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_notifyDestroyed_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_notifyDestroyed_Functor::FunctionType) * size);
   }
   ((Window::Window_notifyDestroyed_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, notifyDestroyed)] = func;
   return func;
}
inline void Window::Window_notifyDestroyed_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Window & window, /*6Fj*/DialogResult result)
{
   SELF(Window, notifyDestroyed);
   Window_notifyDestroyed(self ? self->impl : (C(Window))null, self ? self->impl : (C(Window))null, /*7Al*/window.impl, /*7Al*/(C(DialogResult))result);
}
// inline void Window::register_notifyDestroyed(CPPClass & cl, Window::Window_notifyDestroyed_Functor::FunctionType func)
// {
//    ((Window::Window_notifyDestroyed_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, notifyDestroyed)] = func;
// }

inline Window::Window_notifySaved_Functor::FunctionType Window::Window_notifySaved_Functor::operator= (FunctionType func)
{
   SELF(Window, notifySaved);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_notifySaved_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_notifySaved_Functor::FunctionType) * size);
   }
   ((Window::Window_notifySaved_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, notifySaved)] = func;
   return func;
}
inline void Window::Window_notifySaved_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Window & window, /*6Fj*/const char * filePath)
{
   SELF(Window, notifySaved);
   Window_notifySaved(self ? self->impl : (C(Window))null, self ? self->impl : (C(Window))null, /*7Al*/window.impl, /*7Al*/filePath);
}
// inline void Window::register_notifySaved(CPPClass & cl, Window::Window_notifySaved_Functor::FunctionType func)
// {
//    ((Window::Window_notifySaved_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, notifySaved)] = func;
// }

inline Window::Window_onActivate_Functor::FunctionType Window::Window_onActivate_Functor::operator= (FunctionType func)
{
   SELF(Window, onActivate);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onActivate_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onActivate_Functor::FunctionType) * size);
   }
   ((Window::Window_onActivate_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onActivate)] = func;
   return func;
}
inline bool Window::Window_onActivate_Functor::operator()( /*6Fj*/bool active, /*6Fj*/Window & previous, /*6Cj*/C(bool) * goOnWithActivation, /*6Fj*/bool direct)
{
   SELF(Window, onActivate);
   return (bool)Window_onActivate(self ? self->impl : (C(Window))null, /*7Al*/(C(bool))active, /*7Al*/previous.impl, /*7Al*/goOnWithActivation, /*7Al*/(C(bool))direct);
}
// inline void Window::register_onActivate(CPPClass & cl, Window::Window_onActivate_Functor::FunctionType func)
// {
//    ((Window::Window_onActivate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onActivate)] = func;
// }

inline Window::Window_onActivateClient_Functor::FunctionType Window::Window_onActivateClient_Functor::operator= (FunctionType func)
{
   SELF(Window, onActivateClient);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onActivateClient_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onActivateClient_Functor::FunctionType) * size);
   }
   ((Window::Window_onActivateClient_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onActivateClient)] = func;
   return func;
}
inline void Window::Window_onActivateClient_Functor::operator()( /*6Fj*/Window & client, /*6Fj*/Window & previous)
{
   SELF(Window, onActivateClient);
   Window_onActivateClient(self ? self->impl : (C(Window))null, /*7Al*/client.impl, /*7Al*/previous.impl);
}
// inline void Window::register_onActivateClient(CPPClass & cl, Window::Window_onActivateClient_Functor::FunctionType func)
// {
//    ((Window::Window_onActivateClient_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onActivateClient)] = func;
// }

inline Window::Window_onApplyGraphics_Functor::FunctionType Window::Window_onApplyGraphics_Functor::operator= (FunctionType func)
{
   SELF(Window, onApplyGraphics);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onApplyGraphics_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onApplyGraphics_Functor::FunctionType) * size);
   }
   ((Window::Window_onApplyGraphics_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onApplyGraphics)] = func;
   return func;
}
inline void Window::Window_onApplyGraphics_Functor::operator()( )
{
   SELF(Window, onApplyGraphics);
   Window_onApplyGraphics(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onApplyGraphics(CPPClass & cl, Window::Window_onApplyGraphics_Functor::FunctionType func)
// {
//    ((Window::Window_onApplyGraphics_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onApplyGraphics)] = func;
// }

inline Window::Window_onChildAddedOrRemoved_Functor::FunctionType Window::Window_onChildAddedOrRemoved_Functor::operator= (FunctionType func)
{
   SELF(Window, onChildAddedOrRemoved);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onChildAddedOrRemoved_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onChildAddedOrRemoved_Functor::FunctionType) * size);
   }
   ((Window::Window_onChildAddedOrRemoved_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onChildAddedOrRemoved)] = func;
   return func;
}
inline void Window::Window_onChildAddedOrRemoved_Functor::operator()( /*6Fj*/Window & child, /*6Fj*/bool removed)
{
   SELF(Window, onChildAddedOrRemoved);
   Window_onChildAddedOrRemoved(self ? self->impl : (C(Window))null, /*7Al*/child.impl, /*7Al*/(C(bool))removed);
}
// inline void Window::register_onChildAddedOrRemoved(CPPClass & cl, Window::Window_onChildAddedOrRemoved_Functor::FunctionType func)
// {
//    ((Window::Window_onChildAddedOrRemoved_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onChildAddedOrRemoved)] = func;
// }

inline Window::Window_onChildResized_Functor::FunctionType Window::Window_onChildResized_Functor::operator= (FunctionType func)
{
   SELF(Window, onChildResized);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onChildResized_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onChildResized_Functor::FunctionType) * size);
   }
   ((Window::Window_onChildResized_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onChildResized)] = func;
   return func;
}
inline void Window::Window_onChildResized_Functor::operator()( /*6Fj*/Window & child, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int w, /*6Fj*/int h)
{
   SELF(Window, onChildResized);
   Window_onChildResized(self ? self->impl : (C(Window))null, /*7Al*/child.impl, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h);
}
// inline void Window::register_onChildResized(CPPClass & cl, Window::Window_onChildResized_Functor::FunctionType func)
// {
//    ((Window::Window_onChildResized_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onChildResized)] = func;
// }

inline Window::Window_onChildVisibilityToggled_Functor::FunctionType Window::Window_onChildVisibilityToggled_Functor::operator= (FunctionType func)
{
   SELF(Window, onChildVisibilityToggled);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onChildVisibilityToggled_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onChildVisibilityToggled_Functor::FunctionType) * size);
   }
   ((Window::Window_onChildVisibilityToggled_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onChildVisibilityToggled)] = func;
   return func;
}
inline void Window::Window_onChildVisibilityToggled_Functor::operator()( /*6Fj*/Window & child, /*6Fj*/bool visible)
{
   SELF(Window, onChildVisibilityToggled);
   Window_onChildVisibilityToggled(self ? self->impl : (C(Window))null, /*7Al*/child.impl, /*7Al*/(C(bool))visible);
}
// inline void Window::register_onChildVisibilityToggled(CPPClass & cl, Window::Window_onChildVisibilityToggled_Functor::FunctionType func)
// {
//    ((Window::Window_onChildVisibilityToggled_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onChildVisibilityToggled)] = func;
// }

inline Window::Window_onClose_Functor::FunctionType Window::Window_onClose_Functor::operator= (FunctionType func)
{
   SELF(Window, onClose);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onClose_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onClose_Functor::FunctionType) * size);
   }
   ((Window::Window_onClose_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onClose)] = func;
   return func;
}
inline bool Window::Window_onClose_Functor::operator()( /*6Fj*/bool parentClosing)
{
   SELF(Window, onClose);
   return (bool)Window_onClose(self ? self->impl : (C(Window))null, /*7Al*/(C(bool))parentClosing);
}
// inline void Window::register_onClose(CPPClass & cl, Window::Window_onClose_Functor::FunctionType func)
// {
//    ((Window::Window_onClose_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onClose)] = func;
// }

inline Window::Window_onCreate_Functor::FunctionType Window::Window_onCreate_Functor::operator= (FunctionType func)
{
   SELF(Window, onCreate);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onCreate_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onCreate_Functor::FunctionType) * size);
   }
   ((Window::Window_onCreate_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onCreate)] = func;
   return func;
}
inline bool Window::Window_onCreate_Functor::operator()( )
{
   SELF(Window, onCreate);
   return (bool)Window_onCreate(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onCreate(CPPClass & cl, Window::Window_onCreate_Functor::FunctionType func)
// {
//    ((Window::Window_onCreate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onCreate)] = func;
// }

inline Window::Window_onDestroy_Functor::FunctionType Window::Window_onDestroy_Functor::operator= (FunctionType func)
{
   SELF(Window, onDestroy);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onDestroy_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onDestroy_Functor::FunctionType) * size);
   }
   ((Window::Window_onDestroy_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onDestroy)] = func;
   return func;
}
inline void Window::Window_onDestroy_Functor::operator()( )
{
   SELF(Window, onDestroy);
   Window_onDestroy(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onDestroy(CPPClass & cl, Window::Window_onDestroy_Functor::FunctionType func)
// {
//    ((Window::Window_onDestroy_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onDestroy)] = func;
// }

inline Window::Window_onDestroyed_Functor::FunctionType Window::Window_onDestroyed_Functor::operator= (FunctionType func)
{
   SELF(Window, onDestroyed);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onDestroyed_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onDestroyed_Functor::FunctionType) * size);
   }
   ((Window::Window_onDestroyed_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onDestroyed)] = func;
   return func;
}
inline void Window::Window_onDestroyed_Functor::operator()( )
{
   SELF(Window, onDestroyed);
   Window_onDestroyed(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onDestroyed(CPPClass & cl, Window::Window_onDestroyed_Functor::FunctionType func)
// {
//    ((Window::Window_onDestroyed_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onDestroyed)] = func;
// }

inline Window::Window_onDrawOverChildren_Functor::FunctionType Window::Window_onDrawOverChildren_Functor::operator= (FunctionType func)
{
   SELF(Window, onDrawOverChildren);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onDrawOverChildren_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onDrawOverChildren_Functor::FunctionType) * size);
   }
   ((Window::Window_onDrawOverChildren_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onDrawOverChildren)] = func;
   return func;
}
inline void Window::Window_onDrawOverChildren_Functor::operator()( /*6Fj*/Surface & surface)
{
   SELF(Window, onDrawOverChildren);
   Window_onDrawOverChildren(self ? self->impl : (C(Window))null, /*7Al*/surface.impl);
}
// inline void Window::register_onDrawOverChildren(CPPClass & cl, Window::Window_onDrawOverChildren_Functor::FunctionType func)
// {
//    ((Window::Window_onDrawOverChildren_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onDrawOverChildren)] = func;
// }

inline Window::Window_onFileModified_Functor::FunctionType Window::Window_onFileModified_Functor::operator= (FunctionType func)
{
   SELF(Window, onFileModified);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onFileModified_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onFileModified_Functor::FunctionType) * size);
   }
   ((Window::Window_onFileModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onFileModified)] = func;
   return func;
}
inline bool Window::Window_onFileModified_Functor::operator()( /*6Fj*/FileChange fileChange, /*6Fj*/const char * param)
{
   SELF(Window, onFileModified);
   return (bool)Window_onFileModified(self ? self->impl : (C(Window))null, /*7Al*/(C(FileChange))fileChange, /*7Al*/param);
}
// inline void Window::register_onFileModified(CPPClass & cl, Window::Window_onFileModified_Functor::FunctionType func)
// {
//    ((Window::Window_onFileModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onFileModified)] = func;
// }

inline Window::Window_onHScroll_Functor::FunctionType Window::Window_onHScroll_Functor::operator= (FunctionType func)
{
   SELF(Window, onHScroll);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onHScroll_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onHScroll_Functor::FunctionType) * size);
   }
   ((Window::Window_onHScroll_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onHScroll)] = func;
   return func;
}
inline void Window::Window_onHScroll_Functor::operator()( /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key)
{
   SELF(Window, onHScroll);
   Window_onHScroll(self ? self->impl : (C(Window))null, /*7Al*/(C(ScrollBarAction))action, /*7Al*/position, /*7Al*/(C(Key))key);
}
// inline void Window::register_onHScroll(CPPClass & cl, Window::Window_onHScroll_Functor::FunctionType func)
// {
//    ((Window::Window_onHScroll_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onHScroll)] = func;
// }

inline Window::Window_onKeyDown_Functor::FunctionType Window::Window_onKeyDown_Functor::operator= (FunctionType func)
{
   SELF(Window, onKeyDown);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onKeyDown_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onKeyDown_Functor::FunctionType) * size);
   }
   ((Window::Window_onKeyDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onKeyDown)] = func;
   return func;
}
inline bool Window::Window_onKeyDown_Functor::operator()( /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(Window, onKeyDown);
   return (bool)Window_onKeyDown(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void Window::register_onKeyDown(CPPClass & cl, Window::Window_onKeyDown_Functor::FunctionType func)
// {
//    ((Window::Window_onKeyDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onKeyDown)] = func;
// }

inline Window::Window_onKeyHit_Functor::FunctionType Window::Window_onKeyHit_Functor::operator= (FunctionType func)
{
   SELF(Window, onKeyHit);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onKeyHit_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onKeyHit_Functor::FunctionType) * size);
   }
   ((Window::Window_onKeyHit_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onKeyHit)] = func;
   return func;
}
inline bool Window::Window_onKeyHit_Functor::operator()( /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(Window, onKeyHit);
   return (bool)Window_onKeyHit(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void Window::register_onKeyHit(CPPClass & cl, Window::Window_onKeyHit_Functor::FunctionType func)
// {
//    ((Window::Window_onKeyHit_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onKeyHit)] = func;
// }

inline Window::Window_onKeyUp_Functor::FunctionType Window::Window_onKeyUp_Functor::operator= (FunctionType func)
{
   SELF(Window, onKeyUp);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onKeyUp_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onKeyUp_Functor::FunctionType) * size);
   }
   ((Window::Window_onKeyUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onKeyUp)] = func;
   return func;
}
inline bool Window::Window_onKeyUp_Functor::operator()( /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(Window, onKeyUp);
   return (bool)Window_onKeyUp(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void Window::register_onKeyUp(CPPClass & cl, Window::Window_onKeyUp_Functor::FunctionType func)
// {
//    ((Window::Window_onKeyUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onKeyUp)] = func;
// }

inline Window::Window_onLeftButtonDown_Functor::FunctionType Window::Window_onLeftButtonDown_Functor::operator= (FunctionType func)
{
   SELF(Window, onLeftButtonDown);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onLeftButtonDown_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onLeftButtonDown_Functor::FunctionType) * size);
   }
   ((Window::Window_onLeftButtonDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onLeftButtonDown)] = func;
   return func;
}
inline bool Window::Window_onLeftButtonDown_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onLeftButtonDown);
   return (bool)Window_onLeftButtonDown(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onLeftButtonDown(CPPClass & cl, Window::Window_onLeftButtonDown_Functor::FunctionType func)
// {
//    ((Window::Window_onLeftButtonDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onLeftButtonDown)] = func;
// }

inline Window::Window_onLeftButtonUp_Functor::FunctionType Window::Window_onLeftButtonUp_Functor::operator= (FunctionType func)
{
   SELF(Window, onLeftButtonUp);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onLeftButtonUp_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onLeftButtonUp_Functor::FunctionType) * size);
   }
   ((Window::Window_onLeftButtonUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onLeftButtonUp)] = func;
   return func;
}
inline bool Window::Window_onLeftButtonUp_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onLeftButtonUp);
   return (bool)Window_onLeftButtonUp(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onLeftButtonUp(CPPClass & cl, Window::Window_onLeftButtonUp_Functor::FunctionType func)
// {
//    ((Window::Window_onLeftButtonUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onLeftButtonUp)] = func;
// }

inline Window::Window_onLeftDoubleClick_Functor::FunctionType Window::Window_onLeftDoubleClick_Functor::operator= (FunctionType func)
{
   SELF(Window, onLeftDoubleClick);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onLeftDoubleClick_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onLeftDoubleClick_Functor::FunctionType) * size);
   }
   ((Window::Window_onLeftDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onLeftDoubleClick)] = func;
   return func;
}
inline bool Window::Window_onLeftDoubleClick_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onLeftDoubleClick);
   return (bool)Window_onLeftDoubleClick(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onLeftDoubleClick(CPPClass & cl, Window::Window_onLeftDoubleClick_Functor::FunctionType func)
// {
//    ((Window::Window_onLeftDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onLeftDoubleClick)] = func;
// }

inline Window::Window_onLoadGraphics_Functor::FunctionType Window::Window_onLoadGraphics_Functor::operator= (FunctionType func)
{
   SELF(Window, onLoadGraphics);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onLoadGraphics_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onLoadGraphics_Functor::FunctionType) * size);
   }
   ((Window::Window_onLoadGraphics_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onLoadGraphics)] = func;
   return func;
}
inline bool Window::Window_onLoadGraphics_Functor::operator()( )
{
   SELF(Window, onLoadGraphics);
   return (bool)Window_onLoadGraphics(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onLoadGraphics(CPPClass & cl, Window::Window_onLoadGraphics_Functor::FunctionType func)
// {
//    ((Window::Window_onLoadGraphics_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onLoadGraphics)] = func;
// }

inline Window::Window_onMiddleButtonDown_Functor::FunctionType Window::Window_onMiddleButtonDown_Functor::operator= (FunctionType func)
{
   SELF(Window, onMiddleButtonDown);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMiddleButtonDown_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMiddleButtonDown_Functor::FunctionType) * size);
   }
   ((Window::Window_onMiddleButtonDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMiddleButtonDown)] = func;
   return func;
}
inline bool Window::Window_onMiddleButtonDown_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onMiddleButtonDown);
   return (bool)Window_onMiddleButtonDown(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onMiddleButtonDown(CPPClass & cl, Window::Window_onMiddleButtonDown_Functor::FunctionType func)
// {
//    ((Window::Window_onMiddleButtonDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMiddleButtonDown)] = func;
// }

inline Window::Window_onMiddleButtonUp_Functor::FunctionType Window::Window_onMiddleButtonUp_Functor::operator= (FunctionType func)
{
   SELF(Window, onMiddleButtonUp);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMiddleButtonUp_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMiddleButtonUp_Functor::FunctionType) * size);
   }
   ((Window::Window_onMiddleButtonUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMiddleButtonUp)] = func;
   return func;
}
inline bool Window::Window_onMiddleButtonUp_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onMiddleButtonUp);
   return (bool)Window_onMiddleButtonUp(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onMiddleButtonUp(CPPClass & cl, Window::Window_onMiddleButtonUp_Functor::FunctionType func)
// {
//    ((Window::Window_onMiddleButtonUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMiddleButtonUp)] = func;
// }

inline Window::Window_onMiddleDoubleClick_Functor::FunctionType Window::Window_onMiddleDoubleClick_Functor::operator= (FunctionType func)
{
   SELF(Window, onMiddleDoubleClick);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMiddleDoubleClick_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMiddleDoubleClick_Functor::FunctionType) * size);
   }
   ((Window::Window_onMiddleDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMiddleDoubleClick)] = func;
   return func;
}
inline bool Window::Window_onMiddleDoubleClick_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onMiddleDoubleClick);
   return (bool)Window_onMiddleDoubleClick(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onMiddleDoubleClick(CPPClass & cl, Window::Window_onMiddleDoubleClick_Functor::FunctionType func)
// {
//    ((Window::Window_onMiddleDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMiddleDoubleClick)] = func;
// }

inline Window::Window_onMouseCaptureLost_Functor::FunctionType Window::Window_onMouseCaptureLost_Functor::operator= (FunctionType func)
{
   SELF(Window, onMouseCaptureLost);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMouseCaptureLost_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMouseCaptureLost_Functor::FunctionType) * size);
   }
   ((Window::Window_onMouseCaptureLost_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMouseCaptureLost)] = func;
   return func;
}
inline void Window::Window_onMouseCaptureLost_Functor::operator()( )
{
   SELF(Window, onMouseCaptureLost);
   Window_onMouseCaptureLost(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onMouseCaptureLost(CPPClass & cl, Window::Window_onMouseCaptureLost_Functor::FunctionType func)
// {
//    ((Window::Window_onMouseCaptureLost_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMouseCaptureLost)] = func;
// }

inline Window::Window_onMouseLeave_Functor::FunctionType Window::Window_onMouseLeave_Functor::operator= (FunctionType func)
{
   SELF(Window, onMouseLeave);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMouseLeave_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMouseLeave_Functor::FunctionType) * size);
   }
   ((Window::Window_onMouseLeave_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMouseLeave)] = func;
   return func;
}
inline bool Window::Window_onMouseLeave_Functor::operator()( /*6Fj*/Modifiers mods)
{
   SELF(Window, onMouseLeave);
   return (bool)Window_onMouseLeave(self ? self->impl : (C(Window))null, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onMouseLeave(CPPClass & cl, Window::Window_onMouseLeave_Functor::FunctionType func)
// {
//    ((Window::Window_onMouseLeave_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMouseLeave)] = func;
// }

inline Window::Window_onMouseMove_Functor::FunctionType Window::Window_onMouseMove_Functor::operator= (FunctionType func)
{
   SELF(Window, onMouseMove);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMouseMove_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMouseMove_Functor::FunctionType) * size);
   }
   ((Window::Window_onMouseMove_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMouseMove)] = func;
   return func;
}
inline bool Window::Window_onMouseMove_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onMouseMove);
   return (bool)Window_onMouseMove(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onMouseMove(CPPClass & cl, Window::Window_onMouseMove_Functor::FunctionType func)
// {
//    ((Window::Window_onMouseMove_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMouseMove)] = func;
// }

inline Window::Window_onMouseOver_Functor::FunctionType Window::Window_onMouseOver_Functor::operator= (FunctionType func)
{
   SELF(Window, onMouseOver);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMouseOver_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMouseOver_Functor::FunctionType) * size);
   }
   ((Window::Window_onMouseOver_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMouseOver)] = func;
   return func;
}
inline bool Window::Window_onMouseOver_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onMouseOver);
   return (bool)Window_onMouseOver(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onMouseOver(CPPClass & cl, Window::Window_onMouseOver_Functor::FunctionType func)
// {
//    ((Window::Window_onMouseOver_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMouseOver)] = func;
// }

inline Window::Window_onMoving_Functor::FunctionType Window::Window_onMoving_Functor::operator= (FunctionType func)
{
   SELF(Window, onMoving);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMoving_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMoving_Functor::FunctionType) * size);
   }
   ((Window::Window_onMoving_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMoving)] = func;
   return func;
}
inline bool Window::Window_onMoving_Functor::operator()( /*6Fj*/int * x, /*6Fj*/int * y, /*6Fj*/int w, /*6Fj*/int h)
{
   SELF(Window, onMoving);
   return (bool)Window_onMoving(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/w, /*7Al*/h);
}
// inline void Window::register_onMoving(CPPClass & cl, Window::Window_onMoving_Functor::FunctionType func)
// {
//    ((Window::Window_onMoving_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMoving)] = func;
// }

inline Window::Window_onMultiTouch_Functor::FunctionType Window::Window_onMultiTouch_Functor::operator= (FunctionType func)
{
   SELF(Window, onMultiTouch);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onMultiTouch_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onMultiTouch_Functor::FunctionType) * size);
   }
   ((Window::Window_onMultiTouch_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onMultiTouch)] = func;
   return func;
}
inline bool Window::Window_onMultiTouch_Functor::operator()( /*6Fj*/TouchPointerEvent event, /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*6Fj*/Modifiers mods)
{
   SELF(Window, onMultiTouch);
   return (bool)Window_onMultiTouch(self ? self->impl : (C(Window))null, /*7Al*/(C(TouchPointerEvent))event, /*7Al*/((Instance&)infos).impl, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onMultiTouch(CPPClass & cl, Window::Window_onMultiTouch_Functor::FunctionType func)
// {
//    ((Window::Window_onMultiTouch_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onMultiTouch)] = func;
// }

inline Window::Window_onPosition_Functor::FunctionType Window::Window_onPosition_Functor::operator= (FunctionType func)
{
   SELF(Window, onPosition);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onPosition_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onPosition_Functor::FunctionType) * size);
   }
   ((Window::Window_onPosition_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onPosition)] = func;
   return func;
}
inline void Window::Window_onPosition_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/int width, /*6Fj*/int height)
{
   SELF(Window, onPosition);
   Window_onPosition(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/width, /*7Al*/height);
}
// inline void Window::register_onPosition(CPPClass & cl, Window::Window_onPosition_Functor::FunctionType func)
// {
//    ((Window::Window_onPosition_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onPosition)] = func;
// }

inline Window::Window_onPostCreate_Functor::FunctionType Window::Window_onPostCreate_Functor::operator= (FunctionType func)
{
   SELF(Window, onPostCreate);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onPostCreate_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onPostCreate_Functor::FunctionType) * size);
   }
   ((Window::Window_onPostCreate_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onPostCreate)] = func;
   return func;
}
inline bool Window::Window_onPostCreate_Functor::operator()( )
{
   SELF(Window, onPostCreate);
   return (bool)Window_onPostCreate(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onPostCreate(CPPClass & cl, Window::Window_onPostCreate_Functor::FunctionType func)
// {
//    ((Window::Window_onPostCreate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onPostCreate)] = func;
// }

inline Window::Window_onRedraw_Functor::FunctionType Window::Window_onRedraw_Functor::operator= (FunctionType func)
{
   SELF(Window, onRedraw);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onRedraw_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onRedraw_Functor::FunctionType) * size);
   }
   ((Window::Window_onRedraw_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onRedraw)] = func;
   return func;
}
inline void Window::Window_onRedraw_Functor::operator()( /*6Fj*/Surface & surface)
{
   SELF(Window, onRedraw);
   Window_onRedraw(self ? self->impl : (C(Window))null, /*7Al*/surface.impl);
}
// inline void Window::register_onRedraw(CPPClass & cl, Window::Window_onRedraw_Functor::FunctionType func)
// {
//    ((Window::Window_onRedraw_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onRedraw)] = func;
// }

inline Window::Window_onResize_Functor::FunctionType Window::Window_onResize_Functor::operator= (FunctionType func)
{
   SELF(Window, onResize);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onResize_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onResize_Functor::FunctionType) * size);
   }
   ((Window::Window_onResize_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onResize)] = func;
   return func;
}
inline void Window::Window_onResize_Functor::operator()( /*6Fj*/int width, /*6Fj*/int height)
{
   SELF(Window, onResize);
   Window_onResize(self ? self->impl : (C(Window))null, /*7Al*/width, /*7Al*/height);
}
// inline void Window::register_onResize(CPPClass & cl, Window::Window_onResize_Functor::FunctionType func)
// {
//    ((Window::Window_onResize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onResize)] = func;
// }

inline Window::Window_onResizing_Functor::FunctionType Window::Window_onResizing_Functor::operator= (FunctionType func)
{
   SELF(Window, onResizing);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onResizing_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onResizing_Functor::FunctionType) * size);
   }
   ((Window::Window_onResizing_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onResizing)] = func;
   return func;
}
inline bool Window::Window_onResizing_Functor::operator()( /*6Fj*/int * width, /*6Fj*/int * height)
{
   SELF(Window, onResizing);
   return (bool)Window_onResizing(self ? self->impl : (C(Window))null, /*7Al*/width, /*7Al*/height);
}
// inline void Window::register_onResizing(CPPClass & cl, Window::Window_onResizing_Functor::FunctionType func)
// {
//    ((Window::Window_onResizing_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onResizing)] = func;
// }

inline Window::Window_onRightButtonDown_Functor::FunctionType Window::Window_onRightButtonDown_Functor::operator= (FunctionType func)
{
   SELF(Window, onRightButtonDown);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onRightButtonDown_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onRightButtonDown_Functor::FunctionType) * size);
   }
   ((Window::Window_onRightButtonDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onRightButtonDown)] = func;
   return func;
}
inline bool Window::Window_onRightButtonDown_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onRightButtonDown);
   return (bool)Window_onRightButtonDown(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onRightButtonDown(CPPClass & cl, Window::Window_onRightButtonDown_Functor::FunctionType func)
// {
//    ((Window::Window_onRightButtonDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onRightButtonDown)] = func;
// }

inline Window::Window_onRightButtonUp_Functor::FunctionType Window::Window_onRightButtonUp_Functor::operator= (FunctionType func)
{
   SELF(Window, onRightButtonUp);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onRightButtonUp_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onRightButtonUp_Functor::FunctionType) * size);
   }
   ((Window::Window_onRightButtonUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onRightButtonUp)] = func;
   return func;
}
inline bool Window::Window_onRightButtonUp_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onRightButtonUp);
   return (bool)Window_onRightButtonUp(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onRightButtonUp(CPPClass & cl, Window::Window_onRightButtonUp_Functor::FunctionType func)
// {
//    ((Window::Window_onRightButtonUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onRightButtonUp)] = func;
// }

inline Window::Window_onRightDoubleClick_Functor::FunctionType Window::Window_onRightDoubleClick_Functor::operator= (FunctionType func)
{
   SELF(Window, onRightDoubleClick);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onRightDoubleClick_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onRightDoubleClick_Functor::FunctionType) * size);
   }
   ((Window::Window_onRightDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onRightDoubleClick)] = func;
   return func;
}
inline bool Window::Window_onRightDoubleClick_Functor::operator()( /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Window, onRightDoubleClick);
   return (bool)Window_onRightDoubleClick(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onRightDoubleClick(CPPClass & cl, Window::Window_onRightDoubleClick_Functor::FunctionType func)
// {
//    ((Window::Window_onRightDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onRightDoubleClick)] = func;
// }

inline Window::Window_onSaveFile_Functor::FunctionType Window::Window_onSaveFile_Functor::operator= (FunctionType func)
{
   SELF(Window, onSaveFile);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onSaveFile_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onSaveFile_Functor::FunctionType) * size);
   }
   ((Window::Window_onSaveFile_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onSaveFile)] = func;
   return func;
}
inline bool Window::Window_onSaveFile_Functor::operator()( /*6Fj*/const char * fileName)
{
   SELF(Window, onSaveFile);
   return (bool)Window_onSaveFile(self ? self->impl : (C(Window))null, /*7Al*/fileName);
}
// inline void Window::register_onSaveFile(CPPClass & cl, Window::Window_onSaveFile_Functor::FunctionType func)
// {
//    ((Window::Window_onSaveFile_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onSaveFile)] = func;
// }

inline Window::Window_onStateChange_Functor::FunctionType Window::Window_onStateChange_Functor::operator= (FunctionType func)
{
   SELF(Window, onStateChange);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onStateChange_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onStateChange_Functor::FunctionType) * size);
   }
   ((Window::Window_onStateChange_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onStateChange)] = func;
   return func;
}
inline bool Window::Window_onStateChange_Functor::operator()( /*6Fj*/WindowState state, /*6Fj*/Modifiers mods)
{
   SELF(Window, onStateChange);
   return (bool)Window_onStateChange(self ? self->impl : (C(Window))null, /*7Al*/(C(WindowState))state, /*7Al*/(C(Modifiers))mods);
}
// inline void Window::register_onStateChange(CPPClass & cl, Window::Window_onStateChange_Functor::FunctionType func)
// {
//    ((Window::Window_onStateChange_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onStateChange)] = func;
// }

inline Window::Window_onSysKeyDown_Functor::FunctionType Window::Window_onSysKeyDown_Functor::operator= (FunctionType func)
{
   SELF(Window, onSysKeyDown);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onSysKeyDown_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onSysKeyDown_Functor::FunctionType) * size);
   }
   ((Window::Window_onSysKeyDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onSysKeyDown)] = func;
   return func;
}
inline bool Window::Window_onSysKeyDown_Functor::operator()( /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(Window, onSysKeyDown);
   return (bool)Window_onSysKeyDown(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void Window::register_onSysKeyDown(CPPClass & cl, Window::Window_onSysKeyDown_Functor::FunctionType func)
// {
//    ((Window::Window_onSysKeyDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onSysKeyDown)] = func;
// }

inline Window::Window_onSysKeyHit_Functor::FunctionType Window::Window_onSysKeyHit_Functor::operator= (FunctionType func)
{
   SELF(Window, onSysKeyHit);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onSysKeyHit_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onSysKeyHit_Functor::FunctionType) * size);
   }
   ((Window::Window_onSysKeyHit_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onSysKeyHit)] = func;
   return func;
}
inline bool Window::Window_onSysKeyHit_Functor::operator()( /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(Window, onSysKeyHit);
   return (bool)Window_onSysKeyHit(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void Window::register_onSysKeyHit(CPPClass & cl, Window::Window_onSysKeyHit_Functor::FunctionType func)
// {
//    ((Window::Window_onSysKeyHit_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onSysKeyHit)] = func;
// }

inline Window::Window_onSysKeyUp_Functor::FunctionType Window::Window_onSysKeyUp_Functor::operator= (FunctionType func)
{
   SELF(Window, onSysKeyUp);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onSysKeyUp_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onSysKeyUp_Functor::FunctionType) * size);
   }
   ((Window::Window_onSysKeyUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onSysKeyUp)] = func;
   return func;
}
inline bool Window::Window_onSysKeyUp_Functor::operator()( /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(Window, onSysKeyUp);
   return (bool)Window_onSysKeyUp(self ? self->impl : (C(Window))null, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void Window::register_onSysKeyUp(CPPClass & cl, Window::Window_onSysKeyUp_Functor::FunctionType func)
// {
//    ((Window::Window_onSysKeyUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onSysKeyUp)] = func;
// }

inline Window::Window_onUnloadGraphics_Functor::FunctionType Window::Window_onUnloadGraphics_Functor::operator= (FunctionType func)
{
   SELF(Window, onUnloadGraphics);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onUnloadGraphics_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onUnloadGraphics_Functor::FunctionType) * size);
   }
   ((Window::Window_onUnloadGraphics_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onUnloadGraphics)] = func;
   return func;
}
inline void Window::Window_onUnloadGraphics_Functor::operator()( )
{
   SELF(Window, onUnloadGraphics);
   Window_onUnloadGraphics(self ? self->impl : (C(Window))null);
}
// inline void Window::register_onUnloadGraphics(CPPClass & cl, Window::Window_onUnloadGraphics_Functor::FunctionType func)
// {
//    ((Window::Window_onUnloadGraphics_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onUnloadGraphics)] = func;
// }

inline Window::Window_onVScroll_Functor::FunctionType Window::Window_onVScroll_Functor::operator= (FunctionType func)
{
   SELF(Window, onVScroll);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_onVScroll_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_onVScroll_Functor::FunctionType) * size);
   }
   ((Window::Window_onVScroll_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, onVScroll)] = func;
   return func;
}
inline void Window::Window_onVScroll_Functor::operator()( /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key)
{
   SELF(Window, onVScroll);
   Window_onVScroll(self ? self->impl : (C(Window))null, /*7Al*/(C(ScrollBarAction))action, /*7Al*/position, /*7Al*/(C(Key))key);
}
// inline void Window::register_onVScroll(CPPClass & cl, Window::Window_onVScroll_Functor::FunctionType func)
// {
//    ((Window::Window_onVScroll_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, onVScroll)] = func;
// }

inline Window::Window_preShowDecorations_Functor::FunctionType Window::Window_preShowDecorations_Functor::operator= (FunctionType func)
{
   SELF(Window, preShowDecorations);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_preShowDecorations_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_preShowDecorations_Functor::FunctionType) * size);
   }
   ((Window::Window_preShowDecorations_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, preShowDecorations)] = func;
   return func;
}
inline void Window::Window_preShowDecorations_Functor::operator()( /*6Fj*/Font captionFont, /*6Fj*/Surface & surface, /*6Fj*/const char * name, /*6Fj*/bool active, /*6Fj*/bool moving)
{
   SELF(Window, preShowDecorations);
   Window_preShowDecorations(self ? self->impl : (C(Window))null, /*7Al*/captionFont.impl, /*7Al*/surface.impl, /*7Al*/name, /*7Al*/(C(bool))active, /*7Al*/(C(bool))moving);
}
// inline void Window::register_preShowDecorations(CPPClass & cl, Window::Window_preShowDecorations_Functor::FunctionType func)
// {
//    ((Window::Window_preShowDecorations_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, preShowDecorations)] = func;
// }

inline Window::Window_setBox_Functor::FunctionType Window::Window_setBox_Functor::operator= (FunctionType func)
{
   SELF(Window, setBox);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_setBox_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_setBox_Functor::FunctionType) * size);
   }
   ((Window::Window_setBox_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, setBox)] = func;
   return func;
}
inline void Window::Window_setBox_Functor::operator()( /*6Fj*/Box & box)
{
   SELF(Window, setBox);
   Window_setBox(self ? self->impl : (C(Window))null, /*7Al*/&box.impl);
}
// inline void Window::register_setBox(CPPClass & cl, Window::Window_setBox_Functor::FunctionType func)
// {
//    ((Window::Window_setBox_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, setBox)] = func;
// }

inline Window::Window_setWindowArea_Functor::FunctionType Window::Window_setWindowArea_Functor::operator= (FunctionType func)
{
   SELF(Window, setWindowArea);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_setWindowArea_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_setWindowArea_Functor::FunctionType) * size);
   }
   ((Window::Window_setWindowArea_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, setWindowArea)] = func;
   return func;
}
inline void Window::Window_setWindowArea_Functor::operator()( /*6Fj*/int * x, /*6Fj*/int * y, /*6Fj*/MinMaxValue * w, /*6Fj*/MinMaxValue * h, /*6Fj*/MinMaxValue * cw, /*6Fj*/MinMaxValue * ch)
{
   SELF(Window, setWindowArea);
   Window_setWindowArea(self ? self->impl : (C(Window))null, /*7Al*/x, /*7Al*/y, /*7Al*/&w->impl, /*7Al*/&h->impl, /*7Al*/&cw->impl, /*7Al*/&ch->impl);
}
// inline void Window::register_setWindowArea(CPPClass & cl, Window::Window_setWindowArea_Functor::FunctionType func)
// {
//    ((Window::Window_setWindowArea_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, setWindowArea)] = func;
// }

inline Window::Window_setWindowMinimum_Functor::FunctionType Window::Window_setWindowMinimum_Functor::operator= (FunctionType func)
{
   SELF(Window, setWindowMinimum);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_setWindowMinimum_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_setWindowMinimum_Functor::FunctionType) * size);
   }
   ((Window::Window_setWindowMinimum_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, setWindowMinimum)] = func;
   return func;
}
inline void Window::Window_setWindowMinimum_Functor::operator()( /*6Fj*/MinMaxValue * mw, /*6Fj*/MinMaxValue * mh)
{
   SELF(Window, setWindowMinimum);
   Window_setWindowMinimum(self ? self->impl : (C(Window))null, /*7Al*/&mw->impl, /*7Al*/&mh->impl);
}
// inline void Window::register_setWindowMinimum(CPPClass & cl, Window::Window_setWindowMinimum_Functor::FunctionType func)
// {
//    ((Window::Window_setWindowMinimum_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, setWindowMinimum)] = func;
// }

inline Window::Window_showDecorations_Functor::FunctionType Window::Window_showDecorations_Functor::operator= (FunctionType func)
{
   SELF(Window, showDecorations);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_showDecorations_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_showDecorations_Functor::FunctionType) * size);
   }
   ((Window::Window_showDecorations_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, showDecorations)] = func;
   return func;
}
inline void Window::Window_showDecorations_Functor::operator()( /*6Fj*/Font captionFont, /*6Fj*/Surface & surface, /*6Fj*/const char * name, /*6Fj*/bool active, /*6Fj*/bool moving)
{
   SELF(Window, showDecorations);
   Window_showDecorations(self ? self->impl : (C(Window))null, /*7Al*/captionFont.impl, /*7Al*/surface.impl, /*7Al*/name, /*7Al*/(C(bool))active, /*7Al*/(C(bool))moving);
}
// inline void Window::register_showDecorations(CPPClass & cl, Window::Window_showDecorations_Functor::FunctionType func)
// {
//    ((Window::Window_showDecorations_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, showDecorations)] = func;
// }

inline Window::Window_updateNonClient_Functor::FunctionType Window::Window_updateNonClient_Functor::operator= (FunctionType func)
{
   SELF(Window, updateNonClient);
   if(self->vTbl == Window::_cpp_class.vTbl)
   {
      uint size = Window::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Window::Window_updateNonClient_Functor::FunctionType, size);
      memcpy(self->vTbl, Window::_cpp_class.vTbl, sizeof(Window::Window_updateNonClient_Functor::FunctionType) * size);
   }
   ((Window::Window_updateNonClient_Functor::FunctionType *)self->vTbl)[M_VTBLID(Window, updateNonClient)] = func;
   return func;
}
inline void Window::Window_updateNonClient_Functor::operator()( )
{
   SELF(Window, updateNonClient);
   Window_updateNonClient(self ? self->impl : (C(Window))null);
}
// inline void Window::register_updateNonClient(CPPClass & cl, Window::Window_updateNonClient_Functor::FunctionType func)
// {
//    ((Window::Window_updateNonClient_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Window, updateNonClient)] = func;
// }


inline C(bool) Window::acquireInput(/*1Ab*/bool acquired)
{
   return Window_acquireInput(impl, /*5Ee*/(C(bool))acquired);
}
inline void Window::activate()
{
   Window_activate(impl);
}
inline void Window::addResource(/*1Ab*/Resource & resource)
{
   Window_addResource(impl, /*5De*/resource.impl);
}
inline C(bool) Window::buttonCloseDialog(/*1Ab*/Button & button, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers mods)
{
   return Window_buttonCloseDialog(impl, /*5De*/button.impl, /*5Ge*/x, /*5Ge*/y, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::capture()
{
   return Window_capture(impl);
}
inline C(bool) Window::closeConfirmation(/*1Ab*/bool parentClosing)
{
   return Window_closeConfirmation(impl, /*5Ee*/(C(bool))parentClosing);
}
inline C(bool) Window::create()
{
   return Window_create(impl);
}
inline C(bool) Window::cycleChildren(/*1Ab*/bool backward, /*1Ab*/bool clientOnly, /*1Ab*/bool tabCycleOnly, /*1Ab*/bool cycleParents)
{
   return Window_cycleChildren(impl, /*5Ee*/(C(bool))backward, /*5Ee*/(C(bool))clientOnly, /*5Ee*/(C(bool))tabCycleOnly, /*5Ee*/(C(bool))cycleParents);
}
inline void Window::deactivate()
{
   Window_deactivate(impl);
}
inline C(bool) Window::destroy(/*1Ab*/int64 code)
{
   return Window_destroy(impl, /*5Ge*/code);
}
inline C(DialogResult) Window::doModal()
{
   return Window_doModal(impl);
}
inline C(DialogResult) Window::doModalEnd()
{
   return Window_doModalEnd(impl);
}
inline C(bool) Window::doModalLoop()
{
   return Window_doModalLoop(impl);
}
inline void Window::doModalStart()
{
   Window_doModalStart(impl);
}
inline void Window::externalPosition(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h)
{
   Window_externalPosition(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/w, /*5Ge*/h);
}
inline void Window::flash()
{
   Window_flash(impl);
}
inline void Window::freeMouseRange()
{
   Window_freeMouseRange();
}
inline void Window::getCaretPosition(/*1Ab*/Point & caretPos)
{
   Window_getCaretPosition(impl, /*5De*/&caretPos.impl);
}
inline void Window::getCaretPosition(/*1Ac*/Point * caretPos)
{
   Window_getCaretPosition(impl, /*5Cf*/(C(Point) *)caretPos);
}
inline int Window::getCaretSize()
{
   return Window_getCaretSize(impl);
}
inline BitmapResource Window::getIcon(/*1Ab*/SkinBitmap iconID)
{
   return BitmapResource(Window_getIcon(impl, /*5Ee*/(C(SkinBitmap))iconID));
}
inline void Window::getMousePosition(/*1Ab*/int * x, /*1Ab*/int * y)
{
   Window_getMousePosition(impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Window::getNCMousePosition(/*1Ab*/int * x, /*1Ab*/int * y)
{
   Window_getNCMousePosition(impl, /*5Ge*/x, /*5Ge*/y);
}
inline C(bool) Window::grab(/*1Ab*/Bitmap & bitmap, /*1Ab*/Box & box, /*1Ab*/bool decorations)
{
   return Window_grab(impl, /*5De*/bitmap.impl, /*5De*/&box.impl, /*5Ee*/(C(bool))decorations);
}
inline C(bool) Window::grab(/*1Ac*/Bitmap & bitmap, /*1Ac*/Box * box, /*1Ac*/bool decorations)
{
   return Window_grab(impl, /*5Df*/bitmap.impl, /*5Cf*/(C(Box) *)box, /*5Ef*/(C(bool))decorations);
}
inline void Window::makeActive()
{
   Window_makeActive(impl);
}
inline C(bool) Window::menuFileClose(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuFileClose(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuFileExit(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuFileExit(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuFileSave(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuFileSave(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuFileSaveAll(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuFileSaveAll(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuFileSaveAs(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuFileSaveAs(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowArrangeIcons(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowArrangeIcons(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowCascade(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowCascade(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowClose(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowClose(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowCloseAll(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowCloseAll(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowMaximize(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowMaximize(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowMinimize(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowMinimize(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowMove(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowMove(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowNext(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowNext(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowPrevious(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowPrevious(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowRestore(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowRestore(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowSelectWindow(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowSelectWindow(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowSize(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowSize(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowStayOnTop(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowStayOnTop(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowTileHorz(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowTileHorz(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowTileVert(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowTileVert(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(bool) Window::menuWindowWindows(/*1Ab*/MenuItem & selection, /*1Ab*/Modifiers mods)
{
   return Window_menuWindowWindows(impl, /*5De*/selection.impl, /*5Ee*/(C(Modifiers))mods.impl);
}
inline C(DialogResult) Window::modal()
{
   return Window_modal(impl);
}
inline C(bool) Window::mouseMessage(/*1Ab*/uint method, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers * mods, /*1Ab*/bool consequential, /*1Ab*/bool activate)
{
   return Window_mouseMessage(impl, /*5Ge*/method, /*5Ge*/x, /*5Ge*/y, /*5Ee*/(C(Modifiers) *)mods, /*5Ee*/(C(bool))consequential, /*5Ee*/(C(bool))activate);
}
inline void Window::move(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int w, /*1Ab*/int h)
{
   Window_move(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/w, /*5Ge*/h);
}
inline C(bool) Window::multiTouchMessage(/*1Ab*/TouchPointerEvent event, /*1Ab*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Ab*/Modifiers * mods, /*1Ab*/bool consequential, /*1Ab*/bool activate)
{
   return Window_multiTouchMessage(impl, /*5Ee*/(C(TouchPointerEvent))event, /*5De*/((Instance&&)infos).impl, /*5Ee*/(C(Modifiers) *)mods, /*5Ee*/(C(bool))consequential, /*5Ee*/(C(bool))activate);
}
inline void Window::releaseCapture()
{
   Window_releaseCapture(impl);
}
inline void Window::removeResource(/*1Ab*/Resource & resource)
{
   Window_removeResource(impl, /*5De*/resource.impl);
}
inline void Window::restoreCaret()
{
   Window_restoreCaret();
}
inline void Window::_scroll(/*1Ab*/int x, /*1Ab*/int y)
{
   Window_scroll(impl, /*5Ge*/x, /*5Ge*/y);
}
template<typename... Args> inline void Window::setCaption(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   Window_setCaption(impl, /*5Ge*/format, /*5Ae*/args...);
}
inline void Window::setCaret(/*1Ab*/int x, /*1Ab*/int y, /*1Ab*/int size)
{
   Window_setCaret(impl, /*5Ge*/x, /*5Ge*/y, /*5Ge*/size);
}
inline void Window::setMousePosition(/*1Ab*/int x, /*1Ab*/int y)
{
   Window_setMousePosition(impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Window::setMouseRange(/*1Ab*/Box & range)
{
   Window_setMouseRange(impl, /*5De*/&range.impl);
}
inline void Window::setMouseRange(/*1Ac*/Box * range)
{
   Window_setMouseRange(impl, /*5Cf*/(C(Box) *)range);
}
inline void Window::setMouseRangeToClient()
{
   Window_setMouseRangeToClient(impl);
}
inline void Window::setMouseRangeToWindow()
{
   Window_setMouseRangeToWindow(impl);
}
inline void Window::setScrollArea(/*1Ab*/int width, /*1Ab*/int height, /*1Ab*/bool snapToStep)
{
   Window_setScrollArea(impl, /*5Ge*/width, /*5Ge*/height, /*5Ee*/(C(bool))snapToStep);
}
inline void Window::setScrollLineStep(/*1Ab*/int stepX, /*1Ab*/int stepY)
{
   Window_setScrollLineStep(impl, /*5Ge*/stepX, /*5Ge*/stepY);
}
inline void Window::setScrollPosition(/*1Ab*/int x, /*1Ab*/int y)
{
   Window_setScrollPosition(impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Window::setState(/*1Ab*/WindowState newState, /*1Ab*/bool activate, /*1Ab*/Modifiers mods)
{
   Window_setState(impl, /*5Ee*/(C(WindowState))newState, /*5Ee*/(C(bool))activate, /*5Ee*/(C(Modifiers))mods.impl);
}
template<typename... Args> inline void Window::setText(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   Window_setText(impl, /*5Ge*/format, /*5Ae*/args...);
}
inline void Window::showSysMenu(/*1Ab*/int x, /*1Ab*/int y)
{
   Window_showSysMenu(impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Window::softActivate()
{
   Window_softActivate(impl);
}
inline void Window::update(/*1Ab*/const Box & region)
{
   Window_update(impl, /*5De*/&region.impl);
}
inline void Window::update(/*1Ac*/const Box * region)
{
   Window_update(impl, /*5Cf*/(C(Box) *)region);
}
inline void Window::updateDisplay()
{
   Window_updateDisplay(impl);
}
inline void Window::writeCaption(/*1Ab*/Surface & surface, /*1Ab*/int x, /*1Ab*/int y)
{
   Window_writeCaption(impl, /*5De*/surface.impl, /*5Ge*/x, /*5Ge*/y);
}


// property callers: Window::parent
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & Window::parent_Prop::operator= (/*0A*/const Window & v)
{
   SELF(Window, parent);
   Window_set_parent(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Window::parent_Prop & Window::parent_Prop::operator= (Window::parent_Prop & prop)
{
   SELF(Window, parent);
   /*0A*/const Window & v = prop;
   Window_set_parent(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * Window::parent_Prop::operator= (/*0C*/const Window * v)
{
   SELF(Window, parent);
   Window_set_parent(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Window::parent_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, parent);
   C(Instance) i = Window_get_parent(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::parent_Prop::operator /*0D*/-> () const
{
   SELF(Window, parent);
   C(Instance) i = Window_get_parent(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::parent_Prop::operator /*0E*/Window () const
{
   SELF(Window, parent);
   C(Instance) i = Window_get_parent(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::parent_Prop::operator /*0F*/Window* () const
{
   SELF(Window, parent);
   C(Instance) i = Window_get_parent(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::master
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & Window::master_Prop::operator= (/*0A*/const Window & v)
{
   SELF(Window, master);
   Window_set_master(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Window::master_Prop & Window::master_Prop::operator= (Window::master_Prop & prop)
{
   SELF(Window, master);
   /*0A*/const Window & v = prop;
   Window_set_master(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * Window::master_Prop::operator= (/*0C*/const Window * v)
{
   SELF(Window, master);
   Window_set_master(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Window::master_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, master);
   C(Instance) i = Window_get_master(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::master_Prop::operator /*0D*/-> () const
{
   SELF(Window, master);
   C(Instance) i = Window_get_master(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::master_Prop::operator /*0E*/Window () const
{
   SELF(Window, master);
   C(Instance) i = Window_get_master(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::master_Prop::operator /*0F*/Window* () const
{
   SELF(Window, master);
   C(Instance) i = Window_get_master(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::caption
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * Window::caption_Prop::operator= (/*0H*/const char * v)
{
   SELF(Window, caption);
   Window_set_caption(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::caption_Prop & Window::caption_Prop::operator= (Window::caption_Prop & prop)
{
   SELF(Window, caption);
   /*0H*/const char * v = prop;
   Window_set_caption(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::caption_Prop::operator /*0I*/const char * () const
{
   SELF(Window, caption);
   return Window_get_caption(self ? self->impl : null);
}

// property callers: Window::hotKey
// (normal::bits|unsigned int)

/*nstSet*/inline /*0H*/Key Window::hotKey_Prop::operator= (/*0H*/Key v)
{
   SELF(Window, hotKey);
   Window_set_hotKey(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::hotKey_Prop & Window::hotKey_Prop::operator= (Window::hotKey_Prop & prop)
{
   SELF(Window, hotKey);
   /*0H*/Key v = prop;
   Window_set_hotKey(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::hotKey_Prop::operator /*0I*/Key () const
{
   SELF(Window, hotKey);
   return Window_get_hotKey(self ? self->impl : null);
}

// property callers: Window::background
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color Window::background_Prop::operator= (/*0H*/Color v)
{
   SELF(Window, background);
   Window_set_background(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::background_Prop & Window::background_Prop::operator= (Window::background_Prop & prop)
{
   SELF(Window, background);
   /*0H*/Color v = prop;
   Window_set_background(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::background_Prop::operator /*0I*/Color () const
{
   SELF(Window, background);
   return Window_get_background(self ? self->impl : null);
}

// property callers: Window::opacity
// (normal::unit|float)

/*nstSet*/inline /*0H*/Percentage Window::opacity_Prop::operator= (/*0H*/Percentage v)
{
   SELF(Window, opacity);
   Window_set_opacity(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Window::opacity_Prop & Window::opacity_Prop::operator= (Window::opacity_Prop & prop)
{
   SELF(Window, opacity);
   /*0H*/Percentage v = prop;
   Window_set_opacity(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline Window::opacity_Prop::operator /*0I*/Percentage () const
{
   SELF(Window, opacity);
   Percentage value(Window_get_opacity(self->impl));
   return value;
}
/*regGet*/inline Window::opacity_Prop::operator /*0J*/C(Percentage) () const
{
   SELF(Window, opacity);
   return Percentage(self->opacity);
}

// property callers: Window::foreground
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color Window::foreground_Prop::operator= (/*0H*/Color v)
{
   SELF(Window, foreground);
   Window_set_foreground(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::foreground_Prop & Window::foreground_Prop::operator= (Window::foreground_Prop & prop)
{
   SELF(Window, foreground);
   /*0H*/Color v = prop;
   Window_set_foreground(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::foreground_Prop::operator /*0I*/Color () const
{
   SELF(Window, foreground);
   return Window_get_foreground(self ? self->impl : null);
}

// property callers: Window::borderStyle
// (normal::enum|unsigned int)

/*nstSet*/inline /*0H*/BorderStyle Window::borderStyle_Prop::operator= (/*0H*/BorderStyle v)
{
   SELF(Window, borderStyle);
   Window_set_borderStyle(self ? self->impl : null, (C(BorderStyle))v);
   return v;
}

/*regSet*/inline Window::borderStyle_Prop & Window::borderStyle_Prop::operator= (Window::borderStyle_Prop & prop)
{
   SELF(Window, borderStyle);
   /*0H*/BorderStyle v = prop;
   Window_set_borderStyle(self ? self->impl : null, (C(BorderStyle))v);
   return prop;
}
/*regGet*/inline Window::borderStyle_Prop::operator /*0I*/BorderStyle () const
{
   SELF(Window, borderStyle);
   return (BorderStyle)Window_get_borderStyle(self ? self->impl : null);
}

// property callers: Window::minClientSize
// (normal::struct)

/*nstSet*/inline /*0H*/Size Window::minClientSize_Prop::operator= (/*0H*/Size v)
{
   SELF(Window, minClientSize);
   Window_set_minClientSize(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::minClientSize_Prop & Window::minClientSize_Prop::operator= (Window::minClientSize_Prop & prop)
{
   SELF(Window, minClientSize);
   /*0H*/Size v = prop;
   Window_set_minClientSize(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::minClientSize_Prop::operator /*0I*/Size () const
{
   SELF(Window, minClientSize);
   Size value;Window_get_minClientSize(self->impl, &value.impl);
   return value;
}

// property callers: Window::maxClientSize
// (normal::struct)

/*nstSet*/inline /*0H*/Size Window::maxClientSize_Prop::operator= (/*0H*/Size v)
{
   SELF(Window, maxClientSize);
   Window_set_maxClientSize(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::maxClientSize_Prop & Window::maxClientSize_Prop::operator= (Window::maxClientSize_Prop & prop)
{
   SELF(Window, maxClientSize);
   /*0H*/Size v = prop;
   Window_set_maxClientSize(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::maxClientSize_Prop::operator /*0I*/Size () const
{
   SELF(Window, maxClientSize);
   Size value;Window_get_maxClientSize(self->impl, &value.impl);
   return value;
}

// property callers: Window::hasMaximize
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::hasMaximize_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, hasMaximize);
   Window_set_hasMaximize(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::hasMaximize_Prop & Window::hasMaximize_Prop::operator= (Window::hasMaximize_Prop & prop)
{
   SELF(Window, hasMaximize);
   /*0H*/bool v = prop;
   Window_set_hasMaximize(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::hasMaximize_Prop::operator /*0I*/bool () const
{
   SELF(Window, hasMaximize);
   return (bool)Window_get_hasMaximize(self ? self->impl : null);
}

// property callers: Window::hasMinimize
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::hasMinimize_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, hasMinimize);
   Window_set_hasMinimize(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::hasMinimize_Prop & Window::hasMinimize_Prop::operator= (Window::hasMinimize_Prop & prop)
{
   SELF(Window, hasMinimize);
   /*0H*/bool v = prop;
   Window_set_hasMinimize(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::hasMinimize_Prop::operator /*0I*/bool () const
{
   SELF(Window, hasMinimize);
   return (bool)Window_get_hasMinimize(self ? self->impl : null);
}

// property callers: Window::hasClose
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::hasClose_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, hasClose);
   Window_set_hasClose(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::hasClose_Prop & Window::hasClose_Prop::operator= (Window::hasClose_Prop & prop)
{
   SELF(Window, hasClose);
   /*0H*/bool v = prop;
   Window_set_hasClose(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::hasClose_Prop::operator /*0I*/bool () const
{
   SELF(Window, hasClose);
   return (bool)Window_get_hasClose(self ? self->impl : null);
}

// property callers: Window::nonClient
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::nonClient_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, nonClient);
   Window_set_nonClient(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::nonClient_Prop & Window::nonClient_Prop::operator= (Window::nonClient_Prop & prop)
{
   SELF(Window, nonClient);
   /*0H*/bool v = prop;
   Window_set_nonClient(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::nonClient_Prop::operator /*0I*/bool () const
{
   SELF(Window, nonClient);
   return (bool)Window_get_nonClient(self ? self->impl : null);
}

// property callers: Window::inactive
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::inactive_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, inactive);
   Window_set_inactive(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::inactive_Prop & Window::inactive_Prop::operator= (Window::inactive_Prop & prop)
{
   SELF(Window, inactive);
   /*0H*/bool v = prop;
   Window_set_inactive(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::inactive_Prop::operator /*0I*/bool () const
{
   SELF(Window, inactive);
   return (bool)Window_get_inactive(self ? self->impl : null);
}

// property callers: Window::clickThrough
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::clickThrough_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, clickThrough);
   Window_set_clickThrough(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::clickThrough_Prop & Window::clickThrough_Prop::operator= (Window::clickThrough_Prop & prop)
{
   SELF(Window, clickThrough);
   /*0H*/bool v = prop;
   Window_set_clickThrough(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::clickThrough_Prop::operator /*0I*/bool () const
{
   SELF(Window, clickThrough);
   return (bool)Window_get_clickThrough(self ? self->impl : null);
}

// property callers: Window::isRemote
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::isRemote_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, isRemote);
   Window_set_isRemote(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::isRemote_Prop & Window::isRemote_Prop::operator= (Window::isRemote_Prop & prop)
{
   SELF(Window, isRemote);
   /*0H*/bool v = prop;
   Window_set_isRemote(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::isRemote_Prop::operator /*0I*/bool () const
{
   SELF(Window, isRemote);
   return (bool)Window_get_isRemote(self ? self->impl : null);
}

// property callers: Window::noCycle
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::noCycle_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, noCycle);
   Window_set_noCycle(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::noCycle_Prop & Window::noCycle_Prop::operator= (Window::noCycle_Prop & prop)
{
   SELF(Window, noCycle);
   /*0H*/bool v = prop;
   Window_set_noCycle(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::noCycle_Prop::operator /*0I*/bool () const
{
   SELF(Window, noCycle);
   return (bool)Window_get_noCycle(self ? self->impl : null);
}

// property callers: Window::isModal
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::isModal_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, isModal);
   Window_set_isModal(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::isModal_Prop & Window::isModal_Prop::operator= (Window::isModal_Prop & prop)
{
   SELF(Window, isModal);
   /*0H*/bool v = prop;
   Window_set_isModal(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::isModal_Prop::operator /*0I*/bool () const
{
   SELF(Window, isModal);
   return (bool)Window_get_isModal(self ? self->impl : null);
}

// property callers: Window::interim
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::interim_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, interim);
   Window_set_interim(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::interim_Prop & Window::interim_Prop::operator= (Window::interim_Prop & prop)
{
   SELF(Window, interim);
   /*0H*/bool v = prop;
   Window_set_interim(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::interim_Prop::operator /*0I*/bool () const
{
   SELF(Window, interim);
   return (bool)Window_get_interim(self ? self->impl : null);
}

// property callers: Window::tabCycle
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::tabCycle_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, tabCycle);
   Window_set_tabCycle(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::tabCycle_Prop & Window::tabCycle_Prop::operator= (Window::tabCycle_Prop & prop)
{
   SELF(Window, tabCycle);
   /*0H*/bool v = prop;
   Window_set_tabCycle(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::tabCycle_Prop::operator /*0I*/bool () const
{
   SELF(Window, tabCycle);
   return (bool)Window_get_tabCycle(self ? self->impl : null);
}

// property callers: Window::isDefault
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::isDefault_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, isDefault);
   Window_set_isDefault(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::isDefault_Prop & Window::isDefault_Prop::operator= (Window::isDefault_Prop & prop)
{
   SELF(Window, isDefault);
   /*0H*/bool v = prop;
   Window_set_isDefault(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::isDefault_Prop::operator /*0I*/bool () const
{
   SELF(Window, isDefault);
   return (bool)Window_get_isDefault(self ? self->impl : null);
}

// property callers: Window::drawBehind
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::drawBehind_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, drawBehind);
   Window_set_drawBehind(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::drawBehind_Prop & Window::drawBehind_Prop::operator= (Window::drawBehind_Prop & prop)
{
   SELF(Window, drawBehind);
   /*0H*/bool v = prop;
   Window_set_drawBehind(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::drawBehind_Prop::operator /*0I*/bool () const
{
   SELF(Window, drawBehind);
   return (bool)Window_get_drawBehind(self ? self->impl : null);
}

// property callers: Window::hasMenuBar
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::hasMenuBar_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, hasMenuBar);
   Window_set_hasMenuBar(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::hasMenuBar_Prop & Window::hasMenuBar_Prop::operator= (Window::hasMenuBar_Prop & prop)
{
   SELF(Window, hasMenuBar);
   /*0H*/bool v = prop;
   Window_set_hasMenuBar(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::hasMenuBar_Prop::operator /*0I*/bool () const
{
   SELF(Window, hasMenuBar);
   return (bool)Window_get_hasMenuBar(self ? self->impl : null);
}

// property callers: Window::hasStatusBar
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::hasStatusBar_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, hasStatusBar);
   Window_set_hasStatusBar(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::hasStatusBar_Prop & Window::hasStatusBar_Prop::operator= (Window::hasStatusBar_Prop & prop)
{
   SELF(Window, hasStatusBar);
   /*0H*/bool v = prop;
   Window_set_hasStatusBar(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::hasStatusBar_Prop::operator /*0I*/bool () const
{
   SELF(Window, hasStatusBar);
   return (bool)Window_get_hasStatusBar(self ? self->impl : null);
}

// property callers: Window::stayOnTop
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::stayOnTop_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, stayOnTop);
   Window_set_stayOnTop(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::stayOnTop_Prop & Window::stayOnTop_Prop::operator= (Window::stayOnTop_Prop & prop)
{
   SELF(Window, stayOnTop);
   /*0H*/bool v = prop;
   Window_set_stayOnTop(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::stayOnTop_Prop::operator /*0I*/bool () const
{
   SELF(Window, stayOnTop);
   return (bool)Window_get_stayOnTop(self ? self->impl : null);
}

// property callers: Window::menu
// (normal::normal)

/*nstSet*/inline /*0A*/const Menu & Window::menu_Prop::operator= (/*0A*/const Menu & v)
{
   SELF(Window, menu);
   Window_set_menu(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Window::menu_Prop & Window::menu_Prop::operator= (Window::menu_Prop & prop)
{
   SELF(Window, menu);
   /*0A*/const Menu & v = prop;
   Window_set_menu(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Menu * Window::menu_Prop::operator= (/*0C*/const Menu * v)
{
   SELF(Window, menu);
   Window_set_menu(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Window::menu_Prop::operator /*0B*/TIH<Menu> () const
{
   SELF(Window, menu);
   C(Instance) i = Window_get_menu(self ? self->impl : null);
   TIH<Menu> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Menu> Window::menu_Prop::operator /*0D*/-> () const
{
   SELF(Window, menu);
   C(Instance) i = Window_get_menu(self ? self->impl : null);
   TIH<Menu> holder(i);
   return holder;
}
/*regGet*/inline Window::menu_Prop::operator /*0E*/Menu () const
{
   SELF(Window, menu);
   C(Instance) i = Window_get_menu(self ? self->impl : null);
   return Menu(i);
}
/*regGet*/inline Window::menu_Prop::operator /*0F*/Menu* () const
{
   SELF(Window, menu);
   C(Instance) i = Window_get_menu(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Menu *)INSTANCEL(i, i->_class) : (Menu *)0;
}

// property callers: Window::font
// (normal::normal)

/*nstSet*/inline /*0A*/const FontResource & Window::font_Prop::operator= (/*0A*/const FontResource & v)
{
   SELF(Window, font);
   Window_set_font(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Window::font_Prop & Window::font_Prop::operator= (Window::font_Prop & prop)
{
   SELF(Window, font);
   /*0A*/const FontResource & v = prop;
   Window_set_font(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const FontResource * Window::font_Prop::operator= (/*0C*/const FontResource * v)
{
   SELF(Window, font);
   Window_set_font(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Window::font_Prop::operator /*0B*/TIH<FontResource> () const
{
   SELF(Window, font);
   C(Instance) i = Window_get_font(self ? self->impl : null);
   TIH<FontResource> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<FontResource> Window::font_Prop::operator /*0D*/-> () const
{
   SELF(Window, font);
   C(Instance) i = Window_get_font(self ? self->impl : null);
   TIH<FontResource> holder(i);
   return holder;
}
/*regGet*/inline Window::font_Prop::operator /*0E*/FontResource () const
{
   SELF(Window, font);
   C(Instance) i = Window_get_font(self ? self->impl : null);
   return FontResource(i);
}
/*regGet*/inline Window::font_Prop::operator /*0F*/FontResource* () const
{
   SELF(Window, font);
   C(Instance) i = Window_get_font(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (FontResource *)INSTANCEL(i, i->_class) : (FontResource *)0;
}

// property callers: Window::sizeAnchor
// (normal::struct)

/*nstSet*/inline /*0H*/SizeAnchor Window::sizeAnchor_Prop::operator= (/*0H*/SizeAnchor v)
{
   SELF(Window, sizeAnchor);
   Window_set_sizeAnchor(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::sizeAnchor_Prop & Window::sizeAnchor_Prop::operator= (Window::sizeAnchor_Prop & prop)
{
   SELF(Window, sizeAnchor);
   /*0H*/SizeAnchor v = prop;
   Window_set_sizeAnchor(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::sizeAnchor_Prop::operator /*0I*/SizeAnchor () const
{
   SELF(Window, sizeAnchor);
   SizeAnchor value;Window_get_sizeAnchor(self->impl, &value.impl);
   return value;
}

// property callers: Window::size
// (normal::struct)

/*nstSet*/inline /*0H*/Size Window::size_Prop::operator= (/*0H*/Size v)
{
   SELF(Window, size);
   Window_set_size(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::size_Prop & Window::size_Prop::operator= (Window::size_Prop & prop)
{
   SELF(Window, size);
   /*0H*/Size v = prop;
   Window_set_size(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::size_Prop::operator /*0I*/Size () const
{
   SELF(Window, size);
   Size value;Window_get_size(self->impl, &value.impl);
   return value;
}

// property callers: Window::clientSize
// (normal::struct)

/*nstSet*/inline /*0H*/Size Window::clientSize_Prop::operator= (/*0H*/Size v)
{
   SELF(Window, clientSize);
   Window_set_clientSize(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::clientSize_Prop & Window::clientSize_Prop::operator= (Window::clientSize_Prop & prop)
{
   SELF(Window, clientSize);
   /*0H*/Size v = prop;
   Window_set_clientSize(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::clientSize_Prop::operator /*0I*/Size () const
{
   SELF(Window, clientSize);
   Size value;Window_get_clientSize(self->impl, &value.impl);
   return value;
}

// property callers: Window::initSize   // get only
// (normal::struct)

/*regGet*/inline Window::initSize_Prop::operator /*0I*/Size () const
{
   SELF(Window, initSize);
   Size value;Window_get_initSize(self->impl, &value.impl);
   return value;
}

// property callers: Window::anchor
// (normal::struct)

/*nstSet*/inline /*0H*/Anchor Window::anchor_Prop::operator= (/*0H*/Anchor v)
{
   SELF(Window, anchor);
   Window_set_anchor(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::anchor_Prop & Window::anchor_Prop::operator= (Window::anchor_Prop & prop)
{
   SELF(Window, anchor);
   /*0H*/Anchor v = prop;
   Window_set_anchor(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::anchor_Prop::operator /*0I*/Anchor () const
{
   SELF(Window, anchor);
   Anchor value;Window_get_anchor(self->impl, &value.impl);
   return value;
}

// property callers: Window::position
// (normal::struct)

/*nstSet*/inline /*0H*/Point Window::position_Prop::operator= (/*0H*/Point v)
{
   SELF(Window, position);
   Window_set_position(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::position_Prop & Window::position_Prop::operator= (Window::position_Prop & prop)
{
   SELF(Window, position);
   /*0H*/Point v = prop;
   Window_set_position(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::position_Prop::operator /*0I*/Point () const
{
   SELF(Window, position);
   Point value;Window_get_position(self->impl, &value.impl);
   return value;
}

// property callers: Window::disabled
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::disabled_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, disabled);
   Window_set_disabled(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::disabled_Prop & Window::disabled_Prop::operator= (Window::disabled_Prop & prop)
{
   SELF(Window, disabled);
   /*0H*/bool v = prop;
   Window_set_disabled(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::disabled_Prop::operator /*0I*/bool () const
{
   SELF(Window, disabled);
   return (bool)Window_get_disabled(self ? self->impl : null);
}

// property callers: Window::isEnabled   // get only
// (normal::enum|uint)

/*regGet*/inline Window::isEnabled_Prop::operator /*0I*/bool () const
{
   SELF(Window, isEnabled);
   return (bool)Window_get_isEnabled(self ? self->impl : null);
}

// property callers: Window::state
// (normal::enum|int)

/*nstSet*/inline /*0H*/WindowState Window::state_Prop::operator= (/*0H*/WindowState v)
{
   SELF(Window, state);
   Window_set_state(self ? self->impl : null, (C(WindowState))v);
   return v;
}

/*regSet*/inline Window::state_Prop & Window::state_Prop::operator= (Window::state_Prop & prop)
{
   SELF(Window, state);
   /*0H*/WindowState v = prop;
   Window_set_state(self ? self->impl : null, (C(WindowState))v);
   return prop;
}
/*regGet*/inline Window::state_Prop::operator /*0I*/WindowState () const
{
   SELF(Window, state);
   return (WindowState)Window_get_state(self ? self->impl : null);
}

// property callers: Window::visible
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::visible_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, visible);
   Window_set_visible(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::visible_Prop & Window::visible_Prop::operator= (Window::visible_Prop & prop)
{
   SELF(Window, visible);
   /*0H*/bool v = prop;
   Window_set_visible(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::visible_Prop::operator /*0I*/bool () const
{
   SELF(Window, visible);
   return (bool)Window_get_visible(self ? self->impl : null);
}

// property callers: Window::isDocument
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::isDocument_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, isDocument);
   Window_set_isDocument(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::isDocument_Prop & Window::isDocument_Prop::operator= (Window::isDocument_Prop & prop)
{
   SELF(Window, isDocument);
   /*0H*/bool v = prop;
   Window_set_isDocument(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::isDocument_Prop::operator /*0I*/bool () const
{
   SELF(Window, isDocument);
   return (bool)Window_get_isDocument(self ? self->impl : null);
}

// property callers: Window::mergeMenus
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::mergeMenus_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, mergeMenus);
   Window_set_mergeMenus(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::mergeMenus_Prop & Window::mergeMenus_Prop::operator= (Window::mergeMenus_Prop & prop)
{
   SELF(Window, mergeMenus);
   /*0H*/bool v = prop;
   Window_set_mergeMenus(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::mergeMenus_Prop::operator /*0I*/bool () const
{
   SELF(Window, mergeMenus);
   return (bool)Window_get_mergeMenus(self ? self->impl : null);
}

// property callers: Window::hasHorzScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::hasHorzScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, hasHorzScroll);
   Window_set_hasHorzScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::hasHorzScroll_Prop & Window::hasHorzScroll_Prop::operator= (Window::hasHorzScroll_Prop & prop)
{
   SELF(Window, hasHorzScroll);
   /*0H*/bool v = prop;
   Window_set_hasHorzScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::hasHorzScroll_Prop::operator /*0I*/bool () const
{
   SELF(Window, hasHorzScroll);
   return (bool)Window_get_hasHorzScroll(self ? self->impl : null);
}

// property callers: Window::hasVertScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::hasVertScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, hasVertScroll);
   Window_set_hasVertScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::hasVertScroll_Prop & Window::hasVertScroll_Prop::operator= (Window::hasVertScroll_Prop & prop)
{
   SELF(Window, hasVertScroll);
   /*0H*/bool v = prop;
   Window_set_hasVertScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::hasVertScroll_Prop::operator /*0I*/bool () const
{
   SELF(Window, hasVertScroll);
   return (bool)Window_get_hasVertScroll(self ? self->impl : null);
}

// property callers: Window::dontHideScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::dontHideScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, dontHideScroll);
   Window_set_dontHideScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::dontHideScroll_Prop & Window::dontHideScroll_Prop::operator= (Window::dontHideScroll_Prop & prop)
{
   SELF(Window, dontHideScroll);
   /*0H*/bool v = prop;
   Window_set_dontHideScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::dontHideScroll_Prop::operator /*0I*/bool () const
{
   SELF(Window, dontHideScroll);
   return (bool)Window_get_dontHideScroll(self ? self->impl : null);
}

// property callers: Window::dontScrollVert
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::dontScrollVert_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, dontScrollVert);
   Window_set_dontScrollVert(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::dontScrollVert_Prop & Window::dontScrollVert_Prop::operator= (Window::dontScrollVert_Prop & prop)
{
   SELF(Window, dontScrollVert);
   /*0H*/bool v = prop;
   Window_set_dontScrollVert(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::dontScrollVert_Prop::operator /*0I*/bool () const
{
   SELF(Window, dontScrollVert);
   return (bool)Window_get_dontScrollVert(self ? self->impl : null);
}

// property callers: Window::dontScrollHorz
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::dontScrollHorz_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, dontScrollHorz);
   Window_set_dontScrollHorz(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::dontScrollHorz_Prop & Window::dontScrollHorz_Prop::operator= (Window::dontScrollHorz_Prop & prop)
{
   SELF(Window, dontScrollHorz);
   /*0H*/bool v = prop;
   Window_set_dontScrollHorz(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::dontScrollHorz_Prop::operator /*0I*/bool () const
{
   SELF(Window, dontScrollHorz);
   return (bool)Window_get_dontScrollHorz(self ? self->impl : null);
}

// property callers: Window::snapVertScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::snapVertScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, snapVertScroll);
   Window_set_snapVertScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::snapVertScroll_Prop & Window::snapVertScroll_Prop::operator= (Window::snapVertScroll_Prop & prop)
{
   SELF(Window, snapVertScroll);
   /*0H*/bool v = prop;
   Window_set_snapVertScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::snapVertScroll_Prop::operator /*0I*/bool () const
{
   SELF(Window, snapVertScroll);
   return (bool)Window_get_snapVertScroll(self ? self->impl : null);
}

// property callers: Window::snapHorzScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::snapHorzScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, snapHorzScroll);
   Window_set_snapHorzScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::snapHorzScroll_Prop & Window::snapHorzScroll_Prop::operator= (Window::snapHorzScroll_Prop & prop)
{
   SELF(Window, snapHorzScroll);
   /*0H*/bool v = prop;
   Window_set_snapHorzScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::snapHorzScroll_Prop::operator /*0I*/bool () const
{
   SELF(Window, snapHorzScroll);
   return (bool)Window_get_snapHorzScroll(self ? self->impl : null);
}

// property callers: Window::scroll
// (normal::struct)

/*nstSet*/inline /*0H*/Point Window::scroll_Prop::operator= (/*0H*/Point v)
{
   SELF(Window, scroll);
   Window_set_scroll(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::scroll_Prop & Window::scroll_Prop::operator= (Window::scroll_Prop & prop)
{
   SELF(Window, scroll);
   /*0H*/Point v = prop;
   Window_set_scroll(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::scroll_Prop::operator /*0I*/Point () const
{
   SELF(Window, scroll);
   Point value;Window_get_scroll(self->impl, &value.impl);
   return value;
}

// property callers: Window::modifyVirtualArea
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::modifyVirtualArea_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, modifyVirtualArea);
   Window_set_modifyVirtualArea(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::modifyVirtualArea_Prop & Window::modifyVirtualArea_Prop::operator= (Window::modifyVirtualArea_Prop & prop)
{
   SELF(Window, modifyVirtualArea);
   /*0H*/bool v = prop;
   Window_set_modifyVirtualArea(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::modifyVirtualArea_Prop::operator /*0I*/bool () const
{
   SELF(Window, modifyVirtualArea);
   return (bool)Window_get_modifyVirtualArea(self ? self->impl : null);
}

// property callers: Window::dontAutoScrollArea
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::dontAutoScrollArea_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, dontAutoScrollArea);
   Window_set_dontAutoScrollArea(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::dontAutoScrollArea_Prop & Window::dontAutoScrollArea_Prop::operator= (Window::dontAutoScrollArea_Prop & prop)
{
   SELF(Window, dontAutoScrollArea);
   /*0H*/bool v = prop;
   Window_set_dontAutoScrollArea(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::dontAutoScrollArea_Prop::operator /*0I*/bool () const
{
   SELF(Window, dontAutoScrollArea);
   return (bool)Window_get_dontAutoScrollArea(self ? self->impl : null);
}

// property callers: Window::fileName
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * Window::fileName_Prop::operator= (/*0H*/const char * v)
{
   SELF(Window, fileName);
   Window_set_fileName(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::fileName_Prop & Window::fileName_Prop::operator= (Window::fileName_Prop & prop)
{
   SELF(Window, fileName);
   /*0H*/const char * v = prop;
   Window_set_fileName(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::fileName_Prop::operator /*0I*/const char * () const
{
   SELF(Window, fileName);
   return Window_get_fileName(self ? self->impl : null);
}

// property callers: Window::id
// (normal::int64)

/*nstSet*/inline /*0H*/int64 Window::id_Prop::operator= (/*0H*/int64 v)
{
   SELF(Window, id);
   Window_set_id(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::id_Prop & Window::id_Prop::operator= (Window::id_Prop & prop)
{
   SELF(Window, id);
   /*0H*/int64 v = prop;
   Window_set_id(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::id_Prop::operator /*0I*/int64 () const
{
   SELF(Window, id);
   return Window_get_id(self ? self->impl : null);
}

// property callers: Window::modifiedDocument
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::modifiedDocument_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, modifiedDocument);
   Window_set_modifiedDocument(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::modifiedDocument_Prop & Window::modifiedDocument_Prop::operator= (Window::modifiedDocument_Prop & prop)
{
   SELF(Window, modifiedDocument);
   /*0H*/bool v = prop;
   Window_set_modifiedDocument(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::modifiedDocument_Prop::operator /*0I*/bool () const
{
   SELF(Window, modifiedDocument);
   return (bool)Window_get_modifiedDocument(self ? self->impl : null);
}

// property callers: Window::showInTaskBar
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::showInTaskBar_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, showInTaskBar);
   Window_set_showInTaskBar(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::showInTaskBar_Prop & Window::showInTaskBar_Prop::operator= (Window::showInTaskBar_Prop & prop)
{
   SELF(Window, showInTaskBar);
   /*0H*/bool v = prop;
   Window_set_showInTaskBar(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::showInTaskBar_Prop::operator /*0I*/bool () const
{
   SELF(Window, showInTaskBar);
   return (bool)Window_get_showInTaskBar(self ? self->impl : null);
}

// property callers: Window::saveDialog   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const FileDialog & Window::saveDialog_Prop::operator= (/*0A*/const FileDialog & v)
{
   SELF(Window, saveDialog);
   Window_set_saveDialog(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const FileDialog * Window::saveDialog_Prop::operator= (/*0C*/const FileDialog * v)
{
   SELF(Window, saveDialog);
   Window_set_saveDialog(self ? self->impl : null, v ? v->impl : null);
   return v;
}


// property callers: Window::isActiveClient
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::isActiveClient_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, isActiveClient);
   Window_set_isActiveClient(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::isActiveClient_Prop & Window::isActiveClient_Prop::operator= (Window::isActiveClient_Prop & prop)
{
   SELF(Window, isActiveClient);
   /*0H*/bool v = prop;
   Window_set_isActiveClient(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::isActiveClient_Prop::operator /*0I*/bool () const
{
   SELF(Window, isActiveClient);
   return (bool)Window_get_isActiveClient(self ? self->impl : null);
}

// property callers: Window::cursor
// (normal::normal)

/*nstSet*/inline /*0A*/const Cursor & Window::cursor_Prop::operator= (/*0A*/const Cursor & v)
{
   SELF(Window, cursor);
   Window_set_cursor(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Window::cursor_Prop & Window::cursor_Prop::operator= (Window::cursor_Prop & prop)
{
   SELF(Window, cursor);
   /*0A*/const Cursor & v = prop;
   Window_set_cursor(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Cursor * Window::cursor_Prop::operator= (/*0C*/const Cursor * v)
{
   SELF(Window, cursor);
   Window_set_cursor(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Window::cursor_Prop::operator /*0B*/TIH<Cursor> () const
{
   SELF(Window, cursor);
   C(Instance) i = Window_get_cursor(self ? self->impl : null);
   TIH<Cursor> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Cursor> Window::cursor_Prop::operator /*0D*/-> () const
{
   SELF(Window, cursor);
   C(Instance) i = Window_get_cursor(self ? self->impl : null);
   TIH<Cursor> holder(i);
   return holder;
}
/*regGet*/inline Window::cursor_Prop::operator /*0E*/Cursor () const
{
   SELF(Window, cursor);
   C(Instance) i = Window_get_cursor(self ? self->impl : null);
   return Cursor(i);
}
/*regGet*/inline Window::cursor_Prop::operator /*0F*/Cursor* () const
{
   SELF(Window, cursor);
   C(Instance) i = Window_get_cursor(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Cursor *)INSTANCEL(i, i->_class) : (Cursor *)0;
}

// property callers: Window::name
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * Window::name_Prop::operator= (/*0H*/const char * v)
{
   SELF(Window, name);
   Window_set_name(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::name_Prop & Window::name_Prop::operator= (Window::name_Prop & prop)
{
   SELF(Window, name);
   /*0H*/const char * v = prop;
   Window_set_name(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::name_Prop::operator /*0I*/const char * () const
{
   SELF(Window, name);
   return Window_get_name(self ? self->impl : null);
}

// property callers: Window::displayDriver
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * Window::displayDriver_Prop::operator= (/*0H*/const char * v)
{
   SELF(Window, displayDriver);
   Window_set_displayDriver(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::displayDriver_Prop & Window::displayDriver_Prop::operator= (Window::displayDriver_Prop & prop)
{
   SELF(Window, displayDriver);
   /*0H*/const char * v = prop;
   Window_set_displayDriver(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::displayDriver_Prop::operator /*0I*/const char * () const
{
   SELF(Window, displayDriver);
   return Window_get_displayDriver(self ? self->impl : null);
}

// property callers: Window::autoCreate
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::autoCreate_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, autoCreate);
   Window_set_autoCreate(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::autoCreate_Prop & Window::autoCreate_Prop::operator= (Window::autoCreate_Prop & prop)
{
   SELF(Window, autoCreate);
   /*0H*/bool v = prop;
   Window_set_autoCreate(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::autoCreate_Prop::operator /*0I*/bool () const
{
   SELF(Window, autoCreate);
   return (bool)Window_get_autoCreate(self ? self->impl : null);
}

// property callers: Window::scrollArea
// (normal::struct)

/*nstSet*/inline /*0H*/Size Window::scrollArea_Prop::operator= (/*0H*/Size v)
{
   SELF(Window, scrollArea);
   Window_set_scrollArea(self ? self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline Window::scrollArea_Prop & Window::scrollArea_Prop::operator= (Window::scrollArea_Prop & prop)
{
   SELF(Window, scrollArea);
   /*0H*/Size v = prop;
   Window_set_scrollArea(self ? self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline Window::scrollArea_Prop::operator /*0I*/Size () const
{
   SELF(Window, scrollArea);
   Size value;Window_get_scrollArea(self->impl, &value.impl);
   return value;
}

// property callers: Window::is3D
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::is3D_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, is3D);
   Window_set_is3D(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::is3D_Prop & Window::is3D_Prop::operator= (Window::is3D_Prop & prop)
{
   SELF(Window, is3D);
   /*0H*/bool v = prop;
   Window_set_is3D(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::is3D_Prop::operator /*0I*/bool () const
{
   SELF(Window, is3D);
   return (bool)Window_get_is3D(self ? self->impl : null);
}

// property callers: Window::fontObject   // get only
// (normal::nohead)

/*regGet*/inline Window::fontObject_Prop::operator /*0I*/Font () const
{
   SELF(Window, fontObject);
   Font value(Window_get_fontObject(self->impl));
   return value;
}

// property callers: Window::clientStart   // get only
// (normal::struct)

/*regGet*/inline Window::clientStart_Prop::operator /*0I*/Point () const
{
   SELF(Window, clientStart);
   Point value;Window_get_clientStart(self->impl, &value.impl);
   return value;
}

// property callers: Window::absPosition   // get only
// (normal::struct)

/*regGet*/inline Window::absPosition_Prop::operator /*0I*/Point () const
{
   SELF(Window, absPosition);
   Point value;Window_get_absPosition(self->impl, &value.impl);
   return value;
}

// property callers: Window::normalAnchor   // get only
// (normal::struct)

/*regGet*/inline Window::normalAnchor_Prop::operator /*0I*/Anchor () const
{
   SELF(Window, normalAnchor);
   Anchor value;Window_get_normalAnchor(self->impl, &value.impl);
   return value;
}

// property callers: Window::normalSizeAnchor   // get only
// (normal::struct)

/*regGet*/inline Window::normalSizeAnchor_Prop::operator /*0I*/SizeAnchor () const
{
   SELF(Window, normalSizeAnchor);
   SizeAnchor value;Window_get_normalSizeAnchor(self->impl, &value.impl);
   return value;
}

// property callers: Window::active   // get only
// (normal::enum|uint)

/*regGet*/inline Window::active_Prop::operator /*0I*/bool () const
{
   SELF(Window, active);
   return (bool)Window_get_active(self ? self->impl : null);
}

// property callers: Window::created   // get only
// (normal::enum|uint)

/*regGet*/inline Window::created_Prop::operator /*0I*/bool () const
{
   SELF(Window, created);
   return (bool)Window_get_created(self ? self->impl : null);
}

// property callers: Window::destroyed   // get only
// (normal::enum|uint)

/*regGet*/inline Window::destroyed_Prop::operator /*0I*/bool () const
{
   SELF(Window, destroyed);
   return (bool)Window_get_destroyed(self ? self->impl : null);
}

// property callers: Window::firstSlave   // get only
// (normal::normal)

/*regGet*/inline Window::firstSlave_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, firstSlave);
   C(Instance) i = Window_get_firstSlave(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::firstSlave_Prop::operator /*0D*/-> () const
{
   SELF(Window, firstSlave);
   C(Instance) i = Window_get_firstSlave(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::firstSlave_Prop::operator /*0E*/Window () const
{
   SELF(Window, firstSlave);
   C(Instance) i = Window_get_firstSlave(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::firstSlave_Prop::operator /*0F*/Window* () const
{
   SELF(Window, firstSlave);
   C(Instance) i = Window_get_firstSlave(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::firstChild   // get only
// (normal::normal)

/*regGet*/inline Window::firstChild_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, firstChild);
   C(Instance) i = Window_get_firstChild(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::firstChild_Prop::operator /*0D*/-> () const
{
   SELF(Window, firstChild);
   C(Instance) i = Window_get_firstChild(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::firstChild_Prop::operator /*0E*/Window () const
{
   SELF(Window, firstChild);
   C(Instance) i = Window_get_firstChild(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::firstChild_Prop::operator /*0F*/Window* () const
{
   SELF(Window, firstChild);
   C(Instance) i = Window_get_firstChild(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::lastChild   // get only
// (normal::normal)

/*regGet*/inline Window::lastChild_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, lastChild);
   C(Instance) i = Window_get_lastChild(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::lastChild_Prop::operator /*0D*/-> () const
{
   SELF(Window, lastChild);
   C(Instance) i = Window_get_lastChild(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::lastChild_Prop::operator /*0E*/Window () const
{
   SELF(Window, lastChild);
   C(Instance) i = Window_get_lastChild(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::lastChild_Prop::operator /*0F*/Window* () const
{
   SELF(Window, lastChild);
   C(Instance) i = Window_get_lastChild(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::activeClient   // get only
// (normal::normal)

/*regGet*/inline Window::activeClient_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, activeClient);
   C(Instance) i = Window_get_activeClient(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::activeClient_Prop::operator /*0D*/-> () const
{
   SELF(Window, activeClient);
   C(Instance) i = Window_get_activeClient(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::activeClient_Prop::operator /*0E*/Window () const
{
   SELF(Window, activeClient);
   C(Instance) i = Window_get_activeClient(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::activeClient_Prop::operator /*0F*/Window* () const
{
   SELF(Window, activeClient);
   C(Instance) i = Window_get_activeClient(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::activeChild   // get only
// (normal::normal)

/*regGet*/inline Window::activeChild_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, activeChild);
   C(Instance) i = Window_get_activeChild(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::activeChild_Prop::operator /*0D*/-> () const
{
   SELF(Window, activeChild);
   C(Instance) i = Window_get_activeChild(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::activeChild_Prop::operator /*0E*/Window () const
{
   SELF(Window, activeChild);
   C(Instance) i = Window_get_activeChild(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::activeChild_Prop::operator /*0F*/Window* () const
{
   SELF(Window, activeChild);
   C(Instance) i = Window_get_activeChild(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::display   // get only
// (normal::normal)

/*regGet*/inline Window::display_Prop::operator /*0B*/TIH<Display> () const
{
   SELF(Window, display);
   C(Instance) i = Window_get_display(self ? self->impl : null);
   TIH<Display> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Display> Window::display_Prop::operator /*0D*/-> () const
{
   SELF(Window, display);
   C(Instance) i = Window_get_display(self ? self->impl : null);
   TIH<Display> holder(i);
   return holder;
}
/*regGet*/inline Window::display_Prop::operator /*0E*/Display () const
{
   SELF(Window, display);
   C(Instance) i = Window_get_display(self ? self->impl : null);
   return Display(i);
}
/*regGet*/inline Window::display_Prop::operator /*0F*/Display* () const
{
   SELF(Window, display);
   C(Instance) i = Window_get_display(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Display *)INSTANCEL(i, i->_class) : (Display *)0;
}

// property callers: Window::displaySystem   // get only
// (normal::normal)

/*regGet*/inline Window::displaySystem_Prop::operator /*0B*/TIH<DisplaySystem> () const
{
   SELF(Window, displaySystem);
   C(Instance) i = Window_get_displaySystem(self ? self->impl : null);
   TIH<DisplaySystem> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DisplaySystem> Window::displaySystem_Prop::operator /*0D*/-> () const
{
   SELF(Window, displaySystem);
   C(Instance) i = Window_get_displaySystem(self ? self->impl : null);
   TIH<DisplaySystem> holder(i);
   return holder;
}
/*regGet*/inline Window::displaySystem_Prop::operator /*0E*/DisplaySystem () const
{
   SELF(Window, displaySystem);
   C(Instance) i = Window_get_displaySystem(self ? self->impl : null);
   return DisplaySystem(i);
}
/*regGet*/inline Window::displaySystem_Prop::operator /*0F*/DisplaySystem* () const
{
   SELF(Window, displaySystem);
   C(Instance) i = Window_get_displaySystem(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DisplaySystem *)INSTANCEL(i, i->_class) : (DisplaySystem *)0;
}

// property callers: Window::horzScroll   // get only
// (normal::normal)

/*regGet*/inline Window::horzScroll_Prop::operator /*0B*/TIH<ScrollBar> () const
{
   SELF(Window, horzScroll);
   C(Instance) i = Window_get_horzScroll(self ? self->impl : null);
   TIH<ScrollBar> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<ScrollBar> Window::horzScroll_Prop::operator /*0D*/-> () const
{
   SELF(Window, horzScroll);
   C(Instance) i = Window_get_horzScroll(self ? self->impl : null);
   TIH<ScrollBar> holder(i);
   return holder;
}
/*regGet*/inline Window::horzScroll_Prop::operator /*0E*/ScrollBar () const
{
   SELF(Window, horzScroll);
   C(Instance) i = Window_get_horzScroll(self ? self->impl : null);
   return ScrollBar(i);
}
/*regGet*/inline Window::horzScroll_Prop::operator /*0F*/ScrollBar* () const
{
   SELF(Window, horzScroll);
   C(Instance) i = Window_get_horzScroll(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (ScrollBar *)INSTANCEL(i, i->_class) : (ScrollBar *)0;
}

// property callers: Window::vertScroll   // get only
// (normal::normal)

/*regGet*/inline Window::vertScroll_Prop::operator /*0B*/TIH<ScrollBar> () const
{
   SELF(Window, vertScroll);
   C(Instance) i = Window_get_vertScroll(self ? self->impl : null);
   TIH<ScrollBar> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<ScrollBar> Window::vertScroll_Prop::operator /*0D*/-> () const
{
   SELF(Window, vertScroll);
   C(Instance) i = Window_get_vertScroll(self ? self->impl : null);
   TIH<ScrollBar> holder(i);
   return holder;
}
/*regGet*/inline Window::vertScroll_Prop::operator /*0E*/ScrollBar () const
{
   SELF(Window, vertScroll);
   C(Instance) i = Window_get_vertScroll(self ? self->impl : null);
   return ScrollBar(i);
}
/*regGet*/inline Window::vertScroll_Prop::operator /*0F*/ScrollBar* () const
{
   SELF(Window, vertScroll);
   C(Instance) i = Window_get_vertScroll(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (ScrollBar *)INSTANCEL(i, i->_class) : (ScrollBar *)0;
}

// property callers: Window::statusBar   // get only
// (normal::normal)

/*regGet*/inline Window::statusBar_Prop::operator /*0B*/TIH<StatusBar> () const
{
   SELF(Window, statusBar);
   C(Instance) i = Window_get_statusBar(self ? self->impl : null);
   TIH<StatusBar> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<StatusBar> Window::statusBar_Prop::operator /*0D*/-> () const
{
   SELF(Window, statusBar);
   C(Instance) i = Window_get_statusBar(self ? self->impl : null);
   TIH<StatusBar> holder(i);
   return holder;
}
/*regGet*/inline Window::statusBar_Prop::operator /*0E*/StatusBar () const
{
   SELF(Window, statusBar);
   C(Instance) i = Window_get_statusBar(self ? self->impl : null);
   return StatusBar(i);
}
/*regGet*/inline Window::statusBar_Prop::operator /*0F*/StatusBar* () const
{
   SELF(Window, statusBar);
   C(Instance) i = Window_get_statusBar(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (StatusBar *)INSTANCEL(i, i->_class) : (StatusBar *)0;
}

// property callers: Window::rootWindow   // get only
// (normal::normal)

/*regGet*/inline Window::rootWindow_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, rootWindow);
   C(Instance) i = Window_get_rootWindow(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::rootWindow_Prop::operator /*0D*/-> () const
{
   SELF(Window, rootWindow);
   C(Instance) i = Window_get_rootWindow(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::rootWindow_Prop::operator /*0E*/Window () const
{
   SELF(Window, rootWindow);
   C(Instance) i = Window_get_rootWindow(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::rootWindow_Prop::operator /*0F*/Window* () const
{
   SELF(Window, rootWindow);
   C(Instance) i = Window_get_rootWindow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::closing
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::closing_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, closing);
   Window_set_closing(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::closing_Prop & Window::closing_Prop::operator= (Window::closing_Prop & prop)
{
   SELF(Window, closing);
   /*0H*/bool v = prop;
   Window_set_closing(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::closing_Prop::operator /*0I*/bool () const
{
   SELF(Window, closing);
   return (bool)Window_get_closing(self ? self->impl : null);
}

// property callers: Window::documentID   // get only
// (normal::int)

/*regGet*/inline Window::documentID_Prop::operator /*0I*/int () const
{
   SELF(Window, documentID);
   return Window_get_documentID(self ? self->impl : null);
}

// property callers: Window::previous   // get only
// (normal::normal)

/*regGet*/inline Window::previous_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, previous);
   C(Instance) i = Window_get_previous(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::previous_Prop::operator /*0D*/-> () const
{
   SELF(Window, previous);
   C(Instance) i = Window_get_previous(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::previous_Prop::operator /*0E*/Window () const
{
   SELF(Window, previous);
   C(Instance) i = Window_get_previous(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::previous_Prop::operator /*0F*/Window* () const
{
   SELF(Window, previous);
   C(Instance) i = Window_get_previous(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::next   // get only
// (normal::normal)

/*regGet*/inline Window::next_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, next);
   C(Instance) i = Window_get_next(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::next_Prop::operator /*0D*/-> () const
{
   SELF(Window, next);
   C(Instance) i = Window_get_next(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::next_Prop::operator /*0E*/Window () const
{
   SELF(Window, next);
   C(Instance) i = Window_get_next(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::next_Prop::operator /*0F*/Window* () const
{
   SELF(Window, next);
   C(Instance) i = Window_get_next(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::nextSlave   // get only
// (normal::normal)

/*regGet*/inline Window::nextSlave_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Window, nextSlave);
   C(Instance) i = Window_get_nextSlave(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Window::nextSlave_Prop::operator /*0D*/-> () const
{
   SELF(Window, nextSlave);
   C(Instance) i = Window_get_nextSlave(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Window::nextSlave_Prop::operator /*0E*/Window () const
{
   SELF(Window, nextSlave);
   C(Instance) i = Window_get_nextSlave(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Window::nextSlave_Prop::operator /*0F*/Window* () const
{
   SELF(Window, nextSlave);
   C(Instance) i = Window_get_nextSlave(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Window::menuBar   // get only
// (normal::normal)

/*regGet*/inline Window::menuBar_Prop::operator /*0B*/TIH<PopupMenu> () const
{
   SELF(Window, menuBar);
   C(Instance) i = Window_get_menuBar(self ? self->impl : null);
   TIH<PopupMenu> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<PopupMenu> Window::menuBar_Prop::operator /*0D*/-> () const
{
   SELF(Window, menuBar);
   C(Instance) i = Window_get_menuBar(self ? self->impl : null);
   TIH<PopupMenu> holder(i);
   return holder;
}
/*regGet*/inline Window::menuBar_Prop::operator /*0E*/PopupMenu () const
{
   SELF(Window, menuBar);
   C(Instance) i = Window_get_menuBar(self ? self->impl : null);
   return PopupMenu(i);
}
/*regGet*/inline Window::menuBar_Prop::operator /*0F*/PopupMenu* () const
{
   SELF(Window, menuBar);
   C(Instance) i = Window_get_menuBar(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (PopupMenu *)INSTANCEL(i, i->_class) : (PopupMenu *)0;
}

// property callers: Window::sbv   // get only
// (normal::normal)

/*regGet*/inline Window::sbv_Prop::operator /*0B*/TIH<ScrollBar> () const
{
   SELF(Window, sbv);
   C(Instance) i = Window_get_sbv(self ? self->impl : null);
   TIH<ScrollBar> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<ScrollBar> Window::sbv_Prop::operator /*0D*/-> () const
{
   SELF(Window, sbv);
   C(Instance) i = Window_get_sbv(self ? self->impl : null);
   TIH<ScrollBar> holder(i);
   return holder;
}
/*regGet*/inline Window::sbv_Prop::operator /*0E*/ScrollBar () const
{
   SELF(Window, sbv);
   C(Instance) i = Window_get_sbv(self ? self->impl : null);
   return ScrollBar(i);
}
/*regGet*/inline Window::sbv_Prop::operator /*0F*/ScrollBar* () const
{
   SELF(Window, sbv);
   C(Instance) i = Window_get_sbv(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (ScrollBar *)INSTANCEL(i, i->_class) : (ScrollBar *)0;
}

// property callers: Window::sbh   // get only
// (normal::normal)

/*regGet*/inline Window::sbh_Prop::operator /*0B*/TIH<ScrollBar> () const
{
   SELF(Window, sbh);
   C(Instance) i = Window_get_sbh(self ? self->impl : null);
   TIH<ScrollBar> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<ScrollBar> Window::sbh_Prop::operator /*0D*/-> () const
{
   SELF(Window, sbh);
   C(Instance) i = Window_get_sbh(self ? self->impl : null);
   TIH<ScrollBar> holder(i);
   return holder;
}
/*regGet*/inline Window::sbh_Prop::operator /*0E*/ScrollBar () const
{
   SELF(Window, sbh);
   C(Instance) i = Window_get_sbh(self ? self->impl : null);
   return ScrollBar(i);
}
/*regGet*/inline Window::sbh_Prop::operator /*0F*/ScrollBar* () const
{
   SELF(Window, sbh);
   C(Instance) i = Window_get_sbh(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (ScrollBar *)INSTANCEL(i, i->_class) : (ScrollBar *)0;
}

// property callers: Window::fullRender
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::fullRender_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, fullRender);
   Window_set_fullRender(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::fullRender_Prop & Window::fullRender_Prop::operator= (Window::fullRender_Prop & prop)
{
   SELF(Window, fullRender);
   /*0H*/bool v = prop;
   Window_set_fullRender(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::fullRender_Prop::operator /*0I*/bool () const
{
   SELF(Window, fullRender);
   return (bool)Window_get_fullRender(self ? self->impl : null);
}

// property callers: Window::systemHandle   // get only
// (normal::void *)

/*regGet*/inline Window::systemHandle_Prop::operator /*0I*/void * () const
{
   SELF(Window, systemHandle);
   return Window_get_systemHandle(self ? self->impl : null);
}

// property callers: Window::minimizeButton   // get only
// (normal::normal)

/*regGet*/inline Window::minimizeButton_Prop::operator /*0B*/TIH<Button> () const
{
   SELF(Window, minimizeButton);
   C(Instance) i = Window_get_minimizeButton(self ? self->impl : null);
   TIH<Button> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Button> Window::minimizeButton_Prop::operator /*0D*/-> () const
{
   SELF(Window, minimizeButton);
   C(Instance) i = Window_get_minimizeButton(self ? self->impl : null);
   TIH<Button> holder(i);
   return holder;
}
/*regGet*/inline Window::minimizeButton_Prop::operator /*0E*/Button () const
{
   SELF(Window, minimizeButton);
   C(Instance) i = Window_get_minimizeButton(self ? self->impl : null);
   return Button(i);
}
/*regGet*/inline Window::minimizeButton_Prop::operator /*0F*/Button* () const
{
   SELF(Window, minimizeButton);
   C(Instance) i = Window_get_minimizeButton(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Button *)INSTANCEL(i, i->_class) : (Button *)0;
}

// property callers: Window::maximizeButton   // get only
// (normal::normal)

/*regGet*/inline Window::maximizeButton_Prop::operator /*0B*/TIH<Button> () const
{
   SELF(Window, maximizeButton);
   C(Instance) i = Window_get_maximizeButton(self ? self->impl : null);
   TIH<Button> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Button> Window::maximizeButton_Prop::operator /*0D*/-> () const
{
   SELF(Window, maximizeButton);
   C(Instance) i = Window_get_maximizeButton(self ? self->impl : null);
   TIH<Button> holder(i);
   return holder;
}
/*regGet*/inline Window::maximizeButton_Prop::operator /*0E*/Button () const
{
   SELF(Window, maximizeButton);
   C(Instance) i = Window_get_maximizeButton(self ? self->impl : null);
   return Button(i);
}
/*regGet*/inline Window::maximizeButton_Prop::operator /*0F*/Button* () const
{
   SELF(Window, maximizeButton);
   C(Instance) i = Window_get_maximizeButton(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Button *)INSTANCEL(i, i->_class) : (Button *)0;
}

// property callers: Window::closeButton   // get only
// (normal::normal)

/*regGet*/inline Window::closeButton_Prop::operator /*0B*/TIH<Button> () const
{
   SELF(Window, closeButton);
   C(Instance) i = Window_get_closeButton(self ? self->impl : null);
   TIH<Button> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Button> Window::closeButton_Prop::operator /*0D*/-> () const
{
   SELF(Window, closeButton);
   C(Instance) i = Window_get_closeButton(self ? self->impl : null);
   TIH<Button> holder(i);
   return holder;
}
/*regGet*/inline Window::closeButton_Prop::operator /*0E*/Button () const
{
   SELF(Window, closeButton);
   C(Instance) i = Window_get_closeButton(self ? self->impl : null);
   return Button(i);
}
/*regGet*/inline Window::closeButton_Prop::operator /*0F*/Button* () const
{
   SELF(Window, closeButton);
   C(Instance) i = Window_get_closeButton(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Button *)INSTANCEL(i, i->_class) : (Button *)0;
}

// property callers: Window::icon
// (normal::normal)

/*nstSet*/inline /*0A*/const BitmapResource & Window::icon_Prop::operator= (/*0A*/const BitmapResource & v)
{
   SELF(Window, icon);
   Window_set_icon(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Window::icon_Prop & Window::icon_Prop::operator= (Window::icon_Prop & prop)
{
   SELF(Window, icon);
   /*0A*/const BitmapResource & v = prop;
   Window_set_icon(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const BitmapResource * Window::icon_Prop::operator= (/*0C*/const BitmapResource * v)
{
   SELF(Window, icon);
   Window_set_icon(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Window::icon_Prop::operator /*0B*/TIH<BitmapResource> () const
{
   SELF(Window, icon);
   C(Instance) i = Window_get_icon(self ? self->impl : null);
   TIH<BitmapResource> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<BitmapResource> Window::icon_Prop::operator /*0D*/-> () const
{
   SELF(Window, icon);
   C(Instance) i = Window_get_icon(self ? self->impl : null);
   TIH<BitmapResource> holder(i);
   return holder;
}
/*regGet*/inline Window::icon_Prop::operator /*0E*/BitmapResource () const
{
   SELF(Window, icon);
   C(Instance) i = Window_get_icon(self ? self->impl : null);
   return BitmapResource(i);
}
/*regGet*/inline Window::icon_Prop::operator /*0F*/BitmapResource* () const
{
   SELF(Window, icon);
   C(Instance) i = Window_get_icon(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (BitmapResource *)INSTANCEL(i, i->_class) : (BitmapResource *)0;
}

// property callers: Window::moveable
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::moveable_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, moveable);
   Window_set_moveable(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::moveable_Prop & Window::moveable_Prop::operator= (Window::moveable_Prop & prop)
{
   SELF(Window, moveable);
   /*0H*/bool v = prop;
   Window_set_moveable(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::moveable_Prop::operator /*0I*/bool () const
{
   SELF(Window, moveable);
   return (bool)Window_get_moveable(self ? self->impl : null);
}

// property callers: Window::alphaBlend
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::alphaBlend_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, alphaBlend);
   Window_set_alphaBlend(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::alphaBlend_Prop & Window::alphaBlend_Prop::operator= (Window::alphaBlend_Prop & prop)
{
   SELF(Window, alphaBlend);
   /*0H*/bool v = prop;
   Window_set_alphaBlend(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::alphaBlend_Prop::operator /*0I*/bool () const
{
   SELF(Window, alphaBlend);
   return (bool)Window_get_alphaBlend(self ? self->impl : null);
}

// property callers: Window::useSharedMemory
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::useSharedMemory_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, useSharedMemory);
   Window_set_useSharedMemory(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::useSharedMemory_Prop & Window::useSharedMemory_Prop::operator= (Window::useSharedMemory_Prop & prop)
{
   SELF(Window, useSharedMemory);
   /*0H*/bool v = prop;
   Window_set_useSharedMemory(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::useSharedMemory_Prop::operator /*0I*/bool () const
{
   SELF(Window, useSharedMemory);
   return (bool)Window_get_useSharedMemory(self ? self->impl : null);
}

// property callers: Window::glCapabilities
// (normal::bits|uint)

/*nstSet*/inline /*0H*/GLCapabilities Window::glCapabilities_Prop::operator= (/*0H*/GLCapabilities v)
{
   SELF(Window, glCapabilities);
   Window_set_glCapabilities(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::glCapabilities_Prop & Window::glCapabilities_Prop::operator= (Window::glCapabilities_Prop & prop)
{
   SELF(Window, glCapabilities);
   /*0H*/GLCapabilities v = prop;
   Window_set_glCapabilities(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::glCapabilities_Prop::operator /*0I*/GLCapabilities () const
{
   SELF(Window, glCapabilities);
   return Window_get_glCapabilities(self ? self->impl : null);
}

// property callers: Window::creationActivation
// (normal::enum|int)

/*nstSet*/inline /*0H*/CreationActivationOption Window::creationActivation_Prop::operator= (/*0H*/CreationActivationOption v)
{
   SELF(Window, creationActivation);
   Window_set_creationActivation(self ? self->impl : null, (C(CreationActivationOption))v);
   return v;
}

/*regSet*/inline Window::creationActivation_Prop & Window::creationActivation_Prop::operator= (Window::creationActivation_Prop & prop)
{
   SELF(Window, creationActivation);
   /*0H*/CreationActivationOption v = prop;
   Window_set_creationActivation(self ? self->impl : null, (C(CreationActivationOption))v);
   return prop;
}
/*regGet*/inline Window::creationActivation_Prop::operator /*0I*/CreationActivationOption () const
{
   SELF(Window, creationActivation);
   return (CreationActivationOption)Window_get_creationActivation(self ? self->impl : null);
}

// property callers: Window::nativeDecorations
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::nativeDecorations_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, nativeDecorations);
   Window_set_nativeDecorations(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::nativeDecorations_Prop & Window::nativeDecorations_Prop::operator= (Window::nativeDecorations_Prop & prop)
{
   SELF(Window, nativeDecorations);
   /*0H*/bool v = prop;
   Window_set_nativeDecorations(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::nativeDecorations_Prop::operator /*0I*/bool () const
{
   SELF(Window, nativeDecorations);
   return (bool)Window_get_nativeDecorations(self ? self->impl : null);
}

// property callers: Window::manageDisplay
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::manageDisplay_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, manageDisplay);
   Window_set_manageDisplay(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::manageDisplay_Prop & Window::manageDisplay_Prop::operator= (Window::manageDisplay_Prop & prop)
{
   SELF(Window, manageDisplay);
   /*0H*/bool v = prop;
   Window_set_manageDisplay(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::manageDisplay_Prop::operator /*0I*/bool () const
{
   SELF(Window, manageDisplay);
   return (bool)Window_get_manageDisplay(self ? self->impl : null);
}

// property callers: Window::text
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * Window::text_Prop::operator= (/*0H*/const char * v)
{
   SELF(Window, text);
   Window_set_text(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Window::text_Prop & Window::text_Prop::operator= (Window::text_Prop & prop)
{
   SELF(Window, text);
   /*0H*/const char * v = prop;
   Window_set_text(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Window::text_Prop::operator /*0I*/const char * () const
{
   SELF(Window, text);
   return Window_get_text(self ? self->impl : null);
}

// property callers: Window::controller
// (normal::normal)

/*nstSet*/inline /*0A*/const WindowController & Window::controller_Prop::operator= (/*0A*/const WindowController & v)
{
   SELF(Window, controller);
   Window_set_controller(self ? self->impl : null, ((Instance *)&v)->impl);
   return v;
}

/*regSet*/inline Window::controller_Prop & Window::controller_Prop::operator= (Window::controller_Prop & prop)
{
   SELF(Window, controller);
   /*0A*/const WindowController * v = prop;
   Window_set_controller(self ? self->impl : null, ((Instance *)v)->impl);
   return prop;
}
/*nstSet*/inline /*0C*/const WindowController * Window::controller_Prop::operator= (/*0C*/const WindowController * v)
{
   SELF(Window, controller);
   Window_set_controller(self ? self->impl : null, v ? ((Instance *)v)->impl : null);
   return v;
}

/*regGet*/inline Window::controller_Prop::operator /*0F*/WindowController* () const
{
   SELF(Window, controller);
   C(Instance) i = Window_get_controller(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (WindowController *)INSTANCEL(i, i->_class) : (WindowController *)0;
}

// property callers: Window::noConsequential
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Window::noConsequential_Prop::operator= (/*0H*/bool v)
{
   SELF(Window, noConsequential);
   Window_set_noConsequential(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Window::noConsequential_Prop & Window::noConsequential_Prop::operator= (Window::noConsequential_Prop & prop)
{
   SELF(Window, noConsequential);
   /*0H*/bool v = prop;
   Window_set_noConsequential(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Window::noConsequential_Prop::operator /*0I*/bool () const
{
   SELF(Window, noConsequential);
   return (bool)Window_get_noConsequential(self ? self->impl : null);
}

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onCreate_Functor::FunctionType TWindowController <TP_V>::WindowController_onCreate_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onCreate);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onCreate_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onCreate_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onCreate_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onCreate)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onCreate_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller)
{
   TSELF(WindowController, (<TP_V>), onCreate);
   return (bool)WindowController_onCreate(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl);
}
// inline void WindowController::register_onCreate(CPPClass & cl, WindowController::WindowController_onCreate_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onCreate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onCreate)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onKeyDown_Functor::FunctionType TWindowController <TP_V>::WindowController_onKeyDown_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onKeyDown);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onKeyDown_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onKeyDown_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onKeyDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onKeyDown)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onKeyDown_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   TSELF(WindowController, (<TP_V>), onKeyDown);
   return (bool)WindowController_onKeyDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void WindowController::register_onKeyDown(CPPClass & cl, WindowController::WindowController_onKeyDown_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onKeyDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onKeyDown)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onKeyHit_Functor::FunctionType TWindowController <TP_V>::WindowController_onKeyHit_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onKeyHit);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onKeyHit_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onKeyHit_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onKeyHit_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onKeyHit)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onKeyHit_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   TSELF(WindowController, (<TP_V>), onKeyHit);
   return (bool)WindowController_onKeyHit(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void WindowController::register_onKeyHit(CPPClass & cl, WindowController::WindowController_onKeyHit_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onKeyHit_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onKeyHit)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onKeyUp_Functor::FunctionType TWindowController <TP_V>::WindowController_onKeyUp_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onKeyUp);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onKeyUp_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onKeyUp_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onKeyUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onKeyUp)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onKeyUp_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   TSELF(WindowController, (<TP_V>), onKeyUp);
   return (bool)WindowController_onKeyUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void WindowController::register_onKeyUp(CPPClass & cl, WindowController::WindowController_onKeyUp_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onKeyUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onKeyUp)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onLeftButtonDown_Functor::FunctionType TWindowController <TP_V>::WindowController_onLeftButtonDown_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onLeftButtonDown);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onLeftButtonDown_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onLeftButtonDown_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onLeftButtonDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onLeftButtonDown)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onLeftButtonDown_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onLeftButtonDown);
   return (bool)WindowController_onLeftButtonDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onLeftButtonDown(CPPClass & cl, WindowController::WindowController_onLeftButtonDown_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onLeftButtonDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onLeftButtonDown)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onLeftButtonUp_Functor::FunctionType TWindowController <TP_V>::WindowController_onLeftButtonUp_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onLeftButtonUp);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onLeftButtonUp_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onLeftButtonUp_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onLeftButtonUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onLeftButtonUp)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onLeftButtonUp_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onLeftButtonUp);
   return (bool)WindowController_onLeftButtonUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onLeftButtonUp(CPPClass & cl, WindowController::WindowController_onLeftButtonUp_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onLeftButtonUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onLeftButtonUp)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onLeftDoubleClick_Functor::FunctionType TWindowController <TP_V>::WindowController_onLeftDoubleClick_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onLeftDoubleClick);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onLeftDoubleClick_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onLeftDoubleClick_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onLeftDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onLeftDoubleClick)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onLeftDoubleClick_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onLeftDoubleClick);
   return (bool)WindowController_onLeftDoubleClick(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onLeftDoubleClick(CPPClass & cl, WindowController::WindowController_onLeftDoubleClick_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onLeftDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onLeftDoubleClick)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onLoadGraphics_Functor::FunctionType TWindowController <TP_V>::WindowController_onLoadGraphics_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onLoadGraphics);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onLoadGraphics_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onLoadGraphics_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onLoadGraphics_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onLoadGraphics)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onLoadGraphics_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller)
{
   TSELF(WindowController, (<TP_V>), onLoadGraphics);
   return (bool)WindowController_onLoadGraphics(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl);
}
// inline void WindowController::register_onLoadGraphics(CPPClass & cl, WindowController::WindowController_onLoadGraphics_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onLoadGraphics_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onLoadGraphics)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onMiddleButtonDown_Functor::FunctionType TWindowController <TP_V>::WindowController_onMiddleButtonDown_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onMiddleButtonDown);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onMiddleButtonDown_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onMiddleButtonDown_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onMiddleButtonDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onMiddleButtonDown)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onMiddleButtonDown_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onMiddleButtonDown);
   return (bool)WindowController_onMiddleButtonDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onMiddleButtonDown(CPPClass & cl, WindowController::WindowController_onMiddleButtonDown_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onMiddleButtonDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onMiddleButtonDown)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onMiddleButtonUp_Functor::FunctionType TWindowController <TP_V>::WindowController_onMiddleButtonUp_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onMiddleButtonUp);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onMiddleButtonUp_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onMiddleButtonUp_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onMiddleButtonUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onMiddleButtonUp)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onMiddleButtonUp_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onMiddleButtonUp);
   return (bool)WindowController_onMiddleButtonUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onMiddleButtonUp(CPPClass & cl, WindowController::WindowController_onMiddleButtonUp_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onMiddleButtonUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onMiddleButtonUp)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onMiddleDoubleClick_Functor::FunctionType TWindowController <TP_V>::WindowController_onMiddleDoubleClick_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onMiddleDoubleClick);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onMiddleDoubleClick_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onMiddleDoubleClick_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onMiddleDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onMiddleDoubleClick)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onMiddleDoubleClick_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onMiddleDoubleClick);
   return (bool)WindowController_onMiddleDoubleClick(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onMiddleDoubleClick(CPPClass & cl, WindowController::WindowController_onMiddleDoubleClick_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onMiddleDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onMiddleDoubleClick)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onMouseMove_Functor::FunctionType TWindowController <TP_V>::WindowController_onMouseMove_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onMouseMove);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onMouseMove_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onMouseMove_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onMouseMove_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onMouseMove)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onMouseMove_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onMouseMove);
   return (bool)WindowController_onMouseMove(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onMouseMove(CPPClass & cl, WindowController::WindowController_onMouseMove_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onMouseMove_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onMouseMove)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onMultiTouch_Functor::FunctionType TWindowController <TP_V>::WindowController_onMultiTouch_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onMultiTouch);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onMultiTouch_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onMultiTouch_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onMultiTouch_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onMultiTouch)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onMultiTouch_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/TouchPointerEvent event, /*6Fj*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onMultiTouch);
   return (bool)WindowController_onMultiTouch(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/(C(TouchPointerEvent))event, /*7Al*/((Instance&)infos).impl, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onMultiTouch(CPPClass & cl, WindowController::WindowController_onMultiTouch_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onMultiTouch_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onMultiTouch)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onRedraw_Functor::FunctionType TWindowController <TP_V>::WindowController_onRedraw_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onRedraw);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onRedraw_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onRedraw_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onRedraw_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onRedraw)] = func;
   return func;
}
template <typename TP_V>
inline void TWindowController <TP_V>::WindowController_onRedraw_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/Surface & surface)
{
   TSELF(WindowController, (<TP_V>), onRedraw);
   WindowController_onRedraw(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/surface.impl);
}
// inline void WindowController::register_onRedraw(CPPClass & cl, WindowController::WindowController_onRedraw_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onRedraw_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onRedraw)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onResize_Functor::FunctionType TWindowController <TP_V>::WindowController_onResize_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onResize);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onResize_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onResize_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onResize_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onResize)] = func;
   return func;
}
template <typename TP_V>
inline void TWindowController <TP_V>::WindowController_onResize_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int width, /*6Fj*/int height)
{
   TSELF(WindowController, (<TP_V>), onResize);
   WindowController_onResize(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/width, /*7Al*/height);
}
// inline void WindowController::register_onResize(CPPClass & cl, WindowController::WindowController_onResize_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onResize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onResize)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onRightButtonDown_Functor::FunctionType TWindowController <TP_V>::WindowController_onRightButtonDown_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onRightButtonDown);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onRightButtonDown_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onRightButtonDown_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onRightButtonDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onRightButtonDown)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onRightButtonDown_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onRightButtonDown);
   return (bool)WindowController_onRightButtonDown(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onRightButtonDown(CPPClass & cl, WindowController::WindowController_onRightButtonDown_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onRightButtonDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onRightButtonDown)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onRightButtonUp_Functor::FunctionType TWindowController <TP_V>::WindowController_onRightButtonUp_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onRightButtonUp);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onRightButtonUp_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onRightButtonUp_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onRightButtonUp_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onRightButtonUp)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onRightButtonUp_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onRightButtonUp);
   return (bool)WindowController_onRightButtonUp(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onRightButtonUp(CPPClass & cl, WindowController::WindowController_onRightButtonUp_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onRightButtonUp_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onRightButtonUp)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onRightDoubleClick_Functor::FunctionType TWindowController <TP_V>::WindowController_onRightDoubleClick_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onRightDoubleClick);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onRightDoubleClick_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onRightDoubleClick_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onRightDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onRightDoubleClick)] = func;
   return func;
}
template <typename TP_V>
inline bool TWindowController <TP_V>::WindowController_onRightDoubleClick_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   TSELF(WindowController, (<TP_V>), onRightDoubleClick);
   return (bool)WindowController_onRightDoubleClick(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void WindowController::register_onRightDoubleClick(CPPClass & cl, WindowController::WindowController_onRightDoubleClick_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onRightDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onRightDoubleClick)] = func;
// }

template <typename TP_V>
inline typename TWindowController <TP_V>::WindowController_onUnloadGraphics_Functor::FunctionType TWindowController <TP_V>::WindowController_onUnloadGraphics_Functor::operator= (FunctionType func)
{
   TSELF(WindowController, (<TP_V>), onUnloadGraphics);
   if(self->vTbl == TWindowController <TP_V>::_cpp_class.vTbl)
   {
      uint size = TWindowController <TP_V>::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())eC_new(sizeof(TWindowController <TP_V>::WindowController_onUnloadGraphics_Functor::FunctionType) * size);
      memcpy(self->vTbl, TWindowController <TP_V>::_cpp_class.vTbl, sizeof(TWindowController <TP_V>::WindowController_onUnloadGraphics_Functor::FunctionType) * size);
   }
   ((TWindowController <TP_V>::WindowController_onUnloadGraphics_Functor::FunctionType *)self->vTbl)[M_VTBLID(WindowController, onUnloadGraphics)] = func;
   return func;
}
template <typename TP_V>
inline void TWindowController <TP_V>::WindowController_onUnloadGraphics_Functor::operator()( /*6Fj*/TP_V & v, /*6Fj*/TWindowController & controller)
{
   TSELF(WindowController, (<TP_V>), onUnloadGraphics);
   WindowController_onUnloadGraphics(self ? self->impl : (C(WindowController))null, /*7Al*/((Instance&)controller).impl);
}
// inline void WindowController::register_onUnloadGraphics(CPPClass & cl, WindowController::WindowController_onUnloadGraphics_Functor::FunctionType func)
// {
//    ((WindowController::WindowController_onUnloadGraphics_Functor::FunctionType *)cl.vTbl)[M_VTBLID(WindowController, onUnloadGraphics)] = func;
// }

template <typename TP_V> TCPPClass<TWindowController<TP_V>> TWindowController<TP_V>::_cpp_class;

template <typename TP_V> void TWindowController<TP_V>::class_registration(CPPClass & _cpp_class)
{

      addMethod(_cpp_class.impl, "OnCreate", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onCreate);
         typename WindowController_onCreate_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onCreate_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onCreate)]);
            if(method) return method (v, controller);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnKeyDown", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onKeyDown);
         typename WindowController_onKeyDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onKeyDown_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onKeyDown)]);
            if(method) return method (v, controller, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnKeyHit", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onKeyHit);
         typename WindowController_onKeyHit_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onKeyHit_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onKeyHit)]);
            if(method) return method (v, controller, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnKeyUp", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Key) key, /*1Aa*/unichar ch)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onKeyUp);
         typename WindowController_onKeyUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onKeyUp_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Hd*/(Key)key, /*3Kd*/ch); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Key) key, /*1Aa*/unichar ch))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onKeyUp)]);
            if(method) return method (v, controller, key, ch);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLeftButtonDown", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onLeftButtonDown);
         typename WindowController_onLeftButtonDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onLeftButtonDown_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onLeftButtonDown)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLeftButtonUp", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onLeftButtonUp);
         typename WindowController_onLeftButtonUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onLeftButtonUp_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onLeftButtonUp)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLeftDoubleClick", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onLeftDoubleClick);
         typename WindowController_onLeftDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onLeftDoubleClick_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onLeftDoubleClick)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnLoadGraphics", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onLoadGraphics);
         typename WindowController_onLoadGraphics_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onLoadGraphics_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onLoadGraphics)]);
            if(method) return method (v, controller);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMiddleButtonDown", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onMiddleButtonDown);
         typename WindowController_onMiddleButtonDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onMiddleButtonDown_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onMiddleButtonDown)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMiddleButtonUp", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onMiddleButtonUp);
         typename WindowController_onMiddleButtonUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onMiddleButtonUp_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onMiddleButtonUp)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMiddleDoubleClick", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onMiddleDoubleClick);
         typename WindowController_onMiddleDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onMiddleDoubleClick_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onMiddleDoubleClick)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMouseMove", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onMouseMove);
         typename WindowController_onMouseMove_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onMouseMove_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onMouseMove)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnMultiTouch", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(TouchPointerEvent) event, /*1Aa*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onMultiTouch);
         typename WindowController_onMultiTouch_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onMultiTouch_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); /*2Bg*/TIH<TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo>> infos_l(infos); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Hd*/(TouchPointerEvent)event, /*3Bd*/*infos_l, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(TouchPointerEvent) event, /*1Aa*/TArray<TouchPointerInfo _ARG int _ARG TouchPointerInfo> & infos, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onMultiTouch)]);
            if(method) return method (v, controller, event, infos, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnRedraw", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Surface) surface)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onRedraw);
         typename WindowController_onRedraw_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onRedraw_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); /*2Bg*/TIH<Surface> surface_l(surface); fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Bd*/*surface_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/C(Surface) surface))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onRedraw)]);
            if(method) return method (v, controller, surface);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnResize", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int width, /*1Aa*/int height)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onResize);
         typename WindowController_onResize_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onResize_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/width, /*3Kd*/height);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int width, /*1Aa*/int height))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onResize)]);
            if(method) return method (v, controller, width, height);
         }
         return ;
      });


      addMethod(_cpp_class.impl, "OnRightButtonDown", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onRightButtonDown);
         typename WindowController_onRightButtonDown_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onRightButtonDown_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onRightButtonDown)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnRightButtonUp", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onRightButtonUp);
         typename WindowController_onRightButtonUp_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onRightButtonUp_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onRightButtonUp)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnRightDoubleClick", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onRightDoubleClick);
         typename WindowController_onRightDoubleClick_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onRightDoubleClick_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); C(bool) ret = (C(bool))fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l, /*3Kd*/x, /*3Kd*/y, /*3Hd*/(Modifiers)mods); return ret;
         }
         // 'cp2' is empty
         else
         {
            auto method = ((C(bool) (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller, /*1Aa*/int x, /*1Aa*/int y, /*1Aa*/C(Modifiers) mods))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onRightDoubleClick)]);
            if(method) return method (v, controller, x, y, mods);
         }
         return (C(bool))1;
      });


      addMethod(_cpp_class.impl, "OnUnloadGraphics", (void *) +[](/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller)
      {
         XClass * cl = (controller) ? (XClass *)(controller)->_class : null;
         // 'cp1' is empty
         TWindowController <TP_V> * i = (controller) ? (TWindowController <TP_V> *)INSTANCEL(controller, cl) : null;
         int vid = M_VTBLID(WindowController, onUnloadGraphics);
         typename WindowController_onUnloadGraphics_Functor::FunctionType fn;
         if(i && i->vTbl && i->vTbl[vid])
         {
            fn = (typename WindowController_onUnloadGraphics_Functor::FunctionType) i->vTbl[vid];
            /*2Ag*/TIH<TP_V> v__holder(fromTA<C(Instance)>(v)); /*2Bg*/TIH<TWindowController<TP_V>> controller_l(controller); fn(*i, /*3Ad*/*v__holder, /*3Bd*/*controller_l);
         }
         // 'cp2' is empty
         else
         {
            auto method = ((void (*) (/*1Aa*/TP(WindowController, V) v, /*1Aa*/C(WindowController) controller))(CO(WindowController)->_vTbl)[M_VTBLID(WindowController, onUnloadGraphics)]);
            if(method) return method (v, controller);
         }
         return ;
      });


}


// property callers: WindowController::window   // get only
// (normal::normal)

/*regGet*/template <typename TP_V> inline TWindowController<TP_V> ::window_Prop::operator /*0B*/TIH<Window> () const
{
   TSELF(WindowController, (<TP_V>), window);
   C(Instance) i = WindowController_get_window(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/template <typename TP_V> inline TIH<Window> TWindowController<TP_V> ::window_Prop::operator /*0D*/-> () const
{
   TSELF(WindowController, (<TP_V>), window);
   C(Instance) i = WindowController_get_window(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/template <typename TP_V> inline TWindowController<TP_V> ::window_Prop::operator /*0E*/Window () const
{
   TSELF(WindowController, (<TP_V>), window);
   C(Instance) i = WindowController_get_window(self ? self->impl : null);
   return Window(i);
}
/*regGet*/template <typename TP_V> inline TWindowController<TP_V> ::window_Prop::operator /*0F*/Window* () const
{
   TSELF(WindowController, (<TP_V>), window);
   C(Instance) i = WindowController_get_window(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: WindowController::controlled
// (normal::V)

/*nstSet*/template <typename TP_V> inline /*0A*/const TP_V & TWindowController<TP_V> ::controlled_Prop::operator= (/*0A*/const TP_V & v)
{
   TSELF(WindowController, (<TP_V>), controlled);
   WindowController_set_controlled(self ? self->impl : null, toTA(v));
   return v;
}

/*regSet*/template <typename TP_V> inline typename TWindowController<TP_V>::controlled_Prop & TWindowController<TP_V>::controlled_Prop::operator= (TWindowController<TP_V>::controlled_Prop & prop)
{
   TSELF(WindowController, (<TP_V>), controlled);
   /*0A*/const TP_V & v = prop;
   WindowController_set_controlled(self ? self->impl : null, toTA(v));
   return prop;
}
/*nstSet*/template <typename TP_V> inline /*0C*/const TP_V * TWindowController<TP_V> ::controlled_Prop::operator= (/*0C*/const TP_V * v)
{
   TSELF(WindowController, (<TP_V>), controlled);
   WindowController_set_controlled(self ? self->impl : null, toTA(v));
   return v;
}

/*regGet*/template <typename TP_V> inline TWindowController<TP_V> ::controlled_Prop::operator /*0B*/TIH<TP_V> () const
{
   TSELF(WindowController, (<TP_V>), controlled);
   return *TIH<TP_V>(fromTA<C(Instance)>(WindowController_get_controlled(self ? self->impl : null)));
}
/*regGet*/template <typename TP_V> inline TIH<TP_V> TWindowController<TP_V> ::controlled_Prop::operator /*0D*/-> () const
{
   TSELF(WindowController, (<TP_V>), controlled);
   return TIH<TP_V>(fromTA<C(Instance)>(WindowController_get_controlled(self ? self->impl : null)));
}
/*regGet*/template <typename TP_V> inline TWindowController<TP_V> ::controlled_Prop::operator /*0E*/TP_V () const
{
   TSELF(WindowController, (<TP_V>), controlled);
   return fromTA<TP_V>(WindowController_get_controlled(self ? self->impl : null));
}
/*regGet*/template <typename TP_V> inline TWindowController<TP_V> ::controlled_Prop::operator /*0F*/TP_V* () const
{
   TSELF(WindowController, (<TP_V>), controlled);
   return fromTA<TP_V *>(WindowController_get_controlled(self ? self->impl : null));
}

////////////////////////////////////////// [ecere]/ecere::gui::controls //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////



inline void BufferLocation::adjustAdd(/*1Ab*/BufferLocation & start, /*1Ab*/BufferLocation & end)
{
   BufferLocation_adjustAdd(&impl, /*5De*/&start.impl, /*5De*/&end.impl);
}
inline void BufferLocation::adjustAdd(/*1Ac*/BufferLocation * start, /*1Ac*/BufferLocation * end)
{
   BufferLocation_adjustAdd(&impl, /*5Cf*/(C(BufferLocation) *)start, /*5Cf*/(C(BufferLocation) *)end);
}
inline void BufferLocation::adjustDelete(/*1Ab*/BufferLocation & start, /*1Ab*/BufferLocation & end)
{
   BufferLocation_adjustDelete(&impl, /*5De*/&start.impl, /*5De*/&end.impl);
}
inline void BufferLocation::adjustDelete(/*1Ac*/BufferLocation * start, /*1Ac*/BufferLocation * end)
{
   BufferLocation_adjustDelete(&impl, /*5Cf*/(C(BufferLocation) *)start, /*5Cf*/(C(BufferLocation) *)end);
}


// member accessors: BufferLocation::line
// (struct::nohead)

/*nstSet*/inline /*0H*/EditLine BufferLocation::line_Prop::operator= (/*0H*/EditLine & v)
{
   SELF(BufferLocation, line);
   self->impl.line = v.impl;
   return v;
}

/*regSet*/inline BufferLocation::line_Prop & BufferLocation::line_Prop::operator= (BufferLocation::line_Prop & prop)
{
   SELF(BufferLocation, line);
   /*0H*/EditLine v = prop;
   self->impl.line = v.impl;
   return prop;
}
/*regGet*/inline BufferLocation::line_Prop::operator /*0I*/EditLine () const
{
   SELF(BufferLocation, line);
   EditLine value(((C(BufferLocation) *)&self->impl)->line);
   return value;
}

// member accessors: BufferLocation::y
// (struct::int)

/*nstSet*/inline /*0H*/int BufferLocation::y_Prop::operator= (/*0H*/int v)
{
   SELF(BufferLocation, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline BufferLocation::y_Prop & BufferLocation::y_Prop::operator= (BufferLocation::y_Prop & prop)
{
   SELF(BufferLocation, y);
   /*0H*/int v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline BufferLocation::y_Prop::operator /*0I*/int () const
{
   SELF(BufferLocation, y);
   return self ? ((C(BufferLocation) *)&self->impl)->y : 0;
}

// member accessors: BufferLocation::x
// (struct::int)

/*nstSet*/inline /*0H*/int BufferLocation::x_Prop::operator= (/*0H*/int v)
{
   SELF(BufferLocation, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline BufferLocation::x_Prop & BufferLocation::x_Prop::operator= (BufferLocation::x_Prop & prop)
{
   SELF(BufferLocation, x);
   /*0H*/int v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline BufferLocation::x_Prop::operator /*0I*/int () const
{
   SELF(BufferLocation, x);
   return self ? ((C(BufferLocation) *)&self->impl)->x : 0;
}

inline Button::Button(Percentage opacity, bool drawBehind = (bool)0, bool isRadio = (bool)0, bool isCheckbox = (bool)0, bool bevel = (bool)0, bool bevelOver = (bool)0, bool toggle = (bool)0, bool checked = (bool)0, Alignment alignment = (Alignment)0) : Button()
{
   this->opacity = opacity.impl;
   this->drawBehind = drawBehind;
   this->isRadio = isRadio;
   this->isCheckbox = isCheckbox;
   this->bevel = bevel;
   this->bevelOver = bevelOver;
   this->toggle = toggle;
   this->checked = checked;
   this->alignment = alignment;
}

inline Button::Button_notifyClicked_Functor::FunctionType Button::Button_notifyClicked_Functor::operator= (FunctionType func)
{
   SELF(Button, notifyClicked);
   if(self->vTbl == Button::_cpp_class.vTbl)
   {
      uint size = Button::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Button::Button_notifyClicked_Functor::FunctionType, size);
      memcpy(self->vTbl, Button::_cpp_class.vTbl, sizeof(Button::Button_notifyClicked_Functor::FunctionType) * size);
   }
   ((Button::Button_notifyClicked_Functor::FunctionType *)self->vTbl)[M_VTBLID(Button, notifyClicked)] = func;
   return func;
}
inline bool Button::Button_notifyClicked_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Button, notifyClicked);
   return (bool)Button_notifyClicked(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Button::register_notifyClicked(CPPClass & cl, Button::Button_notifyClicked_Functor::FunctionType func)
// {
//    ((Button::Button_notifyClicked_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Button, notifyClicked)] = func;
// }

inline Button::Button_notifyDoubleClick_Functor::FunctionType Button::Button_notifyDoubleClick_Functor::operator= (FunctionType func)
{
   SELF(Button, notifyDoubleClick);
   if(self->vTbl == Button::_cpp_class.vTbl)
   {
      uint size = Button::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Button::Button_notifyDoubleClick_Functor::FunctionType, size);
      memcpy(self->vTbl, Button::_cpp_class.vTbl, sizeof(Button::Button_notifyDoubleClick_Functor::FunctionType) * size);
   }
   ((Button::Button_notifyDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(Button, notifyDoubleClick)] = func;
   return func;
}
inline bool Button::Button_notifyDoubleClick_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Button, notifyDoubleClick);
   return (bool)Button_notifyDoubleClick(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Button::register_notifyDoubleClick(CPPClass & cl, Button::Button_notifyDoubleClick_Functor::FunctionType func)
// {
//    ((Button::Button_notifyDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Button, notifyDoubleClick)] = func;
// }

inline Button::Button_notifyMouseLeave_Functor::FunctionType Button::Button_notifyMouseLeave_Functor::operator= (FunctionType func)
{
   SELF(Button, notifyMouseLeave);
   if(self->vTbl == Button::_cpp_class.vTbl)
   {
      uint size = Button::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Button::Button_notifyMouseLeave_Functor::FunctionType, size);
      memcpy(self->vTbl, Button::_cpp_class.vTbl, sizeof(Button::Button_notifyMouseLeave_Functor::FunctionType) * size);
   }
   ((Button::Button_notifyMouseLeave_Functor::FunctionType *)self->vTbl)[M_VTBLID(Button, notifyMouseLeave)] = func;
   return func;
}
inline bool Button::Button_notifyMouseLeave_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/Modifiers mods)
{
   SELF(Button, notifyMouseLeave);
   return (bool)Button_notifyMouseLeave(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void Button::register_notifyMouseLeave(CPPClass & cl, Button::Button_notifyMouseLeave_Functor::FunctionType func)
// {
//    ((Button::Button_notifyMouseLeave_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Button, notifyMouseLeave)] = func;
// }

inline Button::Button_notifyMouseMove_Functor::FunctionType Button::Button_notifyMouseMove_Functor::operator= (FunctionType func)
{
   SELF(Button, notifyMouseMove);
   if(self->vTbl == Button::_cpp_class.vTbl)
   {
      uint size = Button::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Button::Button_notifyMouseMove_Functor::FunctionType, size);
      memcpy(self->vTbl, Button::_cpp_class.vTbl, sizeof(Button::Button_notifyMouseMove_Functor::FunctionType) * size);
   }
   ((Button::Button_notifyMouseMove_Functor::FunctionType *)self->vTbl)[M_VTBLID(Button, notifyMouseMove)] = func;
   return func;
}
inline bool Button::Button_notifyMouseMove_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Button, notifyMouseMove);
   return (bool)Button_notifyMouseMove(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Button::register_notifyMouseMove(CPPClass & cl, Button::Button_notifyMouseMove_Functor::FunctionType func)
// {
//    ((Button::Button_notifyMouseMove_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Button, notifyMouseMove)] = func;
// }

inline Button::Button_notifyMouseOver_Functor::FunctionType Button::Button_notifyMouseOver_Functor::operator= (FunctionType func)
{
   SELF(Button, notifyMouseOver);
   if(self->vTbl == Button::_cpp_class.vTbl)
   {
      uint size = Button::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Button::Button_notifyMouseOver_Functor::FunctionType, size);
      memcpy(self->vTbl, Button::_cpp_class.vTbl, sizeof(Button::Button_notifyMouseOver_Functor::FunctionType) * size);
   }
   ((Button::Button_notifyMouseOver_Functor::FunctionType *)self->vTbl)[M_VTBLID(Button, notifyMouseOver)] = func;
   return func;
}
inline bool Button::Button_notifyMouseOver_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Button, notifyMouseOver);
   return (bool)Button_notifyMouseOver(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Button::register_notifyMouseOver(CPPClass & cl, Button::Button_notifyMouseOver_Functor::FunctionType func)
// {
//    ((Button::Button_notifyMouseOver_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Button, notifyMouseOver)] = func;
// }

inline Button::Button_notifyPushed_Functor::FunctionType Button::Button_notifyPushed_Functor::operator= (FunctionType func)
{
   SELF(Button, notifyPushed);
   if(self->vTbl == Button::_cpp_class.vTbl)
   {
      uint size = Button::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Button::Button_notifyPushed_Functor::FunctionType, size);
      memcpy(self->vTbl, Button::_cpp_class.vTbl, sizeof(Button::Button_notifyPushed_Functor::FunctionType) * size);
   }
   ((Button::Button_notifyPushed_Functor::FunctionType *)self->vTbl)[M_VTBLID(Button, notifyPushed)] = func;
   return func;
}
inline bool Button::Button_notifyPushed_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Button, notifyPushed);
   return (bool)Button_notifyPushed(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Button::register_notifyPushed(CPPClass & cl, Button::Button_notifyPushed_Functor::FunctionType func)
// {
//    ((Button::Button_notifyPushed_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Button, notifyPushed)] = func;
// }

inline Button::Button_notifyReleased_Functor::FunctionType Button::Button_notifyReleased_Functor::operator= (FunctionType func)
{
   SELF(Button, notifyReleased);
   if(self->vTbl == Button::_cpp_class.vTbl)
   {
      uint size = Button::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Button::Button_notifyReleased_Functor::FunctionType, size);
      memcpy(self->vTbl, Button::_cpp_class.vTbl, sizeof(Button::Button_notifyReleased_Functor::FunctionType) * size);
   }
   ((Button::Button_notifyReleased_Functor::FunctionType *)self->vTbl)[M_VTBLID(Button, notifyReleased)] = func;
   return func;
}
inline bool Button::Button_notifyReleased_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/Button & button, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(Button, notifyReleased);
   return (bool)Button_notifyReleased(self ? self->impl : (C(Button))null, o_.impl, /*7Al*/button.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void Button::register_notifyReleased(CPPClass & cl, Button::Button_notifyReleased_Functor::FunctionType func)
// {
//    ((Button::Button_notifyReleased_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Button, notifyReleased)] = func;
// }


inline void Button::removeRadio()
{
   Button_removeRadio(impl);
}
inline void Button::setColor(/*1Ab*/ButtonState state, /*1Ab*/Color value)
{
   Button_setColor(impl, /*5Ee*/(C(ButtonState))state, /*5Ee*/(C(Color))value.impl);
}
inline void Button::setTextColor(/*1Ab*/ButtonState state, /*1Ab*/Color value)
{
   Button_setTextColor(impl, /*5Ee*/(C(ButtonState))state, /*5Ee*/(C(Color))value.impl);
}


// property callers: Button::opacity
// (normal::unit|float)

/*nstSet*/inline /*0H*/Percentage Button::opacity_Prop::operator= (/*0H*/Percentage v)
{
   SELF(Button, opacity);
   Button_set_opacity(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Button::opacity_Prop & Button::opacity_Prop::operator= (Button::opacity_Prop & prop)
{
   SELF(Button, opacity);
   /*0H*/Percentage v = prop;
   Button_set_opacity(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline Button::opacity_Prop::operator /*0I*/Percentage () const
{
   SELF(Button, opacity);
   Percentage value(Button_get_opacity(self->impl));
   return value;
}
/*regGet*/inline Button::opacity_Prop::operator /*0J*/C(Percentage) () const
{
   SELF(Button, opacity);
   return Percentage(self->opacity);
}

// property callers: Button::drawBehind
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::drawBehind_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, drawBehind);
   Button_set_drawBehind(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::drawBehind_Prop & Button::drawBehind_Prop::operator= (Button::drawBehind_Prop & prop)
{
   SELF(Button, drawBehind);
   /*0H*/bool v = prop;
   Button_set_drawBehind(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::drawBehind_Prop::operator /*0I*/bool () const
{
   SELF(Button, drawBehind);
   return (bool)Button_get_drawBehind(self ? self->impl : null);
}

// property callers: Button::isRadio
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::isRadio_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, isRadio);
   Button_set_isRadio(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::isRadio_Prop & Button::isRadio_Prop::operator= (Button::isRadio_Prop & prop)
{
   SELF(Button, isRadio);
   /*0H*/bool v = prop;
   Button_set_isRadio(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::isRadio_Prop::operator /*0I*/bool () const
{
   SELF(Button, isRadio);
   return (bool)Button_get_isRadio(self ? self->impl : null);
}

// property callers: Button::isCheckbox
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::isCheckbox_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, isCheckbox);
   Button_set_isCheckbox(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::isCheckbox_Prop & Button::isCheckbox_Prop::operator= (Button::isCheckbox_Prop & prop)
{
   SELF(Button, isCheckbox);
   /*0H*/bool v = prop;
   Button_set_isCheckbox(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::isCheckbox_Prop::operator /*0I*/bool () const
{
   SELF(Button, isCheckbox);
   return (bool)Button_get_isCheckbox(self ? self->impl : null);
}

// property callers: Button::bevel
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::bevel_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, bevel);
   Button_set_bevel(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::bevel_Prop & Button::bevel_Prop::operator= (Button::bevel_Prop & prop)
{
   SELF(Button, bevel);
   /*0H*/bool v = prop;
   Button_set_bevel(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::bevel_Prop::operator /*0I*/bool () const
{
   SELF(Button, bevel);
   return (bool)Button_get_bevel(self ? self->impl : null);
}

// property callers: Button::bevelOver
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::bevelOver_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, bevelOver);
   Button_set_bevelOver(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::bevelOver_Prop & Button::bevelOver_Prop::operator= (Button::bevelOver_Prop & prop)
{
   SELF(Button, bevelOver);
   /*0H*/bool v = prop;
   Button_set_bevelOver(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::bevelOver_Prop::operator /*0I*/bool () const
{
   SELF(Button, bevelOver);
   return (bool)Button_get_bevelOver(self ? self->impl : null);
}

// property callers: Button::toggle
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::toggle_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, toggle);
   Button_set_toggle(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::toggle_Prop & Button::toggle_Prop::operator= (Button::toggle_Prop & prop)
{
   SELF(Button, toggle);
   /*0H*/bool v = prop;
   Button_set_toggle(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::toggle_Prop::operator /*0I*/bool () const
{
   SELF(Button, toggle);
   return (bool)Button_get_toggle(self ? self->impl : null);
}

// property callers: Button::checked
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::checked_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, checked);
   Button_set_checked(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::checked_Prop & Button::checked_Prop::operator= (Button::checked_Prop & prop)
{
   SELF(Button, checked);
   /*0H*/bool v = prop;
   Button_set_checked(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::checked_Prop::operator /*0I*/bool () const
{
   SELF(Button, checked);
   return (bool)Button_get_checked(self ? self->impl : null);
}

// property callers: Button::alignment
// (normal::enum|int)

/*nstSet*/inline /*0H*/Alignment Button::alignment_Prop::operator= (/*0H*/Alignment v)
{
   SELF(Button, alignment);
   Button_set_alignment(self ? self->impl : null, (C(Alignment))v);
   return v;
}

/*regSet*/inline Button::alignment_Prop & Button::alignment_Prop::operator= (Button::alignment_Prop & prop)
{
   SELF(Button, alignment);
   /*0H*/Alignment v = prop;
   Button_set_alignment(self ? self->impl : null, (C(Alignment))v);
   return prop;
}
/*regGet*/inline Button::alignment_Prop::operator /*0I*/Alignment () const
{
   SELF(Button, alignment);
   return (Alignment)Button_get_alignment(self ? self->impl : null);
}

// property callers: Button::bitmap
// (normal::normal)

/*nstSet*/inline /*0A*/const BitmapResource & Button::bitmap_Prop::operator= (/*0A*/const BitmapResource & v)
{
   SELF(Button, bitmap);
   Button_set_bitmap(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Button::bitmap_Prop & Button::bitmap_Prop::operator= (Button::bitmap_Prop & prop)
{
   SELF(Button, bitmap);
   /*0A*/const BitmapResource & v = prop;
   Button_set_bitmap(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const BitmapResource * Button::bitmap_Prop::operator= (/*0C*/const BitmapResource * v)
{
   SELF(Button, bitmap);
   Button_set_bitmap(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Button::bitmap_Prop::operator /*0B*/TIH<BitmapResource> () const
{
   SELF(Button, bitmap);
   C(Instance) i = Button_get_bitmap(self ? self->impl : null);
   TIH<BitmapResource> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<BitmapResource> Button::bitmap_Prop::operator /*0D*/-> () const
{
   SELF(Button, bitmap);
   C(Instance) i = Button_get_bitmap(self ? self->impl : null);
   TIH<BitmapResource> holder(i);
   return holder;
}
/*regGet*/inline Button::bitmap_Prop::operator /*0E*/BitmapResource () const
{
   SELF(Button, bitmap);
   C(Instance) i = Button_get_bitmap(self ? self->impl : null);
   return BitmapResource(i);
}
/*regGet*/inline Button::bitmap_Prop::operator /*0F*/BitmapResource* () const
{
   SELF(Button, bitmap);
   C(Instance) i = Button_get_bitmap(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (BitmapResource *)INSTANCEL(i, i->_class) : (BitmapResource *)0;
}

// property callers: Button::stayUp
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::stayUp_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, stayUp);
   Button_set_stayUp(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::stayUp_Prop & Button::stayUp_Prop::operator= (Button::stayUp_Prop & prop)
{
   SELF(Button, stayUp);
   /*0H*/bool v = prop;
   Button_set_stayUp(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::stayUp_Prop::operator /*0I*/bool () const
{
   SELF(Button, stayUp);
   return (bool)Button_get_stayUp(self ? self->impl : null);
}

// property callers: Button::scaleBitmap
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::scaleBitmap_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, scaleBitmap);
   Button_set_scaleBitmap(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::scaleBitmap_Prop & Button::scaleBitmap_Prop::operator= (Button::scaleBitmap_Prop & prop)
{
   SELF(Button, scaleBitmap);
   /*0H*/bool v = prop;
   Button_set_scaleBitmap(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::scaleBitmap_Prop::operator /*0I*/bool () const
{
   SELF(Button, scaleBitmap);
   return (bool)Button_get_scaleBitmap(self ? self->impl : null);
}

// property callers: Button::keyRepeat
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::keyRepeat_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, keyRepeat);
   Button_set_keyRepeat(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::keyRepeat_Prop & Button::keyRepeat_Prop::operator= (Button::keyRepeat_Prop & prop)
{
   SELF(Button, keyRepeat);
   /*0H*/bool v = prop;
   Button_set_keyRepeat(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::keyRepeat_Prop::operator /*0I*/bool () const
{
   SELF(Button, keyRepeat);
   return (bool)Button_get_keyRepeat(self ? self->impl : null);
}

// property callers: Button::symbol
// (normal::unit|uint)

/*nstSet*/inline /*0H*/unichar Button::symbol_Prop::operator= (/*0H*/unichar v)
{
   SELF(Button, symbol);
   Button_set_symbol(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Button::symbol_Prop & Button::symbol_Prop::operator= (Button::symbol_Prop & prop)
{
   SELF(Button, symbol);
   /*0H*/unichar v = prop;
   Button_set_symbol(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Button::symbol_Prop::operator /*0I*/unichar () const
{
   SELF(Button, symbol);
   return Button_get_symbol(self ? self->impl : null);
}

// property callers: Button::ellipsis
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::ellipsis_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, ellipsis);
   Button_set_ellipsis(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::ellipsis_Prop & Button::ellipsis_Prop::operator= (Button::ellipsis_Prop & prop)
{
   SELF(Button, ellipsis);
   /*0H*/bool v = prop;
   Button_set_ellipsis(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::ellipsis_Prop::operator /*0I*/bool () const
{
   SELF(Button, ellipsis);
   return (bool)Button_get_ellipsis(self ? self->impl : null);
}

// property callers: Button::stayDown
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::stayDown_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, stayDown);
   Button_set_stayDown(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::stayDown_Prop & Button::stayDown_Prop::operator= (Button::stayDown_Prop & prop)
{
   SELF(Button, stayDown);
   /*0H*/bool v = prop;
   Button_set_stayDown(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::stayDown_Prop::operator /*0I*/bool () const
{
   SELF(Button, stayDown);
   return (bool)Button_get_stayDown(self ? self->impl : null);
}

// property callers: Button::offset
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Button::offset_Prop::operator= (/*0H*/bool v)
{
   SELF(Button, offset);
   Button_set_offset(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Button::offset_Prop & Button::offset_Prop::operator= (Button::offset_Prop & prop)
{
   SELF(Button, offset);
   /*0H*/bool v = prop;
   Button_set_offset(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Button::offset_Prop::operator /*0I*/bool () const
{
   SELF(Button, offset);
   return (bool)Button_get_offset(self ? self->impl : null);
}

// property callers: Button::buttonState
// (normal::enum|int)

/*nstSet*/inline /*0H*/ButtonState Button::buttonState_Prop::operator= (/*0H*/ButtonState v)
{
   SELF(Button, buttonState);
   Button_set_buttonState(self ? self->impl : null, (C(ButtonState))v);
   return v;
}

/*regSet*/inline Button::buttonState_Prop & Button::buttonState_Prop::operator= (Button::buttonState_Prop & prop)
{
   SELF(Button, buttonState);
   /*0H*/ButtonState v = prop;
   Button_set_buttonState(self ? self->impl : null, (C(ButtonState))v);
   return prop;
}
/*regGet*/inline Button::buttonState_Prop::operator /*0I*/ButtonState () const
{
   SELF(Button, buttonState);
   return (ButtonState)Button_get_buttonState(self ? self->impl : null);
}

// property callers: Button::bitmapAlignment
// (normal::enum|int)

/*nstSet*/inline /*0H*/BoxAlignment Button::bitmapAlignment_Prop::operator= (/*0H*/BoxAlignment v)
{
   SELF(Button, bitmapAlignment);
   Button_set_bitmapAlignment(self ? self->impl : null, (C(BoxAlignment))v);
   return v;
}

/*regSet*/inline Button::bitmapAlignment_Prop & Button::bitmapAlignment_Prop::operator= (Button::bitmapAlignment_Prop & prop)
{
   SELF(Button, bitmapAlignment);
   /*0H*/BoxAlignment v = prop;
   Button_set_bitmapAlignment(self ? self->impl : null, (C(BoxAlignment))v);
   return prop;
}
/*regGet*/inline Button::bitmapAlignment_Prop::operator /*0I*/BoxAlignment () const
{
   SELF(Button, bitmapAlignment);
   return (BoxAlignment)Button_get_bitmapAlignment(self ? self->impl : null);
}

inline CalendarControl::CalendarControl(Date dateValue, Month shownMonth = (Month)0, int shownYear = 0) : CalendarControl()
{
   this->dateValue = dateValue.impl;
   this->shownMonth = shownMonth;
   this->shownYear = shownYear;
}

inline CalendarControl::CalendarControl_notifyChanged_Functor::FunctionType CalendarControl::CalendarControl_notifyChanged_Functor::operator= (FunctionType func)
{
   SELF(CalendarControl, notifyChanged);
   if(self->vTbl == CalendarControl::_cpp_class.vTbl)
   {
      uint size = CalendarControl::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(CalendarControl::CalendarControl_notifyChanged_Functor::FunctionType, size);
      memcpy(self->vTbl, CalendarControl::_cpp_class.vTbl, sizeof(CalendarControl::CalendarControl_notifyChanged_Functor::FunctionType) * size);
   }
   ((CalendarControl::CalendarControl_notifyChanged_Functor::FunctionType *)self->vTbl)[M_VTBLID(CalendarControl, notifyChanged)] = func;
   return func;
}
inline void CalendarControl::CalendarControl_notifyChanged_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/CalendarControl & calendarControl, /*6Fj*/bool close)
{
   SELF(CalendarControl, notifyChanged);
   CalendarControl_notifyChanged(self ? self->impl : (C(CalendarControl))null, self ? self->impl : (C(CalendarControl))null, /*7Al*/calendarControl.impl, /*7Al*/(C(bool))close);
}
// inline void CalendarControl::register_notifyChanged(CPPClass & cl, CalendarControl::CalendarControl_notifyChanged_Functor::FunctionType func)
// {
//    ((CalendarControl::CalendarControl_notifyChanged_Functor::FunctionType *)cl.vTbl)[M_VTBLID(CalendarControl, notifyChanged)] = func;
// }



// member accessors: CalendarControl::dateValue
// (normal::struct)

/*nstSet*/inline /*0H*/Date CalendarControl::dateValue_Prop::operator= (/*0H*/Date v)
{
   SELF(CalendarControl, dateValue);
   IPTR(self->impl, CalendarControl)->dateValue = v.impl;
   return v;
}

/*regSet*/inline CalendarControl::dateValue_Prop & CalendarControl::dateValue_Prop::operator= (CalendarControl::dateValue_Prop & prop)
{
   SELF(CalendarControl, dateValue);
   /*0H*/Date v = prop;
   IPTR(self->impl, CalendarControl)->dateValue = v.impl;
   return prop;
}
/*regGet*/inline CalendarControl::dateValue_Prop::operator /*0I*/Date () const
{
   SELF(CalendarControl, dateValue);
   Date value(IPTR(self->impl, CalendarControl)->dateValue);
   return value;
}

// member accessors: CalendarControl::shownMonth
// (normal::enum|int)

/*nstSet*/inline /*0H*/Month CalendarControl::shownMonth_Prop::operator= (/*0H*/Month v)
{
   SELF(CalendarControl, shownMonth);
   IPTR(self->impl, CalendarControl)->shownMonth = (C(Month))v;
   return v;
}

/*regSet*/inline CalendarControl::shownMonth_Prop & CalendarControl::shownMonth_Prop::operator= (CalendarControl::shownMonth_Prop & prop)
{
   SELF(CalendarControl, shownMonth);
   /*0H*/Month v = prop;
   IPTR(self->impl, CalendarControl)->shownMonth = (C(Month))v;
   return prop;
}
/*regGet*/inline CalendarControl::shownMonth_Prop::operator /*0I*/Month () const
{
   SELF(CalendarControl, shownMonth);
   return self ? (Month)IPTR(self->impl, CalendarControl)->shownMonth : (Month)0;
}

// member accessors: CalendarControl::shownYear
// (normal::int)

/*nstSet*/inline /*0H*/int CalendarControl::shownYear_Prop::operator= (/*0H*/int v)
{
   SELF(CalendarControl, shownYear);
   IPTR(self->impl, CalendarControl)->shownYear = v;
   return v;
}

/*regSet*/inline CalendarControl::shownYear_Prop & CalendarControl::shownYear_Prop::operator= (CalendarControl::shownYear_Prop & prop)
{
   SELF(CalendarControl, shownYear);
   /*0H*/int v = prop;
   IPTR(self->impl, CalendarControl)->shownYear = v;
   return prop;
}
/*regGet*/inline CalendarControl::shownYear_Prop::operator /*0I*/int () const
{
   SELF(CalendarControl, shownYear);
   return self ? IPTR(self->impl, CalendarControl)->shownYear : 0;
}

inline DataBox::DataBox_notifyChanged_Functor::FunctionType DataBox::DataBox_notifyChanged_Functor::operator= (FunctionType func)
{
   SELF(DataBox, notifyChanged);
   if(self->vTbl == DataBox::_cpp_class.vTbl)
   {
      uint size = DataBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DataBox::DataBox_notifyChanged_Functor::FunctionType, size);
      memcpy(self->vTbl, DataBox::_cpp_class.vTbl, sizeof(DataBox::DataBox_notifyChanged_Functor::FunctionType) * size);
   }
   ((DataBox::DataBox_notifyChanged_Functor::FunctionType *)self->vTbl)[M_VTBLID(DataBox, notifyChanged)] = func;
   return func;
}
inline bool DataBox::DataBox_notifyChanged_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/DataBox & dataBox, /*6Fj*/bool closingDropDown)
{
   SELF(DataBox, notifyChanged);
   return (bool)DataBox_notifyChanged(self ? self->impl : (C(DataBox))null, o_.impl, /*7Al*/dataBox.impl, /*7Al*/(C(bool))closingDropDown);
}
// inline void DataBox::register_notifyChanged(CPPClass & cl, DataBox::DataBox_notifyChanged_Functor::FunctionType func)
// {
//    ((DataBox::DataBox_notifyChanged_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DataBox, notifyChanged)] = func;
// }

inline DataBox::DataBox_notifyModified_Functor::FunctionType DataBox::DataBox_notifyModified_Functor::operator= (FunctionType func)
{
   SELF(DataBox, notifyModified);
   if(self->vTbl == DataBox::_cpp_class.vTbl)
   {
      uint size = DataBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DataBox::DataBox_notifyModified_Functor::FunctionType, size);
      memcpy(self->vTbl, DataBox::_cpp_class.vTbl, sizeof(DataBox::DataBox_notifyModified_Functor::FunctionType) * size);
   }
   ((DataBox::DataBox_notifyModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(DataBox, notifyModified)] = func;
   return func;
}
inline bool DataBox::DataBox_notifyModified_Functor::operator()(/*6Fk*/Window & o_ )
{
   SELF(DataBox, notifyModified);
   return (bool)DataBox_notifyModified(self ? self->impl : (C(DataBox))null, o_.impl);
}
// inline void DataBox::register_notifyModified(CPPClass & cl, DataBox::DataBox_notifyModified_Functor::FunctionType func)
// {
//    ((DataBox::DataBox_notifyModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DataBox, notifyModified)] = func;
// }

inline DataBox::DataBox_onConfigure_Functor::FunctionType DataBox::DataBox_onConfigure_Functor::operator= (FunctionType func)
{
   SELF(DataBox, onConfigure);
   if(self->vTbl == DataBox::_cpp_class.vTbl)
   {
      uint size = DataBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DataBox::DataBox_onConfigure_Functor::FunctionType, size);
      memcpy(self->vTbl, DataBox::_cpp_class.vTbl, sizeof(DataBox::DataBox_onConfigure_Functor::FunctionType) * size);
   }
   ((DataBox::DataBox_onConfigure_Functor::FunctionType *)self->vTbl)[M_VTBLID(DataBox, onConfigure)] = func;
   return func;
}
inline void DataBox::DataBox_onConfigure_Functor::operator()( /*6Fj*/Window & editor)
{
   SELF(DataBox, onConfigure);
   DataBox_onConfigure(self ? self->impl : (C(DataBox))null, /*7Al*/editor.impl);
}
// inline void DataBox::register_onConfigure(CPPClass & cl, DataBox::DataBox_onConfigure_Functor::FunctionType func)
// {
//    ((DataBox::DataBox_onConfigure_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DataBox, onConfigure)] = func;
// }

inline DataBox::DataBox_setData_Functor::FunctionType DataBox::DataBox_setData_Functor::operator= (FunctionType func)
{
   SELF(DataBox, setData);
   if(self->vTbl == DataBox::_cpp_class.vTbl)
   {
      uint size = DataBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DataBox::DataBox_setData_Functor::FunctionType, size);
      memcpy(self->vTbl, DataBox::_cpp_class.vTbl, sizeof(DataBox::DataBox_setData_Functor::FunctionType) * size);
   }
   ((DataBox::DataBox_setData_Functor::FunctionType *)self->vTbl)[M_VTBLID(DataBox, setData)] = func;
   return func;
}
inline void DataBox::DataBox_setData_Functor::operator()( /*6Fj*/any_object newData, /*6Fj*/bool closingDropDown)
{
   SELF(DataBox, setData);
   DataBox_setData(self ? self->impl : (C(DataBox))null, /*7Al*/newData, /*7Al*/(C(bool))closingDropDown);
}
// inline void DataBox::register_setData(CPPClass & cl, DataBox::DataBox_setData_Functor::FunctionType func)
// {
//    ((DataBox::DataBox_setData_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DataBox, setData)] = func;
// }


inline void DataBox::modified()
{
   DataBox_modified(impl);
}
inline void DataBox::refresh()
{
   DataBox_refresh(impl);
}
inline C(bool) DataBox::saveData()
{
   return DataBox_saveData(impl);
}


// member accessors: DataBox::type
// (normal::nohead)

/*nstSet*/inline /*0H*/Class DataBox::type_Prop::operator= (/*0H*/Class & v)
{
   SELF(DataBox, type);
   IPTR(self->impl, DataBox)->type = v.impl;
   return v;
}

/*regSet*/inline DataBox::type_Prop & DataBox::type_Prop::operator= (DataBox::type_Prop & prop)
{
   SELF(DataBox, type);
   /*0H*/Class v = prop;
   IPTR(self->impl, DataBox)->type = v.impl;
   return prop;
}
/*regGet*/inline DataBox::type_Prop::operator /*0I*/Class () const
{
   SELF(DataBox, type);
   Class value(IPTR(self->impl, DataBox)->type);
   return value;
}

// member accessors: DataBox::data
// (normal::void *)

/*nstSet*/inline /*0H*/void * DataBox::data_Prop::operator= (/*0H*/void * v)
{
   SELF(DataBox, data);
   IPTR(self->impl, DataBox)->data = v;
   return v;
}

/*regSet*/inline DataBox::data_Prop & DataBox::data_Prop::operator= (DataBox::data_Prop & prop)
{
   SELF(DataBox, data);
   /*0H*/void * v = prop;
   IPTR(self->impl, DataBox)->data = v;
   return prop;
}
/*regGet*/inline DataBox::data_Prop::operator /*0I*/void * () const
{
   SELF(DataBox, data);
   return self ? IPTR(self->impl, DataBox)->data : null;
}

// member accessors: DataBox::fieldData
// (normal::void *)

/*nstSet*/inline /*0H*/void * DataBox::fieldData_Prop::operator= (/*0H*/void * v)
{
   SELF(DataBox, fieldData);
   IPTR(self->impl, DataBox)->fieldData = v;
   return v;
}

/*regSet*/inline DataBox::fieldData_Prop & DataBox::fieldData_Prop::operator= (DataBox::fieldData_Prop & prop)
{
   SELF(DataBox, fieldData);
   /*0H*/void * v = prop;
   IPTR(self->impl, DataBox)->fieldData = v;
   return prop;
}
/*regGet*/inline DataBox::fieldData_Prop::operator /*0I*/void * () const
{
   SELF(DataBox, fieldData);
   return self ? IPTR(self->impl, DataBox)->fieldData : null;
}

// member accessors: DataBox::editor
// (normal::normal)

/*nstSet*/inline /*0H*/Window DataBox::editor_Prop::operator= (/*0H*/Window v)
{
   SELF(DataBox, editor);
   IPTR(self->impl, DataBox)->editor = v.impl;
   return v;
}

/*regSet*/inline DataBox::editor_Prop & DataBox::editor_Prop::operator= (DataBox::editor_Prop & prop)
{
   SELF(DataBox, editor);
   /*0H*/Window v = prop;
   IPTR(self->impl, DataBox)->editor = v.impl;
   return prop;
}
/*regGet*/inline DataBox::editor_Prop::operator /*0I*/Window () const
{
   SELF(DataBox, editor);
   Window value(IPTR(self->impl, DataBox)->editor, DataBox::_cpp_class);
   return value;
}

// member accessors: DataBox::readOnly
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataBox::readOnly_Prop::operator= (/*0H*/bool v)
{
   SELF(DataBox, readOnly);
   IPTR(self->impl, DataBox)->readOnly = (C(bool))v;
   return v;
}

/*regSet*/inline DataBox::readOnly_Prop & DataBox::readOnly_Prop::operator= (DataBox::readOnly_Prop & prop)
{
   SELF(DataBox, readOnly);
   /*0H*/bool v = prop;
   IPTR(self->impl, DataBox)->readOnly = (C(bool))v;
   return prop;
}
/*regGet*/inline DataBox::readOnly_Prop::operator /*0I*/bool () const
{
   SELF(DataBox, readOnly);
   return self ? (bool)IPTR(self->impl, DataBox)->readOnly : (bool)0;
}

// member accessors: DataBox::keepEditor
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataBox::keepEditor_Prop::operator= (/*0H*/bool v)
{
   SELF(DataBox, keepEditor);
   IPTR(self->impl, DataBox)->keepEditor = (C(bool))v;
   return v;
}

/*regSet*/inline DataBox::keepEditor_Prop & DataBox::keepEditor_Prop::operator= (DataBox::keepEditor_Prop & prop)
{
   SELF(DataBox, keepEditor);
   /*0H*/bool v = prop;
   IPTR(self->impl, DataBox)->keepEditor = (C(bool))v;
   return prop;
}
/*regGet*/inline DataBox::keepEditor_Prop::operator /*0I*/bool () const
{
   SELF(DataBox, keepEditor);
   return self ? (bool)IPTR(self->impl, DataBox)->keepEditor : (bool)0;
}

// member accessors: DataBox::autoSize
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataBox::autoSize_Prop::operator= (/*0H*/bool v)
{
   SELF(DataBox, autoSize);
   IPTR(self->impl, DataBox)->autoSize = (C(bool))v;
   return v;
}

/*regSet*/inline DataBox::autoSize_Prop & DataBox::autoSize_Prop::operator= (DataBox::autoSize_Prop & prop)
{
   SELF(DataBox, autoSize);
   /*0H*/bool v = prop;
   IPTR(self->impl, DataBox)->autoSize = (C(bool))v;
   return prop;
}
/*regGet*/inline DataBox::autoSize_Prop::operator /*0I*/bool () const
{
   SELF(DataBox, autoSize);
   return self ? (bool)IPTR(self->impl, DataBox)->autoSize : (bool)0;
}

// member accessors: DataBox::needUpdate
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataBox::needUpdate_Prop::operator= (/*0H*/bool v)
{
   SELF(DataBox, needUpdate);
   IPTR(self->impl, DataBox)->needUpdate = (C(bool))v;
   return v;
}

/*regSet*/inline DataBox::needUpdate_Prop & DataBox::needUpdate_Prop::operator= (DataBox::needUpdate_Prop & prop)
{
   SELF(DataBox, needUpdate);
   /*0H*/bool v = prop;
   IPTR(self->impl, DataBox)->needUpdate = (C(bool))v;
   return prop;
}
/*regGet*/inline DataBox::needUpdate_Prop::operator /*0I*/bool () const
{
   SELF(DataBox, needUpdate);
   return self ? (bool)IPTR(self->impl, DataBox)->needUpdate : (bool)0;
}

// member accessors: DataBox::stringValue
// (normal::string)

/*nstSet*/inline /*0H*/char * DataBox::stringValue_Prop::operator= (/*0H*/char * v)
{
   SELF(DataBox, stringValue);
   IPTR(self->impl, DataBox)->stringValue = v;
   return v;
}

/*regSet*/inline DataBox::stringValue_Prop & DataBox::stringValue_Prop::operator= (DataBox::stringValue_Prop & prop)
{
   SELF(DataBox, stringValue);
   /*0H*/char * v = prop;
   IPTR(self->impl, DataBox)->stringValue = v;
   return prop;
}
/*regGet*/inline DataBox::stringValue_Prop::operator /*0I*/char * () const
{
   SELF(DataBox, stringValue);
   return self ? IPTR(self->impl, DataBox)->stringValue : 0;
}



// member accessors: DataDisplayFlags::selected
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DataDisplayFlags::selected_Prop::operator= (/*0H*/bool v)
{
   SELF(DataDisplayFlags, selected);
   DATADISPLAYFLAGS_SET_selected(self->impl, v);
   return v;
}

/*regSet*/inline DataDisplayFlags::selected_Prop & DataDisplayFlags::selected_Prop::operator= (DataDisplayFlags::selected_Prop & prop)
{
   SELF(DataDisplayFlags, selected);
   /*0H*/bool v = prop;
   DATADISPLAYFLAGS_SET_selected(self->impl, v);
   return prop;
}
/*regGet*/inline DataDisplayFlags::selected_Prop::operator /*0I*/bool () const
{
   SELF(DataDisplayFlags, selected);
   return (bool)DATADISPLAYFLAGS_selected(self->impl);
}

// member accessors: DataDisplayFlags::fullRow
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DataDisplayFlags::fullRow_Prop::operator= (/*0H*/bool v)
{
   SELF(DataDisplayFlags, fullRow);
   DATADISPLAYFLAGS_SET_fullRow(self->impl, v);
   return v;
}

/*regSet*/inline DataDisplayFlags::fullRow_Prop & DataDisplayFlags::fullRow_Prop::operator= (DataDisplayFlags::fullRow_Prop & prop)
{
   SELF(DataDisplayFlags, fullRow);
   /*0H*/bool v = prop;
   DATADISPLAYFLAGS_SET_fullRow(self->impl, v);
   return prop;
}
/*regGet*/inline DataDisplayFlags::fullRow_Prop::operator /*0I*/bool () const
{
   SELF(DataDisplayFlags, fullRow);
   return (bool)DATADISPLAYFLAGS_fullRow(self->impl);
}

// member accessors: DataDisplayFlags::current
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DataDisplayFlags::current_Prop::operator= (/*0H*/bool v)
{
   SELF(DataDisplayFlags, current);
   DATADISPLAYFLAGS_SET_current(self->impl, v);
   return v;
}

/*regSet*/inline DataDisplayFlags::current_Prop & DataDisplayFlags::current_Prop::operator= (DataDisplayFlags::current_Prop & prop)
{
   SELF(DataDisplayFlags, current);
   /*0H*/bool v = prop;
   DATADISPLAYFLAGS_SET_current(self->impl, v);
   return prop;
}
/*regGet*/inline DataDisplayFlags::current_Prop::operator /*0I*/bool () const
{
   SELF(DataDisplayFlags, current);
   return (bool)DATADISPLAYFLAGS_current(self->impl);
}

// member accessors: DataDisplayFlags::active
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DataDisplayFlags::active_Prop::operator= (/*0H*/bool v)
{
   SELF(DataDisplayFlags, active);
   DATADISPLAYFLAGS_SET_active(self->impl, v);
   return v;
}

/*regSet*/inline DataDisplayFlags::active_Prop & DataDisplayFlags::active_Prop::operator= (DataDisplayFlags::active_Prop & prop)
{
   SELF(DataDisplayFlags, active);
   /*0H*/bool v = prop;
   DATADISPLAYFLAGS_SET_active(self->impl, v);
   return prop;
}
/*regGet*/inline DataDisplayFlags::active_Prop::operator /*0I*/bool () const
{
   SELF(DataDisplayFlags, active);
   return (bool)DATADISPLAYFLAGS_active(self->impl);
}

// member accessors: DataDisplayFlags::dropBox
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DataDisplayFlags::dropBox_Prop::operator= (/*0H*/bool v)
{
   SELF(DataDisplayFlags, dropBox);
   DATADISPLAYFLAGS_SET_dropBox(self->impl, v);
   return v;
}

/*regSet*/inline DataDisplayFlags::dropBox_Prop & DataDisplayFlags::dropBox_Prop::operator= (DataDisplayFlags::dropBox_Prop & prop)
{
   SELF(DataDisplayFlags, dropBox);
   /*0H*/bool v = prop;
   DATADISPLAYFLAGS_SET_dropBox(self->impl, v);
   return prop;
}
/*regGet*/inline DataDisplayFlags::dropBox_Prop::operator /*0I*/bool () const
{
   SELF(DataDisplayFlags, dropBox);
   return (bool)DATADISPLAYFLAGS_dropBox(self->impl);
}

// member accessors: DataDisplayFlags::header
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DataDisplayFlags::header_Prop::operator= (/*0H*/bool v)
{
   SELF(DataDisplayFlags, header);
   DATADISPLAYFLAGS_SET_header(self->impl, v);
   return v;
}

/*regSet*/inline DataDisplayFlags::header_Prop & DataDisplayFlags::header_Prop::operator= (DataDisplayFlags::header_Prop & prop)
{
   SELF(DataDisplayFlags, header);
   /*0H*/bool v = prop;
   DATADISPLAYFLAGS_SET_header(self->impl, v);
   return prop;
}
/*regGet*/inline DataDisplayFlags::header_Prop::operator /*0I*/bool () const
{
   SELF(DataDisplayFlags, header);
   return (bool)DATADISPLAYFLAGS_header(self->impl);
}

// member accessors: DataDisplayFlags::firstField
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool DataDisplayFlags::firstField_Prop::operator= (/*0H*/bool v)
{
   SELF(DataDisplayFlags, firstField);
   DATADISPLAYFLAGS_SET_firstField(self->impl, v);
   return v;
}

/*regSet*/inline DataDisplayFlags::firstField_Prop & DataDisplayFlags::firstField_Prop::operator= (DataDisplayFlags::firstField_Prop & prop)
{
   SELF(DataDisplayFlags, firstField);
   /*0H*/bool v = prop;
   DATADISPLAYFLAGS_SET_firstField(self->impl, v);
   return prop;
}
/*regGet*/inline DataDisplayFlags::firstField_Prop::operator /*0I*/bool () const
{
   SELF(DataDisplayFlags, firstField);
   return (bool)DATADISPLAYFLAGS_firstField(self->impl);
}


inline void DataField::autoSize()
{
   DataField_autoSize(impl);
}
inline void DataField::move(/*1Ab*/DataField & after)
{
   DataField_move(impl, /*5De*/after.impl);
}


// property callers: DataField::dataType
// (normal::nohead)

/*nstSet*/inline /*0H*/Class DataField::dataType_Prop::operator= (/*0H*/Class & v)
{
   SELF(DataField, dataType);
   DataField_set_dataType(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline DataField::dataType_Prop & DataField::dataType_Prop::operator= (DataField::dataType_Prop & prop)
{
   SELF(DataField, dataType);
   /*0H*/Class v = prop;
   DataField_set_dataType(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline DataField::dataType_Prop::operator /*0I*/Class () const
{
   SELF(DataField, dataType);
   Class value(DataField_get_dataType(self->impl));
   return value;
}

// property callers: DataField::editable   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool DataField::editable_Prop::operator= (/*0G*/bool v)
{
   SELF(DataField, editable);
   DataField_set_editable(self->impl, (C(bool))v);
   return v;
}


// property callers: DataField::fixed
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataField::fixed_Prop::operator= (/*0H*/bool v)
{
   SELF(DataField, fixed);
   DataField_set_fixed(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DataField::fixed_Prop & DataField::fixed_Prop::operator= (DataField::fixed_Prop & prop)
{
   SELF(DataField, fixed);
   /*0H*/bool v = prop;
   DataField_set_fixed(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DataField::fixed_Prop::operator /*0I*/bool () const
{
   SELF(DataField, fixed);
   return (bool)DataField_get_fixed(self ? self->impl : null);
}

// property callers: DataField::alignment
// (normal::enum|int)

/*nstSet*/inline /*0H*/Alignment DataField::alignment_Prop::operator= (/*0H*/Alignment v)
{
   SELF(DataField, alignment);
   DataField_set_alignment(self ? self->impl : null, (C(Alignment))v);
   return v;
}

/*regSet*/inline DataField::alignment_Prop & DataField::alignment_Prop::operator= (DataField::alignment_Prop & prop)
{
   SELF(DataField, alignment);
   /*0H*/Alignment v = prop;
   DataField_set_alignment(self ? self->impl : null, (C(Alignment))v);
   return prop;
}
/*regGet*/inline DataField::alignment_Prop::operator /*0I*/Alignment () const
{
   SELF(DataField, alignment);
   return (Alignment)DataField_get_alignment(self ? self->impl : null);
}

// property callers: DataField::width
// (normal::int)

/*nstSet*/inline /*0H*/int DataField::width_Prop::operator= (/*0H*/int v)
{
   SELF(DataField, width);
   DataField_set_width(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DataField::width_Prop & DataField::width_Prop::operator= (DataField::width_Prop & prop)
{
   SELF(DataField, width);
   /*0H*/int v = prop;
   DataField_set_width(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DataField::width_Prop::operator /*0I*/int () const
{
   SELF(DataField, width);
   return DataField_get_width(self ? self->impl : null);
}

// property callers: DataField::index   // get only
// (normal::int)

/*regGet*/inline DataField::index_Prop::operator /*0I*/int () const
{
   SELF(DataField, index);
   return DataField_get_index(self ? self->impl : null);
}

// property callers: DataField::position
// (normal::int)

/*nstSet*/inline /*0H*/int DataField::position_Prop::operator= (/*0H*/int v)
{
   SELF(DataField, position);
   DataField_set_position(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DataField::position_Prop & DataField::position_Prop::operator= (DataField::position_Prop & prop)
{
   SELF(DataField, position);
   /*0H*/int v = prop;
   DataField_set_position(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DataField::position_Prop::operator /*0I*/int () const
{
   SELF(DataField, position);
   return DataField_get_position(self ? self->impl : null);
}

// property callers: DataField::sortOrder   // get only
// (normal::int)

/*regGet*/inline DataField::sortOrder_Prop::operator /*0I*/int () const
{
   SELF(DataField, sortOrder);
   return DataField_get_sortOrder(self ? self->impl : null);
}

// property callers: DataField::header   // set only
// (normal::const char *)

/*nstSet*/inline /*0G*/const char * DataField::header_Prop::operator= (/*0G*/const char * v)
{
   SELF(DataField, header);
   DataField_set_header(self->impl, v);
   return v;
}


// property callers: DataField::userData
// (normal::void *)

/*nstSet*/inline /*0H*/void * DataField::userData_Prop::operator= (/*0H*/void * v)
{
   SELF(DataField, userData);
   DataField_set_userData(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DataField::userData_Prop & DataField::userData_Prop::operator= (DataField::userData_Prop & prop)
{
   SELF(DataField, userData);
   /*0H*/void * v = prop;
   DataField_set_userData(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DataField::userData_Prop::operator /*0I*/void * () const
{
   SELF(DataField, userData);
   return DataField_get_userData(self ? self->impl : null);
}

// property callers: DataField::freeData
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataField::freeData_Prop::operator= (/*0H*/bool v)
{
   SELF(DataField, freeData);
   DataField_set_freeData(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DataField::freeData_Prop & DataField::freeData_Prop::operator= (DataField::freeData_Prop & prop)
{
   SELF(DataField, freeData);
   /*0H*/bool v = prop;
   DataField_set_freeData(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DataField::freeData_Prop::operator /*0I*/bool () const
{
   SELF(DataField, freeData);
   return (bool)DataField_get_freeData(self ? self->impl : null);
}

// property callers: DataField::prev   // get only
// (normal::normal)

/*regGet*/inline DataField::prev_Prop::operator /*0B*/TIH<DataField> () const
{
   SELF(DataField, prev);
   C(Instance) i = DataField_get_prev(self ? self->impl : null);
   TIH<DataField> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataField> DataField::prev_Prop::operator /*0D*/-> () const
{
   SELF(DataField, prev);
   C(Instance) i = DataField_get_prev(self ? self->impl : null);
   TIH<DataField> holder(i);
   return holder;
}
/*regGet*/inline DataField::prev_Prop::operator /*0E*/DataField () const
{
   SELF(DataField, prev);
   C(Instance) i = DataField_get_prev(self ? self->impl : null);
   return DataField(i);
}
/*regGet*/inline DataField::prev_Prop::operator /*0F*/DataField* () const
{
   SELF(DataField, prev);
   C(Instance) i = DataField_get_prev(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataField *)INSTANCEL(i, i->_class) : (DataField *)0;
}

// property callers: DataField::next   // get only
// (normal::normal)

/*regGet*/inline DataField::next_Prop::operator /*0B*/TIH<DataField> () const
{
   SELF(DataField, next);
   C(Instance) i = DataField_get_next(self ? self->impl : null);
   TIH<DataField> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataField> DataField::next_Prop::operator /*0D*/-> () const
{
   SELF(DataField, next);
   C(Instance) i = DataField_get_next(self ? self->impl : null);
   TIH<DataField> holder(i);
   return holder;
}
/*regGet*/inline DataField::next_Prop::operator /*0E*/DataField () const
{
   SELF(DataField, next);
   C(Instance) i = DataField_get_next(self ? self->impl : null);
   return DataField(i);
}
/*regGet*/inline DataField::next_Prop::operator /*0F*/DataField* () const
{
   SELF(DataField, next);
   C(Instance) i = DataField_get_next(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataField *)INSTANCEL(i, i->_class) : (DataField *)0;
}



// member accessors: DataFieldSort::field
// (struct::normal)

/*nstSet*/inline /*0H*/DataField DataFieldSort::field_Prop::operator= (/*0H*/DataField v)
{
   SELF(DataFieldSort, field);
   self->impl.field = v.impl;
   return v;
}

/*regSet*/inline DataFieldSort::field_Prop & DataFieldSort::field_Prop::operator= (DataFieldSort::field_Prop & prop)
{
   SELF(DataFieldSort, field);
   /*0H*/DataField v = prop;
   self->impl.field = v.impl;
   return prop;
}
/*regGet*/inline DataFieldSort::field_Prop::operator /*0I*/DataField () const
{
   SELF(DataFieldSort, field);
   DataField value(((C(DataFieldSort) *)&self->impl)->field);
   return value;
}

// member accessors: DataFieldSort::order
// (struct::int)

/*nstSet*/inline /*0H*/int DataFieldSort::order_Prop::operator= (/*0H*/int v)
{
   SELF(DataFieldSort, order);
   self->impl.order = v;
   return v;
}

/*regSet*/inline DataFieldSort::order_Prop & DataFieldSort::order_Prop::operator= (DataFieldSort::order_Prop & prop)
{
   SELF(DataFieldSort, order);
   /*0H*/int v = prop;
   self->impl.order = v;
   return prop;
}
/*regGet*/inline DataFieldSort::order_Prop::operator /*0I*/int () const
{
   SELF(DataFieldSort, order);
   return self ? ((C(DataFieldSort) *)&self->impl)->order : 0;
}

inline DataRow::DataRow(int64 tag, const char * string = null, bool isHeader = (bool)0) : DataRow()
{
   this->tag = tag;
   this->string = string;
   this->isHeader = isHeader;
}


inline DataRow DataRow::addRow()
{
   return DataRow(DataRow_addRow(impl));
}
inline DataRow DataRow::addRowAfter(/*1Ab*/DataRow & after)
{
   return DataRow(DataRow_addRowAfter(impl, /*5De*/after.impl));
}
inline DataRow DataRow::addString(/*1Ab*/const char * string)
{
   return DataRow(DataRow_addString(impl, /*5Ge*/string));
}
template<typename... Args> inline DataRow DataRow::addStringf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   return DataRow(DataRow_addStringf(impl, /*5Ge*/format, /*5Ae*/args...));
}
inline void DataRow::edit(/*1Ab*/DataField & field)
{
   DataRow_edit(impl, /*5De*/field.impl);
}
inline DataRow DataRow::findRow(/*1Ab*/int64 tag)
{
   return DataRow(DataRow_findRow(impl, /*5Ge*/tag));
}
inline DataRow DataRow::findSubRow(/*1Ab*/int64 tag)
{
   return DataRow(DataRow_findSubRow(impl, /*5Ge*/tag));
}
inline any_object DataRow::getData(/*1Ab*/DataField & field)
{
   return DataRow_getData(impl, /*5De*/field.impl);
}
inline DataRow DataRow::getNextRow()
{
   return DataRow(DataRow_getNextRow(impl));
}
inline DataRow DataRow::getPrevRow()
{
   return DataRow(DataRow_getPrevRow(impl));
}
inline void DataRow::move(/*1Ab*/DataRow & after)
{
   DataRow_move(impl, /*5De*/after.impl);
}
inline void * DataRow::setData(/*1Ab*/DataField & field, /*1Ab*/any_object newData)
{
   return DataRow_setData(impl, /*5De*/field.impl, /*5Ge*/newData);
}
inline void DataRow::sortSubRows(/*1Ab*/bool scrollToCurrent)
{
   DataRow_sortSubRows(impl, /*5Ee*/(C(bool))scrollToCurrent);
}
inline void DataRow::unsetData(/*1Ab*/DataField & field)
{
   DataRow_unsetData(impl, /*5De*/field.impl);
}


// property callers: DataRow::tag
// (normal::int64)

/*nstSet*/inline /*0H*/int64 DataRow::tag_Prop::operator= (/*0H*/int64 v)
{
   SELF(DataRow, tag);
   DataRow_set_tag(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DataRow::tag_Prop & DataRow::tag_Prop::operator= (DataRow::tag_Prop & prop)
{
   SELF(DataRow, tag);
   /*0H*/int64 v = prop;
   DataRow_set_tag(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DataRow::tag_Prop::operator /*0I*/int64 () const
{
   SELF(DataRow, tag);
   return DataRow_get_tag(self ? self->impl : null);
}

// property callers: DataRow::previous   // get only
// (normal::normal)

/*regGet*/inline DataRow::previous_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DataRow, previous);
   C(Instance) i = DataRow_get_previous(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DataRow::previous_Prop::operator /*0D*/-> () const
{
   SELF(DataRow, previous);
   C(Instance) i = DataRow_get_previous(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DataRow::previous_Prop::operator /*0E*/DataRow () const
{
   SELF(DataRow, previous);
   C(Instance) i = DataRow_get_previous(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DataRow::previous_Prop::operator /*0F*/DataRow* () const
{
   SELF(DataRow, previous);
   C(Instance) i = DataRow_get_previous(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: DataRow::next   // get only
// (normal::normal)

/*regGet*/inline DataRow::next_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DataRow, next);
   C(Instance) i = DataRow_get_next(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DataRow::next_Prop::operator /*0D*/-> () const
{
   SELF(DataRow, next);
   C(Instance) i = DataRow_get_next(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DataRow::next_Prop::operator /*0E*/DataRow () const
{
   SELF(DataRow, next);
   C(Instance) i = DataRow_get_next(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DataRow::next_Prop::operator /*0F*/DataRow* () const
{
   SELF(DataRow, next);
   C(Instance) i = DataRow_get_next(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: DataRow::index   // get only
// (normal::int)

/*regGet*/inline DataRow::index_Prop::operator /*0I*/int () const
{
   SELF(DataRow, index);
   return DataRow_get_index(self ? self->impl : null);
}

// property callers: DataRow::string
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * DataRow::string_Prop::operator= (/*0H*/const char * v)
{
   SELF(DataRow, string);
   DataRow_set_string(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DataRow::string_Prop & DataRow::string_Prop::operator= (DataRow::string_Prop & prop)
{
   SELF(DataRow, string);
   /*0H*/const char * v = prop;
   DataRow_set_string(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DataRow::string_Prop::operator /*0I*/const char * () const
{
   SELF(DataRow, string);
   return DataRow_get_string(self ? self->impl : null);
}

// property callers: DataRow::isHeader
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataRow::isHeader_Prop::operator= (/*0H*/bool v)
{
   SELF(DataRow, isHeader);
   DataRow_set_isHeader(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DataRow::isHeader_Prop & DataRow::isHeader_Prop::operator= (DataRow::isHeader_Prop & prop)
{
   SELF(DataRow, isHeader);
   /*0H*/bool v = prop;
   DataRow_set_isHeader(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DataRow::isHeader_Prop::operator /*0I*/bool () const
{
   SELF(DataRow, isHeader);
   return (bool)DataRow_get_isHeader(self ? self->impl : null);
}

// property callers: DataRow::icon
// (normal::normal)

/*nstSet*/inline /*0A*/const BitmapResource & DataRow::icon_Prop::operator= (/*0A*/const BitmapResource & v)
{
   SELF(DataRow, icon);
   DataRow_set_icon(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline DataRow::icon_Prop & DataRow::icon_Prop::operator= (DataRow::icon_Prop & prop)
{
   SELF(DataRow, icon);
   /*0A*/const BitmapResource & v = prop;
   DataRow_set_icon(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const BitmapResource * DataRow::icon_Prop::operator= (/*0C*/const BitmapResource * v)
{
   SELF(DataRow, icon);
   DataRow_set_icon(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline DataRow::icon_Prop::operator /*0B*/TIH<BitmapResource> () const
{
   SELF(DataRow, icon);
   C(Instance) i = DataRow_get_icon(self ? self->impl : null);
   TIH<BitmapResource> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<BitmapResource> DataRow::icon_Prop::operator /*0D*/-> () const
{
   SELF(DataRow, icon);
   C(Instance) i = DataRow_get_icon(self ? self->impl : null);
   TIH<BitmapResource> holder(i);
   return holder;
}
/*regGet*/inline DataRow::icon_Prop::operator /*0E*/BitmapResource () const
{
   SELF(DataRow, icon);
   C(Instance) i = DataRow_get_icon(self ? self->impl : null);
   return BitmapResource(i);
}
/*regGet*/inline DataRow::icon_Prop::operator /*0F*/BitmapResource* () const
{
   SELF(DataRow, icon);
   C(Instance) i = DataRow_get_icon(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (BitmapResource *)INSTANCEL(i, i->_class) : (BitmapResource *)0;
}

// property callers: DataRow::collapsed
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataRow::collapsed_Prop::operator= (/*0H*/bool v)
{
   SELF(DataRow, collapsed);
   DataRow_set_collapsed(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DataRow::collapsed_Prop & DataRow::collapsed_Prop::operator= (DataRow::collapsed_Prop & prop)
{
   SELF(DataRow, collapsed);
   /*0H*/bool v = prop;
   DataRow_set_collapsed(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DataRow::collapsed_Prop::operator /*0I*/bool () const
{
   SELF(DataRow, collapsed);
   return (bool)DataRow_get_collapsed(self ? self->impl : null);
}

// property callers: DataRow::selected
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DataRow::selected_Prop::operator= (/*0H*/bool v)
{
   SELF(DataRow, selected);
   DataRow_set_selected(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DataRow::selected_Prop & DataRow::selected_Prop::operator= (DataRow::selected_Prop & prop)
{
   SELF(DataRow, selected);
   /*0H*/bool v = prop;
   DataRow_set_selected(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DataRow::selected_Prop::operator /*0I*/bool () const
{
   SELF(DataRow, selected);
   return (bool)DataRow_get_selected(self ? self->impl : null);
}

// property callers: DataRow::parent
// (normal::normal)

/*nstSet*/inline /*0A*/const DataRow & DataRow::parent_Prop::operator= (/*0A*/const DataRow & v)
{
   SELF(DataRow, parent);
   DataRow_set_parent(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline DataRow::parent_Prop & DataRow::parent_Prop::operator= (DataRow::parent_Prop & prop)
{
   SELF(DataRow, parent);
   /*0A*/const DataRow & v = prop;
   DataRow_set_parent(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const DataRow * DataRow::parent_Prop::operator= (/*0C*/const DataRow * v)
{
   SELF(DataRow, parent);
   DataRow_set_parent(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline DataRow::parent_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DataRow, parent);
   C(Instance) i = DataRow_get_parent(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DataRow::parent_Prop::operator /*0D*/-> () const
{
   SELF(DataRow, parent);
   C(Instance) i = DataRow_get_parent(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DataRow::parent_Prop::operator /*0E*/DataRow () const
{
   SELF(DataRow, parent);
   C(Instance) i = DataRow_get_parent(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DataRow::parent_Prop::operator /*0F*/DataRow* () const
{
   SELF(DataRow, parent);
   C(Instance) i = DataRow_get_parent(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: DataRow::lastRow   // get only
// (normal::normal)

/*regGet*/inline DataRow::lastRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DataRow, lastRow);
   C(Instance) i = DataRow_get_lastRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DataRow::lastRow_Prop::operator /*0D*/-> () const
{
   SELF(DataRow, lastRow);
   C(Instance) i = DataRow_get_lastRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DataRow::lastRow_Prop::operator /*0E*/DataRow () const
{
   SELF(DataRow, lastRow);
   C(Instance) i = DataRow_get_lastRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DataRow::lastRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(DataRow, lastRow);
   C(Instance) i = DataRow_get_lastRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: DataRow::firstRow   // get only
// (normal::normal)

/*regGet*/inline DataRow::firstRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DataRow, firstRow);
   C(Instance) i = DataRow_get_firstRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DataRow::firstRow_Prop::operator /*0D*/-> () const
{
   SELF(DataRow, firstRow);
   C(Instance) i = DataRow_get_firstRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DataRow::firstRow_Prop::operator /*0E*/DataRow () const
{
   SELF(DataRow, firstRow);
   C(Instance) i = DataRow_get_firstRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DataRow::firstRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(DataRow, firstRow);
   C(Instance) i = DataRow_get_firstRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

inline DirectoriesBox::DirectoriesBox(bool browsing) : DirectoriesBox()
{
   this->browsing = browsing;
}

inline DirectoriesBox::DirectoriesBox_notifyModified_Functor::FunctionType DirectoriesBox::DirectoriesBox_notifyModified_Functor::operator= (FunctionType func)
{
   SELF(DirectoriesBox, notifyModified);
   if(self->vTbl == DirectoriesBox::_cpp_class.vTbl)
   {
      uint size = DirectoriesBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DirectoriesBox::DirectoriesBox_notifyModified_Functor::FunctionType, size);
      memcpy(self->vTbl, DirectoriesBox::_cpp_class.vTbl, sizeof(DirectoriesBox::DirectoriesBox_notifyModified_Functor::FunctionType) * size);
   }
   ((DirectoriesBox::DirectoriesBox_notifyModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(DirectoriesBox, notifyModified)] = func;
   return func;
}
inline bool DirectoriesBox::DirectoriesBox_notifyModified_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/DirectoriesBox & dirsBox)
{
   SELF(DirectoriesBox, notifyModified);
   return (bool)DirectoriesBox_notifyModified(self ? self->impl : (C(DirectoriesBox))null, o_.impl, /*7Al*/dirsBox.impl);
}
// inline void DirectoriesBox::register_notifyModified(CPPClass & cl, DirectoriesBox::DirectoriesBox_notifyModified_Functor::FunctionType func)
// {
//    ((DirectoriesBox::DirectoriesBox_notifyModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DirectoriesBox, notifyModified)] = func;
// }

inline DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::FunctionType DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::operator= (FunctionType func)
{
   SELF(DirectoriesBox, notifyPathBoxModified);
   if(self->vTbl == DirectoriesBox::_cpp_class.vTbl)
   {
      uint size = DirectoriesBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::FunctionType, size);
      memcpy(self->vTbl, DirectoriesBox::_cpp_class.vTbl, sizeof(DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::FunctionType) * size);
   }
   ((DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(DirectoriesBox, notifyPathBoxModified)] = func;
   return func;
}
inline bool DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/DirectoriesBox & dirsBox, /*6Fj*/PathBox & pathBox)
{
   SELF(DirectoriesBox, notifyPathBoxModified);
   return (bool)DirectoriesBox_notifyPathBoxModified(self ? self->impl : (C(DirectoriesBox))null, o_.impl, /*7Al*/dirsBox.impl, /*7Al*/pathBox.impl);
}
// inline void DirectoriesBox::register_notifyPathBoxModified(CPPClass & cl, DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::FunctionType func)
// {
//    ((DirectoriesBox::DirectoriesBox_notifyPathBoxModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DirectoriesBox, notifyPathBoxModified)] = func;
// }

inline DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::FunctionType DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::operator= (FunctionType func)
{
   SELF(DirectoriesBox, onBrowsedDir);
   if(self->vTbl == DirectoriesBox::_cpp_class.vTbl)
   {
      uint size = DirectoriesBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::FunctionType, size);
      memcpy(self->vTbl, DirectoriesBox::_cpp_class.vTbl, sizeof(DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::FunctionType) * size);
   }
   ((DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::FunctionType *)self->vTbl)[M_VTBLID(DirectoriesBox, onBrowsedDir)] = func;
   return func;
}
inline bool DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::operator()( /*6Fj*/char ** directory)
{
   SELF(DirectoriesBox, onBrowsedDir);
   return (bool)DirectoriesBox_onBrowsedDir(self ? self->impl : (C(DirectoriesBox))null, /*7Al*/directory);
}
// inline void DirectoriesBox::register_onBrowsedDir(CPPClass & cl, DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::FunctionType func)
// {
//    ((DirectoriesBox::DirectoriesBox_onBrowsedDir_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DirectoriesBox, onBrowsedDir)] = func;
// }

inline DirectoriesBox::DirectoriesBox_onChangedDir_Functor::FunctionType DirectoriesBox::DirectoriesBox_onChangedDir_Functor::operator= (FunctionType func)
{
   SELF(DirectoriesBox, onChangedDir);
   if(self->vTbl == DirectoriesBox::_cpp_class.vTbl)
   {
      uint size = DirectoriesBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DirectoriesBox::DirectoriesBox_onChangedDir_Functor::FunctionType, size);
      memcpy(self->vTbl, DirectoriesBox::_cpp_class.vTbl, sizeof(DirectoriesBox::DirectoriesBox_onChangedDir_Functor::FunctionType) * size);
   }
   ((DirectoriesBox::DirectoriesBox_onChangedDir_Functor::FunctionType *)self->vTbl)[M_VTBLID(DirectoriesBox, onChangedDir)] = func;
   return func;
}
inline bool DirectoriesBox::DirectoriesBox_onChangedDir_Functor::operator()( /*6Fj*/char ** directory)
{
   SELF(DirectoriesBox, onChangedDir);
   return (bool)DirectoriesBox_onChangedDir(self ? self->impl : (C(DirectoriesBox))null, /*7Al*/directory);
}
// inline void DirectoriesBox::register_onChangedDir(CPPClass & cl, DirectoriesBox::DirectoriesBox_onChangedDir_Functor::FunctionType func)
// {
//    ((DirectoriesBox::DirectoriesBox_onChangedDir_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DirectoriesBox, onChangedDir)] = func;
// }

inline DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::operator= (FunctionType func)
{
   SELF(DirectoriesBox, onPrepareBrowseDir);
   if(self->vTbl == DirectoriesBox::_cpp_class.vTbl)
   {
      uint size = DirectoriesBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType, size);
      memcpy(self->vTbl, DirectoriesBox::_cpp_class.vTbl, sizeof(DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType) * size);
   }
   ((DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType *)self->vTbl)[M_VTBLID(DirectoriesBox, onPrepareBrowseDir)] = func;
   return func;
}
inline bool DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::operator()( /*6Fj*/char ** directory)
{
   SELF(DirectoriesBox, onPrepareBrowseDir);
   return (bool)DirectoriesBox_onPrepareBrowseDir(self ? self->impl : (C(DirectoriesBox))null, /*7Al*/directory);
}
// inline void DirectoriesBox::register_onPrepareBrowseDir(CPPClass & cl, DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType func)
// {
//    ((DirectoriesBox::DirectoriesBox_onPrepareBrowseDir_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DirectoriesBox, onPrepareBrowseDir)] = func;
// }



// property callers: DirectoriesBox::strings
// (normal::normal)

/*nstSet*/inline /*0A*/const TArray<C(String) _ARG int _ARG C(String)> & DirectoriesBox::strings_Prop::operator= (/*0A*/const TArray<C(String) _ARG int _ARG C(String)> & v)
{
   SELF(DirectoriesBox, strings);
   DirectoriesBox_set_strings(self ? self->impl : null, ((Instance *)&v)->impl);
   return v;
}

/*regSet*/inline DirectoriesBox::strings_Prop & DirectoriesBox::strings_Prop::operator= (DirectoriesBox::strings_Prop & prop)
{
   SELF(DirectoriesBox, strings);
   /*0A*/const TArray<C(String) _ARG int _ARG C(String)> & v = prop;
   DirectoriesBox_set_strings(self ? self->impl : null, ((Instance *)&v)->impl);
   return prop;
}
/*nstSet*/inline /*0C*/const TArray<C(String) _ARG int _ARG C(String)> * DirectoriesBox::strings_Prop::operator= (/*0C*/const TArray<C(String) _ARG int _ARG C(String)> * v)
{
   SELF(DirectoriesBox, strings);
   DirectoriesBox_set_strings(self ? self->impl : null, v ? ((Instance *)v)->impl : null);
   return v;
}

/*regGet*/inline DirectoriesBox::strings_Prop::operator /*0B*/TIH<TArray<C(String) _ARG int _ARG C(String)>> () const
{
   SELF(DirectoriesBox, strings);
   C(Instance) i = DirectoriesBox_get_strings(self ? self->impl : null);
   TIH<TArray<C(String) _ARG int _ARG C(String)>> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<TArray<C(String) _ARG int _ARG C(String)>> DirectoriesBox::strings_Prop::operator /*0D*/-> () const
{
   SELF(DirectoriesBox, strings);
   C(Instance) i = DirectoriesBox_get_strings(self ? self->impl : null);
   TIH<TArray<C(String) _ARG int _ARG C(String)>> holder(i);
   return holder;
}
/*regGet*/inline DirectoriesBox::strings_Prop::operator /*0E*/TArray<C(String) _ARG int _ARG C(String)> () const
{
   SELF(DirectoriesBox, strings);
   C(Instance) i = DirectoriesBox_get_strings(self ? self->impl : null);
   return TArray<C(String) _ARG int _ARG C(String)>(i);
}
/*regGet*/inline DirectoriesBox::strings_Prop::operator /*0F*/TArray<C(String) _ARG int _ARG C(String)>* () const
{
   SELF(DirectoriesBox, strings);
   C(Instance) i = DirectoriesBox_get_strings(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (TArray<C(String) _ARG int _ARG C(String)> *)INSTANCEL(i, i->_class) : (TArray<C(String) _ARG int _ARG C(String)> *)0;
}

// property callers: DirectoriesBox::browseDialog
// (normal::normal)

/*nstSet*/inline /*0A*/const FileDialog & DirectoriesBox::browseDialog_Prop::operator= (/*0A*/const FileDialog & v)
{
   SELF(DirectoriesBox, browseDialog);
   DirectoriesBox_set_browseDialog(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline DirectoriesBox::browseDialog_Prop & DirectoriesBox::browseDialog_Prop::operator= (DirectoriesBox::browseDialog_Prop & prop)
{
   SELF(DirectoriesBox, browseDialog);
   /*0A*/const FileDialog & v = prop;
   DirectoriesBox_set_browseDialog(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const FileDialog * DirectoriesBox::browseDialog_Prop::operator= (/*0C*/const FileDialog * v)
{
   SELF(DirectoriesBox, browseDialog);
   DirectoriesBox_set_browseDialog(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline DirectoriesBox::browseDialog_Prop::operator /*0B*/TIH<FileDialog> () const
{
   SELF(DirectoriesBox, browseDialog);
   C(Instance) i = DirectoriesBox_get_browseDialog(self ? self->impl : null);
   TIH<FileDialog> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<FileDialog> DirectoriesBox::browseDialog_Prop::operator /*0D*/-> () const
{
   SELF(DirectoriesBox, browseDialog);
   C(Instance) i = DirectoriesBox_get_browseDialog(self ? self->impl : null);
   TIH<FileDialog> holder(i);
   return holder;
}
/*regGet*/inline DirectoriesBox::browseDialog_Prop::operator /*0E*/FileDialog () const
{
   SELF(DirectoriesBox, browseDialog);
   C(Instance) i = DirectoriesBox_get_browseDialog(self ? self->impl : null);
   return FileDialog(i);
}
/*regGet*/inline DirectoriesBox::browseDialog_Prop::operator /*0F*/FileDialog* () const
{
   SELF(DirectoriesBox, browseDialog);
   C(Instance) i = DirectoriesBox_get_browseDialog(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (FileDialog *)INSTANCEL(i, i->_class) : (FileDialog *)0;
}

// property callers: DirectoriesBox::baseBrowsePath
// (normal::string)

/*nstSet*/inline /*0H*/char * DirectoriesBox::baseBrowsePath_Prop::operator= (/*0H*/char * v)
{
   SELF(DirectoriesBox, baseBrowsePath);
   DirectoriesBox_set_baseBrowsePath(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DirectoriesBox::baseBrowsePath_Prop & DirectoriesBox::baseBrowsePath_Prop::operator= (DirectoriesBox::baseBrowsePath_Prop & prop)
{
   SELF(DirectoriesBox, baseBrowsePath);
   /*0H*/char * v = prop;
   DirectoriesBox_set_baseBrowsePath(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DirectoriesBox::baseBrowsePath_Prop::operator /*0I*/char * () const
{
   SELF(DirectoriesBox, baseBrowsePath);
   return DirectoriesBox_get_baseBrowsePath(self ? self->impl : null);
}


// member accessors: DirectoriesBox::browsing
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DirectoriesBox::browsing_Prop::operator= (/*0H*/bool v)
{
   SELF(DirectoriesBox, browsing);
   IPTR(self->impl, DirectoriesBox)->browsing = (C(bool))v;
   return v;
}

/*regSet*/inline DirectoriesBox::browsing_Prop & DirectoriesBox::browsing_Prop::operator= (DirectoriesBox::browsing_Prop & prop)
{
   SELF(DirectoriesBox, browsing);
   /*0H*/bool v = prop;
   IPTR(self->impl, DirectoriesBox)->browsing = (C(bool))v;
   return prop;
}
/*regGet*/inline DirectoriesBox::browsing_Prop::operator /*0I*/bool () const
{
   SELF(DirectoriesBox, browsing);
   return self ? (bool)IPTR(self->impl, DirectoriesBox)->browsing : (bool)0;
}

// member accessors: DirectoriesBox::add
// (normal::normal)

/*nstSet*/inline /*0H*/Button DirectoriesBox::add_Prop::operator= (/*0H*/Button v)
{
   SELF(DirectoriesBox, add);
   IPTR(self->impl, DirectoriesBox)->add = v.impl;
   return v;
}

/*regSet*/inline DirectoriesBox::add_Prop & DirectoriesBox::add_Prop::operator= (DirectoriesBox::add_Prop & prop)
{
   SELF(DirectoriesBox, add);
   /*0H*/Button v = prop;
   IPTR(self->impl, DirectoriesBox)->add = v.impl;
   return prop;
}
/*regGet*/inline DirectoriesBox::add_Prop::operator /*0I*/Button () const
{
   SELF(DirectoriesBox, add);
   Button value(IPTR(self->impl, DirectoriesBox)->add, DirectoriesBox::_cpp_class);
   return value;
}

// member accessors: DirectoriesBox::remove
// (normal::normal)

/*nstSet*/inline /*0H*/Button DirectoriesBox::remove_Prop::operator= (/*0H*/Button v)
{
   SELF(DirectoriesBox, remove);
   IPTR(self->impl, DirectoriesBox)->remove = v.impl;
   return v;
}

/*regSet*/inline DirectoriesBox::remove_Prop & DirectoriesBox::remove_Prop::operator= (DirectoriesBox::remove_Prop & prop)
{
   SELF(DirectoriesBox, remove);
   /*0H*/Button v = prop;
   IPTR(self->impl, DirectoriesBox)->remove = v.impl;
   return prop;
}
/*regGet*/inline DirectoriesBox::remove_Prop::operator /*0I*/Button () const
{
   SELF(DirectoriesBox, remove);
   Button value(IPTR(self->impl, DirectoriesBox)->remove, DirectoriesBox::_cpp_class);
   return value;
}

// member accessors: DirectoriesBox::up
// (normal::normal)

/*nstSet*/inline /*0H*/RepButton DirectoriesBox::up_Prop::operator= (/*0H*/RepButton v)
{
   SELF(DirectoriesBox, up);
   IPTR(self->impl, DirectoriesBox)->up = v.impl;
   return v;
}

/*regSet*/inline DirectoriesBox::up_Prop & DirectoriesBox::up_Prop::operator= (DirectoriesBox::up_Prop & prop)
{
   SELF(DirectoriesBox, up);
   /*0H*/RepButton v = prop;
   IPTR(self->impl, DirectoriesBox)->up = v.impl;
   return prop;
}
/*regGet*/inline DirectoriesBox::up_Prop::operator /*0I*/RepButton () const
{
   SELF(DirectoriesBox, up);
   RepButton value(IPTR(self->impl, DirectoriesBox)->up, DirectoriesBox::_cpp_class);
   return value;
}

// member accessors: DirectoriesBox::down
// (normal::normal)

/*nstSet*/inline /*0H*/RepButton DirectoriesBox::down_Prop::operator= (/*0H*/RepButton v)
{
   SELF(DirectoriesBox, down);
   IPTR(self->impl, DirectoriesBox)->down = v.impl;
   return v;
}

/*regSet*/inline DirectoriesBox::down_Prop & DirectoriesBox::down_Prop::operator= (DirectoriesBox::down_Prop & prop)
{
   SELF(DirectoriesBox, down);
   /*0H*/RepButton v = prop;
   IPTR(self->impl, DirectoriesBox)->down = v.impl;
   return prop;
}
/*regGet*/inline DirectoriesBox::down_Prop::operator /*0I*/RepButton () const
{
   SELF(DirectoriesBox, down);
   RepButton value(IPTR(self->impl, DirectoriesBox)->down, DirectoriesBox::_cpp_class);
   return value;
}

// member accessors: DirectoriesBox::list
// (normal::normal)

/*nstSet*/inline /*0H*/ListBox DirectoriesBox::list_Prop::operator= (/*0H*/ListBox v)
{
   SELF(DirectoriesBox, list);
   IPTR(self->impl, DirectoriesBox)->list = v.impl;
   return v;
}

/*regSet*/inline DirectoriesBox::list_Prop & DirectoriesBox::list_Prop::operator= (DirectoriesBox::list_Prop & prop)
{
   SELF(DirectoriesBox, list);
   /*0H*/ListBox v = prop;
   IPTR(self->impl, DirectoriesBox)->list = v.impl;
   return prop;
}
/*regGet*/inline DirectoriesBox::list_Prop::operator /*0I*/ListBox () const
{
   SELF(DirectoriesBox, list);
   ListBox value(IPTR(self->impl, DirectoriesBox)->list, DirectoriesBox::_cpp_class);
   return value;
}

// member accessors: DirectoriesBox::dirField
// (normal::normal)

/*nstSet*/inline /*0H*/DataField DirectoriesBox::dirField_Prop::operator= (/*0H*/DataField v)
{
   SELF(DirectoriesBox, dirField);
   IPTR(self->impl, DirectoriesBox)->dirField = v.impl;
   return v;
}

/*regSet*/inline DirectoriesBox::dirField_Prop & DirectoriesBox::dirField_Prop::operator= (DirectoriesBox::dirField_Prop & prop)
{
   SELF(DirectoriesBox, dirField);
   /*0H*/DataField v = prop;
   IPTR(self->impl, DirectoriesBox)->dirField = v.impl;
   return prop;
}
/*regGet*/inline DirectoriesBox::dirField_Prop::operator /*0I*/DataField () const
{
   SELF(DirectoriesBox, dirField);
   DataField value(IPTR(self->impl, DirectoriesBox)->dirField, DirectoriesBox::_cpp_class);
   return value;
}

inline DropBox::DropBox(bool activeStipple, bool showButton = (bool)0, Alignment alignment = (Alignment)0, bool noHighlight = (bool)0, bool activeColor = (bool)0) : DropBox()
{
   this->activeStipple = activeStipple;
   this->showButton = showButton;
   this->alignment = alignment;
   this->noHighlight = noHighlight;
   this->activeColor = activeColor;
}

inline DropBox::DropBox_notifyClose_Functor::FunctionType DropBox::DropBox_notifyClose_Functor::operator= (FunctionType func)
{
   SELF(DropBox, notifyClose);
   if(self->vTbl == DropBox::_cpp_class.vTbl)
   {
      uint size = DropBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DropBox::DropBox_notifyClose_Functor::FunctionType, size);
      memcpy(self->vTbl, DropBox::_cpp_class.vTbl, sizeof(DropBox::DropBox_notifyClose_Functor::FunctionType) * size);
   }
   ((DropBox::DropBox_notifyClose_Functor::FunctionType *)self->vTbl)[M_VTBLID(DropBox, notifyClose)] = func;
   return func;
}
inline bool DropBox::DropBox_notifyClose_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox)
{
   SELF(DropBox, notifyClose);
   return (bool)DropBox_notifyClose(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl);
}
// inline void DropBox::register_notifyClose(CPPClass & cl, DropBox::DropBox_notifyClose_Functor::FunctionType func)
// {
//    ((DropBox::DropBox_notifyClose_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DropBox, notifyClose)] = func;
// }

inline DropBox::DropBox_notifyHighlight_Functor::FunctionType DropBox::DropBox_notifyHighlight_Functor::operator= (FunctionType func)
{
   SELF(DropBox, notifyHighlight);
   if(self->vTbl == DropBox::_cpp_class.vTbl)
   {
      uint size = DropBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DropBox::DropBox_notifyHighlight_Functor::FunctionType, size);
      memcpy(self->vTbl, DropBox::_cpp_class.vTbl, sizeof(DropBox::DropBox_notifyHighlight_Functor::FunctionType) * size);
   }
   ((DropBox::DropBox_notifyHighlight_Functor::FunctionType *)self->vTbl)[M_VTBLID(DropBox, notifyHighlight)] = func;
   return func;
}
inline bool DropBox::DropBox_notifyHighlight_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods)
{
   SELF(DropBox, notifyHighlight);
   return (bool)DropBox_notifyHighlight(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void DropBox::register_notifyHighlight(CPPClass & cl, DropBox::DropBox_notifyHighlight_Functor::FunctionType func)
// {
//    ((DropBox::DropBox_notifyHighlight_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DropBox, notifyHighlight)] = func;
// }

inline DropBox::DropBox_notifySelect_Functor::FunctionType DropBox::DropBox_notifySelect_Functor::operator= (FunctionType func)
{
   SELF(DropBox, notifySelect);
   if(self->vTbl == DropBox::_cpp_class.vTbl)
   {
      uint size = DropBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DropBox::DropBox_notifySelect_Functor::FunctionType, size);
      memcpy(self->vTbl, DropBox::_cpp_class.vTbl, sizeof(DropBox::DropBox_notifySelect_Functor::FunctionType) * size);
   }
   ((DropBox::DropBox_notifySelect_Functor::FunctionType *)self->vTbl)[M_VTBLID(DropBox, notifySelect)] = func;
   return func;
}
inline bool DropBox::DropBox_notifySelect_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods)
{
   SELF(DropBox, notifySelect);
   return (bool)DropBox_notifySelect(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void DropBox::register_notifySelect(CPPClass & cl, DropBox::DropBox_notifySelect_Functor::FunctionType func)
// {
//    ((DropBox::DropBox_notifySelect_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DropBox, notifySelect)] = func;
// }

inline DropBox::DropBox_notifyTextEntry_Functor::FunctionType DropBox::DropBox_notifyTextEntry_Functor::operator= (FunctionType func)
{
   SELF(DropBox, notifyTextEntry);
   if(self->vTbl == DropBox::_cpp_class.vTbl)
   {
      uint size = DropBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DropBox::DropBox_notifyTextEntry_Functor::FunctionType, size);
      memcpy(self->vTbl, DropBox::_cpp_class.vTbl, sizeof(DropBox::DropBox_notifyTextEntry_Functor::FunctionType) * size);
   }
   ((DropBox::DropBox_notifyTextEntry_Functor::FunctionType *)self->vTbl)[M_VTBLID(DropBox, notifyTextEntry)] = func;
   return func;
}
inline bool DropBox::DropBox_notifyTextEntry_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/DropBox & dropBox, /*6Fj*/const char * string, /*6Fj*/bool confirmed)
{
   SELF(DropBox, notifyTextEntry);
   return (bool)DropBox_notifyTextEntry(self ? self->impl : (C(DropBox))null, o_.impl, /*7Al*/dropBox.impl, /*7Al*/string, /*7Al*/(C(bool))confirmed);
}
// inline void DropBox::register_notifyTextEntry(CPPClass & cl, DropBox::DropBox_notifyTextEntry_Functor::FunctionType func)
// {
//    ((DropBox::DropBox_notifyTextEntry_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DropBox, notifyTextEntry)] = func;
// }

inline DropBox::DropBox_onCloseDropDown_Functor::FunctionType DropBox::DropBox_onCloseDropDown_Functor::operator= (FunctionType func)
{
   SELF(DropBox, onCloseDropDown);
   if(self->vTbl == DropBox::_cpp_class.vTbl)
   {
      uint size = DropBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DropBox::DropBox_onCloseDropDown_Functor::FunctionType, size);
      memcpy(self->vTbl, DropBox::_cpp_class.vTbl, sizeof(DropBox::DropBox_onCloseDropDown_Functor::FunctionType) * size);
   }
   ((DropBox::DropBox_onCloseDropDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(DropBox, onCloseDropDown)] = func;
   return func;
}
inline void DropBox::DropBox_onCloseDropDown_Functor::operator()( /*6Fj*/Window & pullDown)
{
   SELF(DropBox, onCloseDropDown);
   DropBox_onCloseDropDown(self ? self->impl : (C(DropBox))null, /*7Al*/pullDown.impl);
}
// inline void DropBox::register_onCloseDropDown(CPPClass & cl, DropBox::DropBox_onCloseDropDown_Functor::FunctionType func)
// {
//    ((DropBox::DropBox_onCloseDropDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DropBox, onCloseDropDown)] = func;
// }

inline DropBox::DropBox_onDropDown_Functor::FunctionType DropBox::DropBox_onDropDown_Functor::operator= (FunctionType func)
{
   SELF(DropBox, onDropDown);
   if(self->vTbl == DropBox::_cpp_class.vTbl)
   {
      uint size = DropBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DropBox::DropBox_onDropDown_Functor::FunctionType, size);
      memcpy(self->vTbl, DropBox::_cpp_class.vTbl, sizeof(DropBox::DropBox_onDropDown_Functor::FunctionType) * size);
   }
   ((DropBox::DropBox_onDropDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(DropBox, onDropDown)] = func;
   return func;
}
inline Window * DropBox::DropBox_onDropDown_Functor::operator()( )
{
   SELF(DropBox, onDropDown);
   C(Window) retWindow = DropBox_onDropDown(self ? self->impl : (C(DropBox))null);
      return BINDINGS_CLASS(retWindow) ? (Window *)INSTANCEL(retWindow, retWindow->_class) : (Window *)0;
}
// inline void DropBox::register_onDropDown(CPPClass & cl, DropBox::DropBox_onDropDown_Functor::FunctionType func)
// {
//    ((DropBox::DropBox_onDropDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DropBox, onDropDown)] = func;
// }


inline void DropBox::addField(/*1Ab*/DataField & field)
{
   DropBox_addField(impl, /*5De*/field.impl);
}
inline DataRow DropBox::addRow()
{
   return DataRow(DropBox_addRow(impl));
}
inline DataRow DropBox::addRowAfter(/*1Ab*/DataRow & after)
{
   return DataRow(DropBox_addRowAfter(impl, /*5De*/after.impl));
}
inline DataRow DropBox::addString(/*1Ab*/const char * string)
{
   return DataRow(DropBox_addString(impl, /*5Ge*/string));
}
template<typename... Args> inline DataRow DropBox::addStringf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   return DataRow(DropBox_addStringf(impl, /*5Ge*/format, /*5Ae*/args...));
}
inline void DropBox::clear()
{
   DropBox_clear(impl);
}
inline void DropBox::deleteRow(/*1Ab*/DataRow & row)
{
   DropBox_deleteRow(impl, /*5De*/row.impl);
}
inline DataRow DropBox::findRow(/*1Ab*/int64 tag)
{
   return DataRow(DropBox_findRow(impl, /*5Ge*/tag));
}
inline DataRow DropBox::findSubRow(/*1Ab*/int64 tag)
{
   return DataRow(DropBox_findSubRow(impl, /*5Ge*/tag));
}
inline any_object DropBox::getData(/*1Ab*/DataField & field)
{
   return DropBox_getData(impl, /*5De*/field.impl);
}
inline int DropBox::getRowCount()
{
   return DropBox_getRowCount(impl);
}
inline int64 DropBox::getTag()
{
   return DropBox_getTag(impl);
}
inline C(bool) DropBox::save()
{
   return DropBox_save(impl);
}
inline void DropBox::selectRow(/*1Ab*/DataRow & row)
{
   DropBox_selectRow(impl, /*5De*/row.impl);
}
inline void * DropBox::setData(/*1Ab*/DataField & field, /*1Ab*/any_object data)
{
   return DropBox_setData(impl, /*5De*/field.impl, /*5Ge*/data);
}
inline void DropBox::sort(/*1Ab*/DataField & field, /*1Ab*/int order)
{
   DropBox_sort(impl, /*5De*/field.impl, /*5Ge*/order);
}


// property callers: DropBox::activeStipple
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DropBox::activeStipple_Prop::operator= (/*0H*/bool v)
{
   SELF(DropBox, activeStipple);
   DropBox_set_activeStipple(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DropBox::activeStipple_Prop & DropBox::activeStipple_Prop::operator= (DropBox::activeStipple_Prop & prop)
{
   SELF(DropBox, activeStipple);
   /*0H*/bool v = prop;
   DropBox_set_activeStipple(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DropBox::activeStipple_Prop::operator /*0I*/bool () const
{
   SELF(DropBox, activeStipple);
   return (bool)DropBox_get_activeStipple(self ? self->impl : null);
}

// property callers: DropBox::showButton
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DropBox::showButton_Prop::operator= (/*0H*/bool v)
{
   SELF(DropBox, showButton);
   DropBox_set_showButton(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DropBox::showButton_Prop & DropBox::showButton_Prop::operator= (DropBox::showButton_Prop & prop)
{
   SELF(DropBox, showButton);
   /*0H*/bool v = prop;
   DropBox_set_showButton(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DropBox::showButton_Prop::operator /*0I*/bool () const
{
   SELF(DropBox, showButton);
   return (bool)DropBox_get_showButton(self ? self->impl : null);
}

// property callers: DropBox::alignment
// (normal::enum|int)

/*nstSet*/inline /*0H*/Alignment DropBox::alignment_Prop::operator= (/*0H*/Alignment v)
{
   SELF(DropBox, alignment);
   DropBox_set_alignment(self ? self->impl : null, (C(Alignment))v);
   return v;
}

/*regSet*/inline DropBox::alignment_Prop & DropBox::alignment_Prop::operator= (DropBox::alignment_Prop & prop)
{
   SELF(DropBox, alignment);
   /*0H*/Alignment v = prop;
   DropBox_set_alignment(self ? self->impl : null, (C(Alignment))v);
   return prop;
}
/*regGet*/inline DropBox::alignment_Prop::operator /*0I*/Alignment () const
{
   SELF(DropBox, alignment);
   return (Alignment)DropBox_get_alignment(self ? self->impl : null);
}

// property callers: DropBox::noHighlight
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DropBox::noHighlight_Prop::operator= (/*0H*/bool v)
{
   SELF(DropBox, noHighlight);
   DropBox_set_noHighlight(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DropBox::noHighlight_Prop & DropBox::noHighlight_Prop::operator= (DropBox::noHighlight_Prop & prop)
{
   SELF(DropBox, noHighlight);
   /*0H*/bool v = prop;
   DropBox_set_noHighlight(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DropBox::noHighlight_Prop::operator /*0I*/bool () const
{
   SELF(DropBox, noHighlight);
   return (bool)DropBox_get_noHighlight(self ? self->impl : null);
}

// property callers: DropBox::activeColor
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DropBox::activeColor_Prop::operator= (/*0H*/bool v)
{
   SELF(DropBox, activeColor);
   DropBox_set_activeColor(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DropBox::activeColor_Prop & DropBox::activeColor_Prop::operator= (DropBox::activeColor_Prop & prop)
{
   SELF(DropBox, activeColor);
   /*0H*/bool v = prop;
   DropBox_set_activeColor(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DropBox::activeColor_Prop::operator /*0I*/bool () const
{
   SELF(DropBox, activeColor);
   return (bool)DropBox_get_activeColor(self ? self->impl : null);
}

// property callers: DropBox::currentRow
// (normal::normal)

/*nstSet*/inline /*0A*/const DataRow & DropBox::currentRow_Prop::operator= (/*0A*/const DataRow & v)
{
   SELF(DropBox, currentRow);
   DropBox_set_currentRow(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline DropBox::currentRow_Prop & DropBox::currentRow_Prop::operator= (DropBox::currentRow_Prop & prop)
{
   SELF(DropBox, currentRow);
   /*0A*/const DataRow & v = prop;
   DropBox_set_currentRow(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const DataRow * DropBox::currentRow_Prop::operator= (/*0C*/const DataRow * v)
{
   SELF(DropBox, currentRow);
   DropBox_set_currentRow(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline DropBox::currentRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DropBox, currentRow);
   C(Instance) i = DropBox_get_currentRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DropBox::currentRow_Prop::operator /*0D*/-> () const
{
   SELF(DropBox, currentRow);
   C(Instance) i = DropBox_get_currentRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DropBox::currentRow_Prop::operator /*0E*/DataRow () const
{
   SELF(DropBox, currentRow);
   C(Instance) i = DropBox_get_currentRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DropBox::currentRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(DropBox, currentRow);
   C(Instance) i = DropBox_get_currentRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: DropBox::firstRow   // get only
// (normal::normal)

/*regGet*/inline DropBox::firstRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DropBox, firstRow);
   C(Instance) i = DropBox_get_firstRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DropBox::firstRow_Prop::operator /*0D*/-> () const
{
   SELF(DropBox, firstRow);
   C(Instance) i = DropBox_get_firstRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DropBox::firstRow_Prop::operator /*0E*/DataRow () const
{
   SELF(DropBox, firstRow);
   C(Instance) i = DropBox_get_firstRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DropBox::firstRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(DropBox, firstRow);
   C(Instance) i = DropBox_get_firstRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: DropBox::lastRow   // get only
// (normal::normal)

/*regGet*/inline DropBox::lastRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(DropBox, lastRow);
   C(Instance) i = DropBox_get_lastRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> DropBox::lastRow_Prop::operator /*0D*/-> () const
{
   SELF(DropBox, lastRow);
   C(Instance) i = DropBox_get_lastRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline DropBox::lastRow_Prop::operator /*0E*/DataRow () const
{
   SELF(DropBox, lastRow);
   C(Instance) i = DropBox_get_lastRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline DropBox::lastRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(DropBox, lastRow);
   C(Instance) i = DropBox_get_lastRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: DropBox::contents
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * DropBox::contents_Prop::operator= (/*0H*/const char * v)
{
   SELF(DropBox, contents);
   DropBox_set_contents(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DropBox::contents_Prop & DropBox::contents_Prop::operator= (DropBox::contents_Prop & prop)
{
   SELF(DropBox, contents);
   /*0H*/const char * v = prop;
   DropBox_set_contents(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DropBox::contents_Prop::operator /*0I*/const char * () const
{
   SELF(DropBox, contents);
   return DropBox_get_contents(self ? self->impl : null);
}

// property callers: DropBox::editText
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DropBox::editText_Prop::operator= (/*0H*/bool v)
{
   SELF(DropBox, editText);
   DropBox_set_editText(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DropBox::editText_Prop & DropBox::editText_Prop::operator= (DropBox::editText_Prop & prop)
{
   SELF(DropBox, editText);
   /*0H*/bool v = prop;
   DropBox_set_editText(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DropBox::editText_Prop::operator /*0I*/bool () const
{
   SELF(DropBox, editText);
   return (bool)DropBox_get_editText(self ? self->impl : null);
}

// property callers: DropBox::editBox   // get only
// (normal::normal)

/*regGet*/inline DropBox::editBox_Prop::operator /*0B*/TIH<EditBox> () const
{
   SELF(DropBox, editBox);
   C(Instance) i = DropBox_get_editBox(self ? self->impl : null);
   TIH<EditBox> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<EditBox> DropBox::editBox_Prop::operator /*0D*/-> () const
{
   SELF(DropBox, editBox);
   C(Instance) i = DropBox_get_editBox(self ? self->impl : null);
   TIH<EditBox> holder(i);
   return holder;
}
/*regGet*/inline DropBox::editBox_Prop::operator /*0E*/EditBox () const
{
   SELF(DropBox, editBox);
   C(Instance) i = DropBox_get_editBox(self ? self->impl : null);
   return EditBox(i);
}
/*regGet*/inline DropBox::editBox_Prop::operator /*0F*/EditBox* () const
{
   SELF(DropBox, editBox);
   C(Instance) i = DropBox_get_editBox(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (EditBox *)INSTANCEL(i, i->_class) : (EditBox *)0;
}

// property callers: DropBox::typingTimeout
// (normal::unit|double)

/*nstSet*/inline /*0H*/Seconds DropBox::typingTimeout_Prop::operator= (/*0H*/Seconds v)
{
   SELF(DropBox, typingTimeout);
   DropBox_set_typingTimeout(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline DropBox::typingTimeout_Prop & DropBox::typingTimeout_Prop::operator= (DropBox::typingTimeout_Prop & prop)
{
   SELF(DropBox, typingTimeout);
   /*0H*/Seconds v = prop;
   DropBox_set_typingTimeout(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline DropBox::typingTimeout_Prop::operator /*0I*/Seconds () const
{
   SELF(DropBox, typingTimeout);
   Seconds value(DropBox_get_typingTimeout(self->impl));
   return value;
}
/*regGet*/inline DropBox::typingTimeout_Prop::operator /*0J*/C(Time) () const
{
   SELF(DropBox, typingTimeout);
   return Seconds(self->typingTimeout);
}

// property callers: DropBox::rowHeight
// (normal::int)

/*nstSet*/inline /*0H*/int DropBox::rowHeight_Prop::operator= (/*0H*/int v)
{
   SELF(DropBox, rowHeight);
   DropBox_set_rowHeight(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DropBox::rowHeight_Prop & DropBox::rowHeight_Prop::operator= (DropBox::rowHeight_Prop & prop)
{
   SELF(DropBox, rowHeight);
   /*0H*/int v = prop;
   DropBox_set_rowHeight(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DropBox::rowHeight_Prop::operator /*0I*/int () const
{
   SELF(DropBox, rowHeight);
   return DropBox_get_rowHeight(self ? self->impl : null);
}

// property callers: DropBox::maxShown
// (normal::int)

/*nstSet*/inline /*0H*/int DropBox::maxShown_Prop::operator= (/*0H*/int v)
{
   SELF(DropBox, maxShown);
   DropBox_set_maxShown(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DropBox::maxShown_Prop & DropBox::maxShown_Prop::operator= (DropBox::maxShown_Prop & prop)
{
   SELF(DropBox, maxShown);
   /*0H*/int v = prop;
   DropBox_set_maxShown(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DropBox::maxShown_Prop::operator /*0I*/int () const
{
   SELF(DropBox, maxShown);
   return DropBox_get_maxShown(self ? self->impl : null);
}

// property callers: DropBox::pullDown   // get only
// (normal::normal)

/*regGet*/inline DropBox::pullDown_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(DropBox, pullDown);
   C(Instance) i = DropBox_get_pullDown(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> DropBox::pullDown_Prop::operator /*0D*/-> () const
{
   SELF(DropBox, pullDown);
   C(Instance) i = DropBox_get_pullDown(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline DropBox::pullDown_Prop::operator /*0E*/Window () const
{
   SELF(DropBox, pullDown);
   C(Instance) i = DropBox_get_pullDown(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline DropBox::pullDown_Prop::operator /*0F*/Window* () const
{
   SELF(DropBox, pullDown);
   C(Instance) i = DropBox_get_pullDown(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: DropBox::showNone
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DropBox::showNone_Prop::operator= (/*0H*/bool v)
{
   SELF(DropBox, showNone);
   DropBox_set_showNone(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DropBox::showNone_Prop & DropBox::showNone_Prop::operator= (DropBox::showNone_Prop & prop)
{
   SELF(DropBox, showNone);
   /*0H*/bool v = prop;
   DropBox_set_showNone(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DropBox::showNone_Prop::operator /*0I*/bool () const
{
   SELF(DropBox, showNone);
   return (bool)DropBox_get_showNone(self ? self->impl : null);
}

// property callers: DropBox::selectionColor
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color DropBox::selectionColor_Prop::operator= (/*0H*/Color v)
{
   SELF(DropBox, selectionColor);
   DropBox_set_selectionColor(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DropBox::selectionColor_Prop & DropBox::selectionColor_Prop::operator= (DropBox::selectionColor_Prop & prop)
{
   SELF(DropBox, selectionColor);
   /*0H*/Color v = prop;
   DropBox_set_selectionColor(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DropBox::selectionColor_Prop::operator /*0I*/Color () const
{
   SELF(DropBox, selectionColor);
   return DropBox_get_selectionColor(self ? self->impl : null);
}

// property callers: DropBox::selectionText
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color DropBox::selectionText_Prop::operator= (/*0H*/Color v)
{
   SELF(DropBox, selectionText);
   DropBox_set_selectionText(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline DropBox::selectionText_Prop & DropBox::selectionText_Prop::operator= (DropBox::selectionText_Prop & prop)
{
   SELF(DropBox, selectionText);
   /*0H*/Color v = prop;
   DropBox_set_selectionText(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline DropBox::selectionText_Prop::operator /*0I*/Color () const
{
   SELF(DropBox, selectionText);
   return DropBox_get_selectionText(self ? self->impl : null);
}

// property callers: DropBox::changeContents
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DropBox::changeContents_Prop::operator= (/*0H*/bool v)
{
   SELF(DropBox, changeContents);
   DropBox_set_changeContents(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline DropBox::changeContents_Prop & DropBox::changeContents_Prop::operator= (DropBox::changeContents_Prop & prop)
{
   SELF(DropBox, changeContents);
   /*0H*/bool v = prop;
   DropBox_set_changeContents(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline DropBox::changeContents_Prop::operator /*0I*/bool () const
{
   SELF(DropBox, changeContents);
   return (bool)DropBox_get_changeContents(self ? self->impl : null);
}

// property callers: DropBox::listBox   // get only
// (normal::normal)

/*regGet*/inline DropBox::listBox_Prop::operator /*0B*/TIH<ListBox> () const
{
   SELF(DropBox, listBox);
   C(Instance) i = DropBox_get_listBox(self ? self->impl : null);
   TIH<ListBox> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<ListBox> DropBox::listBox_Prop::operator /*0D*/-> () const
{
   SELF(DropBox, listBox);
   C(Instance) i = DropBox_get_listBox(self ? self->impl : null);
   TIH<ListBox> holder(i);
   return holder;
}
/*regGet*/inline DropBox::listBox_Prop::operator /*0E*/ListBox () const
{
   SELF(DropBox, listBox);
   C(Instance) i = DropBox_get_listBox(self ? self->impl : null);
   return ListBox(i);
}
/*regGet*/inline DropBox::listBox_Prop::operator /*0F*/ListBox* () const
{
   SELF(DropBox, listBox);
   C(Instance) i = DropBox_get_listBox(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (ListBox *)INSTANCEL(i, i->_class) : (ListBox *)0;
}

// property callers: DropBox::rowCount   // get only
// (normal::int)

/*regGet*/inline DropBox::rowCount_Prop::operator /*0I*/int () const
{
   SELF(DropBox, rowCount);
   return DropBox_get_rowCount(self ? self->impl : null);
}


// member accessors: DropBox::button
// (normal::normal)

/*nstSet*/inline /*0H*/Button DropBox::button_Prop::operator= (/*0H*/Button v)
{
   SELF(DropBox, button);
   IPTR(self->impl, DropBox)->button = v.impl;
   return v;
}

/*regSet*/inline DropBox::button_Prop & DropBox::button_Prop::operator= (DropBox::button_Prop & prop)
{
   SELF(DropBox, button);
   /*0H*/Button v = prop;
   IPTR(self->impl, DropBox)->button = v.impl;
   return prop;
}
/*regGet*/inline DropBox::button_Prop::operator /*0I*/Button () const
{
   SELF(DropBox, button);
   Button value(IPTR(self->impl, DropBox)->button, DropBox::_cpp_class);
   return value;
}

inline EditBox::EditBox(bool textHorzScroll, bool textVertScroll = (bool)0, bool readOnly = (bool)0, bool multiLine = (bool)0, bool freeCaret = (bool)0, bool tabKey = (bool)0, int tabSize = 0, bool tabSelection = (bool)0, bool smartHome = (bool)0, bool autoEmpty = (bool)0, bool noCaret = (bool)0, int maxLineSize = 0, int maxNumLines = 0, bool useTab = (bool)0) : EditBox()
{
   this->textHorzScroll = textHorzScroll;
   this->textVertScroll = textVertScroll;
   this->readOnly = readOnly;
   this->multiLine = multiLine;
   this->freeCaret = freeCaret;
   this->tabKey = tabKey;
   this->tabSize = tabSize;
   this->tabSelection = tabSelection;
   this->smartHome = smartHome;
   this->autoEmpty = autoEmpty;
   this->noCaret = noCaret;
   this->maxLineSize = maxLineSize;
   this->maxNumLines = maxNumLines;
   this->useTab = useTab;
}

inline EditBox::EditBox_notifyCaretMove_Functor::FunctionType EditBox::EditBox_notifyCaretMove_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyCaretMove);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyCaretMove_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyCaretMove_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyCaretMove_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyCaretMove)] = func;
   return func;
}
inline void EditBox::EditBox_notifyCaretMove_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/int line, /*6Fj*/int charPos)
{
   SELF(EditBox, notifyCaretMove);
   EditBox_notifyCaretMove(self ? self->impl : (C(EditBox))null, self ? self->impl : (C(EditBox))null, /*7Al*/editBox.impl, /*7Al*/line, /*7Al*/charPos);
}
// inline void EditBox::register_notifyCaretMove(CPPClass & cl, EditBox::EditBox_notifyCaretMove_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyCaretMove_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyCaretMove)] = func;
// }

inline EditBox::EditBox_notifyCharsAdded_Functor::FunctionType EditBox::EditBox_notifyCharsAdded_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyCharsAdded);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyCharsAdded_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyCharsAdded_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyCharsAdded_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyCharsAdded)] = func;
   return func;
}
inline bool EditBox::EditBox_notifyCharsAdded_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/BufferLocation & before, /*6Fj*/BufferLocation & after, /*6Fj*/bool pasteOperation)
{
   SELF(EditBox, notifyCharsAdded);
   return (bool)EditBox_notifyCharsAdded(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/&before.impl, /*7Al*/&after.impl, /*7Al*/(C(bool))pasteOperation);
}
// inline void EditBox::register_notifyCharsAdded(CPPClass & cl, EditBox::EditBox_notifyCharsAdded_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyCharsAdded_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyCharsAdded)] = func;
// }

inline EditBox::EditBox_notifyCharsDeleted_Functor::FunctionType EditBox::EditBox_notifyCharsDeleted_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyCharsDeleted);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyCharsDeleted_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyCharsDeleted_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyCharsDeleted_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyCharsDeleted)] = func;
   return func;
}
inline bool EditBox::EditBox_notifyCharsDeleted_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/BufferLocation & beforeLoc, /*6Fj*/BufferLocation & after, /*6Fj*/bool pasteOperation)
{
   SELF(EditBox, notifyCharsDeleted);
   return (bool)EditBox_notifyCharsDeleted(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/&beforeLoc.impl, /*7Al*/&after.impl, /*7Al*/(C(bool))pasteOperation);
}
// inline void EditBox::register_notifyCharsDeleted(CPPClass & cl, EditBox::EditBox_notifyCharsDeleted_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyCharsDeleted_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyCharsDeleted)] = func;
// }

inline EditBox::EditBox_notifyDoubleClick_Functor::FunctionType EditBox::EditBox_notifyDoubleClick_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyDoubleClick);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyDoubleClick_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyDoubleClick_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyDoubleClick)] = func;
   return func;
}
inline bool EditBox::EditBox_notifyDoubleClick_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/EditLine line, /*6Fj*/Modifiers mods)
{
   SELF(EditBox, notifyDoubleClick);
   return (bool)EditBox_notifyDoubleClick(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/line.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void EditBox::register_notifyDoubleClick(CPPClass & cl, EditBox::EditBox_notifyDoubleClick_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyDoubleClick)] = func;
// }

inline EditBox::EditBox_notifyDropped_Functor::FunctionType EditBox::EditBox_notifyDropped_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyDropped);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyDropped_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyDropped_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyDropped_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyDropped)] = func;
   return func;
}
inline bool EditBox::EditBox_notifyDropped_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/int x, /*6Fj*/int y)
{
   SELF(EditBox, notifyDropped);
   return (bool)EditBox_notifyDropped(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/x, /*7Al*/y);
}
// inline void EditBox::register_notifyDropped(CPPClass & cl, EditBox::EditBox_notifyDropped_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyDropped_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyDropped)] = func;
// }

inline EditBox::EditBox_notifyKeyDown_Functor::FunctionType EditBox::EditBox_notifyKeyDown_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyKeyDown);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyKeyDown_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyKeyDown_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyKeyDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyKeyDown)] = func;
   return func;
}
inline bool EditBox::EditBox_notifyKeyDown_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(EditBox, notifyKeyDown);
   return (bool)EditBox_notifyKeyDown(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void EditBox::register_notifyKeyDown(CPPClass & cl, EditBox::EditBox_notifyKeyDown_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyKeyDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyKeyDown)] = func;
// }

inline EditBox::EditBox_notifyModified_Functor::FunctionType EditBox::EditBox_notifyModified_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyModified);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyModified_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyModified_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyModified)] = func;
   return func;
}
inline bool EditBox::EditBox_notifyModified_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox)
{
   SELF(EditBox, notifyModified);
   return (bool)EditBox_notifyModified(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl);
}
// inline void EditBox::register_notifyModified(CPPClass & cl, EditBox::EditBox_notifyModified_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyModified)] = func;
// }

inline EditBox::EditBox_notifyOvrToggle_Functor::FunctionType EditBox::EditBox_notifyOvrToggle_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyOvrToggle);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyOvrToggle_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyOvrToggle_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyOvrToggle_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyOvrToggle)] = func;
   return func;
}
inline void EditBox::EditBox_notifyOvrToggle_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox, /*6Fj*/bool overwrite)
{
   SELF(EditBox, notifyOvrToggle);
   EditBox_notifyOvrToggle(self ? self->impl : (C(EditBox))null, self ? self->impl : (C(EditBox))null, /*7Al*/editBox.impl, /*7Al*/(C(bool))overwrite);
}
// inline void EditBox::register_notifyOvrToggle(CPPClass & cl, EditBox::EditBox_notifyOvrToggle_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyOvrToggle_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyOvrToggle)] = func;
// }

inline EditBox::EditBox_notifyUnsetModified_Functor::FunctionType EditBox::EditBox_notifyUnsetModified_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyUnsetModified);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyUnsetModified_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyUnsetModified_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyUnsetModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyUnsetModified)] = func;
   return func;
}
inline bool EditBox::EditBox_notifyUnsetModified_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox)
{
   SELF(EditBox, notifyUnsetModified);
   return (bool)EditBox_notifyUnsetModified(self ? self->impl : (C(EditBox))null, o_.impl, /*7Al*/editBox.impl);
}
// inline void EditBox::register_notifyUnsetModified(CPPClass & cl, EditBox::EditBox_notifyUnsetModified_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyUnsetModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyUnsetModified)] = func;
// }

inline EditBox::EditBox_notifyUpdate_Functor::FunctionType EditBox::EditBox_notifyUpdate_Functor::operator= (FunctionType func)
{
   SELF(EditBox, notifyUpdate);
   if(self->vTbl == EditBox::_cpp_class.vTbl)
   {
      uint size = EditBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditBox::EditBox_notifyUpdate_Functor::FunctionType, size);
      memcpy(self->vTbl, EditBox::_cpp_class.vTbl, sizeof(EditBox::EditBox_notifyUpdate_Functor::FunctionType) * size);
   }
   ((EditBox::EditBox_notifyUpdate_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditBox, notifyUpdate)] = func;
   return func;
}
inline void EditBox::EditBox_notifyUpdate_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditBox & editBox)
{
   SELF(EditBox, notifyUpdate);
   EditBox_notifyUpdate(self ? self->impl : (C(EditBox))null, self ? self->impl : (C(EditBox))null, /*7Al*/editBox.impl);
}
// inline void EditBox::register_notifyUpdate(CPPClass & cl, EditBox::EditBox_notifyUpdate_Functor::FunctionType func)
// {
//    ((EditBox::EditBox_notifyUpdate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditBox, notifyUpdate)] = func;
// }


inline C(bool) EditBox::addCh(/*1Ab*/unichar ch)
{
   return EditBox_addCh(impl, /*5Ge*/ch);
}
inline C(bool) EditBox::addS(/*1Ab*/const char * string)
{
   return EditBox_addS(impl, /*5Ge*/string);
}
inline void EditBox::backSpace()
{
   EditBox_backSpace(impl);
}
inline void EditBox::centerOnCursor()
{
   EditBox_centerOnCursor(impl);
}
inline void EditBox::clear()
{
   EditBox_clear(impl);
}
inline void EditBox::clearLine()
{
   EditBox_clearLine(impl);
}
inline void EditBox::copy()
{
   EditBox_copy(impl);
}
inline void EditBox::cut()
{
   EditBox_cut(impl);
}
inline void EditBox::_delete(/*1Ab*/EditLine line1, /*1Ab*/int y1, /*1Ab*/int x1, /*1Ab*/EditLine line2, /*1Ab*/int y2, /*1Ab*/int x2)
{
   EditBox_delete(impl, /*5De*/line1.impl, /*5Ge*/y1, /*5Ge*/x1, /*5De*/line2.impl, /*5Ge*/y2, /*5Ge*/x2);
}
inline void EditBox::deleteSelection()
{
   EditBox_deleteSelection(impl);
}
inline void EditBox::deselect()
{
   EditBox_deselect(impl);
}
inline void EditBox::end()
{
   EditBox_end(impl);
}
inline C(EditBoxFindResult) EditBox::find(/*1Ab*/const char * text, /*1Ab*/bool matchWord, /*1Ab*/bool matchCase, /*1Ab*/bool isSearchDown)
{
   return EditBox_find(impl, /*5Ge*/text, /*5Ee*/(C(bool))matchWord, /*5Ee*/(C(bool))matchCase, /*5Ee*/(C(bool))isSearchDown);
}
inline C(EditBoxFindResult) EditBox::findInSelection(/*1Ab*/const char * text, /*1Ab*/bool matchWord, /*1Ab*/bool matchCase, /*1Ab*/EditLine l2, /*1Ab*/int y2, /*1Ab*/int x2)
{
   return EditBox_findInSelection(impl, /*5Ge*/text, /*5Ee*/(C(bool))matchWord, /*5Ee*/(C(bool))matchCase, /*5De*/l2.impl, /*5Ge*/y2, /*5Ge*/x2);
}
inline void EditBox::getSel(/*1Ab*/char * text, /*1Ab*/bool addCr)
{
   EditBox_getSel(impl, /*5Ge*/text, /*5Ee*/(C(bool))addCr);
}
inline void EditBox::getSelPos(/*1Ab*/EditLine * l1, /*1Ab*/int * y1, /*1Ab*/int * x1, /*1Ab*/EditLine * l2, /*1Ab*/int * y2, /*1Ab*/int * x2, /*1Ab*/bool reorder)
{
   EditBox_getSelPos(impl, /*5Ce*/(C(EditLine) *)l1, /*5Ge*/y1, /*5Ge*/x1, /*5Ce*/(C(EditLine) *)l2, /*5Ge*/y2, /*5Ge*/x2, /*5Ee*/(C(bool))reorder);
}
inline int EditBox::getText(/*1Ab*/char * text, /*1Ab*/EditLine _l1, /*1Ab*/int _y1, /*1Ab*/int _x1, /*1Ab*/EditLine _l2, /*1Ab*/int _y2, /*1Ab*/int _x2, /*1Ab*/bool addCr, /*1Ab*/bool addSpaces)
{
   return EditBox_getText(impl, /*5Ge*/text, /*5De*/_l1.impl, /*5Ge*/_y1, /*5Ge*/_x1, /*5De*/_l2.impl, /*5Ge*/_y2, /*5Ge*/_x2, /*5Ee*/(C(bool))addCr, /*5Ee*/(C(bool))addSpaces);
}
inline C(bool) EditBox::goToLineNum(/*1Ab*/int lineNum)
{
   return EditBox_goToLineNum(impl, /*5Ge*/lineNum);
}
inline C(bool) EditBox::goToPosition(/*1Ab*/EditLine line, /*1Ab*/int y, /*1Ab*/int x)
{
   return EditBox_goToPosition(impl, /*5De*/line.impl, /*5Ge*/y, /*5Ge*/x);
}
inline void EditBox::home()
{
   EditBox_home(impl);
}
inline void EditBox::lineDown()
{
   EditBox_lineDown(impl);
}
inline void EditBox::lineUp()
{
   EditBox_lineUp(impl);
}
inline void EditBox::load(/*1Ab*/File & f)
{
   EditBox_load(impl, /*5De*/f.impl);
}
inline void EditBox::modified()
{
   EditBox_modified(impl);
}
inline void EditBox::pageDown()
{
   EditBox_pageDown(impl);
}
inline void EditBox::pageUp()
{
   EditBox_pageUp(impl);
}
inline void EditBox::paste()
{
   EditBox_paste(impl);
}
template<typename... Args> inline void EditBox::_printf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   EditBox_printf(impl, /*5Ge*/format, /*5Ae*/args...);
}
inline void EditBox::putCh(/*1Ab*/unichar ch)
{
   EditBox_putCh(impl, /*5Ge*/ch);
}
inline void EditBox::putS(/*1Ab*/const char * string)
{
   EditBox_putS(impl, /*5Ge*/string);
}
inline void EditBox::record(/*1Ab*/UndoAction action)
{
   EditBox_record(impl, /*5De*/action.impl);
}
inline void EditBox::redo()
{
   EditBox_redo(impl);
}
inline void EditBox::save(/*1Ab*/File & f, /*1Ab*/bool cr)
{
   EditBox_save(impl, /*5De*/f.impl, /*5Ee*/(C(bool))cr);
}
inline uint EditBox::selSize()
{
   return EditBox_selSize(impl);
}
inline void EditBox::select(/*1Ab*/EditLine line1, /*1Ab*/int y1, /*1Ab*/int x1, /*1Ab*/EditLine line2, /*1Ab*/int y2, /*1Ab*/int x2)
{
   EditBox_select(impl, /*5De*/line1.impl, /*5Ge*/y1, /*5Ge*/x1, /*5De*/line2.impl, /*5Ge*/y2, /*5Ge*/x2);
}
inline void EditBox::selectAll()
{
   EditBox_selectAll(impl);
}
template<typename... Args> inline void EditBox::setContents(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   EditBox_setContents(impl, /*5Ge*/format, /*5Ae*/args...);
}
inline void EditBox::setCursorToView()
{
   EditBox_setCursorToView(impl);
}
inline void EditBox::setModified(/*1Ab*/bool flag)
{
   EditBox_setModified(impl, /*5Ee*/(C(bool))flag);
}
inline void EditBox::setSelPos(/*1Ab*/EditLine l1, /*1Ab*/int y1, /*1Ab*/int x1, /*1Ab*/EditLine l2, /*1Ab*/int y2, /*1Ab*/int x2)
{
   EditBox_setSelPos(impl, /*5De*/l1.impl, /*5Ge*/y1, /*5Ge*/x1, /*5De*/l2.impl, /*5Ge*/y2, /*5Ge*/x2);
}
inline void EditBox::setViewToCursor(/*1Ab*/bool setCaret)
{
   EditBox_setViewToCursor(impl, /*5Ee*/(C(bool))setCaret);
}
inline void EditBox::undo()
{
   EditBox_undo(impl);
}


// property callers: EditBox::textHorzScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::textHorzScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, textHorzScroll);
   EditBox_set_textHorzScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::textHorzScroll_Prop & EditBox::textHorzScroll_Prop::operator= (EditBox::textHorzScroll_Prop & prop)
{
   SELF(EditBox, textHorzScroll);
   /*0H*/bool v = prop;
   EditBox_set_textHorzScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::textHorzScroll_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, textHorzScroll);
   return (bool)EditBox_get_textHorzScroll(self ? self->impl : null);
}

// property callers: EditBox::textVertScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::textVertScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, textVertScroll);
   EditBox_set_textVertScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::textVertScroll_Prop & EditBox::textVertScroll_Prop::operator= (EditBox::textVertScroll_Prop & prop)
{
   SELF(EditBox, textVertScroll);
   /*0H*/bool v = prop;
   EditBox_set_textVertScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::textVertScroll_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, textVertScroll);
   return (bool)EditBox_get_textVertScroll(self ? self->impl : null);
}

// property callers: EditBox::readOnly
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::readOnly_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, readOnly);
   EditBox_set_readOnly(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::readOnly_Prop & EditBox::readOnly_Prop::operator= (EditBox::readOnly_Prop & prop)
{
   SELF(EditBox, readOnly);
   /*0H*/bool v = prop;
   EditBox_set_readOnly(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::readOnly_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, readOnly);
   return (bool)EditBox_get_readOnly(self ? self->impl : null);
}

// property callers: EditBox::multiLine
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::multiLine_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, multiLine);
   EditBox_set_multiLine(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::multiLine_Prop & EditBox::multiLine_Prop::operator= (EditBox::multiLine_Prop & prop)
{
   SELF(EditBox, multiLine);
   /*0H*/bool v = prop;
   EditBox_set_multiLine(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::multiLine_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, multiLine);
   return (bool)EditBox_get_multiLine(self ? self->impl : null);
}

// property callers: EditBox::freeCaret
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::freeCaret_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, freeCaret);
   EditBox_set_freeCaret(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::freeCaret_Prop & EditBox::freeCaret_Prop::operator= (EditBox::freeCaret_Prop & prop)
{
   SELF(EditBox, freeCaret);
   /*0H*/bool v = prop;
   EditBox_set_freeCaret(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::freeCaret_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, freeCaret);
   return (bool)EditBox_get_freeCaret(self ? self->impl : null);
}

// property callers: EditBox::tabKey
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::tabKey_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, tabKey);
   EditBox_set_tabKey(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::tabKey_Prop & EditBox::tabKey_Prop::operator= (EditBox::tabKey_Prop & prop)
{
   SELF(EditBox, tabKey);
   /*0H*/bool v = prop;
   EditBox_set_tabKey(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::tabKey_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, tabKey);
   return (bool)EditBox_get_tabKey(self ? self->impl : null);
}

// property callers: EditBox::tabSize
// (normal::int)

/*nstSet*/inline /*0H*/int EditBox::tabSize_Prop::operator= (/*0H*/int v)
{
   SELF(EditBox, tabSize);
   EditBox_set_tabSize(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline EditBox::tabSize_Prop & EditBox::tabSize_Prop::operator= (EditBox::tabSize_Prop & prop)
{
   SELF(EditBox, tabSize);
   /*0H*/int v = prop;
   EditBox_set_tabSize(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline EditBox::tabSize_Prop::operator /*0I*/int () const
{
   SELF(EditBox, tabSize);
   return EditBox_get_tabSize(self ? self->impl : null);
}

// property callers: EditBox::tabSelection
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::tabSelection_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, tabSelection);
   EditBox_set_tabSelection(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::tabSelection_Prop & EditBox::tabSelection_Prop::operator= (EditBox::tabSelection_Prop & prop)
{
   SELF(EditBox, tabSelection);
   /*0H*/bool v = prop;
   EditBox_set_tabSelection(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::tabSelection_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, tabSelection);
   return (bool)EditBox_get_tabSelection(self ? self->impl : null);
}

// property callers: EditBox::smartHome
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::smartHome_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, smartHome);
   EditBox_set_smartHome(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::smartHome_Prop & EditBox::smartHome_Prop::operator= (EditBox::smartHome_Prop & prop)
{
   SELF(EditBox, smartHome);
   /*0H*/bool v = prop;
   EditBox_set_smartHome(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::smartHome_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, smartHome);
   return (bool)EditBox_get_smartHome(self ? self->impl : null);
}

// property callers: EditBox::autoEmpty
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::autoEmpty_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, autoEmpty);
   EditBox_set_autoEmpty(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::autoEmpty_Prop & EditBox::autoEmpty_Prop::operator= (EditBox::autoEmpty_Prop & prop)
{
   SELF(EditBox, autoEmpty);
   /*0H*/bool v = prop;
   EditBox_set_autoEmpty(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::autoEmpty_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, autoEmpty);
   return (bool)EditBox_get_autoEmpty(self ? self->impl : null);
}

// property callers: EditBox::noCaret
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::noCaret_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, noCaret);
   EditBox_set_noCaret(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::noCaret_Prop & EditBox::noCaret_Prop::operator= (EditBox::noCaret_Prop & prop)
{
   SELF(EditBox, noCaret);
   /*0H*/bool v = prop;
   EditBox_set_noCaret(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::noCaret_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, noCaret);
   return (bool)EditBox_get_noCaret(self ? self->impl : null);
}

// property callers: EditBox::maxLineSize
// (normal::int)

/*nstSet*/inline /*0H*/int EditBox::maxLineSize_Prop::operator= (/*0H*/int v)
{
   SELF(EditBox, maxLineSize);
   EditBox_set_maxLineSize(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline EditBox::maxLineSize_Prop & EditBox::maxLineSize_Prop::operator= (EditBox::maxLineSize_Prop & prop)
{
   SELF(EditBox, maxLineSize);
   /*0H*/int v = prop;
   EditBox_set_maxLineSize(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline EditBox::maxLineSize_Prop::operator /*0I*/int () const
{
   SELF(EditBox, maxLineSize);
   return EditBox_get_maxLineSize(self ? self->impl : null);
}

// property callers: EditBox::maxNumLines
// (normal::int)

/*nstSet*/inline /*0H*/int EditBox::maxNumLines_Prop::operator= (/*0H*/int v)
{
   SELF(EditBox, maxNumLines);
   EditBox_set_maxNumLines(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline EditBox::maxNumLines_Prop & EditBox::maxNumLines_Prop::operator= (EditBox::maxNumLines_Prop & prop)
{
   SELF(EditBox, maxNumLines);
   /*0H*/int v = prop;
   EditBox_set_maxNumLines(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline EditBox::maxNumLines_Prop::operator /*0I*/int () const
{
   SELF(EditBox, maxNumLines);
   return EditBox_get_maxNumLines(self ? self->impl : null);
}

// property callers: EditBox::useTab
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::useTab_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, useTab);
   EditBox_set_useTab(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::useTab_Prop & EditBox::useTab_Prop::operator= (EditBox::useTab_Prop & prop)
{
   SELF(EditBox, useTab);
   /*0H*/bool v = prop;
   EditBox_set_useTab(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::useTab_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, useTab);
   return (bool)EditBox_get_useTab(self ? self->impl : null);
}

// property callers: EditBox::syntaxHighlighting
// (normal::normal)

/*nstSet*/inline /*0A*/const EditSyntaxHL & EditBox::syntaxHighlighting_Prop::operator= (/*0A*/const EditSyntaxHL & v)
{
   SELF(EditBox, syntaxHighlighting);
   EditBox_set_syntaxHighlighting(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline EditBox::syntaxHighlighting_Prop & EditBox::syntaxHighlighting_Prop::operator= (EditBox::syntaxHighlighting_Prop & prop)
{
   SELF(EditBox, syntaxHighlighting);
   /*0A*/const EditSyntaxHL & v = prop;
   EditBox_set_syntaxHighlighting(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const EditSyntaxHL * EditBox::syntaxHighlighting_Prop::operator= (/*0C*/const EditSyntaxHL * v)
{
   SELF(EditBox, syntaxHighlighting);
   EditBox_set_syntaxHighlighting(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline EditBox::syntaxHighlighting_Prop::operator /*0B*/TIH<EditSyntaxHL> () const
{
   SELF(EditBox, syntaxHighlighting);
   C(Instance) i = EditBox_get_syntaxHighlighting(self ? self->impl : null);
   TIH<EditSyntaxHL> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<EditSyntaxHL> EditBox::syntaxHighlighting_Prop::operator /*0D*/-> () const
{
   SELF(EditBox, syntaxHighlighting);
   C(Instance) i = EditBox_get_syntaxHighlighting(self ? self->impl : null);
   TIH<EditSyntaxHL> holder(i);
   return holder;
}
/*regGet*/inline EditBox::syntaxHighlighting_Prop::operator /*0E*/EditSyntaxHL () const
{
   SELF(EditBox, syntaxHighlighting);
   C(Instance) i = EditBox_get_syntaxHighlighting(self ? self->impl : null);
   return EditSyntaxHL(i);
}
/*regGet*/inline EditBox::syntaxHighlighting_Prop::operator /*0F*/EditSyntaxHL* () const
{
   SELF(EditBox, syntaxHighlighting);
   C(Instance) i = EditBox_get_syntaxHighlighting(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (EditSyntaxHL *)INSTANCEL(i, i->_class) : (EditSyntaxHL *)0;
}

// property callers: EditBox::noSelect
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::noSelect_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, noSelect);
   EditBox_set_noSelect(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::noSelect_Prop & EditBox::noSelect_Prop::operator= (EditBox::noSelect_Prop & prop)
{
   SELF(EditBox, noSelect);
   /*0H*/bool v = prop;
   EditBox_set_noSelect(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::noSelect_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, noSelect);
   return (bool)EditBox_get_noSelect(self ? self->impl : null);
}

// property callers: EditBox::allCaps
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::allCaps_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, allCaps);
   EditBox_set_allCaps(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::allCaps_Prop & EditBox::allCaps_Prop::operator= (EditBox::allCaps_Prop & prop)
{
   SELF(EditBox, allCaps);
   /*0H*/bool v = prop;
   EditBox_set_allCaps(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::allCaps_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, allCaps);
   return (bool)EditBox_get_allCaps(self ? self->impl : null);
}

// property callers: EditBox::autoSize
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::autoSize_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, autoSize);
   EditBox_set_autoSize(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::autoSize_Prop & EditBox::autoSize_Prop::operator= (EditBox::autoSize_Prop & prop)
{
   SELF(EditBox, autoSize);
   /*0H*/bool v = prop;
   EditBox_set_autoSize(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::autoSize_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, autoSize);
   return (bool)EditBox_get_autoSize(self ? self->impl : null);
}

// property callers: EditBox::wrap
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::wrap_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, wrap);
   EditBox_set_wrap(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::wrap_Prop & EditBox::wrap_Prop::operator= (EditBox::wrap_Prop & prop)
{
   SELF(EditBox, wrap);
   /*0H*/bool v = prop;
   EditBox_set_wrap(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::wrap_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, wrap);
   return (bool)EditBox_get_wrap(self ? self->impl : null);
}

// property callers: EditBox::numLines   // get only
// (normal::int)

/*regGet*/inline EditBox::numLines_Prop::operator /*0I*/int () const
{
   SELF(EditBox, numLines);
   return EditBox_get_numLines(self ? self->impl : null);
}

// property callers: EditBox::lineNumber   // get only
// (normal::int)

/*regGet*/inline EditBox::lineNumber_Prop::operator /*0I*/int () const
{
   SELF(EditBox, lineNumber);
   return EditBox_get_lineNumber(self ? self->impl : null);
}

// property callers: EditBox::column   // get only
// (normal::int)

/*regGet*/inline EditBox::column_Prop::operator /*0I*/int () const
{
   SELF(EditBox, column);
   return EditBox_get_column(self ? self->impl : null);
}

// property callers: EditBox::charPos   // get only
// (normal::int)

/*regGet*/inline EditBox::charPos_Prop::operator /*0I*/int () const
{
   SELF(EditBox, charPos);
   return EditBox_get_charPos(self ? self->impl : null);
}

// property callers: EditBox::firstLine   // get only
// (normal::nohead)

/*regGet*/inline EditBox::firstLine_Prop::operator /*0I*/EditLine () const
{
   SELF(EditBox, firstLine);
   EditLine value(EditBox_get_firstLine(self->impl));
   return value;
}

// property callers: EditBox::lastLine   // get only
// (normal::nohead)

/*regGet*/inline EditBox::lastLine_Prop::operator /*0I*/EditLine () const
{
   SELF(EditBox, lastLine);
   EditLine value(EditBox_get_lastLine(self->impl));
   return value;
}

// property callers: EditBox::line   // get only
// (normal::nohead)

/*regGet*/inline EditBox::line_Prop::operator /*0I*/EditLine () const
{
   SELF(EditBox, line);
   EditLine value(EditBox_get_line(self->impl));
   return value;
}

// property callers: EditBox::contents
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * EditBox::contents_Prop::operator= (/*0H*/const char * v)
{
   SELF(EditBox, contents);
   EditBox_set_contents(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline EditBox::contents_Prop & EditBox::contents_Prop::operator= (EditBox::contents_Prop & prop)
{
   SELF(EditBox, contents);
   /*0H*/const char * v = prop;
   EditBox_set_contents(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline EditBox::contents_Prop::operator /*0I*/const char * () const
{
   SELF(EditBox, contents);
   return EditBox_get_contents(self ? self->impl : null);
}

// property callers: EditBox::overwrite   // get only
// (normal::enum|uint)

/*regGet*/inline EditBox::overwrite_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, overwrite);
   return (bool)EditBox_get_overwrite(self ? self->impl : null);
}

// property callers: EditBox::caretFollowsScrolling
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::caretFollowsScrolling_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, caretFollowsScrolling);
   EditBox_set_caretFollowsScrolling(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::caretFollowsScrolling_Prop & EditBox::caretFollowsScrolling_Prop::operator= (EditBox::caretFollowsScrolling_Prop & prop)
{
   SELF(EditBox, caretFollowsScrolling);
   /*0H*/bool v = prop;
   EditBox_set_caretFollowsScrolling(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::caretFollowsScrolling_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, caretFollowsScrolling);
   return (bool)EditBox_get_caretFollowsScrolling(self ? self->impl : null);
}

// property callers: EditBox::multiLineContents   // get only
// (normal::char *)

/*regGet*/inline EditBox::multiLineContents_Prop::operator /*0I*/char * () const
{
   SELF(EditBox, multiLineContents);
   return EditBox_get_multiLineContents(self ? self->impl : null);
}

// property callers: EditBox::selectionColor
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color EditBox::selectionColor_Prop::operator= (/*0H*/Color v)
{
   SELF(EditBox, selectionColor);
   EditBox_set_selectionColor(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline EditBox::selectionColor_Prop & EditBox::selectionColor_Prop::operator= (EditBox::selectionColor_Prop & prop)
{
   SELF(EditBox, selectionColor);
   /*0H*/Color v = prop;
   EditBox_set_selectionColor(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline EditBox::selectionColor_Prop::operator /*0I*/Color () const
{
   SELF(EditBox, selectionColor);
   return EditBox_get_selectionColor(self ? self->impl : null);
}

// property callers: EditBox::selectionText
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color EditBox::selectionText_Prop::operator= (/*0H*/Color v)
{
   SELF(EditBox, selectionText);
   EditBox_set_selectionText(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline EditBox::selectionText_Prop & EditBox::selectionText_Prop::operator= (EditBox::selectionText_Prop & prop)
{
   SELF(EditBox, selectionText);
   /*0H*/Color v = prop;
   EditBox_set_selectionText(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline EditBox::selectionText_Prop::operator /*0I*/Color () const
{
   SELF(EditBox, selectionText);
   return EditBox_get_selectionText(self ? self->impl : null);
}

// property callers: EditBox::recordUndoEvent
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditBox::recordUndoEvent_Prop::operator= (/*0H*/bool v)
{
   SELF(EditBox, recordUndoEvent);
   EditBox_set_recordUndoEvent(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditBox::recordUndoEvent_Prop & EditBox::recordUndoEvent_Prop::operator= (EditBox::recordUndoEvent_Prop & prop)
{
   SELF(EditBox, recordUndoEvent);
   /*0H*/bool v = prop;
   EditBox_set_recordUndoEvent(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditBox::recordUndoEvent_Prop::operator /*0I*/bool () const
{
   SELF(EditBox, recordUndoEvent);
   return (bool)EditBox_get_recordUndoEvent(self ? self->impl : null);
}


inline void EditBoxStream::deleteBytes(/*1Ab*/uint count)
{
   EditBoxStream_deleteBytes(impl, /*5Ge*/count);
}


// property callers: EditBoxStream::editBox
// (normal::normal)

/*nstSet*/inline /*0A*/const EditBox & EditBoxStream::editBox_Prop::operator= (/*0A*/const EditBox & v)
{
   SELF(EditBoxStream, editBox);
   EditBoxStream_set_editBox(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline EditBoxStream::editBox_Prop & EditBoxStream::editBox_Prop::operator= (EditBoxStream::editBox_Prop & prop)
{
   SELF(EditBoxStream, editBox);
   /*0A*/const EditBox & v = prop;
   EditBoxStream_set_editBox(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const EditBox * EditBoxStream::editBox_Prop::operator= (/*0C*/const EditBox * v)
{
   SELF(EditBoxStream, editBox);
   EditBoxStream_set_editBox(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline EditBoxStream::editBox_Prop::operator /*0B*/TIH<EditBox> () const
{
   SELF(EditBoxStream, editBox);
   C(Instance) i = EditBoxStream_get_editBox(self ? self->impl : null);
   TIH<EditBox> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<EditBox> EditBoxStream::editBox_Prop::operator /*0D*/-> () const
{
   SELF(EditBoxStream, editBox);
   C(Instance) i = EditBoxStream_get_editBox(self ? self->impl : null);
   TIH<EditBox> holder(i);
   return holder;
}
/*regGet*/inline EditBoxStream::editBox_Prop::operator /*0E*/EditBox () const
{
   SELF(EditBoxStream, editBox);
   C(Instance) i = EditBoxStream_get_editBox(self ? self->impl : null);
   return EditBox(i);
}
/*regGet*/inline EditBoxStream::editBox_Prop::operator /*0F*/EditBox* () const
{
   SELF(EditBoxStream, editBox);
   C(Instance) i = EditBoxStream_get_editBox(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (EditBox *)INSTANCEL(i, i->_class) : (EditBox *)0;
}



// property callers: EditLine::text
// (nohead::const char *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/const char * TEditLine<TC, TCO>::text_Prop::operator= (/*0H*/const char * v)
{
   SELF(EditLine, text);
   EditLine_set_text(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TEditLine<TC, TCO>::text_Prop & TEditLine<TC, TCO>::text_Prop::operator= (typename TEditLine<TC, TCO>::text_Prop & prop)
{
   SELF(EditLine, text);
   /*0H*/const char * v = prop;
   EditLine_set_text(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TEditLine<TC, TCO>::text_Prop::operator /*0I*/const char * () const
{
   __attribute__((unused)) TEditLine TCTCO * self = CONTAINER_OF(this, TEditLine TCTCO, text);
   return EditLine_get_text(self ? self->impl : null);
}

// property callers: EditLine::prev   // get only
// (nohead::nohead)

/*regGet*/template <class TC, C(Class) ** TCO> inline TEditLine<TC, TCO>::prev_Prop::operator /*0I*/EditLine () const
{
   __attribute__((unused)) TEditLine TCTCO * self = CONTAINER_OF(this, TEditLine TCTCO, prev);
   EditLine value(EditLine_get_prev(self->impl));
   return value;
}

// property callers: EditLine::next   // get only
// (nohead::nohead)

/*regGet*/template <class TC, C(Class) ** TCO> inline TEditLine<TC, TCO>::next_Prop::operator /*0I*/EditLine () const
{
   __attribute__((unused)) TEditLine TCTCO * self = CONTAINER_OF(this, TEditLine TCTCO, next);
   EditLine value(EditLine_get_next(self->impl));
   return value;
}

// property callers: EditLine::count   // get only
// (nohead::int)

/*regGet*/template <class TC, C(Class) ** TCO> inline TEditLine<TC, TCO>::count_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TEditLine TCTCO * self = CONTAINER_OF(this, TEditLine TCTCO, count);
   return EditLine_get_count(self ? self->impl : null);
}

inline EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, canImpactOtherLines);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, canImpactOtherLines)] = func;
   return func;
}
inline bool EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::operator()( /*6Fj*/EditLine line)
{
   SELF(EditSyntaxHL, canImpactOtherLines);
   return (bool)EditSyntaxHL_canImpactOtherLines(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/line.impl);
}
// inline void EditSyntaxHL::register_canImpactOtherLines(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_canImpactOtherLines_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, canImpactOtherLines)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, figureStartSyntaxStates);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, figureStartSyntaxStates)] = func;
   return func;
}
inline void EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::operator()( /*6Fj*/EditLine firstLine, /*6Fj*/bool reset, /*6Fj*/EditLine viewLine)
{
   SELF(EditSyntaxHL, figureStartSyntaxStates);
   EditSyntaxHL_figureStartSyntaxStates(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/firstLine.impl, /*7Al*/(C(bool))reset, /*7Al*/viewLine.impl);
}
// inline void EditSyntaxHL::register_figureStartSyntaxStates(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_figureStartSyntaxStates_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, figureStartSyntaxStates)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, gotSpace);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, gotSpace)] = func;
   return func;
}
inline void EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::operator()( /*6Fj*/bool beforeEnd)
{
   SELF(EditSyntaxHL, gotSpace);
   EditSyntaxHL_gotSpace(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/(C(bool))beforeEnd);
}
// inline void EditSyntaxHL::register_gotSpace(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_gotSpace_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, gotSpace)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_initDraw_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_initDraw_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, initDraw);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_initDraw_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_initDraw_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_initDraw_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, initDraw)] = func;
   return func;
}
inline void EditSyntaxHL::EditSyntaxHL_initDraw_Functor::operator()( )
{
   SELF(EditSyntaxHL, initDraw);
   EditSyntaxHL_initDraw(self ? self->impl : (C(EditSyntaxHL))null);
}
// inline void EditSyntaxHL::register_initDraw(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_initDraw_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_initDraw_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, initDraw)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_nextLine_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_nextLine_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, nextLine);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_nextLine_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_nextLine_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_nextLine_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, nextLine)] = func;
   return func;
}
inline void EditSyntaxHL::EditSyntaxHL_nextLine_Functor::operator()( /*6Fj*/char * buffer, /*6Fj*/int count)
{
   SELF(EditSyntaxHL, nextLine);
   EditSyntaxHL_nextLine(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/buffer, /*7Al*/count);
}
// inline void EditSyntaxHL::register_nextLine(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_nextLine_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_nextLine_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, nextLine)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_parseWord_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_parseWord_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, parseWord);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_parseWord_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_parseWord_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_parseWord_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, parseWord)] = func;
   return func;
}
inline int EditSyntaxHL::EditSyntaxHL_parseWord_Functor::operator()( /*6Fj*/char * buffer, /*6Fj*/int count, /*6Fj*/int wordLen)
{
   SELF(EditSyntaxHL, parseWord);
   return EditSyntaxHL_parseWord(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/buffer, /*7Al*/count, /*7Al*/wordLen);
}
// inline void EditSyntaxHL::register_parseWord(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_parseWord_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_parseWord_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, parseWord)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_process_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_process_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, process);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_process_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_process_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_process_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, process)] = func;
   return func;
}
inline Color EditSyntaxHL::EditSyntaxHL_process_Functor::operator()( /*6Fj*/char * word, /*6Fj*/int * wordLen, /*6Fj*/bool beforeEndOfLine, /*6Fj*/Color defaultTextColor, /*6Fj*/const char * buffer, /*6Fj*/int * ap1)
{
   SELF(EditSyntaxHL, process);
   return EditSyntaxHL_process(self ? self->impl : (C(EditSyntaxHL))null, /*7Al*/word, /*7Al*/wordLen, /*7Al*/(C(bool))beforeEndOfLine, /*7Al*/(C(Color))defaultTextColor, /*7Al*/buffer, /*7Al*/ap1);
}
// inline void EditSyntaxHL::register_process(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_process_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_process_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, process)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_resetState_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_resetState_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, resetState);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_resetState_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_resetState_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_resetState_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, resetState)] = func;
   return func;
}
inline void EditSyntaxHL::EditSyntaxHL_resetState_Functor::operator()( )
{
   SELF(EditSyntaxHL, resetState);
   EditSyntaxHL_resetState(self ? self->impl : (C(EditSyntaxHL))null);
}
// inline void EditSyntaxHL::register_resetState(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_resetState_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_resetState_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, resetState)] = func;
// }

inline EditSyntaxHL::EditSyntaxHL_startLine_Functor::FunctionType EditSyntaxHL::EditSyntaxHL_startLine_Functor::operator= (FunctionType func)
{
   SELF(EditSyntaxHL, startLine);
   if(self->vTbl == EditSyntaxHL::_cpp_class.vTbl)
   {
      uint size = EditSyntaxHL::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditSyntaxHL::EditSyntaxHL_startLine_Functor::FunctionType, size);
      memcpy(self->vTbl, EditSyntaxHL::_cpp_class.vTbl, sizeof(EditSyntaxHL::EditSyntaxHL_startLine_Functor::FunctionType) * size);
   }
   ((EditSyntaxHL::EditSyntaxHL_startLine_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditSyntaxHL, startLine)] = func;
   return func;
}
inline void EditSyntaxHL::EditSyntaxHL_startLine_Functor::operator()( )
{
   SELF(EditSyntaxHL, startLine);
   EditSyntaxHL_startLine(self ? self->impl : (C(EditSyntaxHL))null);
}
// inline void EditSyntaxHL::register_startLine(CPPClass & cl, EditSyntaxHL::EditSyntaxHL_startLine_Functor::FunctionType func)
// {
//    ((EditSyntaxHL::EditSyntaxHL_startLine_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditSyntaxHL, startLine)] = func;
// }


inline EditableSelectorButton::EditableSelectorButton(bool renameable) : EditableSelectorButton()
{
   this->renameable = renameable;
}

inline EditableSelectorButton::EditableSelectorButton_onRename_Functor::FunctionType EditableSelectorButton::EditableSelectorButton_onRename_Functor::operator= (FunctionType func)
{
   SELF(EditableSelectorButton, onRename);
   if(self->vTbl == EditableSelectorButton::_cpp_class.vTbl)
   {
      uint size = EditableSelectorButton::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(EditableSelectorButton::EditableSelectorButton_onRename_Functor::FunctionType, size);
      memcpy(self->vTbl, EditableSelectorButton::_cpp_class.vTbl, sizeof(EditableSelectorButton::EditableSelectorButton_onRename_Functor::FunctionType) * size);
   }
   ((EditableSelectorButton::EditableSelectorButton_onRename_Functor::FunctionType *)self->vTbl)[M_VTBLID(EditableSelectorButton, onRename)] = func;
   return func;
}
inline bool EditableSelectorButton::EditableSelectorButton_onRename_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/EditableSelectorButton & button, /*6Fj*/char ** oldName, /*6Fj*/char ** newName)
{
   SELF(EditableSelectorButton, onRename);
   return (bool)EditableSelectorButton_onRename(self ? self->impl : (C(EditableSelectorButton))null, o_.impl, /*7Al*/button.impl, /*7Al*/oldName, /*7Al*/newName);
}
// inline void EditableSelectorButton::register_onRename(CPPClass & cl, EditableSelectorButton::EditableSelectorButton_onRename_Functor::FunctionType func)
// {
//    ((EditableSelectorButton::EditableSelectorButton_onRename_Functor::FunctionType *)cl.vTbl)[M_VTBLID(EditableSelectorButton, onRename)] = func;
// }



// property callers: EditableSelectorButton::renameable
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool EditableSelectorButton::renameable_Prop::operator= (/*0H*/bool v)
{
   SELF(EditableSelectorButton, renameable);
   EditableSelectorButton_set_renameable(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline EditableSelectorButton::renameable_Prop & EditableSelectorButton::renameable_Prop::operator= (EditableSelectorButton::renameable_Prop & prop)
{
   SELF(EditableSelectorButton, renameable);
   /*0H*/bool v = prop;
   EditableSelectorButton_set_renameable(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline EditableSelectorButton::renameable_Prop::operator /*0I*/bool () const
{
   SELF(EditableSelectorButton, renameable);
   return (bool)EditableSelectorButton_get_renameable(self ? self->impl : null);
}

// property callers: EditableSelectorButton::editBox   // get only
// (normal::normal)

/*regGet*/inline EditableSelectorButton::editBox_Prop::operator /*0B*/TIH<EditBox> () const
{
   SELF(EditableSelectorButton, editBox);
   C(Instance) i = EditableSelectorButton_get_editBox(self ? self->impl : null);
   TIH<EditBox> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<EditBox> EditableSelectorButton::editBox_Prop::operator /*0D*/-> () const
{
   SELF(EditableSelectorButton, editBox);
   C(Instance) i = EditableSelectorButton_get_editBox(self ? self->impl : null);
   TIH<EditBox> holder(i);
   return holder;
}
/*regGet*/inline EditableSelectorButton::editBox_Prop::operator /*0E*/EditBox () const
{
   SELF(EditableSelectorButton, editBox);
   C(Instance) i = EditableSelectorButton_get_editBox(self ? self->impl : null);
   return EditBox(i);
}
/*regGet*/inline EditableSelectorButton::editBox_Prop::operator /*0F*/EditBox* () const
{
   SELF(EditableSelectorButton, editBox);
   C(Instance) i = EditableSelectorButton_get_editBox(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (EditBox *)INSTANCEL(i, i->_class) : (EditBox *)0;
}



// property callers: Label::labeledWindow
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & Label::labeledWindow_Prop::operator= (/*0A*/const Window & v)
{
   SELF(Label, labeledWindow);
   Label_set_labeledWindow(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Label::labeledWindow_Prop & Label::labeledWindow_Prop::operator= (Label::labeledWindow_Prop & prop)
{
   SELF(Label, labeledWindow);
   /*0A*/const Window & v = prop;
   Label_set_labeledWindow(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * Label::labeledWindow_Prop::operator= (/*0C*/const Window * v)
{
   SELF(Label, labeledWindow);
   Label_set_labeledWindow(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Label::labeledWindow_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Label, labeledWindow);
   C(Instance) i = Label_get_labeledWindow(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Label::labeledWindow_Prop::operator /*0D*/-> () const
{
   SELF(Label, labeledWindow);
   C(Instance) i = Label_get_labeledWindow(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Label::labeledWindow_Prop::operator /*0E*/Window () const
{
   SELF(Label, labeledWindow);
   C(Instance) i = Label_get_labeledWindow(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Label::labeledWindow_Prop::operator /*0F*/Window* () const
{
   SELF(Label, labeledWindow);
   C(Instance) i = Label_get_labeledWindow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Label::isGroupBox
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Label::isGroupBox_Prop::operator= (/*0H*/bool v)
{
   SELF(Label, isGroupBox);
   Label_set_isGroupBox(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Label::isGroupBox_Prop & Label::isGroupBox_Prop::operator= (Label::isGroupBox_Prop & prop)
{
   SELF(Label, isGroupBox);
   /*0H*/bool v = prop;
   Label_set_isGroupBox(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Label::isGroupBox_Prop::operator /*0I*/bool () const
{
   SELF(Label, isGroupBox);
   return (bool)Label_get_isGroupBox(self ? self->impl : null);
}

inline ListBox::ListBox(bool freeSelect) : ListBox()
{
   this->freeSelect = freeSelect;
}

inline ListBox::ListBox_notifyChanged_Functor::FunctionType ListBox::ListBox_notifyChanged_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyChanged);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyChanged_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyChanged_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyChanged_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyChanged)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyChanged_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row)
{
   SELF(ListBox, notifyChanged);
   return (bool)ListBox_notifyChanged(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);
}
// inline void ListBox::register_notifyChanged(CPPClass & cl, ListBox::ListBox_notifyChanged_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyChanged_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyChanged)] = func;
// }

inline ListBox::ListBox_notifyCollapse_Functor::FunctionType ListBox::ListBox_notifyCollapse_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyCollapse);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyCollapse_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyCollapse_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyCollapse_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyCollapse)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyCollapse_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/bool collapsed)
{
   SELF(ListBox, notifyCollapse);
   return (bool)ListBox_notifyCollapse(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(bool))collapsed);
}
// inline void ListBox::register_notifyCollapse(CPPClass & cl, ListBox::ListBox_notifyCollapse_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyCollapse_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyCollapse)] = func;
// }

inline ListBox::ListBox_notifyDoubleClick_Functor::FunctionType ListBox::ListBox_notifyDoubleClick_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyDoubleClick);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyDoubleClick_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyDoubleClick_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyDoubleClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyDoubleClick)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyDoubleClick_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyDoubleClick);
   return (bool)ListBox_notifyDoubleClick(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyDoubleClick(CPPClass & cl, ListBox::ListBox_notifyDoubleClick_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyDoubleClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyDoubleClick)] = func;
// }

inline ListBox::ListBox_notifyEditDone_Functor::FunctionType ListBox::ListBox_notifyEditDone_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyEditDone);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyEditDone_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyEditDone_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyEditDone_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyEditDone)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyEditDone_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row)
{
   SELF(ListBox, notifyEditDone);
   return (bool)ListBox_notifyEditDone(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);
}
// inline void ListBox::register_notifyEditDone(CPPClass & cl, ListBox::ListBox_notifyEditDone_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyEditDone_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyEditDone)] = func;
// }

inline ListBox::ListBox_notifyEdited_Functor::FunctionType ListBox::ListBox_notifyEdited_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyEdited);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyEdited_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyEdited_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyEdited_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyEdited)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyEdited_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row)
{
   SELF(ListBox, notifyEdited);
   return (bool)ListBox_notifyEdited(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);
}
// inline void ListBox::register_notifyEdited(CPPClass & cl, ListBox::ListBox_notifyEdited_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyEdited_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyEdited)] = func;
// }

inline ListBox::ListBox_notifyEditing_Functor::FunctionType ListBox::ListBox_notifyEditing_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyEditing);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyEditing_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyEditing_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyEditing_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyEditing)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyEditing_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row)
{
   SELF(ListBox, notifyEditing);
   return (bool)ListBox_notifyEditing(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);
}
// inline void ListBox::register_notifyEditing(CPPClass & cl, ListBox::ListBox_notifyEditing_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyEditing_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyEditing)] = func;
// }

inline ListBox::ListBox_notifyHighlight_Functor::FunctionType ListBox::ListBox_notifyHighlight_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyHighlight);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyHighlight_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyHighlight_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyHighlight_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyHighlight)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyHighlight_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyHighlight);
   return (bool)ListBox_notifyHighlight(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyHighlight(CPPClass & cl, ListBox::ListBox_notifyHighlight_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyHighlight_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyHighlight)] = func;
// }

inline ListBox::ListBox_notifyKeyDown_Functor::FunctionType ListBox::ListBox_notifyKeyDown_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyKeyDown);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyKeyDown_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyKeyDown_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyKeyDown_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyKeyDown)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyKeyDown_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(ListBox, notifyKeyDown);
   return (bool)ListBox_notifyKeyDown(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void ListBox::register_notifyKeyDown(CPPClass & cl, ListBox::ListBox_notifyKeyDown_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyKeyDown_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyKeyDown)] = func;
// }

inline ListBox::ListBox_notifyKeyHit_Functor::FunctionType ListBox::ListBox_notifyKeyHit_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyKeyHit);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyKeyHit_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyKeyHit_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyKeyHit_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyKeyHit)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyKeyHit_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Key key, /*6Fj*/unichar ch)
{
   SELF(ListBox, notifyKeyHit);
   return (bool)ListBox_notifyKeyHit(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Key))key, /*7Al*/ch);
}
// inline void ListBox::register_notifyKeyHit(CPPClass & cl, ListBox::ListBox_notifyKeyHit_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyKeyHit_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyKeyHit)] = func;
// }

inline ListBox::ListBox_notifyModified_Functor::FunctionType ListBox::ListBox_notifyModified_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyModified);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyModified_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyModified_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyModified)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyModified_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row)
{
   SELF(ListBox, notifyModified);
   return (bool)ListBox_notifyModified(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl);
}
// inline void ListBox::register_notifyModified(CPPClass & cl, ListBox::ListBox_notifyModified_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyModified)] = func;
// }

inline ListBox::ListBox_notifyMove_Functor::FunctionType ListBox::ListBox_notifyMove_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyMove);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyMove_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyMove_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyMove_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyMove)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyMove_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyMove);
   return (bool)ListBox_notifyMove(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyMove(CPPClass & cl, ListBox::ListBox_notifyMove_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyMove_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyMove)] = func;
// }

inline ListBox::ListBox_notifyMoved_Functor::FunctionType ListBox::ListBox_notifyMoved_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyMoved);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyMoved_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyMoved_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyMoved_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyMoved)] = func;
   return func;
}
inline void ListBox::ListBox_notifyMoved_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyMoved);
   ListBox_notifyMoved(self ? self->impl : (C(ListBox))null, self ? self->impl : (C(ListBox))null, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyMoved(CPPClass & cl, ListBox::ListBox_notifyMoved_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyMoved_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyMoved)] = func;
// }

inline ListBox::ListBox_notifyMovedField_Functor::FunctionType ListBox::ListBox_notifyMovedField_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyMovedField);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyMovedField_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyMovedField_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyMovedField_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyMovedField)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyMovedField_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyMovedField);
   return (bool)ListBox_notifyMovedField(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/field.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyMovedField(CPPClass & cl, ListBox::ListBox_notifyMovedField_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyMovedField_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyMovedField)] = func;
// }

inline ListBox::ListBox_notifyReclick_Functor::FunctionType ListBox::ListBox_notifyReclick_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyReclick);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyReclick_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyReclick_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyReclick_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyReclick)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyReclick_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyReclick);
   return (bool)ListBox_notifyReclick(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyReclick(CPPClass & cl, ListBox::ListBox_notifyReclick_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyReclick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyReclick)] = func;
// }

inline ListBox::ListBox_notifyResized_Functor::FunctionType ListBox::ListBox_notifyResized_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyResized);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyResized_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyResized_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyResized_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyResized)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyResized_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyResized);
   return (bool)ListBox_notifyResized(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/field.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyResized(CPPClass & cl, ListBox::ListBox_notifyResized_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyResized_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyResized)] = func;
// }

inline ListBox::ListBox_notifyRightClick_Functor::FunctionType ListBox::ListBox_notifyRightClick_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifyRightClick);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifyRightClick_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifyRightClick_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifyRightClick_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifyRightClick)] = func;
   return func;
}
inline bool ListBox::ListBox_notifyRightClick_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/int x, /*6Fj*/int y, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifyRightClick);
   return (bool)ListBox_notifyRightClick(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/x, /*7Al*/y, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifyRightClick(CPPClass & cl, ListBox::ListBox_notifyRightClick_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifyRightClick_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifyRightClick)] = func;
// }

inline ListBox::ListBox_notifySelect_Functor::FunctionType ListBox::ListBox_notifySelect_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifySelect);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifySelect_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifySelect_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifySelect_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifySelect)] = func;
   return func;
}
inline bool ListBox::ListBox_notifySelect_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataRow & row, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifySelect);
   return (bool)ListBox_notifySelect(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/row.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifySelect(CPPClass & cl, ListBox::ListBox_notifySelect_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifySelect_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifySelect)] = func;
// }

inline ListBox::ListBox_notifySort_Functor::FunctionType ListBox::ListBox_notifySort_Functor::operator= (FunctionType func)
{
   SELF(ListBox, notifySort);
   if(self->vTbl == ListBox::_cpp_class.vTbl)
   {
      uint size = ListBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ListBox::ListBox_notifySort_Functor::FunctionType, size);
      memcpy(self->vTbl, ListBox::_cpp_class.vTbl, sizeof(ListBox::ListBox_notifySort_Functor::FunctionType) * size);
   }
   ((ListBox::ListBox_notifySort_Functor::FunctionType *)self->vTbl)[M_VTBLID(ListBox, notifySort)] = func;
   return func;
}
inline bool ListBox::ListBox_notifySort_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ListBox & listBox, /*6Fj*/DataField & field, /*6Fj*/Modifiers mods)
{
   SELF(ListBox, notifySort);
   return (bool)ListBox_notifySort(self ? self->impl : (C(ListBox))null, o_.impl, /*7Al*/listBox.impl, /*7Al*/field.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void ListBox::register_notifySort(CPPClass & cl, ListBox::ListBox_notifySort_Functor::FunctionType func)
// {
//    ((ListBox::ListBox_notifySort_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ListBox, notifySort)] = func;
// }


inline void ListBox::addField(/*1Ab*/DataField & addedField)
{
   ListBox_addField(impl, /*5De*/addedField.impl);
}
inline DataRow ListBox::addRow()
{
   return DataRow(ListBox_addRow(impl));
}
inline DataRow ListBox::addRowAfter(/*1Ab*/DataRow & after)
{
   return DataRow(ListBox_addRowAfter(impl, /*5De*/after.impl));
}
inline DataRow ListBox::addRowNone()
{
   return DataRow(ListBox_addRowNone(impl));
}
inline DataRow ListBox::addString(/*1Ab*/const char * string)
{
   return DataRow(ListBox_addString(impl, /*5Ge*/string));
}
template<typename... Args> inline DataRow ListBox::addStringf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   return DataRow(ListBox_addStringf(impl, /*5Ge*/format, /*5Ae*/args...));
}
inline void ListBox::clear()
{
   ListBox_clear(impl);
}
inline void ListBox::clearFields()
{
   ListBox_clearFields(impl);
}
inline void ListBox::deleteRow(/*1Ab*/DataRow & row)
{
   ListBox_deleteRow(impl, /*5De*/row.impl);
}
inline DataRow ListBox::findRow(/*1Ab*/int64 tag)
{
   return DataRow(ListBox_findRow(impl, /*5Ge*/tag));
}
inline DataRow ListBox::findString(/*1Ab*/const char * searchedString)
{
   return DataRow(ListBox_findString(impl, /*5Ge*/searchedString));
}
inline DataRow ListBox::findSubRow(/*1Ab*/int64 tag)
{
   return DataRow(ListBox_findSubRow(impl, /*5Ge*/tag));
}
inline DataRow ListBox::findSubString(/*1Ab*/const char * subString)
{
   return DataRow(ListBox_findSubString(impl, /*5Ge*/subString));
}
inline DataRow ListBox::findSubStringAfter(/*1Ab*/DataRow & after, /*1Ab*/const char * subString)
{
   return DataRow(ListBox_findSubStringAfter(impl, /*5De*/after.impl, /*5Ge*/subString));
}
inline DataRow ListBox::findSubStringi(/*1Ab*/const char * subString)
{
   return DataRow(ListBox_findSubStringi(impl, /*5Ge*/subString));
}
inline any_object ListBox::getData(/*1Ab*/DataField & field)
{
   return ListBox_getData(impl, /*5De*/field.impl);
}
inline void ListBox::getMultiSelection(/*1Ab*/OldList & list)
{
   ListBox_getMultiSelection(impl, /*5De*/&list.impl);
}
inline void ListBox::getMultiSelection(/*1Ac*/OldList * list)
{
   ListBox_getMultiSelection(impl, /*5Cf*/(C(OldList) *)list);
}
inline int64 ListBox::getTag()
{
   return ListBox_getTag(impl);
}
inline void ListBox::multiSort(/*1Ab*/TArray<DataFieldSort _ARG int _ARG DataFieldSort> & fields)
{
   ListBox_multiSort(impl, /*5De*/((Instance&&)fields).impl);
}
inline void ListBox::removeField(/*1Ab*/DataField & field)
{
   ListBox_removeField(impl, /*5De*/field.impl);
}
inline void ListBox::selectRow(/*1Ab*/DataRow & row)
{
   ListBox_selectRow(impl, /*5De*/row.impl);
}
inline void * ListBox::setData(/*1Ab*/DataField & field, /*1Ab*/any_object data)
{
   return ListBox_setData(impl, /*5De*/field.impl, /*5Ge*/data);
}
inline void ListBox::sort(/*1Ab*/DataField & field, /*1Ab*/int order)
{
   ListBox_sort(impl, /*5De*/field.impl, /*5Ge*/order);
}
inline void ListBox::sortAlsoBy(/*1Ab*/DataField & field, /*1Ab*/int order)
{
   ListBox_sortAlsoBy(impl, /*5De*/field.impl, /*5Ge*/order);
}
inline void ListBox::stopEditing(/*1Ab*/bool save)
{
   ListBox_stopEditing(impl, /*5Ee*/(C(bool))save);
}


// property callers: ListBox::freeSelect
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::freeSelect_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, freeSelect);
   ListBox_set_freeSelect(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::freeSelect_Prop & ListBox::freeSelect_Prop::operator= (ListBox::freeSelect_Prop & prop)
{
   SELF(ListBox, freeSelect);
   /*0H*/bool v = prop;
   ListBox_set_freeSelect(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::freeSelect_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, freeSelect);
   return (bool)ListBox_get_freeSelect(self ? self->impl : null);
}

// property callers: ListBox::currentRow
// (normal::normal)

/*nstSet*/inline /*0A*/const DataRow & ListBox::currentRow_Prop::operator= (/*0A*/const DataRow & v)
{
   SELF(ListBox, currentRow);
   ListBox_set_currentRow(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline ListBox::currentRow_Prop & ListBox::currentRow_Prop::operator= (ListBox::currentRow_Prop & prop)
{
   SELF(ListBox, currentRow);
   /*0A*/const DataRow & v = prop;
   ListBox_set_currentRow(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const DataRow * ListBox::currentRow_Prop::operator= (/*0C*/const DataRow * v)
{
   SELF(ListBox, currentRow);
   ListBox_set_currentRow(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline ListBox::currentRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(ListBox, currentRow);
   C(Instance) i = ListBox_get_currentRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> ListBox::currentRow_Prop::operator /*0D*/-> () const
{
   SELF(ListBox, currentRow);
   C(Instance) i = ListBox_get_currentRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline ListBox::currentRow_Prop::operator /*0E*/DataRow () const
{
   SELF(ListBox, currentRow);
   C(Instance) i = ListBox_get_currentRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline ListBox::currentRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(ListBox, currentRow);
   C(Instance) i = ListBox_get_currentRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: ListBox::currentField
// (normal::normal)

/*nstSet*/inline /*0A*/const DataField & ListBox::currentField_Prop::operator= (/*0A*/const DataField & v)
{
   SELF(ListBox, currentField);
   ListBox_set_currentField(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline ListBox::currentField_Prop & ListBox::currentField_Prop::operator= (ListBox::currentField_Prop & prop)
{
   SELF(ListBox, currentField);
   /*0A*/const DataField & v = prop;
   ListBox_set_currentField(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const DataField * ListBox::currentField_Prop::operator= (/*0C*/const DataField * v)
{
   SELF(ListBox, currentField);
   ListBox_set_currentField(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline ListBox::currentField_Prop::operator /*0B*/TIH<DataField> () const
{
   SELF(ListBox, currentField);
   C(Instance) i = ListBox_get_currentField(self ? self->impl : null);
   TIH<DataField> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataField> ListBox::currentField_Prop::operator /*0D*/-> () const
{
   SELF(ListBox, currentField);
   C(Instance) i = ListBox_get_currentField(self ? self->impl : null);
   TIH<DataField> holder(i);
   return holder;
}
/*regGet*/inline ListBox::currentField_Prop::operator /*0E*/DataField () const
{
   SELF(ListBox, currentField);
   C(Instance) i = ListBox_get_currentField(self ? self->impl : null);
   return DataField(i);
}
/*regGet*/inline ListBox::currentField_Prop::operator /*0F*/DataField* () const
{
   SELF(ListBox, currentField);
   C(Instance) i = ListBox_get_currentField(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataField *)INSTANCEL(i, i->_class) : (DataField *)0;
}

// property callers: ListBox::rowHeight
// (normal::int)

/*nstSet*/inline /*0H*/int ListBox::rowHeight_Prop::operator= (/*0H*/int v)
{
   SELF(ListBox, rowHeight);
   ListBox_set_rowHeight(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ListBox::rowHeight_Prop & ListBox::rowHeight_Prop::operator= (ListBox::rowHeight_Prop & prop)
{
   SELF(ListBox, rowHeight);
   /*0H*/int v = prop;
   ListBox_set_rowHeight(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ListBox::rowHeight_Prop::operator /*0I*/int () const
{
   SELF(ListBox, rowHeight);
   return ListBox_get_rowHeight(self ? self->impl : null);
}

// property callers: ListBox::typingTimeout
// (normal::unit|double)

/*nstSet*/inline /*0H*/Seconds ListBox::typingTimeout_Prop::operator= (/*0H*/Seconds v)
{
   SELF(ListBox, typingTimeout);
   ListBox_set_typingTimeout(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline ListBox::typingTimeout_Prop & ListBox::typingTimeout_Prop::operator= (ListBox::typingTimeout_Prop & prop)
{
   SELF(ListBox, typingTimeout);
   /*0H*/Seconds v = prop;
   ListBox_set_typingTimeout(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline ListBox::typingTimeout_Prop::operator /*0I*/Seconds () const
{
   SELF(ListBox, typingTimeout);
   Seconds value(ListBox_get_typingTimeout(self->impl));
   return value;
}
/*regGet*/inline ListBox::typingTimeout_Prop::operator /*0J*/C(Time) () const
{
   SELF(ListBox, typingTimeout);
   return Seconds(self->typingTimeout);
}

// property callers: ListBox::moveRows
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::moveRows_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, moveRows);
   ListBox_set_moveRows(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::moveRows_Prop & ListBox::moveRows_Prop::operator= (ListBox::moveRows_Prop & prop)
{
   SELF(ListBox, moveRows);
   /*0H*/bool v = prop;
   ListBox_set_moveRows(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::moveRows_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, moveRows);
   return (bool)ListBox_get_moveRows(self ? self->impl : null);
}

// property callers: ListBox::moveFields
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::moveFields_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, moveFields);
   ListBox_set_moveFields(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::moveFields_Prop & ListBox::moveFields_Prop::operator= (ListBox::moveFields_Prop & prop)
{
   SELF(ListBox, moveFields);
   /*0H*/bool v = prop;
   ListBox_set_moveFields(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::moveFields_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, moveFields);
   return (bool)ListBox_get_moveFields(self ? self->impl : null);
}

// property callers: ListBox::resizable
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::resizable_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, resizable);
   ListBox_set_resizable(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::resizable_Prop & ListBox::resizable_Prop::operator= (ListBox::resizable_Prop & prop)
{
   SELF(ListBox, resizable);
   /*0H*/bool v = prop;
   ListBox_set_resizable(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::resizable_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, resizable);
   return (bool)ListBox_get_resizable(self ? self->impl : null);
}

// property callers: ListBox::autoScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::autoScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, autoScroll);
   ListBox_set_autoScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::autoScroll_Prop & ListBox::autoScroll_Prop::operator= (ListBox::autoScroll_Prop & prop)
{
   SELF(ListBox, autoScroll);
   /*0H*/bool v = prop;
   ListBox_set_autoScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::autoScroll_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, autoScroll);
   return (bool)ListBox_get_autoScroll(self ? self->impl : null);
}

// property callers: ListBox::alwaysHighLight
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::alwaysHighLight_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, alwaysHighLight);
   ListBox_set_alwaysHighLight(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::alwaysHighLight_Prop & ListBox::alwaysHighLight_Prop::operator= (ListBox::alwaysHighLight_Prop & prop)
{
   SELF(ListBox, alwaysHighLight);
   /*0H*/bool v = prop;
   ListBox_set_alwaysHighLight(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::alwaysHighLight_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, alwaysHighLight);
   return (bool)ListBox_get_alwaysHighLight(self ? self->impl : null);
}

// property callers: ListBox::hasClearHeader
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::hasClearHeader_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, hasClearHeader);
   ListBox_set_hasClearHeader(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::hasClearHeader_Prop & ListBox::hasClearHeader_Prop::operator= (ListBox::hasClearHeader_Prop & prop)
{
   SELF(ListBox, hasClearHeader);
   /*0H*/bool v = prop;
   ListBox_set_hasClearHeader(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::hasClearHeader_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, hasClearHeader);
   return (bool)ListBox_get_hasClearHeader(self ? self->impl : null);
}

// property callers: ListBox::hasHeader
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::hasHeader_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, hasHeader);
   ListBox_set_hasHeader(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::hasHeader_Prop & ListBox::hasHeader_Prop::operator= (ListBox::hasHeader_Prop & prop)
{
   SELF(ListBox, hasHeader);
   /*0H*/bool v = prop;
   ListBox_set_hasHeader(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::hasHeader_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, hasHeader);
   return (bool)ListBox_get_hasHeader(self ? self->impl : null);
}

// property callers: ListBox::multiSelect
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::multiSelect_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, multiSelect);
   ListBox_set_multiSelect(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::multiSelect_Prop & ListBox::multiSelect_Prop::operator= (ListBox::multiSelect_Prop & prop)
{
   SELF(ListBox, multiSelect);
   /*0H*/bool v = prop;
   ListBox_set_multiSelect(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::multiSelect_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, multiSelect);
   return (bool)ListBox_get_multiSelect(self ? self->impl : null);
}

// property callers: ListBox::alwaysEdit
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::alwaysEdit_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, alwaysEdit);
   ListBox_set_alwaysEdit(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::alwaysEdit_Prop & ListBox::alwaysEdit_Prop::operator= (ListBox::alwaysEdit_Prop & prop)
{
   SELF(ListBox, alwaysEdit);
   /*0H*/bool v = prop;
   ListBox_set_alwaysEdit(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::alwaysEdit_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, alwaysEdit);
   return (bool)ListBox_get_alwaysEdit(self ? self->impl : null);
}

// property callers: ListBox::fullRowSelect
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::fullRowSelect_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, fullRowSelect);
   ListBox_set_fullRowSelect(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::fullRowSelect_Prop & ListBox::fullRowSelect_Prop::operator= (ListBox::fullRowSelect_Prop & prop)
{
   SELF(ListBox, fullRowSelect);
   /*0H*/bool v = prop;
   ListBox_set_fullRowSelect(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::fullRowSelect_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, fullRowSelect);
   return (bool)ListBox_get_fullRowSelect(self ? self->impl : null);
}

// property callers: ListBox::collapseControl
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::collapseControl_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, collapseControl);
   ListBox_set_collapseControl(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::collapseControl_Prop & ListBox::collapseControl_Prop::operator= (ListBox::collapseControl_Prop & prop)
{
   SELF(ListBox, collapseControl);
   /*0H*/bool v = prop;
   ListBox_set_collapseControl(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::collapseControl_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, collapseControl);
   return (bool)ListBox_get_collapseControl(self ? self->impl : null);
}

// property callers: ListBox::treeBranches
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::treeBranches_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, treeBranches);
   ListBox_set_treeBranches(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::treeBranches_Prop & ListBox::treeBranches_Prop::operator= (ListBox::treeBranches_Prop & prop)
{
   SELF(ListBox, treeBranches);
   /*0H*/bool v = prop;
   ListBox_set_treeBranches(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::treeBranches_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, treeBranches);
   return (bool)ListBox_get_treeBranches(self ? self->impl : null);
}

// property callers: ListBox::rootCollapseButton
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::rootCollapseButton_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, rootCollapseButton);
   ListBox_set_rootCollapseButton(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::rootCollapseButton_Prop & ListBox::rootCollapseButton_Prop::operator= (ListBox::rootCollapseButton_Prop & prop)
{
   SELF(ListBox, rootCollapseButton);
   /*0H*/bool v = prop;
   ListBox_set_rootCollapseButton(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::rootCollapseButton_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, rootCollapseButton);
   return (bool)ListBox_get_rootCollapseButton(self ? self->impl : null);
}

// property callers: ListBox::sortable
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::sortable_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, sortable);
   ListBox_set_sortable(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::sortable_Prop & ListBox::sortable_Prop::operator= (ListBox::sortable_Prop & prop)
{
   SELF(ListBox, sortable);
   /*0H*/bool v = prop;
   ListBox_set_sortable(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::sortable_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, sortable);
   return (bool)ListBox_get_sortable(self ? self->impl : null);
}

// property callers: ListBox::noDragging
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::noDragging_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, noDragging);
   ListBox_set_noDragging(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::noDragging_Prop & ListBox::noDragging_Prop::operator= (ListBox::noDragging_Prop & prop)
{
   SELF(ListBox, noDragging);
   /*0H*/bool v = prop;
   ListBox_set_noDragging(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::noDragging_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, noDragging);
   return (bool)ListBox_get_noDragging(self ? self->impl : null);
}

// property callers: ListBox::fillLastField
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::fillLastField_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, fillLastField);
   ListBox_set_fillLastField(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::fillLastField_Prop & ListBox::fillLastField_Prop::operator= (ListBox::fillLastField_Prop & prop)
{
   SELF(ListBox, fillLastField);
   /*0H*/bool v = prop;
   ListBox_set_fillLastField(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::fillLastField_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, fillLastField);
   return (bool)ListBox_get_fillLastField(self ? self->impl : null);
}

// property callers: ListBox::numSelections   // get only
// (normal::int)

/*regGet*/inline ListBox::numSelections_Prop::operator /*0I*/int () const
{
   SELF(ListBox, numSelections);
   return ListBox_get_numSelections(self ? self->impl : null);
}

// property callers: ListBox::currentIndex   // get only
// (normal::int)

/*regGet*/inline ListBox::currentIndex_Prop::operator /*0I*/int () const
{
   SELF(ListBox, currentIndex);
   return ListBox_get_currentIndex(self ? self->impl : null);
}

// property callers: ListBox::lastRow   // get only
// (normal::normal)

/*regGet*/inline ListBox::lastRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(ListBox, lastRow);
   C(Instance) i = ListBox_get_lastRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> ListBox::lastRow_Prop::operator /*0D*/-> () const
{
   SELF(ListBox, lastRow);
   C(Instance) i = ListBox_get_lastRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline ListBox::lastRow_Prop::operator /*0E*/DataRow () const
{
   SELF(ListBox, lastRow);
   C(Instance) i = ListBox_get_lastRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline ListBox::lastRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(ListBox, lastRow);
   C(Instance) i = ListBox_get_lastRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: ListBox::firstRow   // get only
// (normal::normal)

/*regGet*/inline ListBox::firstRow_Prop::operator /*0B*/TIH<DataRow> () const
{
   SELF(ListBox, firstRow);
   C(Instance) i = ListBox_get_firstRow(self ? self->impl : null);
   TIH<DataRow> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataRow> ListBox::firstRow_Prop::operator /*0D*/-> () const
{
   SELF(ListBox, firstRow);
   C(Instance) i = ListBox_get_firstRow(self ? self->impl : null);
   TIH<DataRow> holder(i);
   return holder;
}
/*regGet*/inline ListBox::firstRow_Prop::operator /*0E*/DataRow () const
{
   SELF(ListBox, firstRow);
   C(Instance) i = ListBox_get_firstRow(self ? self->impl : null);
   return DataRow(i);
}
/*regGet*/inline ListBox::firstRow_Prop::operator /*0F*/DataRow* () const
{
   SELF(ListBox, firstRow);
   C(Instance) i = ListBox_get_firstRow(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataRow *)INSTANCEL(i, i->_class) : (DataRow *)0;
}

// property callers: ListBox::rowCount   // get only
// (normal::int)

/*regGet*/inline ListBox::rowCount_Prop::operator /*0I*/int () const
{
   SELF(ListBox, rowCount);
   return ListBox_get_rowCount(self ? self->impl : null);
}

// property callers: ListBox::firstField   // get only
// (normal::normal)

/*regGet*/inline ListBox::firstField_Prop::operator /*0B*/TIH<DataField> () const
{
   SELF(ListBox, firstField);
   C(Instance) i = ListBox_get_firstField(self ? self->impl : null);
   TIH<DataField> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<DataField> ListBox::firstField_Prop::operator /*0D*/-> () const
{
   SELF(ListBox, firstField);
   C(Instance) i = ListBox_get_firstField(self ? self->impl : null);
   TIH<DataField> holder(i);
   return holder;
}
/*regGet*/inline ListBox::firstField_Prop::operator /*0E*/DataField () const
{
   SELF(ListBox, firstField);
   C(Instance) i = ListBox_get_firstField(self ? self->impl : null);
   return DataField(i);
}
/*regGet*/inline ListBox::firstField_Prop::operator /*0F*/DataField* () const
{
   SELF(ListBox, firstField);
   C(Instance) i = ListBox_get_firstField(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (DataField *)INSTANCEL(i, i->_class) : (DataField *)0;
}

// property callers: ListBox::selectionColor
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color ListBox::selectionColor_Prop::operator= (/*0H*/Color v)
{
   SELF(ListBox, selectionColor);
   ListBox_set_selectionColor(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ListBox::selectionColor_Prop & ListBox::selectionColor_Prop::operator= (ListBox::selectionColor_Prop & prop)
{
   SELF(ListBox, selectionColor);
   /*0H*/Color v = prop;
   ListBox_set_selectionColor(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ListBox::selectionColor_Prop::operator /*0I*/Color () const
{
   SELF(ListBox, selectionColor);
   return ListBox_get_selectionColor(self ? self->impl : null);
}

// property callers: ListBox::selectionText
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color ListBox::selectionText_Prop::operator= (/*0H*/Color v)
{
   SELF(ListBox, selectionText);
   ListBox_set_selectionText(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ListBox::selectionText_Prop & ListBox::selectionText_Prop::operator= (ListBox::selectionText_Prop & prop)
{
   SELF(ListBox, selectionText);
   /*0H*/Color v = prop;
   ListBox_set_selectionText(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ListBox::selectionText_Prop::operator /*0I*/Color () const
{
   SELF(ListBox, selectionText);
   return ListBox_get_selectionText(self ? self->impl : null);
}

// property callers: ListBox::stippleColor
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color ListBox::stippleColor_Prop::operator= (/*0H*/Color v)
{
   SELF(ListBox, stippleColor);
   ListBox_set_stippleColor(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ListBox::stippleColor_Prop & ListBox::stippleColor_Prop::operator= (ListBox::stippleColor_Prop & prop)
{
   SELF(ListBox, stippleColor);
   /*0H*/Color v = prop;
   ListBox_set_stippleColor(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ListBox::stippleColor_Prop::operator /*0I*/Color () const
{
   SELF(ListBox, stippleColor);
   return ListBox_get_stippleColor(self ? self->impl : null);
}

// property callers: ListBox::expandOnAdd
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ListBox::expandOnAdd_Prop::operator= (/*0H*/bool v)
{
   SELF(ListBox, expandOnAdd);
   ListBox_set_expandOnAdd(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ListBox::expandOnAdd_Prop & ListBox::expandOnAdd_Prop::operator= (ListBox::expandOnAdd_Prop & prop)
{
   SELF(ListBox, expandOnAdd);
   /*0H*/bool v = prop;
   ListBox_set_expandOnAdd(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ListBox::expandOnAdd_Prop::operator /*0I*/bool () const
{
   SELF(ListBox, expandOnAdd);
   return (bool)ListBox_get_expandOnAdd(self ? self->impl : null);
}


// member accessors: ListBox::typingTimeOut
// (normal::double)

/*nstSet*/inline /*0H*/double ListBox::typingTimeOut_Prop::operator= (/*0H*/double v)
{
   SELF(ListBox, typingTimeOut);
   IPTR(self->impl, ListBox)->typingTimeOut = v;
   return v;
}

/*regSet*/inline ListBox::typingTimeOut_Prop & ListBox::typingTimeOut_Prop::operator= (ListBox::typingTimeOut_Prop & prop)
{
   SELF(ListBox, typingTimeOut);
   /*0H*/double v = prop;
   IPTR(self->impl, ListBox)->typingTimeOut = v;
   return prop;
}
/*regGet*/inline ListBox::typingTimeOut_Prop::operator /*0I*/double () const
{
   SELF(ListBox, typingTimeOut);
   return self ? IPTR(self->impl, ListBox)->typingTimeOut : 0;
}


inline void Menu::addDynamic(/*1Ab*/MenuItem & addedItem, /*1Ab*/Window & master, /*1Ab*/bool persistent)
{
   Menu_addDynamic(impl, /*5De*/addedItem.impl, /*5De*/master.impl, /*5Ee*/(C(bool))persistent);
}
inline void Menu::addItem(/*1Ab*/MenuItem & item)
{
   Menu_addItem(impl, /*5De*/item.impl);
}
inline void Menu::addSubMenu(/*1Ab*/Menu & subMenu)
{
   Menu_addSubMenu(impl, /*5De*/subMenu.impl);
}
inline void Menu::clean(/*1Ab*/Window & window)
{
   Menu_clean(impl, /*5De*/window.impl);
}
inline void Menu::clear()
{
   Menu_clear(impl);
}
inline MenuItem Menu::findItem(C(bool) (* notifySelect)(C(Window) __this, C(MenuItem) selection, C(Modifiers) mods), /*1Ab*/uint64 id)
{
   return MenuItem(Menu_findItem(impl, /*5Ge*/notifySelect, /*5Ge*/id));
}
inline Menu Menu::findMenu(/*1Ab*/const char * name)
{
   return Menu(Menu_findMenu(impl, /*5Ge*/name));
}
inline void Menu::merge(/*1Ab*/Menu & menuBeingMerged, /*1Ab*/bool menuBar, /*1Ab*/Window & window)
{
   Menu_merge(impl, /*5De*/menuBeingMerged.impl, /*5Ee*/(C(bool))menuBar, /*5De*/window.impl);
}
inline void Menu::removeItem(/*1Ab*/MenuItem & item)
{
   Menu_removeItem(impl, /*5De*/item.impl);
}


// property callers: Menu::parent   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const Menu & Menu::parent_Prop::operator= (/*0A*/const Menu & v)
{
   SELF(Menu, parent);
   Menu_set_parent(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const Menu * Menu::parent_Prop::operator= (/*0C*/const Menu * v)
{
   SELF(Menu, parent);
   Menu_set_parent(self ? self->impl : null, v ? v->impl : null);
   return v;
}


// property callers: Menu::text   // set only
// (normal::const char *)

/*nstSet*/inline /*0G*/const char * Menu::text_Prop::operator= (/*0G*/const char * v)
{
   SELF(Menu, text);
   Menu_set_text(self->impl, v);
   return v;
}


// property callers: Menu::hotKey   // set only
// (normal::bits|unsigned int)

/*nstSet*/inline /*0G*/Key Menu::hotKey_Prop::operator= (/*0G*/Key v)
{
   SELF(Menu, hotKey);
   Menu_set_hotKey(self->impl, v);
   return v;
}


// property callers: Menu::hasMargin   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Menu::hasMargin_Prop::operator= (/*0G*/bool v)
{
   SELF(Menu, hasMargin);
   Menu_set_hasMargin(self->impl, (C(bool))v);
   return v;
}


// property callers: Menu::copyText   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool Menu::copyText_Prop::operator= (/*0G*/bool v)
{
   SELF(Menu, copyText);
   Menu_set_copyText(self->impl, (C(bool))v);
   return v;
}



inline MenuItem::MenuItem_notifySelect_Functor::FunctionType MenuItem::MenuItem_notifySelect_Functor::operator= (FunctionType func)
{
   SELF(MenuItem, notifySelect);
   if(self->vTbl == MenuItem::_cpp_class.vTbl)
   {
      uint size = MenuItem::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(MenuItem::MenuItem_notifySelect_Functor::FunctionType, size);
      memcpy(self->vTbl, MenuItem::_cpp_class.vTbl, sizeof(MenuItem::MenuItem_notifySelect_Functor::FunctionType) * size);
   }
   ((MenuItem::MenuItem_notifySelect_Functor::FunctionType *)self->vTbl)[M_VTBLID(MenuItem, notifySelect)] = func;
   return func;
}
inline bool MenuItem::MenuItem_notifySelect_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/MenuItem & selection, /*6Fj*/Modifiers mods)
{
   SELF(MenuItem, notifySelect);
   return (bool)MenuItem_notifySelect(self ? self->impl : (C(MenuItem))null, o_.impl, /*7Al*/selection.impl, /*7Al*/(C(Modifiers))mods);
}
// inline void MenuItem::register_notifySelect(CPPClass & cl, MenuItem::MenuItem_notifySelect_Functor::FunctionType func)
// {
//    ((MenuItem::MenuItem_notifySelect_Functor::FunctionType *)cl.vTbl)[M_VTBLID(MenuItem, notifySelect)] = func;
// }



// property callers: MenuItem::parent   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const Menu & MenuItem::parent_Prop::operator= (/*0A*/const Menu & v)
{
   SELF(MenuItem, parent);
   MenuItem_set_parent(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const Menu * MenuItem::parent_Prop::operator= (/*0C*/const Menu * v)
{
   SELF(MenuItem, parent);
   MenuItem_set_parent(self ? self->impl : null, v ? v->impl : null);
   return v;
}


// property callers: MenuItem::text   // set only
// (normal::const char *)

/*nstSet*/inline /*0G*/const char * MenuItem::text_Prop::operator= (/*0G*/const char * v)
{
   SELF(MenuItem, text);
   MenuItem_set_text(self->impl, v);
   return v;
}


// property callers: MenuItem::hotKey   // set only
// (normal::bits|unsigned int)

/*nstSet*/inline /*0G*/Key MenuItem::hotKey_Prop::operator= (/*0G*/Key v)
{
   SELF(MenuItem, hotKey);
   MenuItem_set_hotKey(self->impl, v);
   return v;
}


// property callers: MenuItem::accelerator   // set only
// (normal::bits|unsigned int)

/*nstSet*/inline /*0G*/Key MenuItem::accelerator_Prop::operator= (/*0G*/Key v)
{
   SELF(MenuItem, accelerator);
   MenuItem_set_accelerator(self->impl, v);
   return v;
}


// property callers: MenuItem::checked
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool MenuItem::checked_Prop::operator= (/*0H*/bool v)
{
   SELF(MenuItem, checked);
   MenuItem_set_checked(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline MenuItem::checked_Prop & MenuItem::checked_Prop::operator= (MenuItem::checked_Prop & prop)
{
   SELF(MenuItem, checked);
   /*0H*/bool v = prop;
   MenuItem_set_checked(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline MenuItem::checked_Prop::operator /*0I*/bool () const
{
   SELF(MenuItem, checked);
   return (bool)MenuItem_get_checked(self ? self->impl : null);
}

// property callers: MenuItem::disabled   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool MenuItem::disabled_Prop::operator= (/*0G*/bool v)
{
   SELF(MenuItem, disabled);
   MenuItem_set_disabled(self->impl, (C(bool))v);
   return v;
}


// property callers: MenuItem::checkable   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool MenuItem::checkable_Prop::operator= (/*0G*/bool v)
{
   SELF(MenuItem, checkable);
   MenuItem_set_checkable(self->impl, (C(bool))v);
   return v;
}


// property callers: MenuItem::isRadio   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool MenuItem::isRadio_Prop::operator= (/*0G*/bool v)
{
   SELF(MenuItem, isRadio);
   MenuItem_set_isRadio(self->impl, (C(bool))v);
   return v;
}


// property callers: MenuItem::id
// (normal::uint64)

/*nstSet*/inline /*0H*/uint64 MenuItem::id_Prop::operator= (/*0H*/uint64 v)
{
   SELF(MenuItem, id);
   MenuItem_set_id(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline MenuItem::id_Prop & MenuItem::id_Prop::operator= (MenuItem::id_Prop & prop)
{
   SELF(MenuItem, id);
   /*0H*/uint64 v = prop;
   MenuItem_set_id(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline MenuItem::id_Prop::operator /*0I*/uint64 () const
{
   SELF(MenuItem, id);
   return MenuItem_get_id(self ? self->impl : null);
}

// property callers: MenuItem::bitmap
// (normal::normal)

/*nstSet*/inline /*0A*/const BitmapResource & MenuItem::bitmap_Prop::operator= (/*0A*/const BitmapResource & v)
{
   SELF(MenuItem, bitmap);
   MenuItem_set_bitmap(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline MenuItem::bitmap_Prop & MenuItem::bitmap_Prop::operator= (MenuItem::bitmap_Prop & prop)
{
   SELF(MenuItem, bitmap);
   /*0A*/const BitmapResource & v = prop;
   MenuItem_set_bitmap(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const BitmapResource * MenuItem::bitmap_Prop::operator= (/*0C*/const BitmapResource * v)
{
   SELF(MenuItem, bitmap);
   MenuItem_set_bitmap(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline MenuItem::bitmap_Prop::operator /*0B*/TIH<BitmapResource> () const
{
   SELF(MenuItem, bitmap);
   C(Instance) i = MenuItem_get_bitmap(self ? self->impl : null);
   TIH<BitmapResource> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<BitmapResource> MenuItem::bitmap_Prop::operator /*0D*/-> () const
{
   SELF(MenuItem, bitmap);
   C(Instance) i = MenuItem_get_bitmap(self ? self->impl : null);
   TIH<BitmapResource> holder(i);
   return holder;
}
/*regGet*/inline MenuItem::bitmap_Prop::operator /*0E*/BitmapResource () const
{
   SELF(MenuItem, bitmap);
   C(Instance) i = MenuItem_get_bitmap(self ? self->impl : null);
   return BitmapResource(i);
}
/*regGet*/inline MenuItem::bitmap_Prop::operator /*0F*/BitmapResource* () const
{
   SELF(MenuItem, bitmap);
   C(Instance) i = MenuItem_get_bitmap(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (BitmapResource *)INSTANCEL(i, i->_class) : (BitmapResource *)0;
}

// property callers: MenuItem::copyText   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool MenuItem::copyText_Prop::operator= (/*0G*/bool v)
{
   SELF(MenuItem, copyText);
   MenuItem_set_copyText(self->impl, (C(bool))v);
   return v;
}


// property callers: MenuItem::bold
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool MenuItem::bold_Prop::operator= (/*0H*/bool v)
{
   SELF(MenuItem, bold);
   MenuItem_set_bold(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline MenuItem::bold_Prop & MenuItem::bold_Prop::operator= (MenuItem::bold_Prop & prop)
{
   SELF(MenuItem, bold);
   /*0H*/bool v = prop;
   MenuItem_set_bold(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline MenuItem::bold_Prop::operator /*0I*/bool () const
{
   SELF(MenuItem, bold);
   return (bool)MenuItem_get_bold(self ? self->impl : null);
}




// property callers: OldArray::size
// (normal::uint)

/*nstSet*/inline /*0H*/uint OldArray::size_Prop::operator= (/*0H*/uint v)
{
   SELF(OldArray, size);
   OldArray_set_size(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline OldArray::size_Prop & OldArray::size_Prop::operator= (OldArray::size_Prop & prop)
{
   SELF(OldArray, size);
   /*0H*/uint v = prop;
   OldArray_set_size(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline OldArray::size_Prop::operator /*0I*/uint () const
{
   SELF(OldArray, size);
   return OldArray_get_size(self ? self->impl : null);
}

// property callers: OldArray::data   // set only
// (normal::void *)

/*nstSet*/inline /*0G*/void * OldArray::data_Prop::operator= (/*0G*/void * v)
{
   SELF(OldArray, data);
   OldArray_set_data(self->impl, v);
   return v;
}



// member accessors: OldArray::type
// (normal::nohead)

/*nstSet*/inline /*0H*/Class OldArray::type_Prop::operator= (/*0H*/Class & v)
{
   SELF(OldArray, type);
   IPTR(self->impl, OldArray)->type = v.impl;
   return v;
}

/*regSet*/inline OldArray::type_Prop & OldArray::type_Prop::operator= (OldArray::type_Prop & prop)
{
   SELF(OldArray, type);
   /*0H*/Class v = prop;
   IPTR(self->impl, OldArray)->type = v.impl;
   return prop;
}
/*regGet*/inline OldArray::type_Prop::operator /*0I*/Class () const
{
   SELF(OldArray, type);
   Class value(IPTR(self->impl, OldArray)->type);
   return value;
}

inline PaneSplitter::PaneSplitter(int toolSize, int toolGap = 0) : PaneSplitter()
{
   this->toolSize = toolSize;
   this->toolGap = toolGap;
}

inline PaneSplitter::PaneSplitter_notifyResized_Functor::FunctionType PaneSplitter::PaneSplitter_notifyResized_Functor::operator= (FunctionType func)
{
   SELF(PaneSplitter, notifyResized);
   if(self->vTbl == PaneSplitter::_cpp_class.vTbl)
   {
      uint size = PaneSplitter::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(PaneSplitter::PaneSplitter_notifyResized_Functor::FunctionType, size);
      memcpy(self->vTbl, PaneSplitter::_cpp_class.vTbl, sizeof(PaneSplitter::PaneSplitter_notifyResized_Functor::FunctionType) * size);
   }
   ((PaneSplitter::PaneSplitter_notifyResized_Functor::FunctionType *)self->vTbl)[M_VTBLID(PaneSplitter, notifyResized)] = func;
   return func;
}
inline bool PaneSplitter::PaneSplitter_notifyResized_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/PaneSplitter & splitter)
{
   SELF(PaneSplitter, notifyResized);
   return (bool)PaneSplitter_notifyResized(self ? self->impl : (C(PaneSplitter))null, o_.impl, /*7Al*/splitter.impl);
}
// inline void PaneSplitter::register_notifyResized(CPPClass & cl, PaneSplitter::PaneSplitter_notifyResized_Functor::FunctionType func)
// {
//    ((PaneSplitter::PaneSplitter_notifyResized_Functor::FunctionType *)cl.vTbl)[M_VTBLID(PaneSplitter, notifyResized)] = func;
// }



// property callers: PaneSplitter::toolSize
// (normal::int)

/*nstSet*/inline /*0H*/int PaneSplitter::toolSize_Prop::operator= (/*0H*/int v)
{
   SELF(PaneSplitter, toolSize);
   PaneSplitter_set_toolSize(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline PaneSplitter::toolSize_Prop & PaneSplitter::toolSize_Prop::operator= (PaneSplitter::toolSize_Prop & prop)
{
   SELF(PaneSplitter, toolSize);
   /*0H*/int v = prop;
   PaneSplitter_set_toolSize(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline PaneSplitter::toolSize_Prop::operator /*0I*/int () const
{
   SELF(PaneSplitter, toolSize);
   return PaneSplitter_get_toolSize(self ? self->impl : null);
}

// property callers: PaneSplitter::toolGap
// (normal::int)

/*nstSet*/inline /*0H*/int PaneSplitter::toolGap_Prop::operator= (/*0H*/int v)
{
   SELF(PaneSplitter, toolGap);
   PaneSplitter_set_toolGap(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline PaneSplitter::toolGap_Prop & PaneSplitter::toolGap_Prop::operator= (PaneSplitter::toolGap_Prop & prop)
{
   SELF(PaneSplitter, toolGap);
   /*0H*/int v = prop;
   PaneSplitter_set_toolGap(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline PaneSplitter::toolGap_Prop::operator /*0I*/int () const
{
   SELF(PaneSplitter, toolGap);
   return PaneSplitter_get_toolGap(self ? self->impl : null);
}

// property callers: PaneSplitter::leftPane
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & PaneSplitter::leftPane_Prop::operator= (/*0A*/const Window & v)
{
   SELF(PaneSplitter, leftPane);
   PaneSplitter_set_leftPane(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline PaneSplitter::leftPane_Prop & PaneSplitter::leftPane_Prop::operator= (PaneSplitter::leftPane_Prop & prop)
{
   SELF(PaneSplitter, leftPane);
   /*0A*/const Window & v = prop;
   PaneSplitter_set_leftPane(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * PaneSplitter::leftPane_Prop::operator= (/*0C*/const Window * v)
{
   SELF(PaneSplitter, leftPane);
   PaneSplitter_set_leftPane(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline PaneSplitter::leftPane_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(PaneSplitter, leftPane);
   C(Instance) i = PaneSplitter_get_leftPane(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> PaneSplitter::leftPane_Prop::operator /*0D*/-> () const
{
   SELF(PaneSplitter, leftPane);
   C(Instance) i = PaneSplitter_get_leftPane(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline PaneSplitter::leftPane_Prop::operator /*0E*/Window () const
{
   SELF(PaneSplitter, leftPane);
   C(Instance) i = PaneSplitter_get_leftPane(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline PaneSplitter::leftPane_Prop::operator /*0F*/Window* () const
{
   SELF(PaneSplitter, leftPane);
   C(Instance) i = PaneSplitter_get_leftPane(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: PaneSplitter::rightPane
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & PaneSplitter::rightPane_Prop::operator= (/*0A*/const Window & v)
{
   SELF(PaneSplitter, rightPane);
   PaneSplitter_set_rightPane(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline PaneSplitter::rightPane_Prop & PaneSplitter::rightPane_Prop::operator= (PaneSplitter::rightPane_Prop & prop)
{
   SELF(PaneSplitter, rightPane);
   /*0A*/const Window & v = prop;
   PaneSplitter_set_rightPane(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * PaneSplitter::rightPane_Prop::operator= (/*0C*/const Window * v)
{
   SELF(PaneSplitter, rightPane);
   PaneSplitter_set_rightPane(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline PaneSplitter::rightPane_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(PaneSplitter, rightPane);
   C(Instance) i = PaneSplitter_get_rightPane(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> PaneSplitter::rightPane_Prop::operator /*0D*/-> () const
{
   SELF(PaneSplitter, rightPane);
   C(Instance) i = PaneSplitter_get_rightPane(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline PaneSplitter::rightPane_Prop::operator /*0E*/Window () const
{
   SELF(PaneSplitter, rightPane);
   C(Instance) i = PaneSplitter_get_rightPane(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline PaneSplitter::rightPane_Prop::operator /*0F*/Window* () const
{
   SELF(PaneSplitter, rightPane);
   C(Instance) i = PaneSplitter_get_rightPane(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: PaneSplitter::topPane
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & PaneSplitter::topPane_Prop::operator= (/*0A*/const Window & v)
{
   SELF(PaneSplitter, topPane);
   PaneSplitter_set_topPane(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline PaneSplitter::topPane_Prop & PaneSplitter::topPane_Prop::operator= (PaneSplitter::topPane_Prop & prop)
{
   SELF(PaneSplitter, topPane);
   /*0A*/const Window & v = prop;
   PaneSplitter_set_topPane(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * PaneSplitter::topPane_Prop::operator= (/*0C*/const Window * v)
{
   SELF(PaneSplitter, topPane);
   PaneSplitter_set_topPane(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline PaneSplitter::topPane_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(PaneSplitter, topPane);
   C(Instance) i = PaneSplitter_get_topPane(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> PaneSplitter::topPane_Prop::operator /*0D*/-> () const
{
   SELF(PaneSplitter, topPane);
   C(Instance) i = PaneSplitter_get_topPane(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline PaneSplitter::topPane_Prop::operator /*0E*/Window () const
{
   SELF(PaneSplitter, topPane);
   C(Instance) i = PaneSplitter_get_topPane(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline PaneSplitter::topPane_Prop::operator /*0F*/Window* () const
{
   SELF(PaneSplitter, topPane);
   C(Instance) i = PaneSplitter_get_topPane(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: PaneSplitter::bottomPane
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & PaneSplitter::bottomPane_Prop::operator= (/*0A*/const Window & v)
{
   SELF(PaneSplitter, bottomPane);
   PaneSplitter_set_bottomPane(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline PaneSplitter::bottomPane_Prop & PaneSplitter::bottomPane_Prop::operator= (PaneSplitter::bottomPane_Prop & prop)
{
   SELF(PaneSplitter, bottomPane);
   /*0A*/const Window & v = prop;
   PaneSplitter_set_bottomPane(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * PaneSplitter::bottomPane_Prop::operator= (/*0C*/const Window * v)
{
   SELF(PaneSplitter, bottomPane);
   PaneSplitter_set_bottomPane(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline PaneSplitter::bottomPane_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(PaneSplitter, bottomPane);
   C(Instance) i = PaneSplitter_get_bottomPane(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> PaneSplitter::bottomPane_Prop::operator /*0D*/-> () const
{
   SELF(PaneSplitter, bottomPane);
   C(Instance) i = PaneSplitter_get_bottomPane(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline PaneSplitter::bottomPane_Prop::operator /*0E*/Window () const
{
   SELF(PaneSplitter, bottomPane);
   C(Instance) i = PaneSplitter_get_bottomPane(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline PaneSplitter::bottomPane_Prop::operator /*0F*/Window* () const
{
   SELF(PaneSplitter, bottomPane);
   C(Instance) i = PaneSplitter_get_bottomPane(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: PaneSplitter::scaleSplit
// (normal::double)

/*nstSet*/inline /*0H*/double PaneSplitter::scaleSplit_Prop::operator= (/*0H*/double v)
{
   SELF(PaneSplitter, scaleSplit);
   PaneSplitter_set_scaleSplit(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline PaneSplitter::scaleSplit_Prop & PaneSplitter::scaleSplit_Prop::operator= (PaneSplitter::scaleSplit_Prop & prop)
{
   SELF(PaneSplitter, scaleSplit);
   /*0H*/double v = prop;
   PaneSplitter_set_scaleSplit(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline PaneSplitter::scaleSplit_Prop::operator /*0I*/double () const
{
   SELF(PaneSplitter, scaleSplit);
   return PaneSplitter_get_scaleSplit(self ? self->impl : null);
}

// property callers: PaneSplitter::orientation
// (normal::enum|int)

/*nstSet*/inline /*0H*/ScrollDirection PaneSplitter::orientation_Prop::operator= (/*0H*/ScrollDirection v)
{
   SELF(PaneSplitter, orientation);
   PaneSplitter_set_orientation(self ? self->impl : null, (C(ScrollDirection))v);
   return v;
}

/*regSet*/inline PaneSplitter::orientation_Prop & PaneSplitter::orientation_Prop::operator= (PaneSplitter::orientation_Prop & prop)
{
   SELF(PaneSplitter, orientation);
   /*0H*/ScrollDirection v = prop;
   PaneSplitter_set_orientation(self ? self->impl : null, (C(ScrollDirection))v);
   return prop;
}
/*regGet*/inline PaneSplitter::orientation_Prop::operator /*0I*/ScrollDirection () const
{
   SELF(PaneSplitter, orientation);
   return (ScrollDirection)PaneSplitter_get_orientation(self ? self->impl : null);
}

// property callers: PaneSplitter::split
// (normal::int)

/*nstSet*/inline /*0H*/int PaneSplitter::split_Prop::operator= (/*0H*/int v)
{
   SELF(PaneSplitter, split);
   PaneSplitter_set_split(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline PaneSplitter::split_Prop & PaneSplitter::split_Prop::operator= (PaneSplitter::split_Prop & prop)
{
   SELF(PaneSplitter, split);
   /*0H*/int v = prop;
   PaneSplitter_set_split(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline PaneSplitter::split_Prop::operator /*0I*/int () const
{
   SELF(PaneSplitter, split);
   return PaneSplitter_get_split(self ? self->impl : null);
}

inline PathBox::PathBox(PathTypeExpected typeExpected) : PathBox()
{
   this->typeExpected = typeExpected;
}

inline PathBox::PathBox_notifyModified_Functor::FunctionType PathBox::PathBox_notifyModified_Functor::operator= (FunctionType func)
{
   SELF(PathBox, notifyModified);
   if(self->vTbl == PathBox::_cpp_class.vTbl)
   {
      uint size = PathBox::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(PathBox::PathBox_notifyModified_Functor::FunctionType, size);
      memcpy(self->vTbl, PathBox::_cpp_class.vTbl, sizeof(PathBox::PathBox_notifyModified_Functor::FunctionType) * size);
   }
   ((PathBox::PathBox_notifyModified_Functor::FunctionType *)self->vTbl)[M_VTBLID(PathBox, notifyModified)] = func;
   return func;
}
inline bool PathBox::PathBox_notifyModified_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/PathBox & pathBox)
{
   SELF(PathBox, notifyModified);
   return (bool)PathBox_notifyModified(self ? self->impl : (C(PathBox))null, o_.impl, /*7Al*/pathBox.impl);
}
// inline void PathBox::register_notifyModified(CPPClass & cl, PathBox::PathBox_notifyModified_Functor::FunctionType func)
// {
//    ((PathBox::PathBox_notifyModified_Functor::FunctionType *)cl.vTbl)[M_VTBLID(PathBox, notifyModified)] = func;
// }


inline void PathBox::deselect()
{
   PathBox_deselect(impl);
}
inline void PathBox::end()
{
   PathBox_end(impl);
}
inline void PathBox::home()
{
   PathBox_home(impl);
}
inline void PathBox::selectAll()
{
   PathBox_selectAll(impl);
}


// property callers: PathBox::editBox   // get only
// (normal::normal)

/*regGet*/inline PathBox::editBox_Prop::operator /*0B*/TIH<EditBox> () const
{
   SELF(PathBox, editBox);
   C(Instance) i = PathBox_get_editBox(self ? self->impl : null);
   TIH<EditBox> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<EditBox> PathBox::editBox_Prop::operator /*0D*/-> () const
{
   SELF(PathBox, editBox);
   C(Instance) i = PathBox_get_editBox(self ? self->impl : null);
   TIH<EditBox> holder(i);
   return holder;
}
/*regGet*/inline PathBox::editBox_Prop::operator /*0E*/EditBox () const
{
   SELF(PathBox, editBox);
   C(Instance) i = PathBox_get_editBox(self ? self->impl : null);
   return EditBox(i);
}
/*regGet*/inline PathBox::editBox_Prop::operator /*0F*/EditBox* () const
{
   SELF(PathBox, editBox);
   C(Instance) i = PathBox_get_editBox(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (EditBox *)INSTANCEL(i, i->_class) : (EditBox *)0;
}

// property callers: PathBox::typeExpected   // set only
// (normal::enum|int)

/*nstSet*/inline /*0G*/PathTypeExpected PathBox::typeExpected_Prop::operator= (/*0G*/PathTypeExpected v)
{
   SELF(PathBox, typeExpected);
   PathBox_set_typeExpected(self->impl, (C(PathTypeExpected))v);
   return v;
}


// property callers: PathBox::browseDialog
// (normal::normal)

/*nstSet*/inline /*0A*/const FileDialog & PathBox::browseDialog_Prop::operator= (/*0A*/const FileDialog & v)
{
   SELF(PathBox, browseDialog);
   PathBox_set_browseDialog(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline PathBox::browseDialog_Prop & PathBox::browseDialog_Prop::operator= (PathBox::browseDialog_Prop & prop)
{
   SELF(PathBox, browseDialog);
   /*0A*/const FileDialog & v = prop;
   PathBox_set_browseDialog(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const FileDialog * PathBox::browseDialog_Prop::operator= (/*0C*/const FileDialog * v)
{
   SELF(PathBox, browseDialog);
   PathBox_set_browseDialog(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline PathBox::browseDialog_Prop::operator /*0B*/TIH<FileDialog> () const
{
   SELF(PathBox, browseDialog);
   C(Instance) i = PathBox_get_browseDialog(self ? self->impl : null);
   TIH<FileDialog> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<FileDialog> PathBox::browseDialog_Prop::operator /*0D*/-> () const
{
   SELF(PathBox, browseDialog);
   C(Instance) i = PathBox_get_browseDialog(self ? self->impl : null);
   TIH<FileDialog> holder(i);
   return holder;
}
/*regGet*/inline PathBox::browseDialog_Prop::operator /*0E*/FileDialog () const
{
   SELF(PathBox, browseDialog);
   C(Instance) i = PathBox_get_browseDialog(self ? self->impl : null);
   return FileDialog(i);
}
/*regGet*/inline PathBox::browseDialog_Prop::operator /*0F*/FileDialog* () const
{
   SELF(PathBox, browseDialog);
   C(Instance) i = PathBox_get_browseDialog(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (FileDialog *)INSTANCEL(i, i->_class) : (FileDialog *)0;
}

// property callers: PathBox::path
// (normal::string)

/*nstSet*/inline /*0H*//*CT-D*/constString PathBox::path_Prop::operator= (/*0H*//*CT-D*/constString v)
{
   SELF(PathBox, path);
   PathBox_set_path(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline PathBox::path_Prop & PathBox::path_Prop::operator= (PathBox::path_Prop & prop)
{
   SELF(PathBox, path);
   /*0H*//*CT-D*/constString v = prop;
   PathBox_set_path(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline PathBox::path_Prop::operator /*0I*//*CT-D*/constString () const
{
   SELF(PathBox, path);
   return PathBox_get_path(self ? self->impl : null);
}

// property callers: PathBox::slashPath   // get only
// (normal::string)

/*regGet*/inline PathBox::slashPath_Prop::operator /*0I*/char * () const
{
   SELF(PathBox, slashPath);
   return PathBox_get_slashPath(self ? self->impl : null);
}

// property callers: PathBox::systemPath   // get only
// (normal::string)

/*regGet*/inline PathBox::systemPath_Prop::operator /*0I*/char * () const
{
   SELF(PathBox, systemPath);
   return PathBox_get_systemPath(self ? self->impl : null);
}

// property callers: PathBox::selectionColor
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color PathBox::selectionColor_Prop::operator= (/*0H*/Color v)
{
   SELF(PathBox, selectionColor);
   PathBox_set_selectionColor(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline PathBox::selectionColor_Prop & PathBox::selectionColor_Prop::operator= (PathBox::selectionColor_Prop & prop)
{
   SELF(PathBox, selectionColor);
   /*0H*/Color v = prop;
   PathBox_set_selectionColor(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline PathBox::selectionColor_Prop::operator /*0I*/Color () const
{
   SELF(PathBox, selectionColor);
   return PathBox_get_selectionColor(self ? self->impl : null);
}

// property callers: PathBox::selectionText
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color PathBox::selectionText_Prop::operator= (/*0H*/Color v)
{
   SELF(PathBox, selectionText);
   PathBox_set_selectionText(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline PathBox::selectionText_Prop & PathBox::selectionText_Prop::operator= (PathBox::selectionText_Prop & prop)
{
   SELF(PathBox, selectionText);
   /*0H*/Color v = prop;
   PathBox_set_selectionText(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline PathBox::selectionText_Prop::operator /*0I*/Color () const
{
   SELF(PathBox, selectionText);
   return PathBox_get_selectionText(self ? self->impl : null);
}

inline Picture::Picture(Color tint) : Picture()
{
   this->tint = tint;
}



// property callers: Picture::tint   // set only
// (normal::bits|uint)

/*nstSet*/inline /*0G*/Color Picture::tint_Prop::operator= (/*0G*/Color v)
{
   SELF(Picture, tint);
   Picture_set_tint(self->impl, v);
   return v;
}


// property callers: Picture::image
// (normal::normal)

/*nstSet*/inline /*0A*/const BitmapResource & Picture::image_Prop::operator= (/*0A*/const BitmapResource & v)
{
   SELF(Picture, image);
   Picture_set_image(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Picture::image_Prop & Picture::image_Prop::operator= (Picture::image_Prop & prop)
{
   SELF(Picture, image);
   /*0A*/const BitmapResource & v = prop;
   Picture_set_image(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const BitmapResource * Picture::image_Prop::operator= (/*0C*/const BitmapResource * v)
{
   SELF(Picture, image);
   Picture_set_image(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Picture::image_Prop::operator /*0B*/TIH<BitmapResource> () const
{
   SELF(Picture, image);
   C(Instance) i = Picture_get_image(self ? self->impl : null);
   TIH<BitmapResource> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<BitmapResource> Picture::image_Prop::operator /*0D*/-> () const
{
   SELF(Picture, image);
   C(Instance) i = Picture_get_image(self ? self->impl : null);
   TIH<BitmapResource> holder(i);
   return holder;
}
/*regGet*/inline Picture::image_Prop::operator /*0E*/BitmapResource () const
{
   SELF(Picture, image);
   C(Instance) i = Picture_get_image(self ? self->impl : null);
   return BitmapResource(i);
}
/*regGet*/inline Picture::image_Prop::operator /*0F*/BitmapResource* () const
{
   SELF(Picture, image);
   C(Instance) i = Picture_get_image(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (BitmapResource *)INSTANCEL(i, i->_class) : (BitmapResource *)0;
}

// property callers: Picture::filter
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Picture::filter_Prop::operator= (/*0H*/bool v)
{
   SELF(Picture, filter);
   Picture_set_filter(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Picture::filter_Prop & Picture::filter_Prop::operator= (Picture::filter_Prop & prop)
{
   SELF(Picture, filter);
   /*0H*/bool v = prop;
   Picture_set_filter(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Picture::filter_Prop::operator /*0I*/bool () const
{
   SELF(Picture, filter);
   return (bool)Picture_get_filter(self ? self->impl : null);
}

// property callers: Picture::bitmapImage   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const Bitmap & Picture::bitmapImage_Prop::operator= (/*0A*/const Bitmap & v)
{
   SELF(Picture, bitmapImage);
   Picture_set_bitmapImage(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const Bitmap * Picture::bitmapImage_Prop::operator= (/*0C*/const Bitmap * v)
{
   SELF(Picture, bitmapImage);
   Picture_set_bitmapImage(self ? self->impl : null, v ? v->impl : null);
   return v;
}




// property callers: PopupMenu::menu
// (normal::normal)

/*nstSet*/inline /*0A*/const Menu & PopupMenu::menu_Prop::operator= (/*0A*/const Menu & v)
{
   SELF(PopupMenu, menu);
   PopupMenu_set_menu(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline PopupMenu::menu_Prop & PopupMenu::menu_Prop::operator= (PopupMenu::menu_Prop & prop)
{
   SELF(PopupMenu, menu);
   /*0A*/const Menu & v = prop;
   PopupMenu_set_menu(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Menu * PopupMenu::menu_Prop::operator= (/*0C*/const Menu * v)
{
   SELF(PopupMenu, menu);
   PopupMenu_set_menu(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline PopupMenu::menu_Prop::operator /*0B*/TIH<Menu> () const
{
   SELF(PopupMenu, menu);
   C(Instance) i = PopupMenu_get_menu(self ? self->impl : null);
   TIH<Menu> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Menu> PopupMenu::menu_Prop::operator /*0D*/-> () const
{
   SELF(PopupMenu, menu);
   C(Instance) i = PopupMenu_get_menu(self ? self->impl : null);
   TIH<Menu> holder(i);
   return holder;
}
/*regGet*/inline PopupMenu::menu_Prop::operator /*0E*/Menu () const
{
   SELF(PopupMenu, menu);
   C(Instance) i = PopupMenu_get_menu(self ? self->impl : null);
   return Menu(i);
}
/*regGet*/inline PopupMenu::menu_Prop::operator /*0F*/Menu* () const
{
   SELF(PopupMenu, menu);
   C(Instance) i = PopupMenu_get_menu(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Menu *)INSTANCEL(i, i->_class) : (Menu *)0;
}

// property callers: PopupMenu::isMenuBar   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool PopupMenu::isMenuBar_Prop::operator= (/*0G*/bool v)
{
   SELF(PopupMenu, isMenuBar);
   PopupMenu_set_isMenuBar(self->impl, (C(bool))v);
   return v;
}


// property callers: PopupMenu::focus   // get only
// (normal::enum|uint)

/*regGet*/inline PopupMenu::focus_Prop::operator /*0I*/bool () const
{
   SELF(PopupMenu, focus);
   return (bool)PopupMenu_get_focus(self ? self->impl : null);
}

inline ProgressBar::ProgressBar(uint progress, uint range = 0) : ProgressBar()
{
   this->progress = progress;
   this->range = range;
}



// property callers: ProgressBar::progress
// (normal::uint)

/*nstSet*/inline /*0H*/uint ProgressBar::progress_Prop::operator= (/*0H*/uint v)
{
   SELF(ProgressBar, progress);
   ProgressBar_set_progress(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ProgressBar::progress_Prop & ProgressBar::progress_Prop::operator= (ProgressBar::progress_Prop & prop)
{
   SELF(ProgressBar, progress);
   /*0H*/uint v = prop;
   ProgressBar_set_progress(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ProgressBar::progress_Prop::operator /*0I*/uint () const
{
   SELF(ProgressBar, progress);
   return ProgressBar_get_progress(self ? self->impl : null);
}

// property callers: ProgressBar::range
// (normal::uint)

/*nstSet*/inline /*0H*/uint ProgressBar::range_Prop::operator= (/*0H*/uint v)
{
   SELF(ProgressBar, range);
   ProgressBar_set_range(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ProgressBar::range_Prop & ProgressBar::range_Prop::operator= (ProgressBar::range_Prop & prop)
{
   SELF(ProgressBar, range);
   /*0H*/uint v = prop;
   ProgressBar_set_range(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ProgressBar::range_Prop::operator /*0I*/uint () const
{
   SELF(ProgressBar, range);
   return ProgressBar_get_range(self ? self->impl : null);
}


inline ScrollBar::ScrollBar(ScrollDirection direction, bool windowOwned = (bool)0, bool snap = (bool)0, int range = 0, int seen = 0, int total = 0, int lineStep = 0, int pageStep = 0, int thumbPosition = 0) : ScrollBar()
{
   this->direction = direction;
   this->windowOwned = windowOwned;
   this->snap = snap;
   this->range = range;
   this->seen = seen;
   this->total = total;
   this->lineStep = lineStep;
   this->pageStep = pageStep;
   this->thumbPosition = thumbPosition;
}

inline ScrollBar::ScrollBar_notifyScrolling_Functor::FunctionType ScrollBar::ScrollBar_notifyScrolling_Functor::operator= (FunctionType func)
{
   SELF(ScrollBar, notifyScrolling);
   if(self->vTbl == ScrollBar::_cpp_class.vTbl)
   {
      uint size = ScrollBar::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ScrollBar::ScrollBar_notifyScrolling_Functor::FunctionType, size);
      memcpy(self->vTbl, ScrollBar::_cpp_class.vTbl, sizeof(ScrollBar::ScrollBar_notifyScrolling_Functor::FunctionType) * size);
   }
   ((ScrollBar::ScrollBar_notifyScrolling_Functor::FunctionType *)self->vTbl)[M_VTBLID(ScrollBar, notifyScrolling)] = func;
   return func;
}
inline void ScrollBar::ScrollBar_notifyScrolling_Functor::operator()(/*6Fk*/Window & o_ , /*6Fj*/ScrollBar & scrollBar, /*6Fj*/ScrollBarAction action, /*6Fj*/int position, /*6Fj*/Key key)
{
   SELF(ScrollBar, notifyScrolling);
   ScrollBar_notifyScrolling(self ? self->impl : (C(ScrollBar))null, self ? self->impl : (C(ScrollBar))null, /*7Al*/scrollBar.impl, /*7Al*/(C(ScrollBarAction))action, /*7Al*/position, /*7Al*/(C(Key))key);
}
// inline void ScrollBar::register_notifyScrolling(CPPClass & cl, ScrollBar::ScrollBar_notifyScrolling_Functor::FunctionType func)
// {
//    ((ScrollBar::ScrollBar_notifyScrolling_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ScrollBar, notifyScrolling)] = func;
// }


inline C(bool) ScrollBar::action(/*1Ab*/ScrollBarAction action, /*1Ab*/int newPosition, /*1Ab*/Key key)
{
   return ScrollBar_action(impl, /*5Ee*/(C(ScrollBarAction))action, /*5Ge*/newPosition, /*5Ee*/(C(Key))key.impl);
}


// property callers: ScrollBar::direction
// (normal::enum|int)

/*nstSet*/inline /*0H*/ScrollDirection ScrollBar::direction_Prop::operator= (/*0H*/ScrollDirection v)
{
   SELF(ScrollBar, direction);
   ScrollBar_set_direction(self ? self->impl : null, (C(ScrollDirection))v);
   return v;
}

/*regSet*/inline ScrollBar::direction_Prop & ScrollBar::direction_Prop::operator= (ScrollBar::direction_Prop & prop)
{
   SELF(ScrollBar, direction);
   /*0H*/ScrollDirection v = prop;
   ScrollBar_set_direction(self ? self->impl : null, (C(ScrollDirection))v);
   return prop;
}
/*regGet*/inline ScrollBar::direction_Prop::operator /*0I*/ScrollDirection () const
{
   SELF(ScrollBar, direction);
   return (ScrollDirection)ScrollBar_get_direction(self ? self->impl : null);
}

// property callers: ScrollBar::windowOwned   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool ScrollBar::windowOwned_Prop::operator= (/*0G*/bool v)
{
   SELF(ScrollBar, windowOwned);
   ScrollBar_set_windowOwned(self->impl, (C(bool))v);
   return v;
}


// property callers: ScrollBar::snap
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ScrollBar::snap_Prop::operator= (/*0H*/bool v)
{
   SELF(ScrollBar, snap);
   ScrollBar_set_snap(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ScrollBar::snap_Prop & ScrollBar::snap_Prop::operator= (ScrollBar::snap_Prop & prop)
{
   SELF(ScrollBar, snap);
   /*0H*/bool v = prop;
   ScrollBar_set_snap(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ScrollBar::snap_Prop::operator /*0I*/bool () const
{
   SELF(ScrollBar, snap);
   return (bool)ScrollBar_get_snap(self ? self->impl : null);
}

// property callers: ScrollBar::range
// (normal::int)

/*nstSet*/inline /*0H*/int ScrollBar::range_Prop::operator= (/*0H*/int v)
{
   SELF(ScrollBar, range);
   ScrollBar_set_range(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ScrollBar::range_Prop & ScrollBar::range_Prop::operator= (ScrollBar::range_Prop & prop)
{
   SELF(ScrollBar, range);
   /*0H*/int v = prop;
   ScrollBar_set_range(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ScrollBar::range_Prop::operator /*0I*/int () const
{
   SELF(ScrollBar, range);
   return ScrollBar_get_range(self ? self->impl : null);
}

// property callers: ScrollBar::seen
// (normal::int)

/*nstSet*/inline /*0H*/int ScrollBar::seen_Prop::operator= (/*0H*/int v)
{
   SELF(ScrollBar, seen);
   ScrollBar_set_seen(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ScrollBar::seen_Prop & ScrollBar::seen_Prop::operator= (ScrollBar::seen_Prop & prop)
{
   SELF(ScrollBar, seen);
   /*0H*/int v = prop;
   ScrollBar_set_seen(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ScrollBar::seen_Prop::operator /*0I*/int () const
{
   SELF(ScrollBar, seen);
   return ScrollBar_get_seen(self ? self->impl : null);
}

// property callers: ScrollBar::total
// (normal::int)

/*nstSet*/inline /*0H*/int ScrollBar::total_Prop::operator= (/*0H*/int v)
{
   SELF(ScrollBar, total);
   ScrollBar_set_total(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ScrollBar::total_Prop & ScrollBar::total_Prop::operator= (ScrollBar::total_Prop & prop)
{
   SELF(ScrollBar, total);
   /*0H*/int v = prop;
   ScrollBar_set_total(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ScrollBar::total_Prop::operator /*0I*/int () const
{
   SELF(ScrollBar, total);
   return ScrollBar_get_total(self ? self->impl : null);
}

// property callers: ScrollBar::lineStep
// (normal::int)

/*nstSet*/inline /*0H*/int ScrollBar::lineStep_Prop::operator= (/*0H*/int v)
{
   SELF(ScrollBar, lineStep);
   ScrollBar_set_lineStep(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ScrollBar::lineStep_Prop & ScrollBar::lineStep_Prop::operator= (ScrollBar::lineStep_Prop & prop)
{
   SELF(ScrollBar, lineStep);
   /*0H*/int v = prop;
   ScrollBar_set_lineStep(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ScrollBar::lineStep_Prop::operator /*0I*/int () const
{
   SELF(ScrollBar, lineStep);
   return ScrollBar_get_lineStep(self ? self->impl : null);
}

// property callers: ScrollBar::pageStep
// (normal::int)

/*nstSet*/inline /*0H*/int ScrollBar::pageStep_Prop::operator= (/*0H*/int v)
{
   SELF(ScrollBar, pageStep);
   ScrollBar_set_pageStep(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ScrollBar::pageStep_Prop & ScrollBar::pageStep_Prop::operator= (ScrollBar::pageStep_Prop & prop)
{
   SELF(ScrollBar, pageStep);
   /*0H*/int v = prop;
   ScrollBar_set_pageStep(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ScrollBar::pageStep_Prop::operator /*0I*/int () const
{
   SELF(ScrollBar, pageStep);
   return ScrollBar_get_pageStep(self ? self->impl : null);
}

// property callers: ScrollBar::thumbPosition
// (normal::int)

/*nstSet*/inline /*0H*/int ScrollBar::thumbPosition_Prop::operator= (/*0H*/int v)
{
   SELF(ScrollBar, thumbPosition);
   ScrollBar_set_thumbPosition(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ScrollBar::thumbPosition_Prop & ScrollBar::thumbPosition_Prop::operator= (ScrollBar::thumbPosition_Prop & prop)
{
   SELF(ScrollBar, thumbPosition);
   /*0H*/int v = prop;
   ScrollBar_set_thumbPosition(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ScrollBar::thumbPosition_Prop::operator /*0I*/int () const
{
   SELF(ScrollBar, thumbPosition);
   return ScrollBar_get_thumbPosition(self ? self->impl : null);
}


// member accessors: ScrollBar::downBtn
// (normal::normal)

/*nstSet*/inline /*0H*/Button ScrollBar::downBtn_Prop::operator= (/*0H*/Button v)
{
   SELF(ScrollBar, downBtn);
   IPTR(self->impl, ScrollBar)->downBtn = v.impl;
   return v;
}

/*regSet*/inline ScrollBar::downBtn_Prop & ScrollBar::downBtn_Prop::operator= (ScrollBar::downBtn_Prop & prop)
{
   SELF(ScrollBar, downBtn);
   /*0H*/Button v = prop;
   IPTR(self->impl, ScrollBar)->downBtn = v.impl;
   return prop;
}
/*regGet*/inline ScrollBar::downBtn_Prop::operator /*0I*/Button () const
{
   SELF(ScrollBar, downBtn);
   Button value(IPTR(self->impl, ScrollBar)->downBtn, ScrollBar::_cpp_class);
   return value;
}

// member accessors: ScrollBar::upBtn
// (normal::normal)

/*nstSet*/inline /*0H*/Button ScrollBar::upBtn_Prop::operator= (/*0H*/Button v)
{
   SELF(ScrollBar, upBtn);
   IPTR(self->impl, ScrollBar)->upBtn = v.impl;
   return v;
}

/*regSet*/inline ScrollBar::upBtn_Prop & ScrollBar::upBtn_Prop::operator= (ScrollBar::upBtn_Prop & prop)
{
   SELF(ScrollBar, upBtn);
   /*0H*/Button v = prop;
   IPTR(self->impl, ScrollBar)->upBtn = v.impl;
   return prop;
}
/*regGet*/inline ScrollBar::upBtn_Prop::operator /*0I*/Button () const
{
   SELF(ScrollBar, upBtn);
   Button value(IPTR(self->impl, ScrollBar)->upBtn, ScrollBar::_cpp_class);
   return value;
}

// member accessors: ScrollBar::thumb
// (normal::normal)

/*nstSet*/inline /*0H*/Button ScrollBar::thumb_Prop::operator= (/*0H*/Button v)
{
   SELF(ScrollBar, thumb);
   IPTR(self->impl, ScrollBar)->thumb = v.impl;
   return v;
}

/*regSet*/inline ScrollBar::thumb_Prop & ScrollBar::thumb_Prop::operator= (ScrollBar::thumb_Prop & prop)
{
   SELF(ScrollBar, thumb);
   /*0H*/Button v = prop;
   IPTR(self->impl, ScrollBar)->thumb = v.impl;
   return prop;
}
/*regGet*/inline ScrollBar::thumb_Prop::operator /*0I*/Button () const
{
   SELF(ScrollBar, thumb);
   Button value(IPTR(self->impl, ScrollBar)->thumb, ScrollBar::_cpp_class);
   return value;
}

// member accessors: ScrollBar::thumbSize
// (normal::int)

/*nstSet*/inline /*0H*/int ScrollBar::thumbSize_Prop::operator= (/*0H*/int v)
{
   SELF(ScrollBar, thumbSize);
   IPTR(self->impl, ScrollBar)->thumbSize = v;
   return v;
}

/*regSet*/inline ScrollBar::thumbSize_Prop & ScrollBar::thumbSize_Prop::operator= (ScrollBar::thumbSize_Prop & prop)
{
   SELF(ScrollBar, thumbSize);
   /*0H*/int v = prop;
   IPTR(self->impl, ScrollBar)->thumbSize = v;
   return prop;
}
/*regGet*/inline ScrollBar::thumbSize_Prop::operator /*0I*/int () const
{
   SELF(ScrollBar, thumbSize);
   return self ? IPTR(self->impl, ScrollBar)->thumbSize : 0;
}


inline void SelectorBar::addButton(/*1Ab*/SelectorButton & button)
{
   SelectorBar_addButton(impl, /*5De*/button.impl);
}
inline void SelectorBar::clear()
{
   SelectorBar_clear(impl);
}
inline SelectorButton SelectorBar::findButtonByID(/*1Ab*/int64 id)
{
   return SelectorButton(SelectorBar_findButtonByID(impl, /*5Ge*/id));
}
inline void SelectorBar::removeButton(/*1Ab*/SelectorButton & button)
{
   SelectorBar_removeButton(impl, /*5De*/button.impl);
}
inline void SelectorBar::select(/*1Ab*/SelectorButton & button)
{
   SelectorBar_select(impl, /*5De*/button.impl);
}


// property callers: SelectorBar::selectedButton   // get only
// (normal::normal)

/*regGet*/inline SelectorBar::selectedButton_Prop::operator /*0B*/TIH<SelectorButton> () const
{
   SELF(SelectorBar, selectedButton);
   C(Instance) i = SelectorBar_get_selectedButton(self ? self->impl : null);
   TIH<SelectorButton> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<SelectorButton> SelectorBar::selectedButton_Prop::operator /*0D*/-> () const
{
   SELF(SelectorBar, selectedButton);
   C(Instance) i = SelectorBar_get_selectedButton(self ? self->impl : null);
   TIH<SelectorButton> holder(i);
   return holder;
}
/*regGet*/inline SelectorBar::selectedButton_Prop::operator /*0E*/SelectorButton () const
{
   SELF(SelectorBar, selectedButton);
   C(Instance) i = SelectorBar_get_selectedButton(self ? self->impl : null);
   return SelectorButton(i);
}
/*regGet*/inline SelectorBar::selectedButton_Prop::operator /*0F*/SelectorButton* () const
{
   SELF(SelectorBar, selectedButton);
   C(Instance) i = SelectorBar_get_selectedButton(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (SelectorButton *)INSTANCEL(i, i->_class) : (SelectorButton *)0;
}



// member accessors: SelectorButton::focusHolder
// (normal::normal)

/*nstSet*/inline /*0H*/Window SelectorButton::focusHolder_Prop::operator= (/*0H*/Window v)
{
   SELF(SelectorButton, focusHolder);
   IPTR(self->impl, SelectorButton)->focusHolder = v.impl;
   return v;
}

/*regSet*/inline SelectorButton::focusHolder_Prop & SelectorButton::focusHolder_Prop::operator= (SelectorButton::focusHolder_Prop & prop)
{
   SELF(SelectorButton, focusHolder);
   /*0H*/Window v = prop;
   IPTR(self->impl, SelectorButton)->focusHolder = v.impl;
   return prop;
}
/*regGet*/inline SelectorButton::focusHolder_Prop::operator /*0I*/Window () const
{
   SELF(SelectorButton, focusHolder);
   Window value(IPTR(self->impl, SelectorButton)->focusHolder, SelectorButton::_cpp_class);
   return value;
}

inline Stacker::Stacker(ScrollDirection direction, int gap = 0, bool reverse = (bool)0, bool scrollable = (bool)0) : Stacker()
{
   this->direction = direction;
   this->gap = gap;
   this->reverse = reverse;
   this->scrollable = scrollable;
}


inline void Stacker::destroyChildren()
{
   Stacker_destroyChildren(impl);
}
inline Window Stacker::getNextStackedItem(/*1Ab*/Window & current, /*1Ab*/bool previous, /*1Ab*/Class filter)
{
   return Window(Stacker_getNextStackedItem(impl, /*5De*/current.impl, /*5Ee*/(C(bool))previous, /*5De*/filter.impl));
}
inline void Stacker::makeControlVisible(/*1Ab*/Window & control)
{
   Stacker_makeControlVisible(impl, /*5De*/control.impl);
}
inline void Stacker::moveControl(/*1Ab*/IteratorPointer ctrl, /*1Ab*/IteratorPointer after, /*1Ab*/bool fixCycle)
{
   Stacker_moveControl(impl, /*5De*/ctrl.impl, /*5De*/after.impl, /*5Ee*/(C(bool))fixCycle);
}


// property callers: Stacker::direction
// (normal::enum|int)

/*nstSet*/inline /*0H*/ScrollDirection Stacker::direction_Prop::operator= (/*0H*/ScrollDirection v)
{
   SELF(Stacker, direction);
   Stacker_set_direction(self ? self->impl : null, (C(ScrollDirection))v);
   return v;
}

/*regSet*/inline Stacker::direction_Prop & Stacker::direction_Prop::operator= (Stacker::direction_Prop & prop)
{
   SELF(Stacker, direction);
   /*0H*/ScrollDirection v = prop;
   Stacker_set_direction(self ? self->impl : null, (C(ScrollDirection))v);
   return prop;
}
/*regGet*/inline Stacker::direction_Prop::operator /*0I*/ScrollDirection () const
{
   SELF(Stacker, direction);
   return (ScrollDirection)Stacker_get_direction(self ? self->impl : null);
}

// property callers: Stacker::gap
// (normal::int)

/*nstSet*/inline /*0H*/int Stacker::gap_Prop::operator= (/*0H*/int v)
{
   SELF(Stacker, gap);
   Stacker_set_gap(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Stacker::gap_Prop & Stacker::gap_Prop::operator= (Stacker::gap_Prop & prop)
{
   SELF(Stacker, gap);
   /*0H*/int v = prop;
   Stacker_set_gap(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Stacker::gap_Prop::operator /*0I*/int () const
{
   SELF(Stacker, gap);
   return Stacker_get_gap(self ? self->impl : null);
}

// property callers: Stacker::reverse
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Stacker::reverse_Prop::operator= (/*0H*/bool v)
{
   SELF(Stacker, reverse);
   Stacker_set_reverse(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Stacker::reverse_Prop & Stacker::reverse_Prop::operator= (Stacker::reverse_Prop & prop)
{
   SELF(Stacker, reverse);
   /*0H*/bool v = prop;
   Stacker_set_reverse(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Stacker::reverse_Prop::operator /*0I*/bool () const
{
   SELF(Stacker, reverse);
   return (bool)Stacker_get_reverse(self ? self->impl : null);
}

// property callers: Stacker::scrollable
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Stacker::scrollable_Prop::operator= (/*0H*/bool v)
{
   SELF(Stacker, scrollable);
   Stacker_set_scrollable(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Stacker::scrollable_Prop & Stacker::scrollable_Prop::operator= (Stacker::scrollable_Prop & prop)
{
   SELF(Stacker, scrollable);
   /*0H*/bool v = prop;
   Stacker_set_scrollable(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Stacker::scrollable_Prop::operator /*0I*/bool () const
{
   SELF(Stacker, scrollable);
   return (bool)Stacker_get_scrollable(self ? self->impl : null);
}

// property callers: Stacker::controls   // get only
// (normal::normal)

/*regGet*/inline Stacker::controls_Prop::operator /*0B*/TIH<TArray<C(Window) _ARG int _ARG C(Window)>> () const
{
   SELF(Stacker, controls);
   C(Instance) i = Stacker_get_controls(self ? self->impl : null);
   TIH<TArray<C(Window) _ARG int _ARG C(Window)>> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<TArray<C(Window) _ARG int _ARG C(Window)>> Stacker::controls_Prop::operator /*0D*/-> () const
{
   SELF(Stacker, controls);
   C(Instance) i = Stacker_get_controls(self ? self->impl : null);
   TIH<TArray<C(Window) _ARG int _ARG C(Window)>> holder(i);
   return holder;
}
/*regGet*/inline Stacker::controls_Prop::operator /*0E*/TArray<C(Window) _ARG int _ARG C(Window)> () const
{
   SELF(Stacker, controls);
   C(Instance) i = Stacker_get_controls(self ? self->impl : null);
   return TArray<C(Window) _ARG int _ARG C(Window)>(i);
}
/*regGet*/inline Stacker::controls_Prop::operator /*0F*/TArray<C(Window) _ARG int _ARG C(Window)>* () const
{
   SELF(Stacker, controls);
   C(Instance) i = Stacker_get_controls(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (TArray<C(Window) _ARG int _ARG C(Window)> *)INSTANCEL(i, i->_class) : (TArray<C(Window) _ARG int _ARG C(Window)> *)0;
}

// property callers: Stacker::flipper
// (normal::normal)

/*nstSet*/inline /*0A*/const Window & Stacker::flipper_Prop::operator= (/*0A*/const Window & v)
{
   SELF(Stacker, flipper);
   Stacker_set_flipper(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Stacker::flipper_Prop & Stacker::flipper_Prop::operator= (Stacker::flipper_Prop & prop)
{
   SELF(Stacker, flipper);
   /*0A*/const Window & v = prop;
   Stacker_set_flipper(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Window * Stacker::flipper_Prop::operator= (/*0C*/const Window * v)
{
   SELF(Stacker, flipper);
   Stacker_set_flipper(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Stacker::flipper_Prop::operator /*0B*/TIH<Window> () const
{
   SELF(Stacker, flipper);
   C(Instance) i = Stacker_get_flipper(self ? self->impl : null);
   TIH<Window> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Window> Stacker::flipper_Prop::operator /*0D*/-> () const
{
   SELF(Stacker, flipper);
   C(Instance) i = Stacker_get_flipper(self ? self->impl : null);
   TIH<Window> holder(i);
   return holder;
}
/*regGet*/inline Stacker::flipper_Prop::operator /*0E*/Window () const
{
   SELF(Stacker, flipper);
   C(Instance) i = Stacker_get_flipper(self ? self->impl : null);
   return Window(i);
}
/*regGet*/inline Stacker::flipper_Prop::operator /*0F*/Window* () const
{
   SELF(Stacker, flipper);
   C(Instance) i = Stacker_get_flipper(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Window *)INSTANCEL(i, i->_class) : (Window *)0;
}

// property callers: Stacker::flipSpring
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Stacker::flipSpring_Prop::operator= (/*0H*/bool v)
{
   SELF(Stacker, flipSpring);
   Stacker_set_flipSpring(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Stacker::flipSpring_Prop & Stacker::flipSpring_Prop::operator= (Stacker::flipSpring_Prop & prop)
{
   SELF(Stacker, flipSpring);
   /*0H*/bool v = prop;
   Stacker_set_flipSpring(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Stacker::flipSpring_Prop::operator /*0I*/bool () const
{
   SELF(Stacker, flipSpring);
   return (bool)Stacker_get_flipSpring(self ? self->impl : null);
}

// property callers: Stacker::autoSize
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Stacker::autoSize_Prop::operator= (/*0H*/bool v)
{
   SELF(Stacker, autoSize);
   Stacker_set_autoSize(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Stacker::autoSize_Prop & Stacker::autoSize_Prop::operator= (Stacker::autoSize_Prop & prop)
{
   SELF(Stacker, autoSize);
   /*0H*/bool v = prop;
   Stacker_set_autoSize(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Stacker::autoSize_Prop::operator /*0I*/bool () const
{
   SELF(Stacker, autoSize);
   return (bool)Stacker_get_autoSize(self ? self->impl : null);
}

// property callers: Stacker::margin
// (normal::int)

/*nstSet*/inline /*0H*/int Stacker::margin_Prop::operator= (/*0H*/int v)
{
   SELF(Stacker, margin);
   Stacker_set_margin(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Stacker::margin_Prop & Stacker::margin_Prop::operator= (Stacker::margin_Prop & prop)
{
   SELF(Stacker, margin);
   /*0H*/int v = prop;
   Stacker_set_margin(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Stacker::margin_Prop::operator /*0I*/int () const
{
   SELF(Stacker, margin);
   return Stacker_get_margin(self ? self->impl : null);
}

// property callers: Stacker::endButtons
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Stacker::endButtons_Prop::operator= (/*0H*/bool v)
{
   SELF(Stacker, endButtons);
   Stacker_set_endButtons(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Stacker::endButtons_Prop & Stacker::endButtons_Prop::operator= (Stacker::endButtons_Prop & prop)
{
   SELF(Stacker, endButtons);
   /*0H*/bool v = prop;
   Stacker_set_endButtons(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Stacker::endButtons_Prop::operator /*0I*/bool () const
{
   SELF(Stacker, endButtons);
   return (bool)Stacker_get_endButtons(self ? self->impl : null);
}

// property callers: Stacker::hoverScroll
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Stacker::hoverScroll_Prop::operator= (/*0H*/bool v)
{
   SELF(Stacker, hoverScroll);
   Stacker_set_hoverScroll(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Stacker::hoverScroll_Prop & Stacker::hoverScroll_Prop::operator= (Stacker::hoverScroll_Prop & prop)
{
   SELF(Stacker, hoverScroll);
   /*0H*/bool v = prop;
   Stacker_set_hoverScroll(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Stacker::hoverScroll_Prop::operator /*0I*/bool () const
{
   SELF(Stacker, hoverScroll);
   return (bool)Stacker_get_hoverScroll(self ? self->impl : null);
}

inline StatusBar::StatusBar(int minInfoWidth) : StatusBar()
{
   this->minInfoWidth = minInfoWidth;
}


inline void StatusBar::addField(/*1Ab*/StatusField & field)
{
   StatusBar_addField(impl, /*5De*/field.impl);
}
inline void StatusBar::clear()
{
   StatusBar_clear(impl);
}
inline void StatusBar::removeField(/*1Ab*/StatusField & field)
{
   StatusBar_removeField(impl, /*5De*/field.impl);
}


// property callers: StatusBar::minInfoWidth
// (normal::int)

/*nstSet*/inline /*0H*/int StatusBar::minInfoWidth_Prop::operator= (/*0H*/int v)
{
   SELF(StatusBar, minInfoWidth);
   StatusBar_set_minInfoWidth(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline StatusBar::minInfoWidth_Prop & StatusBar::minInfoWidth_Prop::operator= (StatusBar::minInfoWidth_Prop & prop)
{
   SELF(StatusBar, minInfoWidth);
   /*0H*/int v = prop;
   StatusBar_set_minInfoWidth(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline StatusBar::minInfoWidth_Prop::operator /*0I*/int () const
{
   SELF(StatusBar, minInfoWidth);
   return StatusBar_get_minInfoWidth(self ? self->impl : null);
}


template<typename... Args> inline void StatusField::setTextf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   StatusField_setTextf(impl, /*5Ge*/format, /*5Ae*/args...);
}


// property callers: StatusField::statusBar   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const StatusBar & StatusField::statusBar_Prop::operator= (/*0A*/const StatusBar & v)
{
   SELF(StatusField, statusBar);
   StatusField_set_statusBar(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const StatusBar * StatusField::statusBar_Prop::operator= (/*0C*/const StatusBar * v)
{
   SELF(StatusField, statusBar);
   StatusField_set_statusBar(self ? self->impl : null, v ? v->impl : null);
   return v;
}


// property callers: StatusField::color   // set only
// (normal::bits|uint)

/*nstSet*/inline /*0G*/Color StatusField::color_Prop::operator= (/*0G*/Color v)
{
   SELF(StatusField, color);
   StatusField_set_color(self->impl, v);
   return v;
}


// property callers: StatusField::backColor   // set only
// (normal::bits|unsigned int)

/*nstSet*/inline /*0G*/ColorAlpha StatusField::backColor_Prop::operator= (/*0G*/ColorAlpha v)
{
   SELF(StatusField, backColor);
   StatusField_set_backColor(self->impl, v);
   return v;
}


// property callers: StatusField::bold   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool StatusField::bold_Prop::operator= (/*0G*/bool v)
{
   SELF(StatusField, bold);
   StatusField_set_bold(self->impl, (C(bool))v);
   return v;
}


// property callers: StatusField::text   // set only
// (normal::const char *)

/*nstSet*/inline /*0G*/const char * StatusField::text_Prop::operator= (/*0G*/const char * v)
{
   SELF(StatusField, text);
   StatusField_set_text(self->impl, v);
   return v;
}


// property callers: StatusField::width   // set only
// (normal::int)

/*nstSet*/inline /*0G*/int StatusField::width_Prop::operator= (/*0G*/int v)
{
   SELF(StatusField, width);
   StatusField_set_width(self->impl, v);
   return v;
}



inline void Tab::selectTab()
{
   Tab_selectTab(impl);
}


// property callers: Tab::tabControl
// (normal::normal)

/*nstSet*/inline /*0A*/const TabControl & Tab::tabControl_Prop::operator= (/*0A*/const TabControl & v)
{
   SELF(Tab, tabControl);
   Tab_set_tabControl(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Tab::tabControl_Prop & Tab::tabControl_Prop::operator= (Tab::tabControl_Prop & prop)
{
   SELF(Tab, tabControl);
   /*0A*/const TabControl & v = prop;
   Tab_set_tabControl(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const TabControl * Tab::tabControl_Prop::operator= (/*0C*/const TabControl * v)
{
   SELF(Tab, tabControl);
   Tab_set_tabControl(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Tab::tabControl_Prop::operator /*0B*/TIH<TabControl> () const
{
   SELF(Tab, tabControl);
   C(Instance) i = Tab_get_tabControl(self ? self->impl : null);
   TIH<TabControl> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<TabControl> Tab::tabControl_Prop::operator /*0D*/-> () const
{
   SELF(Tab, tabControl);
   C(Instance) i = Tab_get_tabControl(self ? self->impl : null);
   TIH<TabControl> holder(i);
   return holder;
}
/*regGet*/inline Tab::tabControl_Prop::operator /*0E*/TabControl () const
{
   SELF(Tab, tabControl);
   C(Instance) i = Tab_get_tabControl(self ? self->impl : null);
   return TabControl(i);
}
/*regGet*/inline Tab::tabControl_Prop::operator /*0F*/TabControl* () const
{
   SELF(Tab, tabControl);
   C(Instance) i = Tab_get_tabControl(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (TabControl *)INSTANCEL(i, i->_class) : (TabControl *)0;
}

// property callers: Tab::isAdded   // get only
// (normal::enum|uint)

/*regGet*/inline Tab::isAdded_Prop::operator /*0I*/bool () const
{
   SELF(Tab, isAdded);
   return (bool)Tab_get_isAdded(self ? self->impl : null);
}

inline TabControl::TabControl(TabsPlacement placement, int buttonsOffset = 0) : TabControl()
{
   this->placement = placement;
   this->buttonsOffset = buttonsOffset;
}


inline void TabControl::addTab(/*1Ab*/Tab & tab)
{
   TabControl_addTab(impl, /*5De*/tab.impl);
}
inline void TabControl::removeTab(/*1Ab*/Tab & tab)
{
   TabControl_removeTab(impl, /*5De*/tab.impl);
}


// property callers: TabControl::placement
// (normal::enum|int)

/*nstSet*/inline /*0H*/TabsPlacement TabControl::placement_Prop::operator= (/*0H*/TabsPlacement v)
{
   SELF(TabControl, placement);
   TabControl_set_placement(self ? self->impl : null, (C(TabsPlacement))v);
   return v;
}

/*regSet*/inline TabControl::placement_Prop & TabControl::placement_Prop::operator= (TabControl::placement_Prop & prop)
{
   SELF(TabControl, placement);
   /*0H*/TabsPlacement v = prop;
   TabControl_set_placement(self ? self->impl : null, (C(TabsPlacement))v);
   return prop;
}
/*regGet*/inline TabControl::placement_Prop::operator /*0I*/TabsPlacement () const
{
   SELF(TabControl, placement);
   return (TabsPlacement)TabControl_get_placement(self ? self->impl : null);
}

// property callers: TabControl::buttonsOffset
// (normal::int)

/*nstSet*/inline /*0H*/int TabControl::buttonsOffset_Prop::operator= (/*0H*/int v)
{
   SELF(TabControl, buttonsOffset);
   TabControl_set_buttonsOffset(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline TabControl::buttonsOffset_Prop & TabControl::buttonsOffset_Prop::operator= (TabControl::buttonsOffset_Prop & prop)
{
   SELF(TabControl, buttonsOffset);
   /*0H*/int v = prop;
   TabControl_set_buttonsOffset(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline TabControl::buttonsOffset_Prop::operator /*0I*/int () const
{
   SELF(TabControl, buttonsOffset);
   return TabControl_get_buttonsOffset(self ? self->impl : null);
}

// property callers: TabControl::curTab
// (normal::normal)

/*nstSet*/inline /*0A*/const Tab & TabControl::curTab_Prop::operator= (/*0A*/const Tab & v)
{
   SELF(TabControl, curTab);
   TabControl_set_curTab(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline TabControl::curTab_Prop & TabControl::curTab_Prop::operator= (TabControl::curTab_Prop & prop)
{
   SELF(TabControl, curTab);
   /*0A*/const Tab & v = prop;
   TabControl_set_curTab(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Tab * TabControl::curTab_Prop::operator= (/*0C*/const Tab * v)
{
   SELF(TabControl, curTab);
   TabControl_set_curTab(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline TabControl::curTab_Prop::operator /*0B*/TIH<Tab> () const
{
   SELF(TabControl, curTab);
   C(Instance) i = TabControl_get_curTab(self ? self->impl : null);
   TIH<Tab> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Tab> TabControl::curTab_Prop::operator /*0D*/-> () const
{
   SELF(TabControl, curTab);
   C(Instance) i = TabControl_get_curTab(self ? self->impl : null);
   TIH<Tab> holder(i);
   return holder;
}
/*regGet*/inline TabControl::curTab_Prop::operator /*0E*/Tab () const
{
   SELF(TabControl, curTab);
   C(Instance) i = TabControl_get_curTab(self ? self->impl : null);
   return Tab(i);
}
/*regGet*/inline TabControl::curTab_Prop::operator /*0F*/Tab* () const
{
   SELF(TabControl, curTab);
   C(Instance) i = TabControl_get_curTab(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Tab *)INSTANCEL(i, i->_class) : (Tab *)0;
}




// property callers: ToolButton::menuItemPtr   // set only
// (normal::normal)

/*nstSet*/inline /*0G*/C(MenuItem)* ToolButton::menuItemPtr_Prop::operator= (/*0G*/C(MenuItem)* v)
{
   SELF(ToolButton, menuItemPtr);
   ToolButton_set_menuItemPtr(self->impl, v);
   return v;
}


// property callers: ToolButton::menuItem   // get only
// (normal::normal)

/*regGet*/inline ToolButton::menuItem_Prop::operator /*0B*/TIH<MenuItem> () const
{
   SELF(ToolButton, menuItem);
   C(Instance) i = ToolButton_get_menuItem(self ? self->impl : null);
   TIH<MenuItem> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<MenuItem> ToolButton::menuItem_Prop::operator /*0D*/-> () const
{
   SELF(ToolButton, menuItem);
   C(Instance) i = ToolButton_get_menuItem(self ? self->impl : null);
   TIH<MenuItem> holder(i);
   return holder;
}
/*regGet*/inline ToolButton::menuItem_Prop::operator /*0E*/MenuItem () const
{
   SELF(ToolButton, menuItem);
   C(Instance) i = ToolButton_get_menuItem(self ? self->impl : null);
   return MenuItem(i);
}
/*regGet*/inline ToolButton::menuItem_Prop::operator /*0F*/MenuItem* () const
{
   SELF(ToolButton, menuItem);
   C(Instance) i = ToolButton_get_menuItem(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (MenuItem *)INSTANCEL(i, i->_class) : (MenuItem *)0;
}


inline ToolTip::ToolTip(/*CT-D*/constString tip) : ToolTip()
{
   this->tip = tip;
}



// property callers: ToolTip::tip
// (normal::string)

/*nstSet*/inline /*0H*//*CT-D*/constString ToolTip::tip_Prop::operator= (/*0H*//*CT-D*/constString v)
{
   SELF(ToolTip, tip);
   ToolTip_set_tip(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ToolTip::tip_Prop & ToolTip::tip_Prop::operator= (ToolTip::tip_Prop & prop)
{
   SELF(ToolTip, tip);
   /*0H*//*CT-D*/constString v = prop;
   ToolTip_set_tip(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ToolTip::tip_Prop::operator /*0I*//*CT-D*/constString () const
{
   SELF(ToolTip, tip);
   return ToolTip_get_tip(self ? self->impl : null);
}



// member accessors: UndoAction::continued
// (nohead::enum|uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/bool TUndoAction<TC, TCO>::continued_Prop::operator= (/*0H*/bool v)
{
   SELF(UndoAction, continued);
   ((C(UndoAction) *)self->impl)->continued = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TUndoAction<TC, TCO>::continued_Prop & TUndoAction<TC, TCO>::continued_Prop::operator= (typename TUndoAction<TC, TCO>::continued_Prop & prop)
{
   SELF(UndoAction, continued);
   /*0H*/bool v = prop;
   ((C(UndoAction) *)self->impl)->continued = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TUndoAction<TC, TCO>::continued_Prop::operator /*0I*/bool () const
{
   __attribute__((unused)) TUndoAction TCTCO * self = CONTAINER_OF(this, TUndoAction TCTCO, continued);
   return self ? ((C(UndoAction) *)self->impl)->continued : (bool)0;
}

inline UndoBuffer::UndoBuffer(int count, int curAction = 0, void * data = null, int dontRecord = 0, bool insideRedo = (bool)0, bool recordAsOne = (bool)0, bool firstEvent = (bool)0) : UndoBuffer()
{
   this->count = count;
   this->curAction = curAction;
   this->data = data;
   this->dontRecord = dontRecord;
   this->insideRedo = insideRedo;
   this->recordAsOne = recordAsOne;
   this->firstEvent = firstEvent;
}


inline void UndoBuffer::clear()
{
   UndoBuffer_clear(impl);
}
inline void UndoBuffer::record(/*1Ab*/UndoAction action)
{
   UndoBuffer_record(impl, /*5De*/action.impl);
}
inline void UndoBuffer::redo()
{
   UndoBuffer_redo(impl);
}
inline void UndoBuffer::undo()
{
   UndoBuffer_undo(impl);
}


// member accessors: UndoBuffer::count
// (normal::int)

/*nstSet*/inline /*0H*/int UndoBuffer::count_Prop::operator= (/*0H*/int v)
{
   SELF(UndoBuffer, count);
   IPTR(self->impl, UndoBuffer)->count = v;
   return v;
}

/*regSet*/inline UndoBuffer::count_Prop & UndoBuffer::count_Prop::operator= (UndoBuffer::count_Prop & prop)
{
   SELF(UndoBuffer, count);
   /*0H*/int v = prop;
   IPTR(self->impl, UndoBuffer)->count = v;
   return prop;
}
/*regGet*/inline UndoBuffer::count_Prop::operator /*0I*/int () const
{
   SELF(UndoBuffer, count);
   return self ? IPTR(self->impl, UndoBuffer)->count : 0;
}

// member accessors: UndoBuffer::curAction
// (normal::int)

/*nstSet*/inline /*0H*/int UndoBuffer::curAction_Prop::operator= (/*0H*/int v)
{
   SELF(UndoBuffer, curAction);
   IPTR(self->impl, UndoBuffer)->curAction = v;
   return v;
}

/*regSet*/inline UndoBuffer::curAction_Prop & UndoBuffer::curAction_Prop::operator= (UndoBuffer::curAction_Prop & prop)
{
   SELF(UndoBuffer, curAction);
   /*0H*/int v = prop;
   IPTR(self->impl, UndoBuffer)->curAction = v;
   return prop;
}
/*regGet*/inline UndoBuffer::curAction_Prop::operator /*0I*/int () const
{
   SELF(UndoBuffer, curAction);
   return self ? IPTR(self->impl, UndoBuffer)->curAction : 0;
}

// member accessors: UndoBuffer::data
// (normal::void *)

/*nstSet*/inline /*0H*/void * UndoBuffer::data_Prop::operator= (/*0H*/void * v)
{
   SELF(UndoBuffer, data);
   IPTR(self->impl, UndoBuffer)->data = v;
   return v;
}

/*regSet*/inline UndoBuffer::data_Prop & UndoBuffer::data_Prop::operator= (UndoBuffer::data_Prop & prop)
{
   SELF(UndoBuffer, data);
   /*0H*/void * v = prop;
   IPTR(self->impl, UndoBuffer)->data = v;
   return prop;
}
/*regGet*/inline UndoBuffer::data_Prop::operator /*0I*/void * () const
{
   SELF(UndoBuffer, data);
   return self ? IPTR(self->impl, UndoBuffer)->data : null;
}

// member accessors: UndoBuffer::dontRecord
// (normal::int)

/*nstSet*/inline /*0H*/int UndoBuffer::dontRecord_Prop::operator= (/*0H*/int v)
{
   SELF(UndoBuffer, dontRecord);
   IPTR(self->impl, UndoBuffer)->dontRecord = v;
   return v;
}

/*regSet*/inline UndoBuffer::dontRecord_Prop & UndoBuffer::dontRecord_Prop::operator= (UndoBuffer::dontRecord_Prop & prop)
{
   SELF(UndoBuffer, dontRecord);
   /*0H*/int v = prop;
   IPTR(self->impl, UndoBuffer)->dontRecord = v;
   return prop;
}
/*regGet*/inline UndoBuffer::dontRecord_Prop::operator /*0I*/int () const
{
   SELF(UndoBuffer, dontRecord);
   return self ? IPTR(self->impl, UndoBuffer)->dontRecord : 0;
}

// member accessors: UndoBuffer::insideRedo
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool UndoBuffer::insideRedo_Prop::operator= (/*0H*/bool v)
{
   SELF(UndoBuffer, insideRedo);
   IPTR(self->impl, UndoBuffer)->insideRedo = (C(bool))v;
   return v;
}

/*regSet*/inline UndoBuffer::insideRedo_Prop & UndoBuffer::insideRedo_Prop::operator= (UndoBuffer::insideRedo_Prop & prop)
{
   SELF(UndoBuffer, insideRedo);
   /*0H*/bool v = prop;
   IPTR(self->impl, UndoBuffer)->insideRedo = (C(bool))v;
   return prop;
}
/*regGet*/inline UndoBuffer::insideRedo_Prop::operator /*0I*/bool () const
{
   SELF(UndoBuffer, insideRedo);
   return self ? (bool)IPTR(self->impl, UndoBuffer)->insideRedo : (bool)0;
}

// member accessors: UndoBuffer::recordAsOne
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool UndoBuffer::recordAsOne_Prop::operator= (/*0H*/bool v)
{
   SELF(UndoBuffer, recordAsOne);
   IPTR(self->impl, UndoBuffer)->recordAsOne = (C(bool))v;
   return v;
}

/*regSet*/inline UndoBuffer::recordAsOne_Prop & UndoBuffer::recordAsOne_Prop::operator= (UndoBuffer::recordAsOne_Prop & prop)
{
   SELF(UndoBuffer, recordAsOne);
   /*0H*/bool v = prop;
   IPTR(self->impl, UndoBuffer)->recordAsOne = (C(bool))v;
   return prop;
}
/*regGet*/inline UndoBuffer::recordAsOne_Prop::operator /*0I*/bool () const
{
   SELF(UndoBuffer, recordAsOne);
   return self ? (bool)IPTR(self->impl, UndoBuffer)->recordAsOne : (bool)0;
}

// member accessors: UndoBuffer::firstEvent
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool UndoBuffer::firstEvent_Prop::operator= (/*0H*/bool v)
{
   SELF(UndoBuffer, firstEvent);
   IPTR(self->impl, UndoBuffer)->firstEvent = (C(bool))v;
   return v;
}

/*regSet*/inline UndoBuffer::firstEvent_Prop & UndoBuffer::firstEvent_Prop::operator= (UndoBuffer::firstEvent_Prop & prop)
{
   SELF(UndoBuffer, firstEvent);
   /*0H*/bool v = prop;
   IPTR(self->impl, UndoBuffer)->firstEvent = (C(bool))v;
   return prop;
}
/*regGet*/inline UndoBuffer::firstEvent_Prop::operator /*0I*/bool () const
{
   SELF(UndoBuffer, firstEvent);
   return self ? (bool)IPTR(self->impl, UndoBuffer)->firstEvent : (bool)0;
}

/////////////////////////////////////////// [ecere]/ecere::gui::dialogs //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


inline ColorPicker::ColorPicker(Color color, bool hasAlpha = (bool)0) : ColorPicker()
{
   this->color = color;
   this->hasAlpha = hasAlpha;
}



// property callers: ColorPicker::color
// (normal::bits|uint)

/*nstSet*/inline /*0H*/Color ColorPicker::color_Prop::operator= (/*0H*/Color v)
{
   SELF(ColorPicker, color);
   ColorPicker_set_color(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ColorPicker::color_Prop & ColorPicker::color_Prop::operator= (ColorPicker::color_Prop & prop)
{
   SELF(ColorPicker, color);
   /*0H*/Color v = prop;
   ColorPicker_set_color(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ColorPicker::color_Prop::operator /*0I*/Color () const
{
   SELF(ColorPicker, color);
   return ColorPicker_get_color(self ? self->impl : null);
}

// property callers: ColorPicker::hasAlpha
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ColorPicker::hasAlpha_Prop::operator= (/*0H*/bool v)
{
   SELF(ColorPicker, hasAlpha);
   ColorPicker_set_hasAlpha(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ColorPicker::hasAlpha_Prop & ColorPicker::hasAlpha_Prop::operator= (ColorPicker::hasAlpha_Prop & prop)
{
   SELF(ColorPicker, hasAlpha);
   /*0H*/bool v = prop;
   ColorPicker_set_hasAlpha(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ColorPicker::hasAlpha_Prop::operator /*0I*/bool () const
{
   SELF(ColorPicker, hasAlpha);
   return (bool)ColorPicker_get_hasAlpha(self ? self->impl : null);
}

inline CreateDirectoryDialog::CreateDirectoryDialog(const char * currentDirectory) : CreateDirectoryDialog()
{
   this->currentDirectory = currentDirectory;
}



// property callers: CreateDirectoryDialog::currentDirectory
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * CreateDirectoryDialog::currentDirectory_Prop::operator= (/*0H*/const char * v)
{
   SELF(CreateDirectoryDialog, currentDirectory);
   CreateDirectoryDialog_set_currentDirectory(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline CreateDirectoryDialog::currentDirectory_Prop & CreateDirectoryDialog::currentDirectory_Prop::operator= (CreateDirectoryDialog::currentDirectory_Prop & prop)
{
   SELF(CreateDirectoryDialog, currentDirectory);
   /*0H*/const char * v = prop;
   CreateDirectoryDialog_set_currentDirectory(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline CreateDirectoryDialog::currentDirectory_Prop::operator /*0I*/const char * () const
{
   SELF(CreateDirectoryDialog, currentDirectory);
   return CreateDirectoryDialog_get_currentDirectory(self ? self->impl : null);
}

inline FileDialog::FileDialog(FileDialogType type, const char * filePath = null, const char * currentDirectory = null, int sizeFilters = 0, int sizeTypes = 0, int filter = 0, int fileType = 0, bool mayNotExist = (bool)0) : FileDialog()
{
   this->type = type;
   this->filePath = filePath;
   this->currentDirectory = currentDirectory;
   this->sizeFilters = sizeFilters;
   this->sizeTypes = sizeTypes;
   this->filter = filter;
   this->fileType = fileType;
   this->mayNotExist = mayNotExist;
}



// property callers: FileDialog::type
// (normal::enum|int)

/*nstSet*/inline /*0H*/FileDialogType FileDialog::type_Prop::operator= (/*0H*/FileDialogType v)
{
   SELF(FileDialog, type);
   FileDialog_set_type(self ? self->impl : null, (C(FileDialogType))v);
   return v;
}

/*regSet*/inline FileDialog::type_Prop & FileDialog::type_Prop::operator= (FileDialog::type_Prop & prop)
{
   SELF(FileDialog, type);
   /*0H*/FileDialogType v = prop;
   FileDialog_set_type(self ? self->impl : null, (C(FileDialogType))v);
   return prop;
}
/*regGet*/inline FileDialog::type_Prop::operator /*0I*/FileDialogType () const
{
   SELF(FileDialog, type);
   return (FileDialogType)FileDialog_get_type(self ? self->impl : null);
}

// property callers: FileDialog::filePath
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * FileDialog::filePath_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileDialog, filePath);
   FileDialog_set_filePath(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileDialog::filePath_Prop & FileDialog::filePath_Prop::operator= (FileDialog::filePath_Prop & prop)
{
   SELF(FileDialog, filePath);
   /*0H*/const char * v = prop;
   FileDialog_set_filePath(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileDialog::filePath_Prop::operator /*0I*/const char * () const
{
   SELF(FileDialog, filePath);
   return FileDialog_get_filePath(self ? self->impl : null);
}

// property callers: FileDialog::currentDirectory
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * FileDialog::currentDirectory_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileDialog, currentDirectory);
   FileDialog_set_currentDirectory(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileDialog::currentDirectory_Prop & FileDialog::currentDirectory_Prop::operator= (FileDialog::currentDirectory_Prop & prop)
{
   SELF(FileDialog, currentDirectory);
   /*0H*/const char * v = prop;
   FileDialog_set_currentDirectory(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileDialog::currentDirectory_Prop::operator /*0I*/const char * () const
{
   SELF(FileDialog, currentDirectory);
   return FileDialog_get_currentDirectory(self ? self->impl : null);
}

// property callers: FileDialog::sizeFilters
// (normal::int)

/*nstSet*/inline /*0H*/int FileDialog::sizeFilters_Prop::operator= (/*0H*/int v)
{
   SELF(FileDialog, sizeFilters);
   FileDialog_set_sizeFilters(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileDialog::sizeFilters_Prop & FileDialog::sizeFilters_Prop::operator= (FileDialog::sizeFilters_Prop & prop)
{
   SELF(FileDialog, sizeFilters);
   /*0H*/int v = prop;
   FileDialog_set_sizeFilters(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileDialog::sizeFilters_Prop::operator /*0I*/int () const
{
   SELF(FileDialog, sizeFilters);
   return FileDialog_get_sizeFilters(self ? self->impl : null);
}

// property callers: FileDialog::sizeTypes
// (normal::int)

/*nstSet*/inline /*0H*/int FileDialog::sizeTypes_Prop::operator= (/*0H*/int v)
{
   SELF(FileDialog, sizeTypes);
   FileDialog_set_sizeTypes(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileDialog::sizeTypes_Prop & FileDialog::sizeTypes_Prop::operator= (FileDialog::sizeTypes_Prop & prop)
{
   SELF(FileDialog, sizeTypes);
   /*0H*/int v = prop;
   FileDialog_set_sizeTypes(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileDialog::sizeTypes_Prop::operator /*0I*/int () const
{
   SELF(FileDialog, sizeTypes);
   return FileDialog_get_sizeTypes(self ? self->impl : null);
}

// property callers: FileDialog::filter
// (normal::int)

/*nstSet*/inline /*0H*/int FileDialog::filter_Prop::operator= (/*0H*/int v)
{
   SELF(FileDialog, filter);
   FileDialog_set_filter(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileDialog::filter_Prop & FileDialog::filter_Prop::operator= (FileDialog::filter_Prop & prop)
{
   SELF(FileDialog, filter);
   /*0H*/int v = prop;
   FileDialog_set_filter(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileDialog::filter_Prop::operator /*0I*/int () const
{
   SELF(FileDialog, filter);
   return FileDialog_get_filter(self ? self->impl : null);
}

// property callers: FileDialog::fileType
// (normal::int)

/*nstSet*/inline /*0H*/int FileDialog::fileType_Prop::operator= (/*0H*/int v)
{
   SELF(FileDialog, fileType);
   FileDialog_set_fileType(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileDialog::fileType_Prop & FileDialog::fileType_Prop::operator= (FileDialog::fileType_Prop & prop)
{
   SELF(FileDialog, fileType);
   /*0H*/int v = prop;
   FileDialog_set_fileType(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileDialog::fileType_Prop::operator /*0I*/int () const
{
   SELF(FileDialog, fileType);
   return FileDialog_get_fileType(self ? self->impl : null);
}

// property callers: FileDialog::mayNotExist
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool FileDialog::mayNotExist_Prop::operator= (/*0H*/bool v)
{
   SELF(FileDialog, mayNotExist);
   FileDialog_set_mayNotExist(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline FileDialog::mayNotExist_Prop & FileDialog::mayNotExist_Prop::operator= (FileDialog::mayNotExist_Prop & prop)
{
   SELF(FileDialog, mayNotExist);
   /*0H*/bool v = prop;
   FileDialog_set_mayNotExist(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline FileDialog::mayNotExist_Prop::operator /*0I*/bool () const
{
   SELF(FileDialog, mayNotExist);
   return (bool)FileDialog_get_mayNotExist(self ? self->impl : null);
}

// property callers: FileDialog::numSelections   // get only
// (normal::int)

/*regGet*/inline FileDialog::numSelections_Prop::operator /*0I*/int () const
{
   SELF(FileDialog, numSelections);
   return FileDialog_get_numSelections(self ? self->impl : null);
}

// property callers: FileDialog::multiFilePaths   // get only
// (normal::const char * const*)

/*regGet*/inline FileDialog::multiFilePaths_Prop::operator /*0I*/const char ** () const
{
   SELF(FileDialog, multiFilePaths);
   return FileDialog_get_multiFilePaths(self ? self->impl : null);
}

inline FileFilter::FileFilter(const char * name, const char * extensions = null)
{
   impl.name = name;
   impl.extensions = extensions;
}


inline C(bool) FileFilter::validateFileName(/*1Ab*/const char * name)
{
   return FileFilter_validateFileName(&impl, /*5Ge*/name);
}


// member accessors: FileFilter::name
// (struct::const char *)

/*nstSet*/inline /*0H*/const char * FileFilter::name_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileFilter, name);
   self->impl.name = v;
   return v;
}

/*regSet*/inline FileFilter::name_Prop & FileFilter::name_Prop::operator= (FileFilter::name_Prop & prop)
{
   SELF(FileFilter, name);
   /*0H*/const char * v = prop;
   self->impl.name = v;
   return prop;
}
/*regGet*/inline FileFilter::name_Prop::operator /*0I*/const char * () const
{
   SELF(FileFilter, name);
   return self ? ((C(FileFilter) *)&self->impl)->name : null;
}

// member accessors: FileFilter::extensions
// (struct::const char *)

/*nstSet*/inline /*0H*/const char * FileFilter::extensions_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileFilter, extensions);
   self->impl.extensions = v;
   return v;
}

/*regSet*/inline FileFilter::extensions_Prop & FileFilter::extensions_Prop::operator= (FileFilter::extensions_Prop & prop)
{
   SELF(FileFilter, extensions);
   /*0H*/const char * v = prop;
   self->impl.extensions = v;
   return prop;
}
/*regGet*/inline FileFilter::extensions_Prop::operator /*0I*/const char * () const
{
   SELF(FileFilter, extensions);
   return self ? ((C(FileFilter) *)&self->impl)->extensions : null;
}

inline FileName::FileName(const char * name, FileNameType type = (FileNameType)0, int indent = 0)
{
   impl.name = name;
   impl.type = (C(FileNameType))type;
   impl.indent = indent;
}



// member accessors: FileName::name
// (struct::const char *)

/*nstSet*/inline /*0H*/const char * FileName::name_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileName, name);
   self->impl.name = v;
   return v;
}

/*regSet*/inline FileName::name_Prop & FileName::name_Prop::operator= (FileName::name_Prop & prop)
{
   SELF(FileName, name);
   /*0H*/const char * v = prop;
   self->impl.name = v;
   return prop;
}
/*regGet*/inline FileName::name_Prop::operator /*0I*/const char * () const
{
   SELF(FileName, name);
   return self ? ((C(FileName) *)&self->impl)->name : null;
}

// member accessors: FileName::type
// (struct::enum|int)

/*nstSet*/inline /*0H*/FileNameType FileName::type_Prop::operator= (/*0H*/FileNameType v)
{
   SELF(FileName, type);
   self->impl.type = (C(FileNameType))v;
   return v;
}

/*regSet*/inline FileName::type_Prop & FileName::type_Prop::operator= (FileName::type_Prop & prop)
{
   SELF(FileName, type);
   /*0H*/FileNameType v = prop;
   self->impl.type = (C(FileNameType))v;
   return prop;
}
/*regGet*/inline FileName::type_Prop::operator /*0I*/FileNameType () const
{
   SELF(FileName, type);
   return self ? (FileNameType)((C(FileName) *)&self->impl)->type : (FileNameType)0;
}

// member accessors: FileName::indent
// (struct::int)

/*nstSet*/inline /*0H*/int FileName::indent_Prop::operator= (/*0H*/int v)
{
   SELF(FileName, indent);
   self->impl.indent = v;
   return v;
}

/*regSet*/inline FileName::indent_Prop & FileName::indent_Prop::operator= (FileName::indent_Prop & prop)
{
   SELF(FileName, indent);
   /*0H*/int v = prop;
   self->impl.indent = v;
   return prop;
}
/*regGet*/inline FileName::indent_Prop::operator /*0I*/int () const
{
   SELF(FileName, indent);
   return self ? ((C(FileName) *)&self->impl)->indent : 0;
}

inline FileType::FileType(const char * name, const char * typeExtension = null, FileForceExtension forceExtension = (FileForceExtension)0)
{
   impl.name = name;
   impl.typeExtension = typeExtension;
   impl.forceExtension = (C(FileForceExtension))forceExtension;
}



// member accessors: FileType::name
// (struct::const char *)

/*nstSet*/inline /*0H*/const char * FileType::name_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileType, name);
   self->impl.name = v;
   return v;
}

/*regSet*/inline FileType::name_Prop & FileType::name_Prop::operator= (FileType::name_Prop & prop)
{
   SELF(FileType, name);
   /*0H*/const char * v = prop;
   self->impl.name = v;
   return prop;
}
/*regGet*/inline FileType::name_Prop::operator /*0I*/const char * () const
{
   SELF(FileType, name);
   return self ? ((C(FileType) *)&self->impl)->name : null;
}

// member accessors: FileType::typeExtension
// (struct::const char *)

/*nstSet*/inline /*0H*/const char * FileType::typeExtension_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileType, typeExtension);
   self->impl.typeExtension = v;
   return v;
}

/*regSet*/inline FileType::typeExtension_Prop & FileType::typeExtension_Prop::operator= (FileType::typeExtension_Prop & prop)
{
   SELF(FileType, typeExtension);
   /*0H*/const char * v = prop;
   self->impl.typeExtension = v;
   return prop;
}
/*regGet*/inline FileType::typeExtension_Prop::operator /*0I*/const char * () const
{
   SELF(FileType, typeExtension);
   return self ? ((C(FileType) *)&self->impl)->typeExtension : null;
}

// member accessors: FileType::forceExtension
// (struct::enum|int)

/*nstSet*/inline /*0H*/FileForceExtension FileType::forceExtension_Prop::operator= (/*0H*/FileForceExtension v)
{
   SELF(FileType, forceExtension);
   self->impl.forceExtension = (C(FileForceExtension))v;
   return v;
}

/*regSet*/inline FileType::forceExtension_Prop & FileType::forceExtension_Prop::operator= (FileType::forceExtension_Prop & prop)
{
   SELF(FileType, forceExtension);
   /*0H*/FileForceExtension v = prop;
   self->impl.forceExtension = (C(FileForceExtension))v;
   return prop;
}
/*regGet*/inline FileType::forceExtension_Prop::operator /*0I*/FileForceExtension () const
{
   SELF(FileType, forceExtension);
   return self ? (FileForceExtension)((C(FileType) *)&self->impl)->forceExtension : (FileForceExtension)0;
}



// property callers: FindDialog::editBox   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const EditBox & FindDialog::editBox_Prop::operator= (/*0A*/const EditBox & v)
{
   SELF(FindDialog, editBox);
   FindDialog_set_editBox(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const EditBox * FindDialog::editBox_Prop::operator= (/*0C*/const EditBox * v)
{
   SELF(FindDialog, editBox);
   FindDialog_set_editBox(self ? self->impl : null, v ? v->impl : null);
   return v;
}


// property callers: FindDialog::searchString
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * FindDialog::searchString_Prop::operator= (/*0H*/const char * v)
{
   SELF(FindDialog, searchString);
   FindDialog_set_searchString(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FindDialog::searchString_Prop & FindDialog::searchString_Prop::operator= (FindDialog::searchString_Prop & prop)
{
   SELF(FindDialog, searchString);
   /*0H*/const char * v = prop;
   FindDialog_set_searchString(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FindDialog::searchString_Prop::operator /*0I*/const char * () const
{
   SELF(FindDialog, searchString);
   return FindDialog_get_searchString(self ? self->impl : null);
}

// property callers: FindDialog::wholeWord
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool FindDialog::wholeWord_Prop::operator= (/*0H*/bool v)
{
   SELF(FindDialog, wholeWord);
   FindDialog_set_wholeWord(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline FindDialog::wholeWord_Prop & FindDialog::wholeWord_Prop::operator= (FindDialog::wholeWord_Prop & prop)
{
   SELF(FindDialog, wholeWord);
   /*0H*/bool v = prop;
   FindDialog_set_wholeWord(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline FindDialog::wholeWord_Prop::operator /*0I*/bool () const
{
   SELF(FindDialog, wholeWord);
   return (bool)FindDialog_get_wholeWord(self ? self->impl : null);
}

// property callers: FindDialog::matchCase
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool FindDialog::matchCase_Prop::operator= (/*0H*/bool v)
{
   SELF(FindDialog, matchCase);
   FindDialog_set_matchCase(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline FindDialog::matchCase_Prop & FindDialog::matchCase_Prop::operator= (FindDialog::matchCase_Prop & prop)
{
   SELF(FindDialog, matchCase);
   /*0H*/bool v = prop;
   FindDialog_set_matchCase(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline FindDialog::matchCase_Prop::operator /*0I*/bool () const
{
   SELF(FindDialog, matchCase);
   return (bool)FindDialog_get_matchCase(self ? self->impl : null);
}

// property callers: FindDialog::searchUp
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool FindDialog::searchUp_Prop::operator= (/*0H*/bool v)
{
   SELF(FindDialog, searchUp);
   FindDialog_set_searchUp(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline FindDialog::searchUp_Prop & FindDialog::searchUp_Prop::operator= (FindDialog::searchUp_Prop & prop)
{
   SELF(FindDialog, searchUp);
   /*0H*/bool v = prop;
   FindDialog_set_searchUp(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline FindDialog::searchUp_Prop::operator /*0I*/bool () const
{
   SELF(FindDialog, searchUp);
   return (bool)FindDialog_get_searchUp(self ? self->impl : null);
}

inline GoToDialog::GoToDialog(int line) : GoToDialog()
{
   this->line = line;
}



// property callers: GoToDialog::line
// (normal::int)

/*nstSet*/inline /*0H*/int GoToDialog::line_Prop::operator= (/*0H*/int v)
{
   SELF(GoToDialog, line);
   GoToDialog_set_line(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GoToDialog::line_Prop & GoToDialog::line_Prop::operator= (GoToDialog::line_Prop & prop)
{
   SELF(GoToDialog, line);
   /*0H*/int v = prop;
   GoToDialog_set_line(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GoToDialog::line_Prop::operator /*0I*/int () const
{
   SELF(GoToDialog, line);
   return GoToDialog_get_line(self ? self->impl : null);
}

// property callers: GoToDialog::editBox
// (normal::normal)

/*nstSet*/inline /*0A*/const EditBox & GoToDialog::editBox_Prop::operator= (/*0A*/const EditBox & v)
{
   SELF(GoToDialog, editBox);
   GoToDialog_set_editBox(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline GoToDialog::editBox_Prop & GoToDialog::editBox_Prop::operator= (GoToDialog::editBox_Prop & prop)
{
   SELF(GoToDialog, editBox);
   /*0A*/const EditBox & v = prop;
   GoToDialog_set_editBox(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const EditBox * GoToDialog::editBox_Prop::operator= (/*0C*/const EditBox * v)
{
   SELF(GoToDialog, editBox);
   GoToDialog_set_editBox(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline GoToDialog::editBox_Prop::operator /*0B*/TIH<EditBox> () const
{
   SELF(GoToDialog, editBox);
   C(Instance) i = GoToDialog_get_editBox(self ? self->impl : null);
   TIH<EditBox> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<EditBox> GoToDialog::editBox_Prop::operator /*0D*/-> () const
{
   SELF(GoToDialog, editBox);
   C(Instance) i = GoToDialog_get_editBox(self ? self->impl : null);
   TIH<EditBox> holder(i);
   return holder;
}
/*regGet*/inline GoToDialog::editBox_Prop::operator /*0E*/EditBox () const
{
   SELF(GoToDialog, editBox);
   C(Instance) i = GoToDialog_get_editBox(self ? self->impl : null);
   return EditBox(i);
}
/*regGet*/inline GoToDialog::editBox_Prop::operator /*0F*/EditBox* () const
{
   SELF(GoToDialog, editBox);
   C(Instance) i = GoToDialog_get_editBox(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (EditBox *)INSTANCEL(i, i->_class) : (EditBox *)0;
}

inline MessageBox::MessageBox(MessageBoxType type, const char * contents = null) : MessageBox()
{
   this->type = type;
   this->contents = contents;
}



// property callers: MessageBox::type   // set only
// (normal::enum|int)

/*nstSet*/inline /*0G*/MessageBoxType MessageBox::type_Prop::operator= (/*0G*/MessageBoxType v)
{
   SELF(MessageBox, type);
   MessageBox_set_type(self->impl, (C(MessageBoxType))v);
   return v;
}


// property callers: MessageBox::contents   // set only
// (normal::const char *)

/*nstSet*/inline /*0G*/const char * MessageBox::contents_Prop::operator= (/*0G*/const char * v)
{
   SELF(MessageBox, contents);
   MessageBox_set_contents(self->impl, v);
   return v;
}




// property callers: ReplaceDialog::editBox   // set only
// (normal::normal)

/*nstSet*/inline /*0A*/const EditBox & ReplaceDialog::editBox_Prop::operator= (/*0A*/const EditBox & v)
{
   SELF(ReplaceDialog, editBox);
   ReplaceDialog_set_editBox(self ? self->impl : null, v.impl);
   return v;
}

/*nstSet*/inline /*0C*/const EditBox * ReplaceDialog::editBox_Prop::operator= (/*0C*/const EditBox * v)
{
   SELF(ReplaceDialog, editBox);
   ReplaceDialog_set_editBox(self ? self->impl : null, v ? v->impl : null);
   return v;
}


// property callers: ReplaceDialog::searchString
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * ReplaceDialog::searchString_Prop::operator= (/*0H*/const char * v)
{
   SELF(ReplaceDialog, searchString);
   ReplaceDialog_set_searchString(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ReplaceDialog::searchString_Prop & ReplaceDialog::searchString_Prop::operator= (ReplaceDialog::searchString_Prop & prop)
{
   SELF(ReplaceDialog, searchString);
   /*0H*/const char * v = prop;
   ReplaceDialog_set_searchString(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ReplaceDialog::searchString_Prop::operator /*0I*/const char * () const
{
   SELF(ReplaceDialog, searchString);
   return ReplaceDialog_get_searchString(self ? self->impl : null);
}

// property callers: ReplaceDialog::replaceString
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * ReplaceDialog::replaceString_Prop::operator= (/*0H*/const char * v)
{
   SELF(ReplaceDialog, replaceString);
   ReplaceDialog_set_replaceString(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline ReplaceDialog::replaceString_Prop & ReplaceDialog::replaceString_Prop::operator= (ReplaceDialog::replaceString_Prop & prop)
{
   SELF(ReplaceDialog, replaceString);
   /*0H*/const char * v = prop;
   ReplaceDialog_set_replaceString(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline ReplaceDialog::replaceString_Prop::operator /*0I*/const char * () const
{
   SELF(ReplaceDialog, replaceString);
   return ReplaceDialog_get_replaceString(self ? self->impl : null);
}

// property callers: ReplaceDialog::wholeWord
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ReplaceDialog::wholeWord_Prop::operator= (/*0H*/bool v)
{
   SELF(ReplaceDialog, wholeWord);
   ReplaceDialog_set_wholeWord(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ReplaceDialog::wholeWord_Prop & ReplaceDialog::wholeWord_Prop::operator= (ReplaceDialog::wholeWord_Prop & prop)
{
   SELF(ReplaceDialog, wholeWord);
   /*0H*/bool v = prop;
   ReplaceDialog_set_wholeWord(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ReplaceDialog::wholeWord_Prop::operator /*0I*/bool () const
{
   SELF(ReplaceDialog, wholeWord);
   return (bool)ReplaceDialog_get_wholeWord(self ? self->impl : null);
}

// property callers: ReplaceDialog::matchCase
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool ReplaceDialog::matchCase_Prop::operator= (/*0H*/bool v)
{
   SELF(ReplaceDialog, matchCase);
   ReplaceDialog_set_matchCase(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline ReplaceDialog::matchCase_Prop & ReplaceDialog::matchCase_Prop::operator= (ReplaceDialog::matchCase_Prop & prop)
{
   SELF(ReplaceDialog, matchCase);
   /*0H*/bool v = prop;
   ReplaceDialog_set_matchCase(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline ReplaceDialog::matchCase_Prop::operator /*0I*/bool () const
{
   SELF(ReplaceDialog, matchCase);
   return (bool)ReplaceDialog_get_matchCase(self ? self->impl : null);
}


///////////////////////////////////////////// [ecere]/ecere::gui::skins //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////





//////////////////////////////////////////////////// [ecere]/ecere::net //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


inline DCOMClientObject::DCOMClientObject(uint objectID, bool answered = (bool)0) : DCOMClientObject()
{
   this->objectID = objectID;
   this->answered = answered;
}

inline DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::FunctionType DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::operator= (FunctionType func)
{
   SELF(DCOMClientObject, callVirtualMethod);
   if(self->vTbl == DCOMClientObject::_cpp_class.vTbl)
   {
      uint size = DCOMClientObject::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::FunctionType, size);
      memcpy(self->vTbl, DCOMClientObject::_cpp_class.vTbl, sizeof(DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::FunctionType) * size);
   }
   ((DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::FunctionType *)self->vTbl)[M_VTBLID(DCOMClientObject, callVirtualMethod)] = func;
   return func;
}
inline void DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::operator()( /*6Fj*/uint __ecereMethodID, /*6Fj*/SerialBuffer & __ecereBuffer)
{
   SELF(DCOMClientObject, callVirtualMethod);
   DCOMClientObject_callVirtualMethod(self ? self->impl : (C(DCOMClientObject))null, /*7Al*/__ecereMethodID, /*7Al*/__ecereBuffer.impl);
}
// inline void DCOMClientObject::register_callVirtualMethod(CPPClass & cl, DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::FunctionType func)
// {
//    ((DCOMClientObject::DCOMClientObject_callVirtualMethod_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DCOMClientObject, callVirtualMethod)] = func;
// }


inline C(bool) DCOMClientObject::callMethod(/*1Ab*/uint methodID, /*1Ab*/bool hasReturnValue)
{
   return DCOMClientObject_callMethod(impl, /*5Ge*/methodID, /*5Ee*/(C(bool))hasReturnValue);
}
inline C(bool) DCOMClientObject::connect(/*1Ab*/const char * server, /*1Ab*/int port)
{
   return DCOMClientObject_connect(impl, /*5Ge*/server, /*5Ge*/port);
}


// member accessors: DCOMClientObject::objectID
// (normal::uint)

/*nstSet*/inline /*0H*/uint DCOMClientObject::objectID_Prop::operator= (/*0H*/uint v)
{
   SELF(DCOMClientObject, objectID);
   IPTR(self->impl, DCOMClientObject)->objectID = v;
   return v;
}

/*regSet*/inline DCOMClientObject::objectID_Prop & DCOMClientObject::objectID_Prop::operator= (DCOMClientObject::objectID_Prop & prop)
{
   SELF(DCOMClientObject, objectID);
   /*0H*/uint v = prop;
   IPTR(self->impl, DCOMClientObject)->objectID = v;
   return prop;
}
/*regGet*/inline DCOMClientObject::objectID_Prop::operator /*0I*/uint () const
{
   SELF(DCOMClientObject, objectID);
   return self ? IPTR(self->impl, DCOMClientObject)->objectID : 0;
}

// member accessors: DCOMClientObject::answered
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool DCOMClientObject::answered_Prop::operator= (/*0H*/bool v)
{
   SELF(DCOMClientObject, answered);
   IPTR(self->impl, DCOMClientObject)->answered = (C(bool))v;
   return v;
}

/*regSet*/inline DCOMClientObject::answered_Prop & DCOMClientObject::answered_Prop::operator= (DCOMClientObject::answered_Prop & prop)
{
   SELF(DCOMClientObject, answered);
   /*0H*/bool v = prop;
   IPTR(self->impl, DCOMClientObject)->answered = (C(bool))v;
   return prop;
}
/*regGet*/inline DCOMClientObject::answered_Prop::operator /*0I*/bool () const
{
   SELF(DCOMClientObject, answered);
   return self ? (bool)IPTR(self->impl, DCOMClientObject)->answered : (bool)0;
}

// member accessors: DCOMClientObject::__ecereBuffer
// (normal::normal)

/*nstSet*/inline /*0H*/SerialBuffer DCOMClientObject::__ecereBuffer_Prop::operator= (/*0H*/SerialBuffer v)
{
   SELF(DCOMClientObject, __ecereBuffer);
   IPTR(self->impl, DCOMClientObject)->__ecereBuffer = v.impl;
   return v;
}

/*regSet*/inline DCOMClientObject::__ecereBuffer_Prop & DCOMClientObject::__ecereBuffer_Prop::operator= (DCOMClientObject::__ecereBuffer_Prop & prop)
{
   SELF(DCOMClientObject, __ecereBuffer);
   /*0H*/SerialBuffer v = prop;
   IPTR(self->impl, DCOMClientObject)->__ecereBuffer = v.impl;
   return prop;
}
/*regGet*/inline DCOMClientObject::__ecereBuffer_Prop::operator /*0I*/SerialBuffer () const
{
   SELF(DCOMClientObject, __ecereBuffer);
   SerialBuffer value(IPTR(self->impl, DCOMClientObject)->__ecereBuffer, DCOMClientObject::_cpp_class);
   return value;
}

// member accessors: DCOMClientObject::nextCallID
// (normal::int)

/*nstSet*/inline /*0H*/int DCOMClientObject::nextCallID_Prop::operator= (/*0H*/int v)
{
   SELF(DCOMClientObject, nextCallID);
   IPTR(self->impl, DCOMClientObject)->nextCallID = v;
   return v;
}

/*regSet*/inline DCOMClientObject::nextCallID_Prop & DCOMClientObject::nextCallID_Prop::operator= (DCOMClientObject::nextCallID_Prop & prop)
{
   SELF(DCOMClientObject, nextCallID);
   /*0H*/int v = prop;
   IPTR(self->impl, DCOMClientObject)->nextCallID = v;
   return prop;
}
/*regGet*/inline DCOMClientObject::nextCallID_Prop::operator /*0I*/int () const
{
   SELF(DCOMClientObject, nextCallID);
   return self ? IPTR(self->impl, DCOMClientObject)->nextCallID : 0;
}


inline void DCOMSendControl::resume()
{
   DCOMSendControl_resume(impl);
}
inline void DCOMSendControl::stop()
{
   DCOMSendControl_stop(impl);
}

inline DCOMServerObject::DCOMServerObject_callMethod_Functor::FunctionType DCOMServerObject::DCOMServerObject_callMethod_Functor::operator= (FunctionType func)
{
   SELF(DCOMServerObject, callMethod);
   if(self->vTbl == DCOMServerObject::_cpp_class.vTbl)
   {
      uint size = DCOMServerObject::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(DCOMServerObject::DCOMServerObject_callMethod_Functor::FunctionType, size);
      memcpy(self->vTbl, DCOMServerObject::_cpp_class.vTbl, sizeof(DCOMServerObject::DCOMServerObject_callMethod_Functor::FunctionType) * size);
   }
   ((DCOMServerObject::DCOMServerObject_callMethod_Functor::FunctionType *)self->vTbl)[M_VTBLID(DCOMServerObject, callMethod)] = func;
   return func;
}
inline void DCOMServerObject::DCOMServerObject_callMethod_Functor::operator()( /*6Fj*/uint __ecereMethodID, /*6Fj*/SerialBuffer & __ecereBuffer)
{
   SELF(DCOMServerObject, callMethod);
   DCOMServerObject_callMethod(self ? self->impl : (C(DCOMServerObject))null, /*7Al*/__ecereMethodID, /*7Al*/__ecereBuffer.impl);
}
// inline void DCOMServerObject::register_callMethod(CPPClass & cl, DCOMServerObject::DCOMServerObject_callMethod_Functor::FunctionType func)
// {
//    ((DCOMServerObject::DCOMServerObject_callMethod_Functor::FunctionType *)cl.vTbl)[M_VTBLID(DCOMServerObject, callMethod)] = func;
// }


inline C(bool) DCOMServerObject::callVirtualMethod(/*1Ab*/uint methodID, /*1Ab*/bool hasReturnValue)
{
   return DCOMServerObject_callVirtualMethod(impl, /*5Ge*/methodID, /*5Ee*/(C(bool))hasReturnValue);
}


// member accessors: DCOMServerObject::instance
// (normal::normal)

/*nstSet*/inline /*0H*/Instance DCOMServerObject::instance_Prop::operator= (/*0H*/Instance v)
{
   SELF(DCOMServerObject, instance);
   IPTR(self->impl, DCOMServerObject)->instance = v.impl;
   return v;
}

/*regSet*/inline DCOMServerObject::instance_Prop & DCOMServerObject::instance_Prop::operator= (DCOMServerObject::instance_Prop & prop)
{
   SELF(DCOMServerObject, instance);
   /*0H*/Instance v = prop;
   IPTR(self->impl, DCOMServerObject)->instance = v.impl;
   return prop;
}
/*regGet*/inline DCOMServerObject::instance_Prop::operator /*0I*/Instance () const
{
   SELF(DCOMServerObject, instance);
   Instance value(IPTR(self->impl, DCOMServerObject)->instance, DCOMServerObject::_cpp_class);
   return value;
}

// member accessors: DCOMServerObject::serverSocket
// (normal::normal)

/*nstSet*/inline /*0H*/DCOMServerSocket DCOMServerObject::serverSocket_Prop::operator= (/*0H*/DCOMServerSocket v)
{
   SELF(DCOMServerObject, serverSocket);
   IPTR(self->impl, DCOMServerObject)->serverSocket = v.impl;
   return v;
}

/*regSet*/inline DCOMServerObject::serverSocket_Prop & DCOMServerObject::serverSocket_Prop::operator= (DCOMServerObject::serverSocket_Prop & prop)
{
   SELF(DCOMServerObject, serverSocket);
   /*0H*/DCOMServerSocket v = prop;
   IPTR(self->impl, DCOMServerObject)->serverSocket = v.impl;
   return prop;
}
/*regGet*/inline DCOMServerObject::serverSocket_Prop::operator /*0I*/DCOMServerSocket () const
{
   SELF(DCOMServerObject, serverSocket);
   DCOMServerSocket value(IPTR(self->impl, DCOMServerObject)->serverSocket, DCOMServerObject::_cpp_class);
   return value;
}

// member accessors: DCOMServerObject::id
// (normal::uint)

/*nstSet*/inline /*0H*/uint DCOMServerObject::id_Prop::operator= (/*0H*/uint v)
{
   SELF(DCOMServerObject, id);
   IPTR(self->impl, DCOMServerObject)->id = v;
   return v;
}

/*regSet*/inline DCOMServerObject::id_Prop & DCOMServerObject::id_Prop::operator= (DCOMServerObject::id_Prop & prop)
{
   SELF(DCOMServerObject, id);
   /*0H*/uint v = prop;
   IPTR(self->impl, DCOMServerObject)->id = v;
   return prop;
}
/*regGet*/inline DCOMServerObject::id_Prop::operator /*0I*/uint () const
{
   SELF(DCOMServerObject, id);
   return self ? IPTR(self->impl, DCOMServerObject)->id : 0;
}

// member accessors: DCOMServerObject::argsBuffer
// (normal::normal)

/*nstSet*/inline /*0H*/SerialBuffer DCOMServerObject::argsBuffer_Prop::operator= (/*0H*/SerialBuffer v)
{
   SELF(DCOMServerObject, argsBuffer);
   IPTR(self->impl, DCOMServerObject)->argsBuffer = v.impl;
   return v;
}

/*regSet*/inline DCOMServerObject::argsBuffer_Prop & DCOMServerObject::argsBuffer_Prop::operator= (DCOMServerObject::argsBuffer_Prop & prop)
{
   SELF(DCOMServerObject, argsBuffer);
   /*0H*/SerialBuffer v = prop;
   IPTR(self->impl, DCOMServerObject)->argsBuffer = v.impl;
   return prop;
}
/*regGet*/inline DCOMServerObject::argsBuffer_Prop::operator /*0I*/SerialBuffer () const
{
   SELF(DCOMServerObject, argsBuffer);
   SerialBuffer value(IPTR(self->impl, DCOMServerObject)->argsBuffer, DCOMServerObject::_cpp_class);
   return value;
}

// member accessors: DCOMServerObject::returnBuffer
// (normal::normal)

/*nstSet*/inline /*0H*/SerialBuffer DCOMServerObject::returnBuffer_Prop::operator= (/*0H*/SerialBuffer v)
{
   SELF(DCOMServerObject, returnBuffer);
   IPTR(self->impl, DCOMServerObject)->returnBuffer = v.impl;
   return v;
}

/*regSet*/inline DCOMServerObject::returnBuffer_Prop & DCOMServerObject::returnBuffer_Prop::operator= (DCOMServerObject::returnBuffer_Prop & prop)
{
   SELF(DCOMServerObject, returnBuffer);
   /*0H*/SerialBuffer v = prop;
   IPTR(self->impl, DCOMServerObject)->returnBuffer = v.impl;
   return prop;
}
/*regGet*/inline DCOMServerObject::returnBuffer_Prop::operator /*0I*/SerialBuffer () const
{
   SELF(DCOMServerObject, returnBuffer);
   SerialBuffer value(IPTR(self->impl, DCOMServerObject)->returnBuffer, DCOMServerObject::_cpp_class);
   return value;
}

// member accessors: DCOMServerObject::mutex
// (normal::nohead)

/*nstSet*/inline /*0H*/Mutex DCOMServerObject::mutex_Prop::operator= (/*0H*/Mutex & v)
{
   SELF(DCOMServerObject, mutex);
   IPTR(self->impl, DCOMServerObject)->mutex = v.impl;
   return v;
}

/*regSet*/inline DCOMServerObject::mutex_Prop & DCOMServerObject::mutex_Prop::operator= (DCOMServerObject::mutex_Prop & prop)
{
   SELF(DCOMServerObject, mutex);
   /*0H*/Mutex v = prop;
   IPTR(self->impl, DCOMServerObject)->mutex = v.impl;
   return prop;
}
/*regGet*/inline DCOMServerObject::mutex_Prop::operator /*0I*/Mutex () const
{
   SELF(DCOMServerObject, mutex);
   Mutex value(IPTR(self->impl, DCOMServerObject)->mutex);
   return value;
}

// member accessors: DCOMServerObject::nextCallID
// (normal::int)

/*nstSet*/inline /*0H*/int DCOMServerObject::nextCallID_Prop::operator= (/*0H*/int v)
{
   SELF(DCOMServerObject, nextCallID);
   IPTR(self->impl, DCOMServerObject)->nextCallID = v;
   return v;
}

/*regSet*/inline DCOMServerObject::nextCallID_Prop & DCOMServerObject::nextCallID_Prop::operator= (DCOMServerObject::nextCallID_Prop & prop)
{
   SELF(DCOMServerObject, nextCallID);
   /*0H*/int v = prop;
   IPTR(self->impl, DCOMServerObject)->nextCallID = v;
   return prop;
}
/*regGet*/inline DCOMServerObject::nextCallID_Prop::operator /*0I*/int () const
{
   SELF(DCOMServerObject, nextCallID);
   return self ? IPTR(self->impl, DCOMServerObject)->nextCallID : 0;
}



inline C(bool) DCOMService::start()
{
   return DCOMService_start(impl);
}
inline C(bool) DCOMService::stop()
{
   return DCOMService_stop(impl);
}


inline NetworkClientFile FileServerConnection::open(/*1Ab*/const char * fileName, /*1Ab*/FileOpenMode mode)
{
   return NetworkClientFile(FileServerConnection_open(impl, /*5Ge*/fileName, /*5Ee*/(C(FileOpenMode))mode));
}

inline HTTPFile::HTTPFile(bool reuseConnection) : HTTPFile()
{
   this->reuseConnection = reuseConnection;
}


inline C(bool) HTTPFile::openURL(/*1Ab*/const char * name, /*1Ab*/const char * referer, /*1Ab*/char * relocation)
{
   return HTTPFile_openURL(impl, /*5Ge*/name, /*5Ge*/referer, /*5Ge*/relocation);
}
inline C(bool) HTTPFile::openURLEx(/*1Ab*/const char * name, /*1Ab*/const char * referer, /*1Ab*/char * relocation, /*1Ab*/const char * acceptHeader)
{
   return HTTPFile_openURLEx(impl, /*5Ge*/name, /*5Ge*/referer, /*5Ge*/relocation, /*5Ge*/acceptHeader);
}


// property callers: HTTPFile::reuseConnection
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool HTTPFile::reuseConnection_Prop::operator= (/*0H*/bool v)
{
   SELF(HTTPFile, reuseConnection);
   HTTPFile_set_reuseConnection(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline HTTPFile::reuseConnection_Prop & HTTPFile::reuseConnection_Prop::operator= (HTTPFile::reuseConnection_Prop & prop)
{
   SELF(HTTPFile, reuseConnection);
   /*0H*/bool v = prop;
   HTTPFile_set_reuseConnection(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline HTTPFile::reuseConnection_Prop::operator /*0I*/bool () const
{
   SELF(HTTPFile, reuseConnection);
   return (bool)HTTPFile_get_reuseConnection(self ? self->impl : null);
}

// property callers: HTTPFile::contentType   // get only
// (normal::string)

/*regGet*/inline HTTPFile::contentType_Prop::operator /*0I*/char * () const
{
   SELF(HTTPFile, contentType);
   return HTTPFile_get_contentType(self ? self->impl : null);
}

// property callers: HTTPFile::contentDisposition   // get only
// (normal::string)

/*regGet*/inline HTTPFile::contentDisposition_Prop::operator /*0I*/char * () const
{
   SELF(HTTPFile, contentDisposition);
   return HTTPFile_get_contentDisposition(self ? self->impl : null);
}

// property callers: HTTPFile::httpCode   // get only
// (normal::int)

/*regGet*/inline HTTPFile::httpCode_Prop::operator /*0I*/int () const
{
   SELF(HTTPFile, httpCode);
   return HTTPFile_get_httpCode(self ? self->impl : null);
}




// member accessors: Packet::size
// (nohead::uint)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/uint TPacket<TC, TCO>::size_Prop::operator= (/*0H*/uint v)
{
   SELF(Packet, size);
   ((C(Packet) *)self->impl)->size = v;
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TPacket<TC, TCO>::size_Prop & TPacket<TC, TCO>::size_Prop::operator= (typename TPacket<TC, TCO>::size_Prop & prop)
{
   SELF(Packet, size);
   /*0H*/uint v = prop;
   ((C(Packet) *)self->impl)->size = v;
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TPacket<TC, TCO>::size_Prop::operator /*0I*/uint () const
{
   __attribute__((unused)) TPacket TCTCO * self = CONTAINER_OF(this, TPacket TCTCO, size);
   return self ? ((C(Packet) *)self->impl)->size : 0;
}

inline SSLSocket::SSLSocket(bool autoEstablish) : SSLSocket()
{
   this->autoEstablish = autoEstablish;
}


inline C(bool) SSLSocket::establishConnection()
{
   return SSLSocket_establishConnection(impl);
}


// property callers: SSLSocket::autoEstablish
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool SSLSocket::autoEstablish_Prop::operator= (/*0H*/bool v)
{
   SELF(SSLSocket, autoEstablish);
   SSLSocket_set_autoEstablish(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline SSLSocket::autoEstablish_Prop & SSLSocket::autoEstablish_Prop::operator= (SSLSocket::autoEstablish_Prop & prop)
{
   SELF(SSLSocket, autoEstablish);
   /*0H*/bool v = prop;
   SSLSocket_set_autoEstablish(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline SSLSocket::autoEstablish_Prop::operator /*0I*/bool () const
{
   SELF(SSLSocket, autoEstablish);
   return (bool)SSLSocket_get_autoEstablish(self ? self->impl : null);
}

inline Service::Service(int port, bool processAlone = (bool)0) : Service()
{
   this->port = port;
   this->processAlone = processAlone;
}

inline Service::Service_onAccept_Functor::FunctionType Service::Service_onAccept_Functor::operator= (FunctionType func)
{
   SELF(Service, onAccept);
   if(self->vTbl == Service::_cpp_class.vTbl)
   {
      uint size = Service::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Service::Service_onAccept_Functor::FunctionType, size);
      memcpy(self->vTbl, Service::_cpp_class.vTbl, sizeof(Service::Service_onAccept_Functor::FunctionType) * size);
   }
   ((Service::Service_onAccept_Functor::FunctionType *)self->vTbl)[M_VTBLID(Service, onAccept)] = func;
   return func;
}
inline void Service::Service_onAccept_Functor::operator()( )
{
   SELF(Service, onAccept);
   Service_onAccept(self ? self->impl : (C(Service))null);
}
// inline void Service::register_onAccept(CPPClass & cl, Service::Service_onAccept_Functor::FunctionType func)
// {
//    ((Service::Service_onAccept_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Service, onAccept)] = func;
// }


inline C(bool) Service::process()
{
   return Service_process(impl);
}
inline C(bool) Service::processTimeOut(/*1Ab*/Time timeOut)
{
   return Service_processTimeOut(impl, /*5Ee*/(C(Time))timeOut.impl);
}
inline C(bool) Service::start()
{
   return Service_start(impl);
}
inline C(bool) Service::stop()
{
   return Service_stop(impl);
}


// property callers: Service::port
// (normal::int)

/*nstSet*/inline /*0H*/int Service::port_Prop::operator= (/*0H*/int v)
{
   SELF(Service, port);
   Service_set_port(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline Service::port_Prop & Service::port_Prop::operator= (Service::port_Prop & prop)
{
   SELF(Service, port);
   /*0H*/int v = prop;
   Service_set_port(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline Service::port_Prop::operator /*0I*/int () const
{
   SELF(Service, port);
   return Service_get_port(self ? self->impl : null);
}

// property callers: Service::firstClient   // get only
// (normal::normal)

/*regGet*/inline Service::firstClient_Prop::operator /*0B*/TIH<Socket> () const
{
   SELF(Service, firstClient);
   C(Instance) i = Service_get_firstClient(self ? self->impl : null);
   TIH<Socket> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Socket> Service::firstClient_Prop::operator /*0D*/-> () const
{
   SELF(Service, firstClient);
   C(Instance) i = Service_get_firstClient(self ? self->impl : null);
   TIH<Socket> holder(i);
   return holder;
}
/*regGet*/inline Service::firstClient_Prop::operator /*0E*/Socket () const
{
   SELF(Service, firstClient);
   C(Instance) i = Service_get_firstClient(self ? self->impl : null);
   return Socket(i);
}
/*regGet*/inline Service::firstClient_Prop::operator /*0F*/Socket* () const
{
   SELF(Service, firstClient);
   C(Instance) i = Service_get_firstClient(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Socket *)INSTANCEL(i, i->_class) : (Socket *)0;
}

// property callers: Service::processAlone
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Service::processAlone_Prop::operator= (/*0H*/bool v)
{
   SELF(Service, processAlone);
   Service_set_processAlone(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Service::processAlone_Prop & Service::processAlone_Prop::operator= (Service::processAlone_Prop & prop)
{
   SELF(Service, processAlone);
   /*0H*/bool v = prop;
   Service_set_processAlone(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Service::processAlone_Prop::operator /*0I*/bool () const
{
   SELF(Service, processAlone);
   return (bool)Service_get_processAlone(self ? self->impl : null);
}

// property callers: Service::started   // get only
// (normal::enum|uint)

/*regGet*/inline Service::started_Prop::operator /*0I*/bool () const
{
   SELF(Service, started);
   return (bool)Service_get_started(self ? self->impl : null);
}

inline Socket::Socket_onConnect_Functor::FunctionType Socket::Socket_onConnect_Functor::operator= (FunctionType func)
{
   SELF(Socket, onConnect);
   if(self->vTbl == Socket::_cpp_class.vTbl)
   {
      uint size = Socket::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Socket::Socket_onConnect_Functor::FunctionType, size);
      memcpy(self->vTbl, Socket::_cpp_class.vTbl, sizeof(Socket::Socket_onConnect_Functor::FunctionType) * size);
   }
   ((Socket::Socket_onConnect_Functor::FunctionType *)self->vTbl)[M_VTBLID(Socket, onConnect)] = func;
   return func;
}
inline void Socket::Socket_onConnect_Functor::operator()( )
{
   SELF(Socket, onConnect);
   Socket_onConnect(self ? self->impl : (C(Socket))null);
}
// inline void Socket::register_onConnect(CPPClass & cl, Socket::Socket_onConnect_Functor::FunctionType func)
// {
//    ((Socket::Socket_onConnect_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Socket, onConnect)] = func;
// }

inline Socket::Socket_onDisconnect_Functor::FunctionType Socket::Socket_onDisconnect_Functor::operator= (FunctionType func)
{
   SELF(Socket, onDisconnect);
   if(self->vTbl == Socket::_cpp_class.vTbl)
   {
      uint size = Socket::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Socket::Socket_onDisconnect_Functor::FunctionType, size);
      memcpy(self->vTbl, Socket::_cpp_class.vTbl, sizeof(Socket::Socket_onDisconnect_Functor::FunctionType) * size);
   }
   ((Socket::Socket_onDisconnect_Functor::FunctionType *)self->vTbl)[M_VTBLID(Socket, onDisconnect)] = func;
   return func;
}
inline void Socket::Socket_onDisconnect_Functor::operator()( /*6Fj*/int code)
{
   SELF(Socket, onDisconnect);
   Socket_onDisconnect(self ? self->impl : (C(Socket))null, /*7Al*/code);
}
// inline void Socket::register_onDisconnect(CPPClass & cl, Socket::Socket_onDisconnect_Functor::FunctionType func)
// {
//    ((Socket::Socket_onDisconnect_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Socket, onDisconnect)] = func;
// }

inline Socket::Socket_onEstablishConnection_Functor::FunctionType Socket::Socket_onEstablishConnection_Functor::operator= (FunctionType func)
{
   SELF(Socket, onEstablishConnection);
   if(self->vTbl == Socket::_cpp_class.vTbl)
   {
      uint size = Socket::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Socket::Socket_onEstablishConnection_Functor::FunctionType, size);
      memcpy(self->vTbl, Socket::_cpp_class.vTbl, sizeof(Socket::Socket_onEstablishConnection_Functor::FunctionType) * size);
   }
   ((Socket::Socket_onEstablishConnection_Functor::FunctionType *)self->vTbl)[M_VTBLID(Socket, onEstablishConnection)] = func;
   return func;
}
inline bool Socket::Socket_onEstablishConnection_Functor::operator()( /*6Fj*/int s)
{
   SELF(Socket, onEstablishConnection);
   return (bool)Socket_onEstablishConnection(self ? self->impl : (C(Socket))null, /*7Al*/s);
}
// inline void Socket::register_onEstablishConnection(CPPClass & cl, Socket::Socket_onEstablishConnection_Functor::FunctionType func)
// {
//    ((Socket::Socket_onEstablishConnection_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Socket, onEstablishConnection)] = func;
// }

inline Socket::Socket_onReceive_Functor::FunctionType Socket::Socket_onReceive_Functor::operator= (FunctionType func)
{
   SELF(Socket, onReceive);
   if(self->vTbl == Socket::_cpp_class.vTbl)
   {
      uint size = Socket::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Socket::Socket_onReceive_Functor::FunctionType, size);
      memcpy(self->vTbl, Socket::_cpp_class.vTbl, sizeof(Socket::Socket_onReceive_Functor::FunctionType) * size);
   }
   ((Socket::Socket_onReceive_Functor::FunctionType *)self->vTbl)[M_VTBLID(Socket, onReceive)] = func;
   return func;
}
inline uint Socket::Socket_onReceive_Functor::operator()( /*6Fj*/const unsigned char * buffer, /*6Fj*/uint count)
{
   SELF(Socket, onReceive);
   return Socket_onReceive(self ? self->impl : (C(Socket))null, /*7Al*/buffer, /*7Al*/count);
}
// inline void Socket::register_onReceive(CPPClass & cl, Socket::Socket_onReceive_Functor::FunctionType func)
// {
//    ((Socket::Socket_onReceive_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Socket, onReceive)] = func;
// }

inline Socket::Socket_onReceivePacket_Functor::FunctionType Socket::Socket_onReceivePacket_Functor::operator= (FunctionType func)
{
   SELF(Socket, onReceivePacket);
   if(self->vTbl == Socket::_cpp_class.vTbl)
   {
      uint size = Socket::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Socket::Socket_onReceivePacket_Functor::FunctionType, size);
      memcpy(self->vTbl, Socket::_cpp_class.vTbl, sizeof(Socket::Socket_onReceivePacket_Functor::FunctionType) * size);
   }
   ((Socket::Socket_onReceivePacket_Functor::FunctionType *)self->vTbl)[M_VTBLID(Socket, onReceivePacket)] = func;
   return func;
}
inline void Socket::Socket_onReceivePacket_Functor::operator()( /*6Fj*/Packet packet)
{
   SELF(Socket, onReceivePacket);
   Socket_onReceivePacket(self ? self->impl : (C(Socket))null, /*7Al*/packet.impl);
}
// inline void Socket::register_onReceivePacket(CPPClass & cl, Socket::Socket_onReceivePacket_Functor::FunctionType func)
// {
//    ((Socket::Socket_onReceivePacket_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Socket, onReceivePacket)] = func;
// }

inline Socket::Socket_receiveData_Functor::FunctionType Socket::Socket_receiveData_Functor::operator= (FunctionType func)
{
   SELF(Socket, receiveData);
   if(self->vTbl == Socket::_cpp_class.vTbl)
   {
      uint size = Socket::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Socket::Socket_receiveData_Functor::FunctionType, size);
      memcpy(self->vTbl, Socket::_cpp_class.vTbl, sizeof(Socket::Socket_receiveData_Functor::FunctionType) * size);
   }
   ((Socket::Socket_receiveData_Functor::FunctionType *)self->vTbl)[M_VTBLID(Socket, receiveData)] = func;
   return func;
}
inline int Socket::Socket_receiveData_Functor::operator()( /*6Fj*/unsigned char * buffer, /*6Fj*/int count, /*6Fj*/uint flags)
{
   SELF(Socket, receiveData);
   return Socket_receiveData(self ? self->impl : (C(Socket))null, /*7Al*/buffer, /*7Al*/count, /*7Al*/flags);
}
// inline void Socket::register_receiveData(CPPClass & cl, Socket::Socket_receiveData_Functor::FunctionType func)
// {
//    ((Socket::Socket_receiveData_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Socket, receiveData)] = func;
// }

inline Socket::Socket_sendData_Functor::FunctionType Socket::Socket_sendData_Functor::operator= (FunctionType func)
{
   SELF(Socket, sendData);
   if(self->vTbl == Socket::_cpp_class.vTbl)
   {
      uint size = Socket::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Socket::Socket_sendData_Functor::FunctionType, size);
      memcpy(self->vTbl, Socket::_cpp_class.vTbl, sizeof(Socket::Socket_sendData_Functor::FunctionType) * size);
   }
   ((Socket::Socket_sendData_Functor::FunctionType *)self->vTbl)[M_VTBLID(Socket, sendData)] = func;
   return func;
}
inline int Socket::Socket_sendData_Functor::operator()( /*6Fj*/const unsigned char * buffer, /*6Fj*/int count, /*6Fj*/uint flags)
{
   SELF(Socket, sendData);
   return Socket_sendData(self ? self->impl : (C(Socket))null, /*7Al*/buffer, /*7Al*/count, /*7Al*/flags);
}
// inline void Socket::register_sendData(CPPClass & cl, Socket::Socket_sendData_Functor::FunctionType func)
// {
//    ((Socket::Socket_sendData_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Socket, sendData)] = func;
// }


inline C(bool) Socket::connect(/*1Ab*/const char * address, /*1Ab*/int port)
{
   return Socket_connect(impl, /*5Ge*/address, /*5Ge*/port);
}
inline C(bool) Socket::datagramConnect(/*1Ab*/const char * sendAddress, /*1Ab*/int port)
{
   return Socket_datagramConnect(impl, /*5Ge*/sendAddress, /*5Ge*/port);
}
inline C(bool) Socket::datagramHost(/*1Ab*/int port)
{
   return Socket_datagramHost(impl, /*5Ge*/port);
}
inline void Socket::disconnect(/*1Ab*/DisconnectCode code)
{
   Socket_disconnect(impl, /*5Ee*/(C(DisconnectCode))code);
}
inline C(bool) Socket::process()
{
   return Socket_process(impl);
}
inline C(bool) Socket::processTimeOut(/*1Ab*/Time timeOut)
{
   return Socket_processTimeOut(impl, /*5Ee*/(C(Time))timeOut.impl);
}
inline C(bool) Socket::send(/*1Ab*/const void * buffer, /*1Ab*/int size)
{
   return Socket_send(impl, /*5Ge*/buffer, /*5Ge*/size);
}
inline C(bool) Socket::sendPacket(/*1Ab*/Packet packet)
{
   return Socket_sendPacket(impl, /*5De*/packet.impl);
}
inline C(bool) Socket::sendString(/*1Ab*/const char * string)
{
   return Socket_sendString(impl, /*5Ge*/string);
}
template<typename... Args> inline C(bool) Socket::sendf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   return Socket_sendf(impl, /*5Ge*/format, /*5Ae*/args...);
}
inline void Socket::safeDecRef()
{
   Socket_safeDecRef(impl);
}
inline void Socket::safeIncRef()
{
   Socket_safeIncRef(impl);
}


// property callers: Socket::service
// (normal::normal)

/*nstSet*/inline /*0A*/const Service & Socket::service_Prop::operator= (/*0A*/const Service & v)
{
   SELF(Socket, service);
   Socket_set_service(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Socket::service_Prop & Socket::service_Prop::operator= (Socket::service_Prop & prop)
{
   SELF(Socket, service);
   /*0A*/const Service & v = prop;
   Socket_set_service(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const Service * Socket::service_Prop::operator= (/*0C*/const Service * v)
{
   SELF(Socket, service);
   Socket_set_service(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline Socket::service_Prop::operator /*0B*/TIH<Service> () const
{
   SELF(Socket, service);
   C(Instance) i = Socket_get_service(self ? self->impl : null);
   TIH<Service> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Service> Socket::service_Prop::operator /*0D*/-> () const
{
   SELF(Socket, service);
   C(Instance) i = Socket_get_service(self ? self->impl : null);
   TIH<Service> holder(i);
   return holder;
}
/*regGet*/inline Socket::service_Prop::operator /*0E*/Service () const
{
   SELF(Socket, service);
   C(Instance) i = Socket_get_service(self ? self->impl : null);
   return Service(i);
}
/*regGet*/inline Socket::service_Prop::operator /*0F*/Service* () const
{
   SELF(Socket, service);
   C(Instance) i = Socket_get_service(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Service *)INSTANCEL(i, i->_class) : (Service *)0;
}

// property callers: Socket::inetAddress   // get only
// (normal::const char *)

/*regGet*/inline Socket::inetAddress_Prop::operator /*0I*/const char * () const
{
   SELF(Socket, inetAddress);
   return Socket_get_inetAddress(self ? self->impl : null);
}

// property callers: Socket::inetPort   // get only
// (normal::int)

/*regGet*/inline Socket::inetPort_Prop::operator /*0I*/int () const
{
   SELF(Socket, inetPort);
   return Socket_get_inetPort(self ? self->impl : null);
}

// property callers: Socket::next   // get only
// (normal::normal)

/*regGet*/inline Socket::next_Prop::operator /*0B*/TIH<Socket> () const
{
   SELF(Socket, next);
   C(Instance) i = Socket_get_next(self ? self->impl : null);
   TIH<Socket> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<Socket> Socket::next_Prop::operator /*0D*/-> () const
{
   SELF(Socket, next);
   C(Instance) i = Socket_get_next(self ? self->impl : null);
   TIH<Socket> holder(i);
   return holder;
}
/*regGet*/inline Socket::next_Prop::operator /*0E*/Socket () const
{
   SELF(Socket, next);
   C(Instance) i = Socket_get_next(self ? self->impl : null);
   return Socket(i);
}
/*regGet*/inline Socket::next_Prop::operator /*0F*/Socket* () const
{
   SELF(Socket, next);
   C(Instance) i = Socket_get_next(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (Socket *)INSTANCEL(i, i->_class) : (Socket *)0;
}

// property callers: Socket::connected   // get only
// (normal::enum|uint)

/*regGet*/inline Socket::connected_Prop::operator /*0I*/bool () const
{
   SELF(Socket, connected);
   return (bool)Socket_get_connected(self ? self->impl : null);
}

// property callers: Socket::processAlone
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool Socket::processAlone_Prop::operator= (/*0H*/bool v)
{
   SELF(Socket, processAlone);
   Socket_set_processAlone(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline Socket::processAlone_Prop & Socket::processAlone_Prop::operator= (Socket::processAlone_Prop & prop)
{
   SELF(Socket, processAlone);
   /*0H*/bool v = prop;
   Socket_set_processAlone(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline Socket::processAlone_Prop::operator /*0I*/bool () const
{
   SELF(Socket, processAlone);
   return (bool)Socket_get_processAlone(self ? self->impl : null);
}

//////////////////////////////////////////////////// [ecere]/ecere::sys //////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////
//////////////////////////////////////////////////////////////////////////////// ////////////////


#undef Pi
static constexpr Radians Pi { 3.1415926535897932384626433832795028841971 };

inline Archive::Archive(FileSize totalSize, uint bufferSize = 0, uint bufferRead = 0) : Archive()
{
   this->totalSize = totalSize.impl;
   this->bufferSize = bufferSize;
   this->bufferRead = bufferRead;
}

inline Archive::Archive_clear_Functor::FunctionType Archive::Archive_clear_Functor::operator= (FunctionType func)
{
   SELF(Archive, clear);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_clear_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_clear_Functor::FunctionType) * size);
   }
   ((Archive::Archive_clear_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, clear)] = func;
   return func;
}
inline bool Archive::Archive_clear_Functor::operator()( )
{
   SELF(Archive, clear);
   return (bool)Archive_clear(self ? self->impl : (C(Archive))null);
}
// inline void Archive::register_clear(CPPClass & cl, Archive::Archive_clear_Functor::FunctionType func)
// {
//    ((Archive::Archive_clear_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, clear)] = func;
// }

inline Archive::Archive_fileExists_Functor::FunctionType Archive::Archive_fileExists_Functor::operator= (FunctionType func)
{
   SELF(Archive, fileExists);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_fileExists_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_fileExists_Functor::FunctionType) * size);
   }
   ((Archive::Archive_fileExists_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, fileExists)] = func;
   return func;
}
inline FileAttribs Archive::Archive_fileExists_Functor::operator()( /*6Fj*/const char * fileName)
{
   SELF(Archive, fileExists);
   return Archive_fileExists(self ? self->impl : (C(Archive))null, /*7Al*/fileName);
}
// inline void Archive::register_fileExists(CPPClass & cl, Archive::Archive_fileExists_Functor::FunctionType func)
// {
//    ((Archive::Archive_fileExists_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, fileExists)] = func;
// }

inline Archive::Archive_fileOpen_Functor::FunctionType Archive::Archive_fileOpen_Functor::operator= (FunctionType func)
{
   SELF(Archive, fileOpen);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_fileOpen_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_fileOpen_Functor::FunctionType) * size);
   }
   ((Archive::Archive_fileOpen_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, fileOpen)] = func;
   return func;
}
inline File * Archive::Archive_fileOpen_Functor::operator()( /*6Fj*/const char * fileName)
{
   SELF(Archive, fileOpen);
   C(File) retFile = Archive_fileOpen(self ? self->impl : (C(Archive))null, /*7Al*/fileName);
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;
}
// inline void Archive::register_fileOpen(CPPClass & cl, Archive::Archive_fileOpen_Functor::FunctionType func)
// {
//    ((Archive::Archive_fileOpen_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, fileOpen)] = func;
// }

inline Archive::Archive_fileOpenAtPosition_Functor::FunctionType Archive::Archive_fileOpenAtPosition_Functor::operator= (FunctionType func)
{
   SELF(Archive, fileOpenAtPosition);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_fileOpenAtPosition_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_fileOpenAtPosition_Functor::FunctionType) * size);
   }
   ((Archive::Archive_fileOpenAtPosition_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, fileOpenAtPosition)] = func;
   return func;
}
inline File * Archive::Archive_fileOpenAtPosition_Functor::operator()( /*6Fj*/uint position)
{
   SELF(Archive, fileOpenAtPosition);
   C(File) retFile = Archive_fileOpenAtPosition(self ? self->impl : (C(Archive))null, /*7Al*/position);
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;
}
// inline void Archive::register_fileOpenAtPosition(CPPClass & cl, Archive::Archive_fileOpenAtPosition_Functor::FunctionType func)
// {
//    ((Archive::Archive_fileOpenAtPosition_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, fileOpenAtPosition)] = func;
// }

inline Archive::Archive_fileOpenCompressed_Functor::FunctionType Archive::Archive_fileOpenCompressed_Functor::operator= (FunctionType func)
{
   SELF(Archive, fileOpenCompressed);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_fileOpenCompressed_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_fileOpenCompressed_Functor::FunctionType) * size);
   }
   ((Archive::Archive_fileOpenCompressed_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, fileOpenCompressed)] = func;
   return func;
}
inline File * Archive::Archive_fileOpenCompressed_Functor::operator()( /*6Fj*/const char * fileName, /*6Cj*/C(bool) * isCompressed, /*6Fj*/uint64 * ucSize)
{
   SELF(Archive, fileOpenCompressed);
   C(File) retFile = Archive_fileOpenCompressed(self ? self->impl : (C(Archive))null, /*7Al*/fileName, /*7Al*/isCompressed, /*7Al*/ucSize);
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;
}
// inline void Archive::register_fileOpenCompressed(CPPClass & cl, Archive::Archive_fileOpenCompressed_Functor::FunctionType func)
// {
//    ((Archive::Archive_fileOpenCompressed_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, fileOpenCompressed)] = func;
// }

inline Archive::Archive_openDirectory_Functor::FunctionType Archive::Archive_openDirectory_Functor::operator= (FunctionType func)
{
   SELF(Archive, openDirectory);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_openDirectory_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_openDirectory_Functor::FunctionType) * size);
   }
   ((Archive::Archive_openDirectory_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, openDirectory)] = func;
   return func;
}
inline ArchiveDir * Archive::Archive_openDirectory_Functor::operator()( /*6Fj*/const char * name, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode)
{
   SELF(Archive, openDirectory);
   C(ArchiveDir) retArchiveDir = Archive_openDirectory(self ? self->impl : (C(Archive))null, /*7Al*/name, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode);
      return BINDINGS_CLASS(retArchiveDir) ? (ArchiveDir *)INSTANCEL(retArchiveDir, retArchiveDir->_class) : (ArchiveDir *)0;
}
// inline void Archive::register_openDirectory(CPPClass & cl, Archive::Archive_openDirectory_Functor::FunctionType func)
// {
//    ((Archive::Archive_openDirectory_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, openDirectory)] = func;
// }

inline Archive::Archive_setBufferRead_Functor::FunctionType Archive::Archive_setBufferRead_Functor::operator= (FunctionType func)
{
   SELF(Archive, setBufferRead);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_setBufferRead_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_setBufferRead_Functor::FunctionType) * size);
   }
   ((Archive::Archive_setBufferRead_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, setBufferRead)] = func;
   return func;
}
inline void Archive::Archive_setBufferRead_Functor::operator()( /*6Fj*/uint bufferRead)
{
   SELF(Archive, setBufferRead);
   Archive_setBufferRead(self ? self->impl : (C(Archive))null, /*7Al*/bufferRead);
}
// inline void Archive::register_setBufferRead(CPPClass & cl, Archive::Archive_setBufferRead_Functor::FunctionType func)
// {
//    ((Archive::Archive_setBufferRead_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, setBufferRead)] = func;
// }

inline Archive::Archive_setBufferSize_Functor::FunctionType Archive::Archive_setBufferSize_Functor::operator= (FunctionType func)
{
   SELF(Archive, setBufferSize);
   if(self->vTbl == Archive::_cpp_class.vTbl)
   {
      uint size = Archive::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Archive::Archive_setBufferSize_Functor::FunctionType, size);
      memcpy(self->vTbl, Archive::_cpp_class.vTbl, sizeof(Archive::Archive_setBufferSize_Functor::FunctionType) * size);
   }
   ((Archive::Archive_setBufferSize_Functor::FunctionType *)self->vTbl)[M_VTBLID(Archive, setBufferSize)] = func;
   return func;
}
inline void Archive::Archive_setBufferSize_Functor::operator()( /*6Fj*/uint bufferSize)
{
   SELF(Archive, setBufferSize);
   Archive_setBufferSize(self ? self->impl : (C(Archive))null, /*7Al*/bufferSize);
}
// inline void Archive::register_setBufferSize(CPPClass & cl, Archive::Archive_setBufferSize_Functor::FunctionType func)
// {
//    ((Archive::Archive_setBufferSize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Archive, setBufferSize)] = func;
// }



// property callers: Archive::totalSize
// (normal::unit|uint)

/*nstSet*/inline /*0H*/FileSize Archive::totalSize_Prop::operator= (/*0H*/FileSize v)
{
   SELF(Archive, totalSize);
   Archive_set_totalSize(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline Archive::totalSize_Prop & Archive::totalSize_Prop::operator= (Archive::totalSize_Prop & prop)
{
   SELF(Archive, totalSize);
   /*0H*/FileSize v = prop;
   Archive_set_totalSize(self ? self->impl : null, v.impl);
   return prop;
}
/*regGet*/inline Archive::totalSize_Prop::operator /*0I*/FileSize () const
{
   SELF(Archive, totalSize);
   FileSize value(Archive_get_totalSize(self->impl));
   return value;
}
/*regGet*/inline Archive::totalSize_Prop::operator /*0J*/C(FileSize) () const
{
   SELF(Archive, totalSize);
   return FileSize(self->totalSize);
}

// property callers: Archive::bufferSize   // set only
// (normal::uint)

/*nstSet*/inline /*0G*/uint Archive::bufferSize_Prop::operator= (/*0G*/uint v)
{
   SELF(Archive, bufferSize);
   Archive_set_bufferSize(self->impl, v);
   return v;
}


// property callers: Archive::bufferRead   // set only
// (normal::uint)

/*nstSet*/inline /*0G*/uint Archive::bufferRead_Prop::operator= (/*0G*/uint v)
{
   SELF(Archive, bufferRead);
   Archive_set_bufferRead(self->impl, v);
   return v;
}


inline ArchiveDir::ArchiveDir_addFromFile_Functor::FunctionType ArchiveDir::ArchiveDir_addFromFile_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, addFromFile);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_addFromFile_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_addFromFile_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_addFromFile_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, addFromFile)] = func;
   return func;
}
inline bool ArchiveDir::ArchiveDir_addFromFile_Functor::operator()( /*6Fj*/const char * name, /*6Fj*/File & input, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode, /*6Fj*/int compression, /*6Fj*/int * ratio, /*6Fj*/uint * newPosition)
{
   SELF(ArchiveDir, addFromFile);
   return (bool)ArchiveDir_addFromFile(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/input.impl, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode, /*7Al*/compression, /*7Al*/ratio, /*7Al*/newPosition);
}
// inline void ArchiveDir::register_addFromFile(CPPClass & cl, ArchiveDir::ArchiveDir_addFromFile_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_addFromFile_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, addFromFile)] = func;
// }

inline ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::FunctionType ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, addFromFileAtPosition);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, addFromFileAtPosition)] = func;
   return func;
}
inline bool ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::operator()( /*6Fj*/uint position, /*6Fj*/const char * name, /*6Fj*/File & input, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode, /*6Fj*/int compression, /*6Fj*/int * ratio, /*6Fj*/uint * newPosition)
{
   SELF(ArchiveDir, addFromFileAtPosition);
   return (bool)ArchiveDir_addFromFileAtPosition(self ? self->impl : (C(ArchiveDir))null, /*7Al*/position, /*7Al*/name, /*7Al*/input.impl, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode, /*7Al*/compression, /*7Al*/ratio, /*7Al*/newPosition);
}
// inline void ArchiveDir::register_addFromFileAtPosition(CPPClass & cl, ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_addFromFileAtPosition_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, addFromFileAtPosition)] = func;
// }

inline ArchiveDir::ArchiveDir_delete_Functor::FunctionType ArchiveDir::ArchiveDir_delete_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, delete_);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_delete_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_delete_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_delete_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, delete)] = func;
   return func;
}
inline bool ArchiveDir::ArchiveDir_delete_Functor::operator()( /*6Fj*/const char * fileName)
{
   SELF(ArchiveDir, delete_);
   return (bool)ArchiveDir_delete(self ? self->impl : (C(ArchiveDir))null, /*7Al*/fileName);
}
// inline void ArchiveDir::register_delete(CPPClass & cl, ArchiveDir::ArchiveDir_delete_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_delete_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, delete)] = func;
// }

inline ArchiveDir::ArchiveDir_fileExists_Functor::FunctionType ArchiveDir::ArchiveDir_fileExists_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, fileExists);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_fileExists_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_fileExists_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_fileExists_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, fileExists)] = func;
   return func;
}
inline FileAttribs ArchiveDir::ArchiveDir_fileExists_Functor::operator()( /*6Fj*/const char * fileName)
{
   SELF(ArchiveDir, fileExists);
   return ArchiveDir_fileExists(self ? self->impl : (C(ArchiveDir))null, /*7Al*/fileName);
}
// inline void ArchiveDir::register_fileExists(CPPClass & cl, ArchiveDir::ArchiveDir_fileExists_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_fileExists_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, fileExists)] = func;
// }

inline ArchiveDir::ArchiveDir_fileOpen_Functor::FunctionType ArchiveDir::ArchiveDir_fileOpen_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, fileOpen);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_fileOpen_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_fileOpen_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_fileOpen_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, fileOpen)] = func;
   return func;
}
inline File * ArchiveDir::ArchiveDir_fileOpen_Functor::operator()( /*6Fj*/const char * fileName)
{
   SELF(ArchiveDir, fileOpen);
   C(File) retFile = ArchiveDir_fileOpen(self ? self->impl : (C(ArchiveDir))null, /*7Al*/fileName);
      return BINDINGS_CLASS(retFile) ? (File *)INSTANCEL(retFile, retFile->_class) : (File *)0;
}
// inline void ArchiveDir::register_fileOpen(CPPClass & cl, ArchiveDir::ArchiveDir_fileOpen_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_fileOpen_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, fileOpen)] = func;
// }

inline ArchiveDir::ArchiveDir_move_Functor::FunctionType ArchiveDir::ArchiveDir_move_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, move);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_move_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_move_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_move_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, move)] = func;
   return func;
}
inline bool ArchiveDir::ArchiveDir_move_Functor::operator()( /*6Fj*/const char * name, /*6Fj*/ArchiveDir & to)
{
   SELF(ArchiveDir, move);
   return (bool)ArchiveDir_move(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/to.impl);
}
// inline void ArchiveDir::register_move(CPPClass & cl, ArchiveDir::ArchiveDir_move_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_move_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, move)] = func;
// }

inline ArchiveDir::ArchiveDir_openDirectory_Functor::FunctionType ArchiveDir::ArchiveDir_openDirectory_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, openDirectory);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_openDirectory_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_openDirectory_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_openDirectory_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, openDirectory)] = func;
   return func;
}
inline ArchiveDir * ArchiveDir::ArchiveDir_openDirectory_Functor::operator()( /*6Fj*/const char * name, /*6Fj*/FileStats & stats, /*6Fj*/ArchiveAddMode addMode)
{
   SELF(ArchiveDir, openDirectory);
   C(ArchiveDir) retArchiveDir = ArchiveDir_openDirectory(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/&stats.impl, /*7Al*/(C(ArchiveAddMode))addMode);
      return BINDINGS_CLASS(retArchiveDir) ? (ArchiveDir *)INSTANCEL(retArchiveDir, retArchiveDir->_class) : (ArchiveDir *)0;
}
// inline void ArchiveDir::register_openDirectory(CPPClass & cl, ArchiveDir::ArchiveDir_openDirectory_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_openDirectory_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, openDirectory)] = func;
// }

inline ArchiveDir::ArchiveDir_rename_Functor::FunctionType ArchiveDir::ArchiveDir_rename_Functor::operator= (FunctionType func)
{
   SELF(ArchiveDir, rename);
   if(self->vTbl == ArchiveDir::_cpp_class.vTbl)
   {
      uint size = ArchiveDir::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(ArchiveDir::ArchiveDir_rename_Functor::FunctionType, size);
      memcpy(self->vTbl, ArchiveDir::_cpp_class.vTbl, sizeof(ArchiveDir::ArchiveDir_rename_Functor::FunctionType) * size);
   }
   ((ArchiveDir::ArchiveDir_rename_Functor::FunctionType *)self->vTbl)[M_VTBLID(ArchiveDir, rename)] = func;
   return func;
}
inline bool ArchiveDir::ArchiveDir_rename_Functor::operator()( /*6Fj*/const char * name, /*6Fj*/const char * newName)
{
   SELF(ArchiveDir, rename);
   return (bool)ArchiveDir_rename(self ? self->impl : (C(ArchiveDir))null, /*7Al*/name, /*7Al*/newName);
}
// inline void ArchiveDir::register_rename(CPPClass & cl, ArchiveDir::ArchiveDir_rename_Functor::FunctionType func)
// {
//    ((ArchiveDir::ArchiveDir_rename_Functor::FunctionType *)cl.vTbl)[M_VTBLID(ArchiveDir, rename)] = func;
// }


inline C(bool) ArchiveDir::add(/*1Ab*/const char * name, /*1Ab*/const char * path, /*1Ab*/ArchiveAddMode addMode, /*1Ab*/int compression, /*1Ab*/int * ratio, /*1Ab*/uint * newPosition)
{
   return ArchiveDir_add(impl, /*5Ge*/name, /*5Ge*/path, /*5Ee*/(C(ArchiveAddMode))addMode, /*5Ge*/compression, /*5Ge*/ratio, /*5Ge*/newPosition);
}



// member accessors: ArchiveOpenFlags::writeAccess
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ArchiveOpenFlags::writeAccess_Prop::operator= (/*0H*/bool v)
{
   SELF(ArchiveOpenFlags, writeAccess);
   ARCHIVEOPENFLAGS_SET_writeAccess(self->impl, v);
   return v;
}

/*regSet*/inline ArchiveOpenFlags::writeAccess_Prop & ArchiveOpenFlags::writeAccess_Prop::operator= (ArchiveOpenFlags::writeAccess_Prop & prop)
{
   SELF(ArchiveOpenFlags, writeAccess);
   /*0H*/bool v = prop;
   ARCHIVEOPENFLAGS_SET_writeAccess(self->impl, v);
   return prop;
}
/*regGet*/inline ArchiveOpenFlags::writeAccess_Prop::operator /*0I*/bool () const
{
   SELF(ArchiveOpenFlags, writeAccess);
   return (bool)ARCHIVEOPENFLAGS_writeAccess(self->impl);
}

// member accessors: ArchiveOpenFlags::buffered
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ArchiveOpenFlags::buffered_Prop::operator= (/*0H*/bool v)
{
   SELF(ArchiveOpenFlags, buffered);
   ARCHIVEOPENFLAGS_SET_buffered(self->impl, v);
   return v;
}

/*regSet*/inline ArchiveOpenFlags::buffered_Prop & ArchiveOpenFlags::buffered_Prop::operator= (ArchiveOpenFlags::buffered_Prop & prop)
{
   SELF(ArchiveOpenFlags, buffered);
   /*0H*/bool v = prop;
   ARCHIVEOPENFLAGS_SET_buffered(self->impl, v);
   return prop;
}
/*regGet*/inline ArchiveOpenFlags::buffered_Prop::operator /*0I*/bool () const
{
   SELF(ArchiveOpenFlags, buffered);
   return (bool)ARCHIVEOPENFLAGS_buffered(self->impl);
}

// member accessors: ArchiveOpenFlags::exclusive
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ArchiveOpenFlags::exclusive_Prop::operator= (/*0H*/bool v)
{
   SELF(ArchiveOpenFlags, exclusive);
   ARCHIVEOPENFLAGS_SET_exclusive(self->impl, v);
   return v;
}

/*regSet*/inline ArchiveOpenFlags::exclusive_Prop & ArchiveOpenFlags::exclusive_Prop::operator= (ArchiveOpenFlags::exclusive_Prop & prop)
{
   SELF(ArchiveOpenFlags, exclusive);
   /*0H*/bool v = prop;
   ARCHIVEOPENFLAGS_SET_exclusive(self->impl, v);
   return prop;
}
/*regGet*/inline ArchiveOpenFlags::exclusive_Prop::operator /*0I*/bool () const
{
   SELF(ArchiveOpenFlags, exclusive);
   return (bool)ARCHIVEOPENFLAGS_exclusive(self->impl);
}

// member accessors: ArchiveOpenFlags::waitLock
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool ArchiveOpenFlags::waitLock_Prop::operator= (/*0H*/bool v)
{
   SELF(ArchiveOpenFlags, waitLock);
   ARCHIVEOPENFLAGS_SET_waitLock(self->impl, v);
   return v;
}

/*regSet*/inline ArchiveOpenFlags::waitLock_Prop & ArchiveOpenFlags::waitLock_Prop::operator= (ArchiveOpenFlags::waitLock_Prop & prop)
{
   SELF(ArchiveOpenFlags, waitLock);
   /*0H*/bool v = prop;
   ARCHIVEOPENFLAGS_SET_waitLock(self->impl, v);
   return prop;
}
/*regGet*/inline ArchiveOpenFlags::waitLock_Prop::operator /*0I*/bool () const
{
   SELF(ArchiveOpenFlags, waitLock);
   return (bool)ARCHIVEOPENFLAGS_waitLock(self->impl);
}

inline Box::Box(int left, int top = 0, int right = 0, int bottom = 0)
{
   impl.left = left;
   impl.top = top;
   impl.right = right;
   impl.bottom = bottom;
}


inline void Box::clip(/*1Ab*/Box & against)
{
   Box_clip(&impl, /*5De*/&against.impl);
}
inline void Box::clip(/*1Ac*/Box * against)
{
   Box_clip(&impl, /*5Cf*/(C(Box) *)against);
}
inline void Box::clipOffset(/*1Ab*/Box & against, /*1Ab*/int x, /*1Ab*/int y)
{
   Box_clipOffset(&impl, /*5De*/&against.impl, /*5Ge*/x, /*5Ge*/y);
}
inline void Box::clipOffset(/*1Ac*/Box * against, /*1Ac*/int x, /*1Ac*/int y)
{
   Box_clipOffset(&impl, /*5Cf*/(C(Box) *)against, /*5Gf*/x, /*5Gf*/y);
}
inline C(bool) Box::isPointInside(/*1Ab*/Point & point)
{
   return Box_isPointInside(&impl, /*5De*/&point.impl);
}
inline C(bool) Box::isPointInside(/*1Ac*/Point * point)
{
   return Box_isPointInside(&impl, /*5Cf*/(C(Point) *)point);
}
inline C(bool) Box::overlap(/*1Ab*/Box & box)
{
   return Box_overlap(&impl, /*5De*/&box.impl);
}
inline C(bool) Box::overlap(/*1Ac*/Box * box)
{
   return Box_overlap(&impl, /*5Cf*/(C(Box) *)box);
}


// property callers: Box::width
// (struct::int)

/*nstSet*/inline /*0H*/int Box::width_Prop::operator= (/*0H*/int v)
{
   SELF(Box, width);
   Box_set_width(self ? &self->impl : null, v);
   return v;
}

/*regSet*/inline Box::width_Prop & Box::width_Prop::operator= (Box::width_Prop & prop)
{
   SELF(Box, width);
   /*0H*/int v = prop;
   Box_set_width(self ? &self->impl : null, v);
   return prop;
}
/*regGet*/inline Box::width_Prop::operator /*0I*/int () const
{
   SELF(Box, width);
   return Box_get_width(self ? &self->impl : null);
}

// property callers: Box::height
// (struct::int)

/*nstSet*/inline /*0H*/int Box::height_Prop::operator= (/*0H*/int v)
{
   SELF(Box, height);
   Box_set_height(self ? &self->impl : null, v);
   return v;
}

/*regSet*/inline Box::height_Prop & Box::height_Prop::operator= (Box::height_Prop & prop)
{
   SELF(Box, height);
   /*0H*/int v = prop;
   Box_set_height(self ? &self->impl : null, v);
   return prop;
}
/*regGet*/inline Box::height_Prop::operator /*0I*/int () const
{
   SELF(Box, height);
   return Box_get_height(self ? &self->impl : null);
}


// member accessors: Box::left
// (struct::int)

/*nstSet*/inline /*0H*/int Box::left_Prop::operator= (/*0H*/int v)
{
   SELF(Box, left);
   self->impl.left = v;
   return v;
}

/*regSet*/inline Box::left_Prop & Box::left_Prop::operator= (Box::left_Prop & prop)
{
   SELF(Box, left);
   /*0H*/int v = prop;
   self->impl.left = v;
   return prop;
}
/*regGet*/inline Box::left_Prop::operator /*0I*/int () const
{
   SELF(Box, left);
   return self ? ((C(Box) *)&self->impl)->left : 0;
}

// member accessors: Box::top
// (struct::int)

/*nstSet*/inline /*0H*/int Box::top_Prop::operator= (/*0H*/int v)
{
   SELF(Box, top);
   self->impl.top = v;
   return v;
}

/*regSet*/inline Box::top_Prop & Box::top_Prop::operator= (Box::top_Prop & prop)
{
   SELF(Box, top);
   /*0H*/int v = prop;
   self->impl.top = v;
   return prop;
}
/*regGet*/inline Box::top_Prop::operator /*0I*/int () const
{
   SELF(Box, top);
   return self ? ((C(Box) *)&self->impl)->top : 0;
}

// member accessors: Box::right
// (struct::int)

/*nstSet*/inline /*0H*/int Box::right_Prop::operator= (/*0H*/int v)
{
   SELF(Box, right);
   self->impl.right = v;
   return v;
}

/*regSet*/inline Box::right_Prop & Box::right_Prop::operator= (Box::right_Prop & prop)
{
   SELF(Box, right);
   /*0H*/int v = prop;
   self->impl.right = v;
   return prop;
}
/*regGet*/inline Box::right_Prop::operator /*0I*/int () const
{
   SELF(Box, right);
   return self ? ((C(Box) *)&self->impl)->right : 0;
}

// member accessors: Box::bottom
// (struct::int)

/*nstSet*/inline /*0H*/int Box::bottom_Prop::operator= (/*0H*/int v)
{
   SELF(Box, bottom);
   self->impl.bottom = v;
   return v;
}

/*regSet*/inline Box::bottom_Prop & Box::bottom_Prop::operator= (Box::bottom_Prop & prop)
{
   SELF(Box, bottom);
   /*0H*/int v = prop;
   self->impl.bottom = v;
   return prop;
}
/*regGet*/inline Box::bottom_Prop::operator /*0I*/int () const
{
   SELF(Box, bottom);
   return self ? ((C(Box) *)&self->impl)->bottom : 0;
}



// property callers: BufferedFile::handle
// (normal::normal)

/*nstSet*/inline /*0A*/const File & BufferedFile::handle_Prop::operator= (/*0A*/const File & v)
{
   SELF(BufferedFile, handle);
   BufferedFile_set_handle(self ? self->impl : null, v.impl);
   return v;
}

/*regSet*/inline BufferedFile::handle_Prop & BufferedFile::handle_Prop::operator= (BufferedFile::handle_Prop & prop)
{
   SELF(BufferedFile, handle);
   /*0A*/const File & v = prop;
   BufferedFile_set_handle(self ? self->impl : null, v.impl);
   return prop;
}
/*nstSet*/inline /*0C*/const File * BufferedFile::handle_Prop::operator= (/*0C*/const File * v)
{
   SELF(BufferedFile, handle);
   BufferedFile_set_handle(self ? self->impl : null, v ? v->impl : null);
   return v;
}

/*regGet*/inline BufferedFile::handle_Prop::operator /*0B*/TIH<File> () const
{
   SELF(BufferedFile, handle);
   C(Instance) i = BufferedFile_get_handle(self ? self->impl : null);
   TIH<File> cppi(i);
   return *cppi;
}
/*regGet*/inline TIH<File> BufferedFile::handle_Prop::operator /*0D*/-> () const
{
   SELF(BufferedFile, handle);
   C(Instance) i = BufferedFile_get_handle(self ? self->impl : null);
   TIH<File> holder(i);
   return holder;
}
/*regGet*/inline BufferedFile::handle_Prop::operator /*0E*/File () const
{
   SELF(BufferedFile, handle);
   C(Instance) i = BufferedFile_get_handle(self ? self->impl : null);
   return File(i);
}
/*regGet*/inline BufferedFile::handle_Prop::operator /*0F*/File* () const
{
   SELF(BufferedFile, handle);
   C(Instance) i = BufferedFile_get_handle(self ? self->impl : null);
   return BINDINGS_CLASS(i) ? (File *)INSTANCEL(i, i->_class) : (File *)0;
}

// property callers: BufferedFile::bufferSize
// (normal::uintsize)

/*nstSet*/inline /*0H*/uintsize BufferedFile::bufferSize_Prop::operator= (/*0H*/uintsize v)
{
   SELF(BufferedFile, bufferSize);
   BufferedFile_set_bufferSize(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline BufferedFile::bufferSize_Prop & BufferedFile::bufferSize_Prop::operator= (BufferedFile::bufferSize_Prop & prop)
{
   SELF(BufferedFile, bufferSize);
   /*0H*/uintsize v = prop;
   BufferedFile_set_bufferSize(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline BufferedFile::bufferSize_Prop::operator /*0I*/uintsize () const
{
   SELF(BufferedFile, bufferSize);
   return BufferedFile_get_bufferSize(self ? self->impl : null);
}

// property callers: BufferedFile::bufferRead
// (normal::uintsize)

/*nstSet*/inline /*0H*/uintsize BufferedFile::bufferRead_Prop::operator= (/*0H*/uintsize v)
{
   SELF(BufferedFile, bufferRead);
   BufferedFile_set_bufferRead(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline BufferedFile::bufferRead_Prop & BufferedFile::bufferRead_Prop::operator= (BufferedFile::bufferRead_Prop & prop)
{
   SELF(BufferedFile, bufferRead);
   /*0H*/uintsize v = prop;
   BufferedFile_set_bufferRead(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline BufferedFile::bufferRead_Prop::operator /*0I*/uintsize () const
{
   SELF(BufferedFile, bufferRead);
   return BufferedFile_get_bufferRead(self ? self->impl : null);
}
// A (unit:unit)
inline constexpr Centimeters::operator Meters() const { return Meters(impl); }
inline constexpr Centimeters::Centimeters(const Meters & m) : Distance(m.impl) { }
inline constexpr Centimeters & Centimeters::operator =(const Meters & m) { impl = m.impl; return *this; }



// member accessors: CharCategories::none
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::none_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, none);
   CHARCATEGORIES_SET_none(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::none_Prop & CharCategories::none_Prop::operator= (CharCategories::none_Prop & prop)
{
   SELF(CharCategories, none);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_none(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::none_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, none);
   return (bool)CHARCATEGORIES_none(self->impl);
}

// member accessors: CharCategories::markNonSpacing
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::markNonSpacing_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, markNonSpacing);
   CHARCATEGORIES_SET_markNonSpacing(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::markNonSpacing_Prop & CharCategories::markNonSpacing_Prop::operator= (CharCategories::markNonSpacing_Prop & prop)
{
   SELF(CharCategories, markNonSpacing);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_markNonSpacing(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::markNonSpacing_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, markNonSpacing);
   return (bool)CHARCATEGORIES_markNonSpacing(self->impl);
}

// member accessors: CharCategories::markSpacing
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::markSpacing_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, markSpacing);
   CHARCATEGORIES_SET_markSpacing(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::markSpacing_Prop & CharCategories::markSpacing_Prop::operator= (CharCategories::markSpacing_Prop & prop)
{
   SELF(CharCategories, markSpacing);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_markSpacing(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::markSpacing_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, markSpacing);
   return (bool)CHARCATEGORIES_markSpacing(self->impl);
}

// member accessors: CharCategories::markEnclosing
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::markEnclosing_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, markEnclosing);
   CHARCATEGORIES_SET_markEnclosing(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::markEnclosing_Prop & CharCategories::markEnclosing_Prop::operator= (CharCategories::markEnclosing_Prop & prop)
{
   SELF(CharCategories, markEnclosing);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_markEnclosing(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::markEnclosing_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, markEnclosing);
   return (bool)CHARCATEGORIES_markEnclosing(self->impl);
}

// member accessors: CharCategories::numberDecimalDigit
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::numberDecimalDigit_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, numberDecimalDigit);
   CHARCATEGORIES_SET_numberDecimalDigit(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::numberDecimalDigit_Prop & CharCategories::numberDecimalDigit_Prop::operator= (CharCategories::numberDecimalDigit_Prop & prop)
{
   SELF(CharCategories, numberDecimalDigit);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_numberDecimalDigit(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::numberDecimalDigit_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, numberDecimalDigit);
   return (bool)CHARCATEGORIES_numberDecimalDigit(self->impl);
}

// member accessors: CharCategories::numberLetter
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::numberLetter_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, numberLetter);
   CHARCATEGORIES_SET_numberLetter(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::numberLetter_Prop & CharCategories::numberLetter_Prop::operator= (CharCategories::numberLetter_Prop & prop)
{
   SELF(CharCategories, numberLetter);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_numberLetter(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::numberLetter_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, numberLetter);
   return (bool)CHARCATEGORIES_numberLetter(self->impl);
}

// member accessors: CharCategories::numberOther
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::numberOther_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, numberOther);
   CHARCATEGORIES_SET_numberOther(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::numberOther_Prop & CharCategories::numberOther_Prop::operator= (CharCategories::numberOther_Prop & prop)
{
   SELF(CharCategories, numberOther);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_numberOther(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::numberOther_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, numberOther);
   return (bool)CHARCATEGORIES_numberOther(self->impl);
}

// member accessors: CharCategories::separatorSpace
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::separatorSpace_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, separatorSpace);
   CHARCATEGORIES_SET_separatorSpace(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::separatorSpace_Prop & CharCategories::separatorSpace_Prop::operator= (CharCategories::separatorSpace_Prop & prop)
{
   SELF(CharCategories, separatorSpace);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_separatorSpace(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::separatorSpace_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, separatorSpace);
   return (bool)CHARCATEGORIES_separatorSpace(self->impl);
}

// member accessors: CharCategories::separatorLine
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::separatorLine_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, separatorLine);
   CHARCATEGORIES_SET_separatorLine(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::separatorLine_Prop & CharCategories::separatorLine_Prop::operator= (CharCategories::separatorLine_Prop & prop)
{
   SELF(CharCategories, separatorLine);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_separatorLine(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::separatorLine_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, separatorLine);
   return (bool)CHARCATEGORIES_separatorLine(self->impl);
}

// member accessors: CharCategories::separatorParagraph
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::separatorParagraph_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, separatorParagraph);
   CHARCATEGORIES_SET_separatorParagraph(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::separatorParagraph_Prop & CharCategories::separatorParagraph_Prop::operator= (CharCategories::separatorParagraph_Prop & prop)
{
   SELF(CharCategories, separatorParagraph);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_separatorParagraph(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::separatorParagraph_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, separatorParagraph);
   return (bool)CHARCATEGORIES_separatorParagraph(self->impl);
}

// member accessors: CharCategories::otherControl
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::otherControl_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, otherControl);
   CHARCATEGORIES_SET_otherControl(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::otherControl_Prop & CharCategories::otherControl_Prop::operator= (CharCategories::otherControl_Prop & prop)
{
   SELF(CharCategories, otherControl);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_otherControl(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::otherControl_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, otherControl);
   return (bool)CHARCATEGORIES_otherControl(self->impl);
}

// member accessors: CharCategories::otherFormat
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::otherFormat_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, otherFormat);
   CHARCATEGORIES_SET_otherFormat(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::otherFormat_Prop & CharCategories::otherFormat_Prop::operator= (CharCategories::otherFormat_Prop & prop)
{
   SELF(CharCategories, otherFormat);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_otherFormat(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::otherFormat_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, otherFormat);
   return (bool)CHARCATEGORIES_otherFormat(self->impl);
}

// member accessors: CharCategories::otherSurrogate
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::otherSurrogate_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, otherSurrogate);
   CHARCATEGORIES_SET_otherSurrogate(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::otherSurrogate_Prop & CharCategories::otherSurrogate_Prop::operator= (CharCategories::otherSurrogate_Prop & prop)
{
   SELF(CharCategories, otherSurrogate);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_otherSurrogate(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::otherSurrogate_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, otherSurrogate);
   return (bool)CHARCATEGORIES_otherSurrogate(self->impl);
}

// member accessors: CharCategories::otherPrivateUse
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::otherPrivateUse_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, otherPrivateUse);
   CHARCATEGORIES_SET_otherPrivateUse(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::otherPrivateUse_Prop & CharCategories::otherPrivateUse_Prop::operator= (CharCategories::otherPrivateUse_Prop & prop)
{
   SELF(CharCategories, otherPrivateUse);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_otherPrivateUse(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::otherPrivateUse_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, otherPrivateUse);
   return (bool)CHARCATEGORIES_otherPrivateUse(self->impl);
}

// member accessors: CharCategories::otherNotAssigned
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::otherNotAssigned_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, otherNotAssigned);
   CHARCATEGORIES_SET_otherNotAssigned(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::otherNotAssigned_Prop & CharCategories::otherNotAssigned_Prop::operator= (CharCategories::otherNotAssigned_Prop & prop)
{
   SELF(CharCategories, otherNotAssigned);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_otherNotAssigned(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::otherNotAssigned_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, otherNotAssigned);
   return (bool)CHARCATEGORIES_otherNotAssigned(self->impl);
}

// member accessors: CharCategories::letterUpperCase
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::letterUpperCase_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, letterUpperCase);
   CHARCATEGORIES_SET_letterUpperCase(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::letterUpperCase_Prop & CharCategories::letterUpperCase_Prop::operator= (CharCategories::letterUpperCase_Prop & prop)
{
   SELF(CharCategories, letterUpperCase);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_letterUpperCase(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::letterUpperCase_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, letterUpperCase);
   return (bool)CHARCATEGORIES_letterUpperCase(self->impl);
}

// member accessors: CharCategories::letterLowerCase
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::letterLowerCase_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, letterLowerCase);
   CHARCATEGORIES_SET_letterLowerCase(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::letterLowerCase_Prop & CharCategories::letterLowerCase_Prop::operator= (CharCategories::letterLowerCase_Prop & prop)
{
   SELF(CharCategories, letterLowerCase);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_letterLowerCase(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::letterLowerCase_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, letterLowerCase);
   return (bool)CHARCATEGORIES_letterLowerCase(self->impl);
}

// member accessors: CharCategories::letterTitleCase
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::letterTitleCase_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, letterTitleCase);
   CHARCATEGORIES_SET_letterTitleCase(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::letterTitleCase_Prop & CharCategories::letterTitleCase_Prop::operator= (CharCategories::letterTitleCase_Prop & prop)
{
   SELF(CharCategories, letterTitleCase);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_letterTitleCase(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::letterTitleCase_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, letterTitleCase);
   return (bool)CHARCATEGORIES_letterTitleCase(self->impl);
}

// member accessors: CharCategories::letterModifier
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::letterModifier_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, letterModifier);
   CHARCATEGORIES_SET_letterModifier(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::letterModifier_Prop & CharCategories::letterModifier_Prop::operator= (CharCategories::letterModifier_Prop & prop)
{
   SELF(CharCategories, letterModifier);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_letterModifier(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::letterModifier_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, letterModifier);
   return (bool)CHARCATEGORIES_letterModifier(self->impl);
}

// member accessors: CharCategories::letterOther
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::letterOther_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, letterOther);
   CHARCATEGORIES_SET_letterOther(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::letterOther_Prop & CharCategories::letterOther_Prop::operator= (CharCategories::letterOther_Prop & prop)
{
   SELF(CharCategories, letterOther);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_letterOther(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::letterOther_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, letterOther);
   return (bool)CHARCATEGORIES_letterOther(self->impl);
}

// member accessors: CharCategories::punctuationConnector
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::punctuationConnector_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, punctuationConnector);
   CHARCATEGORIES_SET_punctuationConnector(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::punctuationConnector_Prop & CharCategories::punctuationConnector_Prop::operator= (CharCategories::punctuationConnector_Prop & prop)
{
   SELF(CharCategories, punctuationConnector);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_punctuationConnector(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::punctuationConnector_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, punctuationConnector);
   return (bool)CHARCATEGORIES_punctuationConnector(self->impl);
}

// member accessors: CharCategories::punctuationDash
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::punctuationDash_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, punctuationDash);
   CHARCATEGORIES_SET_punctuationDash(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::punctuationDash_Prop & CharCategories::punctuationDash_Prop::operator= (CharCategories::punctuationDash_Prop & prop)
{
   SELF(CharCategories, punctuationDash);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_punctuationDash(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::punctuationDash_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, punctuationDash);
   return (bool)CHARCATEGORIES_punctuationDash(self->impl);
}

// member accessors: CharCategories::punctuationOpen
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::punctuationOpen_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, punctuationOpen);
   CHARCATEGORIES_SET_punctuationOpen(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::punctuationOpen_Prop & CharCategories::punctuationOpen_Prop::operator= (CharCategories::punctuationOpen_Prop & prop)
{
   SELF(CharCategories, punctuationOpen);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_punctuationOpen(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::punctuationOpen_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, punctuationOpen);
   return (bool)CHARCATEGORIES_punctuationOpen(self->impl);
}

// member accessors: CharCategories::punctuationClose
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::punctuationClose_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, punctuationClose);
   CHARCATEGORIES_SET_punctuationClose(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::punctuationClose_Prop & CharCategories::punctuationClose_Prop::operator= (CharCategories::punctuationClose_Prop & prop)
{
   SELF(CharCategories, punctuationClose);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_punctuationClose(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::punctuationClose_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, punctuationClose);
   return (bool)CHARCATEGORIES_punctuationClose(self->impl);
}

// member accessors: CharCategories::punctuationInitial
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::punctuationInitial_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, punctuationInitial);
   CHARCATEGORIES_SET_punctuationInitial(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::punctuationInitial_Prop & CharCategories::punctuationInitial_Prop::operator= (CharCategories::punctuationInitial_Prop & prop)
{
   SELF(CharCategories, punctuationInitial);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_punctuationInitial(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::punctuationInitial_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, punctuationInitial);
   return (bool)CHARCATEGORIES_punctuationInitial(self->impl);
}

// member accessors: CharCategories::punctuationFinal
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::punctuationFinal_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, punctuationFinal);
   CHARCATEGORIES_SET_punctuationFinal(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::punctuationFinal_Prop & CharCategories::punctuationFinal_Prop::operator= (CharCategories::punctuationFinal_Prop & prop)
{
   SELF(CharCategories, punctuationFinal);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_punctuationFinal(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::punctuationFinal_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, punctuationFinal);
   return (bool)CHARCATEGORIES_punctuationFinal(self->impl);
}

// member accessors: CharCategories::punctuationOther
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::punctuationOther_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, punctuationOther);
   CHARCATEGORIES_SET_punctuationOther(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::punctuationOther_Prop & CharCategories::punctuationOther_Prop::operator= (CharCategories::punctuationOther_Prop & prop)
{
   SELF(CharCategories, punctuationOther);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_punctuationOther(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::punctuationOther_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, punctuationOther);
   return (bool)CHARCATEGORIES_punctuationOther(self->impl);
}

// member accessors: CharCategories::symbolMath
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::symbolMath_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, symbolMath);
   CHARCATEGORIES_SET_symbolMath(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::symbolMath_Prop & CharCategories::symbolMath_Prop::operator= (CharCategories::symbolMath_Prop & prop)
{
   SELF(CharCategories, symbolMath);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_symbolMath(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::symbolMath_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, symbolMath);
   return (bool)CHARCATEGORIES_symbolMath(self->impl);
}

// member accessors: CharCategories::symbolCurrency
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::symbolCurrency_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, symbolCurrency);
   CHARCATEGORIES_SET_symbolCurrency(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::symbolCurrency_Prop & CharCategories::symbolCurrency_Prop::operator= (CharCategories::symbolCurrency_Prop & prop)
{
   SELF(CharCategories, symbolCurrency);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_symbolCurrency(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::symbolCurrency_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, symbolCurrency);
   return (bool)CHARCATEGORIES_symbolCurrency(self->impl);
}

// member accessors: CharCategories::symbolModifier
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::symbolModifier_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, symbolModifier);
   CHARCATEGORIES_SET_symbolModifier(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::symbolModifier_Prop & CharCategories::symbolModifier_Prop::operator= (CharCategories::symbolModifier_Prop & prop)
{
   SELF(CharCategories, symbolModifier);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_symbolModifier(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::symbolModifier_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, symbolModifier);
   return (bool)CHARCATEGORIES_symbolModifier(self->impl);
}

// member accessors: CharCategories::symbolOther
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool CharCategories::symbolOther_Prop::operator= (/*0H*/bool v)
{
   SELF(CharCategories, symbolOther);
   CHARCATEGORIES_SET_symbolOther(self->impl, v);
   return v;
}

/*regSet*/inline CharCategories::symbolOther_Prop & CharCategories::symbolOther_Prop::operator= (CharCategories::symbolOther_Prop & prop)
{
   SELF(CharCategories, symbolOther);
   /*0H*/bool v = prop;
   CHARCATEGORIES_SET_symbolOther(self->impl, v);
   return prop;
}
/*regGet*/inline CharCategories::symbolOther_Prop::operator /*0I*/bool () const
{
   SELF(CharCategories, symbolOther);
   return (bool)CHARCATEGORIES_symbolOther(self->impl);
}


template <class TC, C(Class) ** TCO> inline void TCondition<TC, TCO>::signal()
{
   Condition_signal((C(Condition)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TCondition<TC, TCO>::wait(/*1Ab*/Mutex mutex)
{
   Condition_wait((C(Condition)*)this->impl, /*5De*/mutex.impl);
}


// property callers: Condition::name
// (nohead::const char *)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/const char * TCondition<TC, TCO>::name_Prop::operator= (/*0H*/const char * v)
{
   SELF(Condition, name);
   Condition_set_name(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TCondition<TC, TCO>::name_Prop & TCondition<TC, TCO>::name_Prop::operator= (typename TCondition<TC, TCO>::name_Prop & prop)
{
   SELF(Condition, name);
   /*0H*/const char * v = prop;
   Condition_set_name(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TCondition<TC, TCO>::name_Prop::operator /*0I*/const char * () const
{
   __attribute__((unused)) TCondition TCTCO * self = CONTAINER_OF(this, TCondition TCTCO, name);
   return Condition_get_name(self ? self->impl : null);
}


inline Date::Date(int year, Month month = (Month)0, int day = 0)
{
   impl.year = year;
   impl.month = (C(Month))month;
   impl.day = day;
}


inline const char * Date::onGetStringEn(/*1Ab*/char * stringOutput, /*1Ab*/void * fieldData, /*1Ab*/ObjectNotationType * onType)
{
   return Date_onGetStringEn(&impl, /*5Ge*/stringOutput, /*5Ge*/fieldData, /*5Ee*/(C(ObjectNotationType) *)onType);
}


// property callers: Date::dayOfTheWeek   // get only
// (struct::enum|int)

/*regGet*/inline Date::dayOfTheWeek_Prop::operator /*0I*/DayOfTheWeek () const
{
   SELF(Date, dayOfTheWeek);
   return (DayOfTheWeek)Date_get_dayOfTheWeek(self ? &self->impl : null);
}


// member accessors: Date::year
// (struct::int)

/*nstSet*/inline /*0H*/int Date::year_Prop::operator= (/*0H*/int v)
{
   SELF(Date, year);
   self->impl.year = v;
   return v;
}

/*regSet*/inline Date::year_Prop & Date::year_Prop::operator= (Date::year_Prop & prop)
{
   SELF(Date, year);
   /*0H*/int v = prop;
   self->impl.year = v;
   return prop;
}
/*regGet*/inline Date::year_Prop::operator /*0I*/int () const
{
   SELF(Date, year);
   return self ? ((C(Date) *)&self->impl)->year : 0;
}

// member accessors: Date::month
// (struct::enum|int)

/*nstSet*/inline /*0H*/Month Date::month_Prop::operator= (/*0H*/Month v)
{
   SELF(Date, month);
   self->impl.month = (C(Month))v;
   return v;
}

/*regSet*/inline Date::month_Prop & Date::month_Prop::operator= (Date::month_Prop & prop)
{
   SELF(Date, month);
   /*0H*/Month v = prop;
   self->impl.month = (C(Month))v;
   return prop;
}
/*regGet*/inline Date::month_Prop::operator /*0I*/Month () const
{
   SELF(Date, month);
   return self ? (Month)((C(Date) *)&self->impl)->month : (Month)0;
}

// member accessors: Date::day
// (struct::int)

/*nstSet*/inline /*0H*/int Date::day_Prop::operator= (/*0H*/int v)
{
   SELF(Date, day);
   self->impl.day = v;
   return v;
}

/*regSet*/inline Date::day_Prop & Date::day_Prop::operator= (Date::day_Prop & prop)
{
   SELF(Date, day);
   /*0H*/int v = prop;
   self->impl.day = v;
   return prop;
}
/*regGet*/inline Date::day_Prop::operator /*0I*/int () const
{
   SELF(Date, day);
   return self ? ((C(Date) *)&self->impl)->day : 0;
}
// A (struct:unit)
inline DateTime::operator SecSince1970() const { SecSince1970 s = DateTime_to_SecSince1970(&impl); return s; }
inline DateTime::DateTime(const SecSince1970 & s) { DateTime_from_SecSince1970(&impl, s.impl); }
inline DateTime & DateTime::operator =(const SecSince1970 & s) { DateTime_from_SecSince1970(&impl, s.impl); return *this; }
// A (struct:struct)
inline DateTime::operator Date() const { Date d; DateTime_to_Date(&impl, &d.impl); return d; }
inline DateTime::DateTime(const Date & d) { DateTime_from_Date(&impl, &d.impl); }
inline DateTime & DateTime::operator =(const Date & d) { DateTime_from_Date(&impl, &d.impl); return *this; }

inline DateTime::DateTime(int year, Month month = (Month)0, int day = 0, int hour = 0, int minute = 0, int second = 0, DayOfTheWeek dayOfTheWeek = (DayOfTheWeek)0, int dayInTheYear = 0)
{
   impl.year = year;
   impl.month = (C(Month))month;
   impl.day = day;
   impl.hour = hour;
   impl.minute = minute;
   impl.second = second;
   impl.dayOfTheWeek = (C(DayOfTheWeek))dayOfTheWeek;
   impl.dayInTheYear = dayInTheYear;
}


inline C(bool) DateTime::fixDayOfYear()
{
   return DateTime_fixDayOfYear(&impl);
}
inline C(bool) DateTime::getLocalTime()
{
   return DateTime_getLocalTime(&impl);
}


// property callers: DateTime::global
// (struct::struct)

/*nstSet*/inline /*0H*/DateTime DateTime::global_Prop::operator= (/*0H*/DateTime v)
{
   SELF(DateTime, global);
   DateTime_set_global(self ? &self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline DateTime::global_Prop & DateTime::global_Prop::operator= (DateTime::global_Prop & prop)
{
   SELF(DateTime, global);
   /*0H*/DateTime v = prop;
   DateTime_set_global(self ? &self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline DateTime::global_Prop::operator /*0I*/DateTime () const
{
   SELF(DateTime, global);
   DateTime value;DateTime_get_global(&self->impl, &value.impl);
   return value;
}

// property callers: DateTime::local
// (struct::struct)

/*nstSet*/inline /*0H*/DateTime DateTime::local_Prop::operator= (/*0H*/DateTime v)
{
   SELF(DateTime, local);
   DateTime_set_local(self ? &self->impl : null, &v.impl);
   return v;
}

/*regSet*/inline DateTime::local_Prop & DateTime::local_Prop::operator= (DateTime::local_Prop & prop)
{
   SELF(DateTime, local);
   /*0H*/DateTime v = prop;
   DateTime_set_local(self ? &self->impl : null, &v.impl);
   return prop;
}
/*regGet*/inline DateTime::local_Prop::operator /*0I*/DateTime () const
{
   SELF(DateTime, local);
   DateTime value;DateTime_get_local(&self->impl, &value.impl);
   return value;
}

// property callers: DateTime::daysSince1970   // get only
// (struct::int64)

/*regGet*/inline DateTime::daysSince1970_Prop::operator /*0I*/int64 () const
{
   SELF(DateTime, daysSince1970);
   return DateTime_get_daysSince1970(self ? &self->impl : null);
}


// member accessors: DateTime::year
// (struct::int)

/*nstSet*/inline /*0H*/int DateTime::year_Prop::operator= (/*0H*/int v)
{
   SELF(DateTime, year);
   self->impl.year = v;
   return v;
}

/*regSet*/inline DateTime::year_Prop & DateTime::year_Prop::operator= (DateTime::year_Prop & prop)
{
   SELF(DateTime, year);
   /*0H*/int v = prop;
   self->impl.year = v;
   return prop;
}
/*regGet*/inline DateTime::year_Prop::operator /*0I*/int () const
{
   SELF(DateTime, year);
   return self ? ((C(DateTime) *)&self->impl)->year : 0;
}

// member accessors: DateTime::month
// (struct::enum|int)

/*nstSet*/inline /*0H*/Month DateTime::month_Prop::operator= (/*0H*/Month v)
{
   SELF(DateTime, month);
   self->impl.month = (C(Month))v;
   return v;
}

/*regSet*/inline DateTime::month_Prop & DateTime::month_Prop::operator= (DateTime::month_Prop & prop)
{
   SELF(DateTime, month);
   /*0H*/Month v = prop;
   self->impl.month = (C(Month))v;
   return prop;
}
/*regGet*/inline DateTime::month_Prop::operator /*0I*/Month () const
{
   SELF(DateTime, month);
   return self ? (Month)((C(DateTime) *)&self->impl)->month : (Month)0;
}

// member accessors: DateTime::day
// (struct::int)

/*nstSet*/inline /*0H*/int DateTime::day_Prop::operator= (/*0H*/int v)
{
   SELF(DateTime, day);
   self->impl.day = v;
   return v;
}

/*regSet*/inline DateTime::day_Prop & DateTime::day_Prop::operator= (DateTime::day_Prop & prop)
{
   SELF(DateTime, day);
   /*0H*/int v = prop;
   self->impl.day = v;
   return prop;
}
/*regGet*/inline DateTime::day_Prop::operator /*0I*/int () const
{
   SELF(DateTime, day);
   return self ? ((C(DateTime) *)&self->impl)->day : 0;
}

// member accessors: DateTime::hour
// (struct::int)

/*nstSet*/inline /*0H*/int DateTime::hour_Prop::operator= (/*0H*/int v)
{
   SELF(DateTime, hour);
   self->impl.hour = v;
   return v;
}

/*regSet*/inline DateTime::hour_Prop & DateTime::hour_Prop::operator= (DateTime::hour_Prop & prop)
{
   SELF(DateTime, hour);
   /*0H*/int v = prop;
   self->impl.hour = v;
   return prop;
}
/*regGet*/inline DateTime::hour_Prop::operator /*0I*/int () const
{
   SELF(DateTime, hour);
   return self ? ((C(DateTime) *)&self->impl)->hour : 0;
}

// member accessors: DateTime::minute
// (struct::int)

/*nstSet*/inline /*0H*/int DateTime::minute_Prop::operator= (/*0H*/int v)
{
   SELF(DateTime, minute);
   self->impl.minute = v;
   return v;
}

/*regSet*/inline DateTime::minute_Prop & DateTime::minute_Prop::operator= (DateTime::minute_Prop & prop)
{
   SELF(DateTime, minute);
   /*0H*/int v = prop;
   self->impl.minute = v;
   return prop;
}
/*regGet*/inline DateTime::minute_Prop::operator /*0I*/int () const
{
   SELF(DateTime, minute);
   return self ? ((C(DateTime) *)&self->impl)->minute : 0;
}

// member accessors: DateTime::second
// (struct::int)

/*nstSet*/inline /*0H*/int DateTime::second_Prop::operator= (/*0H*/int v)
{
   SELF(DateTime, second);
   self->impl.second = v;
   return v;
}

/*regSet*/inline DateTime::second_Prop & DateTime::second_Prop::operator= (DateTime::second_Prop & prop)
{
   SELF(DateTime, second);
   /*0H*/int v = prop;
   self->impl.second = v;
   return prop;
}
/*regGet*/inline DateTime::second_Prop::operator /*0I*/int () const
{
   SELF(DateTime, second);
   return self ? ((C(DateTime) *)&self->impl)->second : 0;
}

// member accessors: DateTime::dayOfTheWeek
// (struct::enum|int)

/*nstSet*/inline /*0H*/DayOfTheWeek DateTime::dayOfTheWeek_Prop::operator= (/*0H*/DayOfTheWeek v)
{
   SELF(DateTime, dayOfTheWeek);
   self->impl.dayOfTheWeek = (C(DayOfTheWeek))v;
   return v;
}

/*regSet*/inline DateTime::dayOfTheWeek_Prop & DateTime::dayOfTheWeek_Prop::operator= (DateTime::dayOfTheWeek_Prop & prop)
{
   SELF(DateTime, dayOfTheWeek);
   /*0H*/DayOfTheWeek v = prop;
   self->impl.dayOfTheWeek = (C(DayOfTheWeek))v;
   return prop;
}
/*regGet*/inline DateTime::dayOfTheWeek_Prop::operator /*0I*/DayOfTheWeek () const
{
   SELF(DateTime, dayOfTheWeek);
   return self ? (DayOfTheWeek)((C(DateTime) *)&self->impl)->dayOfTheWeek : (DayOfTheWeek)0;
}

// member accessors: DateTime::dayInTheYear
// (struct::int)

/*nstSet*/inline /*0H*/int DateTime::dayInTheYear_Prop::operator= (/*0H*/int v)
{
   SELF(DateTime, dayInTheYear);
   self->impl.dayInTheYear = v;
   return v;
}

/*regSet*/inline DateTime::dayInTheYear_Prop & DateTime::dayInTheYear_Prop::operator= (DateTime::dayInTheYear_Prop & prop)
{
   SELF(DateTime, dayInTheYear);
   /*0H*/int v = prop;
   self->impl.dayInTheYear = v;
   return prop;
}
/*regGet*/inline DateTime::dayInTheYear_Prop::operator /*0I*/int () const
{
   SELF(DateTime, dayInTheYear);
   return self ? ((C(DateTime) *)&self->impl)->dayInTheYear : 0;
}
// A (unit:unit)
inline constexpr Degrees::operator Radians() const { return Radians(impl); }
inline constexpr Degrees::Degrees(const Radians & r) : Angle(r.impl) { }
inline constexpr Degrees & Degrees::operator =(const Radians & r) { impl = r.impl; return *this; }
// B (unit:unit)


inline int DualPipe::getExitCode()
{
   return DualPipe_getExitCode(impl);
}
inline C(bool) DualPipe::getLinePeek(/*1Ab*/char * s, /*1Ab*/int max, /*1Ab*/int * charsRead)
{
   return DualPipe_getLinePeek(impl, /*5Ge*/s, /*5Ge*/max, /*5Ge*/charsRead);
}
inline int DualPipe::getProcessID()
{
   return DualPipe_getProcessID(impl);
}
inline C(bool) DualPipe::peek()
{
   return DualPipe_peek(impl);
}
inline void DualPipe::terminate()
{
   DualPipe_terminate(impl);
}
inline void DualPipe::wait()
{
   DualPipe_wait(impl);
}





// member accessors: ErrorCode::level
// (bits::enum|int)

/*nstSet*/inline /*0H*/ErrorLevel ErrorCode::level_Prop::operator= (/*0H*/ErrorLevel v)
{
   SELF(ErrorCode, level);
   ERRORCODE_SET_level(self->impl, v);
   return v;
}

/*regSet*/inline ErrorCode::level_Prop & ErrorCode::level_Prop::operator= (ErrorCode::level_Prop & prop)
{
   SELF(ErrorCode, level);
   /*0H*/ErrorLevel v = prop;
   ERRORCODE_SET_level(self->impl, v);
   return prop;
}
/*regGet*/inline ErrorCode::level_Prop::operator /*0I*/ErrorLevel () const
{
   SELF(ErrorCode, level);
   return (ErrorLevel)ERRORCODE_level(self->impl);
}

// member accessors: ErrorCode::code
// (bits::uint)

/*nstSet*/inline /*0H*/uint ErrorCode::code_Prop::operator= (/*0H*/uint v)
{
   SELF(ErrorCode, code);
   ERRORCODE_SET_code(self->impl, v);
   return v;
}

/*regSet*/inline ErrorCode::code_Prop & ErrorCode::code_Prop::operator= (ErrorCode::code_Prop & prop)
{
   SELF(ErrorCode, code);
   /*0H*/uint v = prop;
   ERRORCODE_SET_code(self->impl, v);
   return prop;
}
/*regGet*/inline ErrorCode::code_Prop::operator /*0I*/uint () const
{
   SELF(ErrorCode, code);
   return ERRORCODE_code(self->impl);
}
// A (unit:unit)
inline constexpr Feet::operator Meters() const { return Meters(impl); }
inline constexpr Feet::Feet(const Meters & m) : Distance(m.impl) { }
inline constexpr Feet & Feet::operator =(const Meters & m) { impl = m.impl; return *this; }

inline File::File(void * input, void * output = null, bool buffered = (bool)0) : File()
{
   this->input = input;
   this->output = output;
   this->buffered = buffered;
}

inline File::File_close_Functor::FunctionType File::File_close_Functor::operator= (FunctionType func)
{
   SELF(File, close);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_close_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_close_Functor::FunctionType) * size);
   }
   ((File::File_close_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, close)] = func;
   return func;
}
inline void File::File_close_Functor::operator()( )
{
   SELF(File, close);
   File_close(self ? self->impl : (C(File))null);
}
// inline void File::register_close(CPPClass & cl, File::File_close_Functor::FunctionType func)
// {
//    ((File::File_close_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, close)] = func;
// }

inline File::File_closeInput_Functor::FunctionType File::File_closeInput_Functor::operator= (FunctionType func)
{
   SELF(File, closeInput);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_closeInput_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_closeInput_Functor::FunctionType) * size);
   }
   ((File::File_closeInput_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, closeInput)] = func;
   return func;
}
inline void File::File_closeInput_Functor::operator()( )
{
   SELF(File, closeInput);
   File_closeInput(self ? self->impl : (C(File))null);
}
// inline void File::register_closeInput(CPPClass & cl, File::File_closeInput_Functor::FunctionType func)
// {
//    ((File::File_closeInput_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, closeInput)] = func;
// }

inline File::File_closeOutput_Functor::FunctionType File::File_closeOutput_Functor::operator= (FunctionType func)
{
   SELF(File, closeOutput);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_closeOutput_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_closeOutput_Functor::FunctionType) * size);
   }
   ((File::File_closeOutput_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, closeOutput)] = func;
   return func;
}
inline void File::File_closeOutput_Functor::operator()( )
{
   SELF(File, closeOutput);
   File_closeOutput(self ? self->impl : (C(File))null);
}
// inline void File::register_closeOutput(CPPClass & cl, File::File_closeOutput_Functor::FunctionType func)
// {
//    ((File::File_closeOutput_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, closeOutput)] = func;
// }

inline File::File_eof_Functor::FunctionType File::File_eof_Functor::operator= (FunctionType func)
{
   SELF(File, eof_);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_eof_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_eof_Functor::FunctionType) * size);
   }
   ((File::File_eof_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, eof)] = func;
   return func;
}
inline bool File::File_eof_Functor::operator()( )
{
   SELF(File, eof_);
   return (bool)File_eof(self ? self->impl : (C(File))null);
}
// inline void File::register_eof(CPPClass & cl, File::File_eof_Functor::FunctionType func)
// {
//    ((File::File_eof_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, eof)] = func;
// }

inline File::File_getSize_Functor::FunctionType File::File_getSize_Functor::operator= (FunctionType func)
{
   SELF(File, getSize);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_getSize_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_getSize_Functor::FunctionType) * size);
   }
   ((File::File_getSize_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, getSize)] = func;
   return func;
}
inline uint64 File::File_getSize_Functor::operator()( )
{
   SELF(File, getSize);
   return File_getSize(self ? self->impl : (C(File))null);
}
// inline void File::register_getSize(CPPClass & cl, File::File_getSize_Functor::FunctionType func)
// {
//    ((File::File_getSize_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, getSize)] = func;
// }

inline File::File_getc_Functor::FunctionType File::File_getc_Functor::operator= (FunctionType func)
{
   SELF(File, getc);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_getc_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_getc_Functor::FunctionType) * size);
   }
   ((File::File_getc_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, getc)] = func;
   return func;
}
inline bool File::File_getc_Functor::operator()( /*6Fj*/char * ch)
{
   SELF(File, getc);
   return (bool)File_getc(self ? self->impl : (C(File))null, /*7Al*/ch);
}
// inline void File::register_getc(CPPClass & cl, File::File_getc_Functor::FunctionType func)
// {
//    ((File::File_getc_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, getc)] = func;
// }

inline File::File_lock_Functor::FunctionType File::File_lock_Functor::operator= (FunctionType func)
{
   SELF(File, lock);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_lock_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_lock_Functor::FunctionType) * size);
   }
   ((File::File_lock_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, lock)] = func;
   return func;
}
inline bool File::File_lock_Functor::operator()( /*6Fj*/FileLock type, /*6Fj*/uint64 start, /*6Fj*/uint64 length, /*6Fj*/bool wait)
{
   SELF(File, lock);
   return (bool)File_lock(self ? self->impl : (C(File))null, /*7Al*/(C(FileLock))type, /*7Al*/start, /*7Al*/length, /*7Al*/(C(bool))wait);
}
// inline void File::register_lock(CPPClass & cl, File::File_lock_Functor::FunctionType func)
// {
//    ((File::File_lock_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, lock)] = func;
// }

inline File::File_putc_Functor::FunctionType File::File_putc_Functor::operator= (FunctionType func)
{
   SELF(File, putc);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_putc_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_putc_Functor::FunctionType) * size);
   }
   ((File::File_putc_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, putc)] = func;
   return func;
}
inline bool File::File_putc_Functor::operator()( /*6Fj*/char ch)
{
   SELF(File, putc);
   return (bool)File_putc(self ? self->impl : (C(File))null, /*7Al*/ch);
}
// inline void File::register_putc(CPPClass & cl, File::File_putc_Functor::FunctionType func)
// {
//    ((File::File_putc_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, putc)] = func;
// }

inline File::File_puts_Functor::FunctionType File::File_puts_Functor::operator= (FunctionType func)
{
   SELF(File, puts);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_puts_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_puts_Functor::FunctionType) * size);
   }
   ((File::File_puts_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, puts)] = func;
   return func;
}
inline bool File::File_puts_Functor::operator()( /*6Fj*/const char * string)
{
   SELF(File, puts);
   return (bool)File_puts(self ? self->impl : (C(File))null, /*7Al*/string);
}
// inline void File::register_puts(CPPClass & cl, File::File_puts_Functor::FunctionType func)
// {
//    ((File::File_puts_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, puts)] = func;
// }

inline File::File_read_Functor::FunctionType File::File_read_Functor::operator= (FunctionType func)
{
   SELF(File, read);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_read_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_read_Functor::FunctionType) * size);
   }
   ((File::File_read_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, read)] = func;
   return func;
}
inline uintsize File::File_read_Functor::operator()( /*6Fj*/void * buffer, /*6Fj*/uintsize size, /*6Fj*/uintsize count)
{
   SELF(File, read);
   return File_read(self ? self->impl : (C(File))null, /*7Al*/buffer, /*7Al*/size, /*7Al*/count);
}
// inline void File::register_read(CPPClass & cl, File::File_read_Functor::FunctionType func)
// {
//    ((File::File_read_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, read)] = func;
// }

inline File::File_seek_Functor::FunctionType File::File_seek_Functor::operator= (FunctionType func)
{
   SELF(File, seek);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_seek_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_seek_Functor::FunctionType) * size);
   }
   ((File::File_seek_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, seek)] = func;
   return func;
}
inline bool File::File_seek_Functor::operator()( /*6Fj*/int64 pos, /*6Fj*/FileSeekMode mode)
{
   SELF(File, seek);
   return (bool)File_seek(self ? self->impl : (C(File))null, /*7Al*/pos, /*7Al*/(C(FileSeekMode))mode);
}
// inline void File::register_seek(CPPClass & cl, File::File_seek_Functor::FunctionType func)
// {
//    ((File::File_seek_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, seek)] = func;
// }

inline File::File_tell_Functor::FunctionType File::File_tell_Functor::operator= (FunctionType func)
{
   SELF(File, tell);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_tell_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_tell_Functor::FunctionType) * size);
   }
   ((File::File_tell_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, tell)] = func;
   return func;
}
inline uint64 File::File_tell_Functor::operator()( )
{
   SELF(File, tell);
   return File_tell(self ? self->impl : (C(File))null);
}
// inline void File::register_tell(CPPClass & cl, File::File_tell_Functor::FunctionType func)
// {
//    ((File::File_tell_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, tell)] = func;
// }

inline File::File_truncate_Functor::FunctionType File::File_truncate_Functor::operator= (FunctionType func)
{
   SELF(File, truncate);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_truncate_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_truncate_Functor::FunctionType) * size);
   }
   ((File::File_truncate_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, truncate)] = func;
   return func;
}
inline bool File::File_truncate_Functor::operator()( /*6Fj*/uint64 size)
{
   SELF(File, truncate);
   return (bool)File_truncate(self ? self->impl : (C(File))null, /*7Al*/size);
}
// inline void File::register_truncate(CPPClass & cl, File::File_truncate_Functor::FunctionType func)
// {
//    ((File::File_truncate_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, truncate)] = func;
// }

inline File::File_unlock_Functor::FunctionType File::File_unlock_Functor::operator= (FunctionType func)
{
   SELF(File, unlock);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_unlock_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_unlock_Functor::FunctionType) * size);
   }
   ((File::File_unlock_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, unlock)] = func;
   return func;
}
inline bool File::File_unlock_Functor::operator()( /*6Fj*/uint64 start, /*6Fj*/uint64 length, /*6Fj*/bool wait)
{
   SELF(File, unlock);
   return (bool)File_unlock(self ? self->impl : (C(File))null, /*7Al*/start, /*7Al*/length, /*7Al*/(C(bool))wait);
}
// inline void File::register_unlock(CPPClass & cl, File::File_unlock_Functor::FunctionType func)
// {
//    ((File::File_unlock_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, unlock)] = func;
// }

inline File::File_write_Functor::FunctionType File::File_write_Functor::operator= (FunctionType func)
{
   SELF(File, write);
   if(self->vTbl == File::_cpp_class.vTbl)
   {
      uint size = File::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(File::File_write_Functor::FunctionType, size);
      memcpy(self->vTbl, File::_cpp_class.vTbl, sizeof(File::File_write_Functor::FunctionType) * size);
   }
   ((File::File_write_Functor::FunctionType *)self->vTbl)[M_VTBLID(File, write)] = func;
   return func;
}
inline uintsize File::File_write_Functor::operator()( /*6Fj*/const void * buffer, /*6Fj*/uintsize size, /*6Fj*/uintsize count)
{
   SELF(File, write);
   return File_write(self ? self->impl : (C(File))null, /*7Al*/buffer, /*7Al*/size, /*7Al*/count);
}
// inline void File::register_write(CPPClass & cl, File::File_write_Functor::FunctionType func)
// {
//    ((File::File_write_Functor::FunctionType *)cl.vTbl)[M_VTBLID(File, write)] = func;
// }


inline C(bool) File::copyTo(/*1Ab*/const char * outputFileName)
{
   return File_copyTo(impl, /*5Ge*/outputFileName);
}
inline C(bool) File::copyToFile(/*1Ab*/File & f)
{
   return File_copyToFile(impl, /*5De*/f.impl);
}
inline C(bool) File::flush()
{
   return File_flush(impl);
}
inline double File::getDouble()
{
   return File_getDouble(impl);
}
inline float File::getFloat()
{
   return File_getFloat(impl);
}
inline uint File::getHexValue()
{
   return File_getHexValue(impl);
}
inline C(bool) File::getLine(/*1Ab*/char * s, /*1Ab*/int max)
{
   return File_getLine(impl, /*5Ge*/s, /*5Ge*/max);
}
inline int File::getLineEx(/*1Ab*/char * s, /*1Ab*/int max, /*1Ab*/C(bool) * hasNewLineChar)
{
   return File_getLineEx(impl, /*5Ge*/s, /*5Ge*/max, /*5Ee*/(C(bool) *)hasNewLineChar);
}
inline C(bool) File::getString(/*1Ab*/char * string, /*1Ab*/int max)
{
   return File_getString(impl, /*5Ge*/string, /*5Ge*/max);
}
inline int File::getValue()
{
   return File_getValue(impl);
}
template <typename ...Ts> inline void File::print(/*1Ab*/const Ts&... ts)
{
   std::apply(
      [this](/*1Ab*/auto ...args) { File_print(impl, /*5Ae*/args...); },
      std::tuple_cat(std::make_tuple(classof(ts), vapass(ts))..., std::make_tuple(null))
   );
}
template <typename ...Ts> inline void File::printLn(/*1Ab*/const Ts&... ts)
{
   std::apply(
      [this](/*1Ab*/auto ...args) { File_printLn(impl, /*5Ae*/args...); },
      std::tuple_cat(std::make_tuple(classof(ts), vapass(ts))..., std::make_tuple(null))
   );
}
template<typename... Args> inline int File::_printf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   return File_printf(impl, /*5Ge*/format, /*5Ae*/args...);
}


// property callers: File::input
// (normal::void *)

/*nstSet*/inline /*0H*/void * File::input_Prop::operator= (/*0H*/void * v)
{
   SELF(File, input);
   File_set_input(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline File::input_Prop & File::input_Prop::operator= (File::input_Prop & prop)
{
   SELF(File, input);
   /*0H*/void * v = prop;
   File_set_input(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline File::input_Prop::operator /*0I*/void * () const
{
   SELF(File, input);
   return File_get_input(self ? self->impl : null);
}

// property callers: File::output
// (normal::void *)

/*nstSet*/inline /*0H*/void * File::output_Prop::operator= (/*0H*/void * v)
{
   SELF(File, output);
   File_set_output(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline File::output_Prop & File::output_Prop::operator= (File::output_Prop & prop)
{
   SELF(File, output);
   /*0H*/void * v = prop;
   File_set_output(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline File::output_Prop::operator /*0I*/void * () const
{
   SELF(File, output);
   return File_get_output(self ? self->impl : null);
}

// property callers: File::buffered   // set only
// (normal::enum|uint)

/*nstSet*/inline /*0G*/bool File::buffered_Prop::operator= (/*0G*/bool v)
{
   SELF(File, buffered);
   File_set_buffered(self->impl, (C(bool))v);
   return v;
}


// property callers: File::eof   // get only
// (normal::enum|uint)

/*regGet*/inline File::eof_Prop::operator /*0I*/bool () const
{
   SELF(File, eof);
   return (bool)File_get_eof(self ? self->impl : null);
}



// member accessors: FileAttribs::isFile
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isFile_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isFile);
   FILEATTRIBS_SET_isFile(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isFile_Prop & FileAttribs::isFile_Prop::operator= (FileAttribs::isFile_Prop & prop)
{
   SELF(FileAttribs, isFile);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isFile(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isFile_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isFile);
   return (bool)FILEATTRIBS_isFile(self->impl);
}

// member accessors: FileAttribs::isArchive
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isArchive_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isArchive);
   FILEATTRIBS_SET_isArchive(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isArchive_Prop & FileAttribs::isArchive_Prop::operator= (FileAttribs::isArchive_Prop & prop)
{
   SELF(FileAttribs, isArchive);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isArchive(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isArchive_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isArchive);
   return (bool)FILEATTRIBS_isArchive(self->impl);
}

// member accessors: FileAttribs::isHidden
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isHidden_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isHidden);
   FILEATTRIBS_SET_isHidden(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isHidden_Prop & FileAttribs::isHidden_Prop::operator= (FileAttribs::isHidden_Prop & prop)
{
   SELF(FileAttribs, isHidden);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isHidden(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isHidden_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isHidden);
   return (bool)FILEATTRIBS_isHidden(self->impl);
}

// member accessors: FileAttribs::isReadOnly
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isReadOnly_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isReadOnly);
   FILEATTRIBS_SET_isReadOnly(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isReadOnly_Prop & FileAttribs::isReadOnly_Prop::operator= (FileAttribs::isReadOnly_Prop & prop)
{
   SELF(FileAttribs, isReadOnly);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isReadOnly(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isReadOnly_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isReadOnly);
   return (bool)FILEATTRIBS_isReadOnly(self->impl);
}

// member accessors: FileAttribs::isSystem
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isSystem_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isSystem);
   FILEATTRIBS_SET_isSystem(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isSystem_Prop & FileAttribs::isSystem_Prop::operator= (FileAttribs::isSystem_Prop & prop)
{
   SELF(FileAttribs, isSystem);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isSystem(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isSystem_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isSystem);
   return (bool)FILEATTRIBS_isSystem(self->impl);
}

// member accessors: FileAttribs::isTemporary
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isTemporary_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isTemporary);
   FILEATTRIBS_SET_isTemporary(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isTemporary_Prop & FileAttribs::isTemporary_Prop::operator= (FileAttribs::isTemporary_Prop & prop)
{
   SELF(FileAttribs, isTemporary);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isTemporary(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isTemporary_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isTemporary);
   return (bool)FILEATTRIBS_isTemporary(self->impl);
}

// member accessors: FileAttribs::isDirectory
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isDirectory_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isDirectory);
   FILEATTRIBS_SET_isDirectory(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isDirectory_Prop & FileAttribs::isDirectory_Prop::operator= (FileAttribs::isDirectory_Prop & prop)
{
   SELF(FileAttribs, isDirectory);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isDirectory(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isDirectory_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isDirectory);
   return (bool)FILEATTRIBS_isDirectory(self->impl);
}

// member accessors: FileAttribs::isDrive
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isDrive_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isDrive);
   FILEATTRIBS_SET_isDrive(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isDrive_Prop & FileAttribs::isDrive_Prop::operator= (FileAttribs::isDrive_Prop & prop)
{
   SELF(FileAttribs, isDrive);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isDrive(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isDrive_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isDrive);
   return (bool)FILEATTRIBS_isDrive(self->impl);
}

// member accessors: FileAttribs::isCDROM
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isCDROM_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isCDROM);
   FILEATTRIBS_SET_isCDROM(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isCDROM_Prop & FileAttribs::isCDROM_Prop::operator= (FileAttribs::isCDROM_Prop & prop)
{
   SELF(FileAttribs, isCDROM);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isCDROM(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isCDROM_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isCDROM);
   return (bool)FILEATTRIBS_isCDROM(self->impl);
}

// member accessors: FileAttribs::isRemote
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isRemote_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isRemote);
   FILEATTRIBS_SET_isRemote(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isRemote_Prop & FileAttribs::isRemote_Prop::operator= (FileAttribs::isRemote_Prop & prop)
{
   SELF(FileAttribs, isRemote);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isRemote(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isRemote_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isRemote);
   return (bool)FILEATTRIBS_isRemote(self->impl);
}

// member accessors: FileAttribs::isRemovable
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isRemovable_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isRemovable);
   FILEATTRIBS_SET_isRemovable(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isRemovable_Prop & FileAttribs::isRemovable_Prop::operator= (FileAttribs::isRemovable_Prop & prop)
{
   SELF(FileAttribs, isRemovable);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isRemovable(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isRemovable_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isRemovable);
   return (bool)FILEATTRIBS_isRemovable(self->impl);
}

// member accessors: FileAttribs::isServer
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isServer_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isServer);
   FILEATTRIBS_SET_isServer(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isServer_Prop & FileAttribs::isServer_Prop::operator= (FileAttribs::isServer_Prop & prop)
{
   SELF(FileAttribs, isServer);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isServer(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isServer_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isServer);
   return (bool)FILEATTRIBS_isServer(self->impl);
}

// member accessors: FileAttribs::isShare
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileAttribs::isShare_Prop::operator= (/*0H*/bool v)
{
   SELF(FileAttribs, isShare);
   FILEATTRIBS_SET_isShare(self->impl, v);
   return v;
}

/*regSet*/inline FileAttribs::isShare_Prop & FileAttribs::isShare_Prop::operator= (FileAttribs::isShare_Prop & prop)
{
   SELF(FileAttribs, isShare);
   /*0H*/bool v = prop;
   FILEATTRIBS_SET_isShare(self->impl, v);
   return prop;
}
/*regGet*/inline FileAttribs::isShare_Prop::operator /*0I*/bool () const
{
   SELF(FileAttribs, isShare);
   return (bool)FILEATTRIBS_isShare(self->impl);
}



// member accessors: FileChange::created
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileChange::created_Prop::operator= (/*0H*/bool v)
{
   SELF(FileChange, created);
   FILECHANGE_SET_created(self->impl, v);
   return v;
}

/*regSet*/inline FileChange::created_Prop & FileChange::created_Prop::operator= (FileChange::created_Prop & prop)
{
   SELF(FileChange, created);
   /*0H*/bool v = prop;
   FILECHANGE_SET_created(self->impl, v);
   return prop;
}
/*regGet*/inline FileChange::created_Prop::operator /*0I*/bool () const
{
   SELF(FileChange, created);
   return (bool)FILECHANGE_created(self->impl);
}

// member accessors: FileChange::renamed
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileChange::renamed_Prop::operator= (/*0H*/bool v)
{
   SELF(FileChange, renamed);
   FILECHANGE_SET_renamed(self->impl, v);
   return v;
}

/*regSet*/inline FileChange::renamed_Prop & FileChange::renamed_Prop::operator= (FileChange::renamed_Prop & prop)
{
   SELF(FileChange, renamed);
   /*0H*/bool v = prop;
   FILECHANGE_SET_renamed(self->impl, v);
   return prop;
}
/*regGet*/inline FileChange::renamed_Prop::operator /*0I*/bool () const
{
   SELF(FileChange, renamed);
   return (bool)FILECHANGE_renamed(self->impl);
}

// member accessors: FileChange::modified
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileChange::modified_Prop::operator= (/*0H*/bool v)
{
   SELF(FileChange, modified);
   FILECHANGE_SET_modified(self->impl, v);
   return v;
}

/*regSet*/inline FileChange::modified_Prop & FileChange::modified_Prop::operator= (FileChange::modified_Prop & prop)
{
   SELF(FileChange, modified);
   /*0H*/bool v = prop;
   FILECHANGE_SET_modified(self->impl, v);
   return prop;
}
/*regGet*/inline FileChange::modified_Prop::operator /*0I*/bool () const
{
   SELF(FileChange, modified);
   return (bool)FILECHANGE_modified(self->impl);
}

// member accessors: FileChange::deleted
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileChange::deleted_Prop::operator= (/*0H*/bool v)
{
   SELF(FileChange, deleted);
   FILECHANGE_SET_deleted(self->impl, v);
   return v;
}

/*regSet*/inline FileChange::deleted_Prop & FileChange::deleted_Prop::operator= (FileChange::deleted_Prop & prop)
{
   SELF(FileChange, deleted);
   /*0H*/bool v = prop;
   FILECHANGE_SET_deleted(self->impl, v);
   return prop;
}
/*regGet*/inline FileChange::deleted_Prop::operator /*0I*/bool () const
{
   SELF(FileChange, deleted);
   return (bool)FILECHANGE_deleted(self->impl);
}

// member accessors: FileChange::attribs
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool FileChange::attribs_Prop::operator= (/*0H*/bool v)
{
   SELF(FileChange, attribs);
   FILECHANGE_SET_attribs(self->impl, v);
   return v;
}

/*regSet*/inline FileChange::attribs_Prop & FileChange::attribs_Prop::operator= (FileChange::attribs_Prop & prop)
{
   SELF(FileChange, attribs);
   /*0H*/bool v = prop;
   FILECHANGE_SET_attribs(self->impl, v);
   return prop;
}
/*regGet*/inline FileChange::attribs_Prop::operator /*0I*/bool () const
{
   SELF(FileChange, attribs);
   return (bool)FILECHANGE_attribs(self->impl);
}

inline FileListing::FileListing(const char * directory, const char * extensions = null)
{
   impl.directory = directory;
   impl.extensions = extensions;
}


inline C(bool) FileListing::find()
{
   return FileListing_find(&impl);
}
inline void FileListing::stop()
{
   FileListing_stop(&impl);
}


// property callers: FileListing::name   // get only
// (struct::const char *)

/*regGet*/inline FileListing::name_Prop::operator /*0I*/const char * () const
{
   SELF(FileListing, name);
   return FileListing_get_name(self ? &self->impl : null);
}

// property callers: FileListing::path   // get only
// (struct::const char *)

/*regGet*/inline FileListing::path_Prop::operator /*0I*/const char * () const
{
   SELF(FileListing, path);
   return FileListing_get_path(self ? &self->impl : null);
}

// property callers: FileListing::stats   // get only
// (struct::struct)

/*regGet*/inline FileListing::stats_Prop::operator /*0I*/FileStats () const
{
   SELF(FileListing, stats);
   FileStats value;FileListing_get_stats(&self->impl, &value.impl);
   return value;
}


// member accessors: FileListing::directory
// (struct::const char *)

/*nstSet*/inline /*0H*/const char * FileListing::directory_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileListing, directory);
   self->impl.directory = v;
   return v;
}

/*regSet*/inline FileListing::directory_Prop & FileListing::directory_Prop::operator= (FileListing::directory_Prop & prop)
{
   SELF(FileListing, directory);
   /*0H*/const char * v = prop;
   self->impl.directory = v;
   return prop;
}
/*regGet*/inline FileListing::directory_Prop::operator /*0I*/const char * () const
{
   SELF(FileListing, directory);
   return self ? ((C(FileListing) *)&self->impl)->directory : null;
}

// member accessors: FileListing::extensions
// (struct::const char *)

/*nstSet*/inline /*0H*/const char * FileListing::extensions_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileListing, extensions);
   self->impl.extensions = v;
   return v;
}

/*regSet*/inline FileListing::extensions_Prop & FileListing::extensions_Prop::operator= (FileListing::extensions_Prop & prop)
{
   SELF(FileListing, extensions);
   /*0H*/const char * v = prop;
   self->impl.extensions = v;
   return prop;
}
/*regGet*/inline FileListing::extensions_Prop::operator /*0I*/const char * () const
{
   SELF(FileListing, extensions);
   return self ? ((C(FileListing) *)&self->impl)->extensions : null;
}

inline FileMonitor::FileMonitor(void * userData, FileChange fileChange = FileChange(), const char * fileName = null, const char * directoryName = null) : FileMonitor()
{
   this->userData = userData;
   this->fileChange = fileChange;
   this->fileName = fileName;
   this->directoryName = directoryName;
}

inline FileMonitor::FileMonitor_onDirNotify_Functor::FunctionType FileMonitor::FileMonitor_onDirNotify_Functor::operator= (FunctionType func)
{
   SELF(FileMonitor, onDirNotify);
   if(self->vTbl == FileMonitor::_cpp_class.vTbl)
   {
      uint size = FileMonitor::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FileMonitor::FileMonitor_onDirNotify_Functor::FunctionType, size);
      memcpy(self->vTbl, FileMonitor::_cpp_class.vTbl, sizeof(FileMonitor::FileMonitor_onDirNotify_Functor::FunctionType) * size);
   }
   ((FileMonitor::FileMonitor_onDirNotify_Functor::FunctionType *)self->vTbl)[M_VTBLID(FileMonitor, onDirNotify)] = func;
   return func;
}
inline bool FileMonitor::FileMonitor_onDirNotify_Functor::operator()(/*6Fk*/any_object o_ , /*6Fj*/FileChange action, /*6Fj*/const char * fileName, /*6Fj*/const char * param)
{
   SELF(FileMonitor, onDirNotify);
   return (bool)FileMonitor_onDirNotify(self ? self->impl : (C(FileMonitor))null, o_, /*7Al*/(C(FileChange))action, /*7Al*/fileName, /*7Al*/param);
}
// inline void FileMonitor::register_onDirNotify(CPPClass & cl, FileMonitor::FileMonitor_onDirNotify_Functor::FunctionType func)
// {
//    ((FileMonitor::FileMonitor_onDirNotify_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FileMonitor, onDirNotify)] = func;
// }

inline FileMonitor::FileMonitor_onFileNotify_Functor::FunctionType FileMonitor::FileMonitor_onFileNotify_Functor::operator= (FunctionType func)
{
   SELF(FileMonitor, onFileNotify);
   if(self->vTbl == FileMonitor::_cpp_class.vTbl)
   {
      uint size = FileMonitor::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(FileMonitor::FileMonitor_onFileNotify_Functor::FunctionType, size);
      memcpy(self->vTbl, FileMonitor::_cpp_class.vTbl, sizeof(FileMonitor::FileMonitor_onFileNotify_Functor::FunctionType) * size);
   }
   ((FileMonitor::FileMonitor_onFileNotify_Functor::FunctionType *)self->vTbl)[M_VTBLID(FileMonitor, onFileNotify)] = func;
   return func;
}
inline bool FileMonitor::FileMonitor_onFileNotify_Functor::operator()(/*6Fk*/any_object o_ , /*6Fj*/FileChange action, /*6Fj*/const char * param)
{
   SELF(FileMonitor, onFileNotify);
   return (bool)FileMonitor_onFileNotify(self ? self->impl : (C(FileMonitor))null, o_, /*7Al*/(C(FileChange))action, /*7Al*/param);
}
// inline void FileMonitor::register_onFileNotify(CPPClass & cl, FileMonitor::FileMonitor_onFileNotify_Functor::FunctionType func)
// {
//    ((FileMonitor::FileMonitor_onFileNotify_Functor::FunctionType *)cl.vTbl)[M_VTBLID(FileMonitor, onFileNotify)] = func;
// }


inline void FileMonitor::startMonitoring()
{
   FileMonitor_startMonitoring(impl);
}
inline void FileMonitor::stopMonitoring()
{
   FileMonitor_stopMonitoring(impl);
}


// property callers: FileMonitor::userData   // set only
// (normal::void *)

/*nstSet*/inline /*0G*/void * FileMonitor::userData_Prop::operator= (/*0G*/void * v)
{
   SELF(FileMonitor, userData);
   FileMonitor_set_userData(self->impl, v);
   return v;
}


// property callers: FileMonitor::fileChange   // set only
// (normal::bits|unsigned int)

/*nstSet*/inline /*0G*/FileChange FileMonitor::fileChange_Prop::operator= (/*0G*/FileChange v)
{
   SELF(FileMonitor, fileChange);
   FileMonitor_set_fileChange(self->impl, v);
   return v;
}


// property callers: FileMonitor::fileName
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * FileMonitor::fileName_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileMonitor, fileName);
   FileMonitor_set_fileName(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileMonitor::fileName_Prop & FileMonitor::fileName_Prop::operator= (FileMonitor::fileName_Prop & prop)
{
   SELF(FileMonitor, fileName);
   /*0H*/const char * v = prop;
   FileMonitor_set_fileName(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileMonitor::fileName_Prop::operator /*0I*/const char * () const
{
   SELF(FileMonitor, fileName);
   return FileMonitor_get_fileName(self ? self->impl : null);
}

// property callers: FileMonitor::directoryName
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * FileMonitor::directoryName_Prop::operator= (/*0H*/const char * v)
{
   SELF(FileMonitor, directoryName);
   FileMonitor_set_directoryName(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline FileMonitor::directoryName_Prop & FileMonitor::directoryName_Prop::operator= (FileMonitor::directoryName_Prop & prop)
{
   SELF(FileMonitor, directoryName);
   /*0H*/const char * v = prop;
   FileMonitor_set_directoryName(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline FileMonitor::directoryName_Prop::operator /*0I*/const char * () const
{
   SELF(FileMonitor, directoryName);
   return FileMonitor_get_directoryName(self ? self->impl : null);
}

inline FileStats::FileStats(FileAttribs attribs, uint64 size = 0, SecSince1970 accessed = 0, SecSince1970 modified = 0, SecSince1970 created = 0)
{
   impl.attribs = attribs;
   impl.size = size;
   impl.accessed = accessed.impl;
   impl.modified = modified.impl;
   impl.created = created.impl;
}



// member accessors: FileStats::attribs
// (struct::bits|uint)

/*nstSet*/inline /*0H*/FileAttribs FileStats::attribs_Prop::operator= (/*0H*/FileAttribs v)
{
   SELF(FileStats, attribs);
   self->impl.attribs = v;
   return v;
}

/*regSet*/inline FileStats::attribs_Prop & FileStats::attribs_Prop::operator= (FileStats::attribs_Prop & prop)
{
   SELF(FileStats, attribs);
   /*0H*/FileAttribs v = prop;
   self->impl.attribs = v;
   return prop;
}
/*regGet*/inline FileStats::attribs_Prop::operator /*0I*/FileAttribs () const
{
   SELF(FileStats, attribs);
   return self ? FileAttribs(((C(FileStats) *)&self->impl)->attribs) : FileAttribs();
}

// member accessors: FileStats::size
// (struct::uint64)

/*nstSet*/inline /*0H*/uint64 FileStats::size_Prop::operator= (/*0H*/uint64 v)
{
   SELF(FileStats, size);
   self->impl.size = v;
   return v;
}

/*regSet*/inline FileStats::size_Prop & FileStats::size_Prop::operator= (FileStats::size_Prop & prop)
{
   SELF(FileStats, size);
   /*0H*/uint64 v = prop;
   self->impl.size = v;
   return prop;
}
/*regGet*/inline FileStats::size_Prop::operator /*0I*/uint64 () const
{
   SELF(FileStats, size);
   return self ? ((C(FileStats) *)&self->impl)->size : 0;
}

// member accessors: FileStats::accessed
// (struct::unit|int64)

/*nstSet*/inline /*0H*/SecSince1970 FileStats::accessed_Prop::operator= (/*0H*/SecSince1970 v)
{
   SELF(FileStats, accessed);
   self->impl.accessed = (int64)v.impl;
   return v;
}

/*regSet*/inline FileStats::accessed_Prop & FileStats::accessed_Prop::operator= (FileStats::accessed_Prop & prop)
{
   SELF(FileStats, accessed);
   /*0H*/SecSince1970 v = prop;
   self->impl.accessed = (int64)v.impl;
   return prop;
}
/*regGet*/inline FileStats::accessed_Prop::operator /*0I*/SecSince1970 () const
{
   SELF(FileStats, accessed);
   return SecSince1970(self->impl.accessed);
}
/*regGet*/inline FileStats::accessed_Prop::operator /*0J*/C(SecSince1970) () const
{
   SELF(FileStats, accessed);
   return SecSince1970(self->accessed);
}

// member accessors: FileStats::modified
// (struct::unit|int64)

/*nstSet*/inline /*0H*/SecSince1970 FileStats::modified_Prop::operator= (/*0H*/SecSince1970 v)
{
   SELF(FileStats, modified);
   self->impl.modified = (int64)v.impl;
   return v;
}

/*regSet*/inline FileStats::modified_Prop & FileStats::modified_Prop::operator= (FileStats::modified_Prop & prop)
{
   SELF(FileStats, modified);
   /*0H*/SecSince1970 v = prop;
   self->impl.modified = (int64)v.impl;
   return prop;
}
/*regGet*/inline FileStats::modified_Prop::operator /*0I*/SecSince1970 () const
{
   SELF(FileStats, modified);
   return SecSince1970(self->impl.modified);
}
/*regGet*/inline FileStats::modified_Prop::operator /*0J*/C(SecSince1970) () const
{
   SELF(FileStats, modified);
   return SecSince1970(self->modified);
}

// member accessors: FileStats::created
// (struct::unit|int64)

/*nstSet*/inline /*0H*/SecSince1970 FileStats::created_Prop::operator= (/*0H*/SecSince1970 v)
{
   SELF(FileStats, created);
   self->impl.created = (int64)v.impl;
   return v;
}

/*regSet*/inline FileStats::created_Prop & FileStats::created_Prop::operator= (FileStats::created_Prop & prop)
{
   SELF(FileStats, created);
   /*0H*/SecSince1970 v = prop;
   self->impl.created = (int64)v.impl;
   return prop;
}
/*regGet*/inline FileStats::created_Prop::operator /*0I*/SecSince1970 () const
{
   SELF(FileStats, created);
   return SecSince1970(self->impl.created);
}
/*regGet*/inline FileStats::created_Prop::operator /*0J*/C(SecSince1970) () const
{
   SELF(FileStats, created);
   return SecSince1970(self->created);
}


inline C(bool) GlobalAppSettings::getGlobalValue(/*1Ab*/const char * section, /*1Ab*/const char * name, /*1Ab*/GlobalSettingType type, /*1Ab*/void * value)
{
   return GlobalAppSettings_getGlobalValue(impl, /*5Ge*/section, /*5Ge*/name, /*5Ee*/(C(GlobalSettingType))type, /*5Ge*/value);
}
inline C(bool) GlobalAppSettings::putGlobalValue(/*1Ab*/const char * section, /*1Ab*/const char * name, /*1Ab*/GlobalSettingType type, /*1Ab*/const void * value)
{
   return GlobalAppSettings_putGlobalValue(impl, /*5Ge*/section, /*5Ge*/name, /*5Ee*/(C(GlobalSettingType))type, /*5Ge*/value);
}

inline GlobalSettings::GlobalSettings(const char * settingsName, const char * settingsExtension = null, const char * settingsDirectory = null, const char * settingsLocation = null, const char * settingsFilePath = null, bool allowDefaultLocations = (bool)0, bool allUsers = (bool)0, bool portable = (bool)0, /*CT-D*/constString driver = 0) : GlobalSettings()
{
   this->settingsName = settingsName;
   this->settingsExtension = settingsExtension;
   this->settingsDirectory = settingsDirectory;
   this->settingsLocation = settingsLocation;
   this->settingsFilePath = settingsFilePath;
   this->allowDefaultLocations = allowDefaultLocations;
   this->allUsers = allUsers;
   this->portable = portable;
   this->driver = driver;
}

inline GlobalSettings::GlobalSettings_load_Functor::FunctionType GlobalSettings::GlobalSettings_load_Functor::operator= (FunctionType func)
{
   SELF(GlobalSettings, load);
   if(self->vTbl == GlobalSettings::_cpp_class.vTbl)
   {
      uint size = GlobalSettings::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GlobalSettings::GlobalSettings_load_Functor::FunctionType, size);
      memcpy(self->vTbl, GlobalSettings::_cpp_class.vTbl, sizeof(GlobalSettings::GlobalSettings_load_Functor::FunctionType) * size);
   }
   ((GlobalSettings::GlobalSettings_load_Functor::FunctionType *)self->vTbl)[M_VTBLID(GlobalSettings, load)] = func;
   return func;
}
inline SettingsIOResult GlobalSettings::GlobalSettings_load_Functor::operator()( )
{
   SELF(GlobalSettings, load);
   return (SettingsIOResult)GlobalSettings_load(self ? self->impl : (C(GlobalSettings))null);
}
// inline void GlobalSettings::register_load(CPPClass & cl, GlobalSettings::GlobalSettings_load_Functor::FunctionType func)
// {
//    ((GlobalSettings::GlobalSettings_load_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GlobalSettings, load)] = func;
// }

inline GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::FunctionType GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::operator= (FunctionType func)
{
   SELF(GlobalSettings, onAskReloadSettings);
   if(self->vTbl == GlobalSettings::_cpp_class.vTbl)
   {
      uint size = GlobalSettings::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::FunctionType, size);
      memcpy(self->vTbl, GlobalSettings::_cpp_class.vTbl, sizeof(GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::FunctionType) * size);
   }
   ((GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::FunctionType *)self->vTbl)[M_VTBLID(GlobalSettings, onAskReloadSettings)] = func;
   return func;
}
inline void GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::operator()( )
{
   SELF(GlobalSettings, onAskReloadSettings);
   GlobalSettings_onAskReloadSettings(self ? self->impl : (C(GlobalSettings))null);
}
// inline void GlobalSettings::register_onAskReloadSettings(CPPClass & cl, GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::FunctionType func)
// {
//    ((GlobalSettings::GlobalSettings_onAskReloadSettings_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GlobalSettings, onAskReloadSettings)] = func;
// }

inline GlobalSettings::GlobalSettings_save_Functor::FunctionType GlobalSettings::GlobalSettings_save_Functor::operator= (FunctionType func)
{
   SELF(GlobalSettings, save);
   if(self->vTbl == GlobalSettings::_cpp_class.vTbl)
   {
      uint size = GlobalSettings::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GlobalSettings::GlobalSettings_save_Functor::FunctionType, size);
      memcpy(self->vTbl, GlobalSettings::_cpp_class.vTbl, sizeof(GlobalSettings::GlobalSettings_save_Functor::FunctionType) * size);
   }
   ((GlobalSettings::GlobalSettings_save_Functor::FunctionType *)self->vTbl)[M_VTBLID(GlobalSettings, save)] = func;
   return func;
}
inline SettingsIOResult GlobalSettings::GlobalSettings_save_Functor::operator()( )
{
   SELF(GlobalSettings, save);
   return (SettingsIOResult)GlobalSettings_save(self ? self->impl : (C(GlobalSettings))null);
}
// inline void GlobalSettings::register_save(CPPClass & cl, GlobalSettings::GlobalSettings_save_Functor::FunctionType func)
// {
//    ((GlobalSettings::GlobalSettings_save_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GlobalSettings, save)] = func;
// }


inline void GlobalSettings::close()
{
   GlobalSettings_close(impl);
}
inline void GlobalSettings::closeAndMonitor()
{
   GlobalSettings_closeAndMonitor(impl);
}
inline C(bool) GlobalSettings::openAndLock(/*1Ab*/FileSize * fileSize)
{
   return GlobalSettings_openAndLock(impl, /*5Ee*/(C(FileSize) *)fileSize);
}


// property callers: GlobalSettings::settingsName
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GlobalSettings::settingsName_Prop::operator= (/*0H*/const char * v)
{
   SELF(GlobalSettings, settingsName);
   GlobalSettings_set_settingsName(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GlobalSettings::settingsName_Prop & GlobalSettings::settingsName_Prop::operator= (GlobalSettings::settingsName_Prop & prop)
{
   SELF(GlobalSettings, settingsName);
   /*0H*/const char * v = prop;
   GlobalSettings_set_settingsName(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GlobalSettings::settingsName_Prop::operator /*0I*/const char * () const
{
   SELF(GlobalSettings, settingsName);
   return GlobalSettings_get_settingsName(self ? self->impl : null);
}

// property callers: GlobalSettings::settingsExtension
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GlobalSettings::settingsExtension_Prop::operator= (/*0H*/const char * v)
{
   SELF(GlobalSettings, settingsExtension);
   GlobalSettings_set_settingsExtension(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GlobalSettings::settingsExtension_Prop & GlobalSettings::settingsExtension_Prop::operator= (GlobalSettings::settingsExtension_Prop & prop)
{
   SELF(GlobalSettings, settingsExtension);
   /*0H*/const char * v = prop;
   GlobalSettings_set_settingsExtension(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GlobalSettings::settingsExtension_Prop::operator /*0I*/const char * () const
{
   SELF(GlobalSettings, settingsExtension);
   return GlobalSettings_get_settingsExtension(self ? self->impl : null);
}

// property callers: GlobalSettings::settingsDirectory
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GlobalSettings::settingsDirectory_Prop::operator= (/*0H*/const char * v)
{
   SELF(GlobalSettings, settingsDirectory);
   GlobalSettings_set_settingsDirectory(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GlobalSettings::settingsDirectory_Prop & GlobalSettings::settingsDirectory_Prop::operator= (GlobalSettings::settingsDirectory_Prop & prop)
{
   SELF(GlobalSettings, settingsDirectory);
   /*0H*/const char * v = prop;
   GlobalSettings_set_settingsDirectory(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GlobalSettings::settingsDirectory_Prop::operator /*0I*/const char * () const
{
   SELF(GlobalSettings, settingsDirectory);
   return GlobalSettings_get_settingsDirectory(self ? self->impl : null);
}

// property callers: GlobalSettings::settingsLocation
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GlobalSettings::settingsLocation_Prop::operator= (/*0H*/const char * v)
{
   SELF(GlobalSettings, settingsLocation);
   GlobalSettings_set_settingsLocation(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GlobalSettings::settingsLocation_Prop & GlobalSettings::settingsLocation_Prop::operator= (GlobalSettings::settingsLocation_Prop & prop)
{
   SELF(GlobalSettings, settingsLocation);
   /*0H*/const char * v = prop;
   GlobalSettings_set_settingsLocation(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GlobalSettings::settingsLocation_Prop::operator /*0I*/const char * () const
{
   SELF(GlobalSettings, settingsLocation);
   return GlobalSettings_get_settingsLocation(self ? self->impl : null);
}

// property callers: GlobalSettings::settingsFilePath
// (normal::const char *)

/*nstSet*/inline /*0H*/const char * GlobalSettings::settingsFilePath_Prop::operator= (/*0H*/const char * v)
{
   SELF(GlobalSettings, settingsFilePath);
   GlobalSettings_set_settingsFilePath(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GlobalSettings::settingsFilePath_Prop & GlobalSettings::settingsFilePath_Prop::operator= (GlobalSettings::settingsFilePath_Prop & prop)
{
   SELF(GlobalSettings, settingsFilePath);
   /*0H*/const char * v = prop;
   GlobalSettings_set_settingsFilePath(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GlobalSettings::settingsFilePath_Prop::operator /*0I*/const char * () const
{
   SELF(GlobalSettings, settingsFilePath);
   return GlobalSettings_get_settingsFilePath(self ? self->impl : null);
}

// property callers: GlobalSettings::allowDefaultLocations
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool GlobalSettings::allowDefaultLocations_Prop::operator= (/*0H*/bool v)
{
   SELF(GlobalSettings, allowDefaultLocations);
   GlobalSettings_set_allowDefaultLocations(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline GlobalSettings::allowDefaultLocations_Prop & GlobalSettings::allowDefaultLocations_Prop::operator= (GlobalSettings::allowDefaultLocations_Prop & prop)
{
   SELF(GlobalSettings, allowDefaultLocations);
   /*0H*/bool v = prop;
   GlobalSettings_set_allowDefaultLocations(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline GlobalSettings::allowDefaultLocations_Prop::operator /*0I*/bool () const
{
   SELF(GlobalSettings, allowDefaultLocations);
   return (bool)GlobalSettings_get_allowDefaultLocations(self ? self->impl : null);
}

// property callers: GlobalSettings::allUsers
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool GlobalSettings::allUsers_Prop::operator= (/*0H*/bool v)
{
   SELF(GlobalSettings, allUsers);
   GlobalSettings_set_allUsers(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline GlobalSettings::allUsers_Prop & GlobalSettings::allUsers_Prop::operator= (GlobalSettings::allUsers_Prop & prop)
{
   SELF(GlobalSettings, allUsers);
   /*0H*/bool v = prop;
   GlobalSettings_set_allUsers(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline GlobalSettings::allUsers_Prop::operator /*0I*/bool () const
{
   SELF(GlobalSettings, allUsers);
   return (bool)GlobalSettings_get_allUsers(self ? self->impl : null);
}

// property callers: GlobalSettings::portable
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool GlobalSettings::portable_Prop::operator= (/*0H*/bool v)
{
   SELF(GlobalSettings, portable);
   GlobalSettings_set_portable(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline GlobalSettings::portable_Prop & GlobalSettings::portable_Prop::operator= (GlobalSettings::portable_Prop & prop)
{
   SELF(GlobalSettings, portable);
   /*0H*/bool v = prop;
   GlobalSettings_set_portable(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline GlobalSettings::portable_Prop::operator /*0I*/bool () const
{
   SELF(GlobalSettings, portable);
   return (bool)GlobalSettings_get_portable(self ? self->impl : null);
}

// property callers: GlobalSettings::driver
// (normal::string)

/*nstSet*/inline /*0H*//*CT-D*/constString GlobalSettings::driver_Prop::operator= (/*0H*//*CT-D*/constString v)
{
   SELF(GlobalSettings, driver);
   GlobalSettings_set_driver(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline GlobalSettings::driver_Prop & GlobalSettings::driver_Prop::operator= (GlobalSettings::driver_Prop & prop)
{
   SELF(GlobalSettings, driver);
   /*0H*//*CT-D*/constString v = prop;
   GlobalSettings_set_driver(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline GlobalSettings::driver_Prop::operator /*0I*//*CT-D*/constString () const
{
   SELF(GlobalSettings, driver);
   return GlobalSettings_get_driver(self ? self->impl : null);
}

// property callers: GlobalSettings::isGlobalPath   // get only
// (normal::enum|uint)

/*regGet*/inline GlobalSettings::isGlobalPath_Prop::operator /*0I*/bool () const
{
   SELF(GlobalSettings, isGlobalPath);
   return (bool)GlobalSettings_get_isGlobalPath(self ? self->impl : null);
}


// member accessors: GlobalSettings::data
// (normal::normal)

/*nstSet*/inline /*0H*/GlobalSettingsData GlobalSettings::data_Prop::operator= (/*0H*/GlobalSettingsData v)
{
   SELF(GlobalSettings, data);
   IPTR(self->impl, GlobalSettings)->data = v.impl;
   return v;
}

/*regSet*/inline GlobalSettings::data_Prop & GlobalSettings::data_Prop::operator= (GlobalSettings::data_Prop & prop)
{
   SELF(GlobalSettings, data);
   /*0H*/GlobalSettingsData v = prop;
   IPTR(self->impl, GlobalSettings)->data = v.impl;
   return prop;
}
/*regGet*/inline GlobalSettings::data_Prop::operator /*0I*/GlobalSettingsData () const
{
   SELF(GlobalSettings, data);
   GlobalSettingsData value(IPTR(self->impl, GlobalSettings)->data, GlobalSettings::_cpp_class);
   return value;
}

// member accessors: GlobalSettings::dataOwner
// (normal::normal)

/*nstSet*/inline /*0H*/C(GlobalSettingsData)* GlobalSettings::dataOwner_Prop::operator= (/*0H*/C(GlobalSettingsData)* v)
{
   SELF(GlobalSettings, dataOwner);
   IPTR(self->impl, GlobalSettings)->dataOwner = v;
   return v;
}

/*regSet*/inline GlobalSettings::dataOwner_Prop & GlobalSettings::dataOwner_Prop::operator= (GlobalSettings::dataOwner_Prop & prop)
{
   SELF(GlobalSettings, dataOwner);
   /*0H*/C(GlobalSettingsData)* v = prop;
   IPTR(self->impl, GlobalSettings)->dataOwner = v;
   return prop;
}
/*regGet*/inline GlobalSettings::dataOwner_Prop::operator /*0I*/C(GlobalSettingsData)* () const
{
   SELF(GlobalSettings, dataOwner);
   return self ? IPTR(self->impl, GlobalSettings)->dataOwner : null;
}


inline GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::FunctionType GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::operator= (FunctionType func)
{
   SELF(GlobalSettingsDriver, load);
   if(self->vTbl == GlobalSettingsDriver::_cpp_class.vTbl)
   {
      uint size = GlobalSettingsDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::FunctionType, size);
      memcpy(self->vTbl, GlobalSettingsDriver::_cpp_class.vTbl, sizeof(GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::FunctionType) * size);
   }
   ((GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::FunctionType *)self->vTbl)[M_VTBLID(GlobalSettingsDriver, load)] = func;
   return func;
}
inline SettingsIOResult GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::operator()( /*6Fj*/File & f, /*6Fj*/GlobalSettings & globalSettings)
{
   SELF(GlobalSettingsDriver, load);
   return (SettingsIOResult)GlobalSettingsDriver_load(self ? self->impl : (C(GlobalSettingsDriver))null, /*7Al*/f.impl, /*7Al*/globalSettings.impl);
}
// inline void GlobalSettingsDriver::register_load(CPPClass & cl, GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::FunctionType func)
// {
//    ((GlobalSettingsDriver::GlobalSettingsDriver_load_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GlobalSettingsDriver, load)] = func;
// }

inline GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::FunctionType GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::operator= (FunctionType func)
{
   SELF(GlobalSettingsDriver, save);
   if(self->vTbl == GlobalSettingsDriver::_cpp_class.vTbl)
   {
      uint size = GlobalSettingsDriver::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::FunctionType, size);
      memcpy(self->vTbl, GlobalSettingsDriver::_cpp_class.vTbl, sizeof(GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::FunctionType) * size);
   }
   ((GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::FunctionType *)self->vTbl)[M_VTBLID(GlobalSettingsDriver, save)] = func;
   return func;
}
inline SettingsIOResult GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::operator()( /*6Fj*/File & f, /*6Fj*/GlobalSettings & globalSettings)
{
   SELF(GlobalSettingsDriver, save);
   return (SettingsIOResult)GlobalSettingsDriver_save(self ? self->impl : (C(GlobalSettingsDriver))null, /*7Al*/f.impl, /*7Al*/globalSettings.impl);
}
// inline void GlobalSettingsDriver::register_save(CPPClass & cl, GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::FunctionType func)
// {
//    ((GlobalSettingsDriver::GlobalSettingsDriver_save_Functor::FunctionType *)cl.vTbl)[M_VTBLID(GlobalSettingsDriver, save)] = func;
// }




inline C(JSONResult) JSONParser::getObject(/*1Ab*/Class objectType, /*1Ab*/void ** object)
{
   return JSONParser_getObject(impl, /*5De*/objectType.impl, /*5Ge*/object);
}


// property callers: JSONParser::debug
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool JSONParser::debug_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONParser, debug);
   JSONParser_set_debug(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline JSONParser::debug_Prop & JSONParser::debug_Prop::operator= (JSONParser::debug_Prop & prop)
{
   SELF(JSONParser, debug);
   /*0H*/bool v = prop;
   JSONParser_set_debug(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline JSONParser::debug_Prop::operator /*0I*/bool () const
{
   SELF(JSONParser, debug);
   return (bool)JSONParser_get_debug(self ? self->impl : null);
}

// property callers: JSONParser::warnings
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool JSONParser::warnings_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONParser, warnings);
   JSONParser_set_warnings(self ? self->impl : null, (C(bool))v);
   return v;
}

/*regSet*/inline JSONParser::warnings_Prop & JSONParser::warnings_Prop::operator= (JSONParser::warnings_Prop & prop)
{
   SELF(JSONParser, warnings);
   /*0H*/bool v = prop;
   JSONParser_set_warnings(self ? self->impl : null, (C(bool))v);
   return prop;
}
/*regGet*/inline JSONParser::warnings_Prop::operator /*0I*/bool () const
{
   SELF(JSONParser, warnings);
   return (bool)JSONParser_get_warnings(self ? self->impl : null);
}


// member accessors: JSONParser::f
// (normal::normal)

/*nstSet*/inline /*0H*/File JSONParser::f_Prop::operator= (/*0H*/File v)
{
   SELF(JSONParser, f);
   IPTR(self->impl, JSONParser)->f = v.impl;
   return v;
}

/*regSet*/inline JSONParser::f_Prop & JSONParser::f_Prop::operator= (JSONParser::f_Prop & prop)
{
   SELF(JSONParser, f);
   /*0H*/File v = prop;
   IPTR(self->impl, JSONParser)->f = v.impl;
   return prop;
}
/*regGet*/inline JSONParser::f_Prop::operator /*0I*/File () const
{
   SELF(JSONParser, f);
   File value(IPTR(self->impl, JSONParser)->f, JSONParser::_cpp_class);
   return value;
}

// member accessors: JSONParser::customJsonOptions
// (normal::normal)

/*nstSet*/inline /*0Z*/const OptionsMap & JSONParser::customJsonOptions_Prop::operator= (/*0Z*/const OptionsMap & v)
{
   SELF(JSONParser, customJsonOptions);
   IPTR(self->impl, JSONParser)->customJsonOptions = ((Instance *)&v)->impl;
   return v;
}

/*regSet*/inline JSONParser::customJsonOptions_Prop & JSONParser::customJsonOptions_Prop::operator= (JSONParser::customJsonOptions_Prop & prop)
{
   SELF(JSONParser, customJsonOptions);
   /*0H*/OptionsMap * v = prop;
   Instance * vInstance = (Instance *)v;  // REVIEW: Warning strict aliasing warning if casting directly
   IPTR(self->impl, JSONParser)->customJsonOptions = vInstance->impl;
   return prop;
}
/*regGet*/inline JSONParser::customJsonOptions_Prop::operator /*0I*/OptionsMap * () const
{
   SELF(JSONParser, customJsonOptions);
   C(Instance) i = IPTR(self->impl, JSONParser)->customJsonOptions;
   return BINDINGS_CLASS(i) ? (OptionsMap *)INSTANCEL(i, i->_class) : (OptionsMap *)0;
}



// member accessors: JSONTypeOptions::numbersUseOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::numbersUseOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, numbersUseOGDFS);
   JSONTYPEOPTIONS_SET_numbersUseOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::numbersUseOGDFS_Prop & JSONTypeOptions::numbersUseOGDFS_Prop::operator= (JSONTypeOptions::numbersUseOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, numbersUseOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_numbersUseOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::numbersUseOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, numbersUseOGDFS);
   return (bool)JSONTYPEOPTIONS_numbersUseOGDFS(self->impl);
}

// member accessors: JSONTypeOptions::boolUseOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::boolUseOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, boolUseOGDFS);
   JSONTYPEOPTIONS_SET_boolUseOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::boolUseOGDFS_Prop & JSONTypeOptions::boolUseOGDFS_Prop::operator= (JSONTypeOptions::boolUseOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, boolUseOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_boolUseOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::boolUseOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, boolUseOGDFS);
   return (bool)JSONTYPEOPTIONS_boolUseOGDFS(self->impl);
}

// member accessors: JSONTypeOptions::nullUseOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::nullUseOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, nullUseOGDFS);
   JSONTYPEOPTIONS_SET_nullUseOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::nullUseOGDFS_Prop & JSONTypeOptions::nullUseOGDFS_Prop::operator= (JSONTypeOptions::nullUseOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, nullUseOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_nullUseOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::nullUseOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, nullUseOGDFS);
   return (bool)JSONTYPEOPTIONS_nullUseOGDFS(self->impl);
}

// member accessors: JSONTypeOptions::stringUseOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::stringUseOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, stringUseOGDFS);
   JSONTYPEOPTIONS_SET_stringUseOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::stringUseOGDFS_Prop & JSONTypeOptions::stringUseOGDFS_Prop::operator= (JSONTypeOptions::stringUseOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, stringUseOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_stringUseOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::stringUseOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, stringUseOGDFS);
   return (bool)JSONTYPEOPTIONS_stringUseOGDFS(self->impl);
}

// member accessors: JSONTypeOptions::arrayUseOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::arrayUseOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, arrayUseOGDFS);
   JSONTYPEOPTIONS_SET_arrayUseOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::arrayUseOGDFS_Prop & JSONTypeOptions::arrayUseOGDFS_Prop::operator= (JSONTypeOptions::arrayUseOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, arrayUseOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_arrayUseOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::arrayUseOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, arrayUseOGDFS);
   return (bool)JSONTYPEOPTIONS_arrayUseOGDFS(self->impl);
}

// member accessors: JSONTypeOptions::objectUseOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::objectUseOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, objectUseOGDFS);
   JSONTYPEOPTIONS_SET_objectUseOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::objectUseOGDFS_Prop & JSONTypeOptions::objectUseOGDFS_Prop::operator= (JSONTypeOptions::objectUseOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, objectUseOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_objectUseOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::objectUseOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, objectUseOGDFS);
   return (bool)JSONTYPEOPTIONS_objectUseOGDFS(self->impl);
}

// member accessors: JSONTypeOptions::stripQuotesForOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::stripQuotesForOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, stripQuotesForOGDFS);
   JSONTYPEOPTIONS_SET_stripQuotesForOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::stripQuotesForOGDFS_Prop & JSONTypeOptions::stripQuotesForOGDFS_Prop::operator= (JSONTypeOptions::stripQuotesForOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, stripQuotesForOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_stripQuotesForOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::stripQuotesForOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, stripQuotesForOGDFS);
   return (bool)JSONTYPEOPTIONS_stripQuotesForOGDFS(self->impl);
}

// member accessors: JSONTypeOptions::strictOGDFS
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool JSONTypeOptions::strictOGDFS_Prop::operator= (/*0H*/bool v)
{
   SELF(JSONTypeOptions, strictOGDFS);
   JSONTYPEOPTIONS_SET_strictOGDFS(self->impl, v);
   return v;
}

/*regSet*/inline JSONTypeOptions::strictOGDFS_Prop & JSONTypeOptions::strictOGDFS_Prop::operator= (JSONTypeOptions::strictOGDFS_Prop & prop)
{
   SELF(JSONTypeOptions, strictOGDFS);
   /*0H*/bool v = prop;
   JSONTYPEOPTIONS_SET_strictOGDFS(self->impl, v);
   return prop;
}
/*regGet*/inline JSONTypeOptions::strictOGDFS_Prop::operator /*0I*/bool () const
{
   SELF(JSONTypeOptions, strictOGDFS);
   return (bool)JSONTYPEOPTIONS_strictOGDFS(self->impl);
}
// B (unit:unit)
inline Meters Meters::operator= (Centimeters value) { return Centimeters_to_Meters(value.impl); }
inline Meters::Meters(Centimeters value) { Centimeters_to_Meters(value.impl); }
inline Meters::operator Centimeters() const { return Centimeters_from_Meters(impl); }
// B (unit:unit)
inline Meters Meters::operator= (Feet value) { return Feet_to_Meters(value.impl); }
inline Meters::Meters(Feet value) { Feet_to_Meters(value.impl); }
inline Meters::operator Feet() const { return Feet_from_Meters(impl); }



// member accessors: MoveFileOptions::overwrite
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MoveFileOptions::overwrite_Prop::operator= (/*0H*/bool v)
{
   SELF(MoveFileOptions, overwrite);
   MOVEFILEOPTIONS_SET_overwrite(self->impl, v);
   return v;
}

/*regSet*/inline MoveFileOptions::overwrite_Prop & MoveFileOptions::overwrite_Prop::operator= (MoveFileOptions::overwrite_Prop & prop)
{
   SELF(MoveFileOptions, overwrite);
   /*0H*/bool v = prop;
   MOVEFILEOPTIONS_SET_overwrite(self->impl, v);
   return prop;
}
/*regGet*/inline MoveFileOptions::overwrite_Prop::operator /*0I*/bool () const
{
   SELF(MoveFileOptions, overwrite);
   return (bool)MOVEFILEOPTIONS_overwrite(self->impl);
}

// member accessors: MoveFileOptions::sync
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool MoveFileOptions::sync_Prop::operator= (/*0H*/bool v)
{
   SELF(MoveFileOptions, sync);
   MOVEFILEOPTIONS_SET_sync(self->impl, v);
   return v;
}

/*regSet*/inline MoveFileOptions::sync_Prop & MoveFileOptions::sync_Prop::operator= (MoveFileOptions::sync_Prop & prop)
{
   SELF(MoveFileOptions, sync);
   /*0H*/bool v = prop;
   MOVEFILEOPTIONS_SET_sync(self->impl, v);
   return prop;
}
/*regGet*/inline MoveFileOptions::sync_Prop::operator /*0I*/bool () const
{
   SELF(MoveFileOptions, sync);
   return (bool)MOVEFILEOPTIONS_sync(self->impl);
}




// member accessors: PipeOpenMode::output
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PipeOpenMode::output_Prop::operator= (/*0H*/bool v)
{
   SELF(PipeOpenMode, output);
   PIPEOPENMODE_SET_output(self->impl, v);
   return v;
}

/*regSet*/inline PipeOpenMode::output_Prop & PipeOpenMode::output_Prop::operator= (PipeOpenMode::output_Prop & prop)
{
   SELF(PipeOpenMode, output);
   /*0H*/bool v = prop;
   PIPEOPENMODE_SET_output(self->impl, v);
   return prop;
}
/*regGet*/inline PipeOpenMode::output_Prop::operator /*0I*/bool () const
{
   SELF(PipeOpenMode, output);
   return (bool)PIPEOPENMODE_output(self->impl);
}

// member accessors: PipeOpenMode::error
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PipeOpenMode::error_Prop::operator= (/*0H*/bool v)
{
   SELF(PipeOpenMode, error);
   PIPEOPENMODE_SET_error(self->impl, v);
   return v;
}

/*regSet*/inline PipeOpenMode::error_Prop & PipeOpenMode::error_Prop::operator= (PipeOpenMode::error_Prop & prop)
{
   SELF(PipeOpenMode, error);
   /*0H*/bool v = prop;
   PIPEOPENMODE_SET_error(self->impl, v);
   return prop;
}
/*regGet*/inline PipeOpenMode::error_Prop::operator /*0I*/bool () const
{
   SELF(PipeOpenMode, error);
   return (bool)PIPEOPENMODE_error(self->impl);
}

// member accessors: PipeOpenMode::input
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PipeOpenMode::input_Prop::operator= (/*0H*/bool v)
{
   SELF(PipeOpenMode, input);
   PIPEOPENMODE_SET_input(self->impl, v);
   return v;
}

/*regSet*/inline PipeOpenMode::input_Prop & PipeOpenMode::input_Prop::operator= (PipeOpenMode::input_Prop & prop)
{
   SELF(PipeOpenMode, input);
   /*0H*/bool v = prop;
   PIPEOPENMODE_SET_input(self->impl, v);
   return prop;
}
/*regGet*/inline PipeOpenMode::input_Prop::operator /*0I*/bool () const
{
   SELF(PipeOpenMode, input);
   return (bool)PIPEOPENMODE_input(self->impl);
}

// member accessors: PipeOpenMode::showWindow
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool PipeOpenMode::showWindow_Prop::operator= (/*0H*/bool v)
{
   SELF(PipeOpenMode, showWindow);
   PIPEOPENMODE_SET_showWindow(self->impl, v);
   return v;
}

/*regSet*/inline PipeOpenMode::showWindow_Prop & PipeOpenMode::showWindow_Prop::operator= (PipeOpenMode::showWindow_Prop & prop)
{
   SELF(PipeOpenMode, showWindow);
   /*0H*/bool v = prop;
   PIPEOPENMODE_SET_showWindow(self->impl, v);
   return prop;
}
/*regGet*/inline PipeOpenMode::showWindow_Prop::operator /*0I*/bool () const
{
   SELF(PipeOpenMode, showWindow);
   return (bool)PIPEOPENMODE_showWindow(self->impl);
}

inline Point::Point(int x, int y = 0)
{
   impl.x = x;
   impl.y = y;
}



// member accessors: Point::x
// (struct::int)

/*nstSet*/inline /*0H*/int Point::x_Prop::operator= (/*0H*/int v)
{
   SELF(Point, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline Point::x_Prop & Point::x_Prop::operator= (Point::x_Prop & prop)
{
   SELF(Point, x);
   /*0H*/int v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline Point::x_Prop::operator /*0I*/int () const
{
   SELF(Point, x);
   return self ? ((C(Point) *)&self->impl)->x : 0;
}

// member accessors: Point::y
// (struct::int)

/*nstSet*/inline /*0H*/int Point::y_Prop::operator= (/*0H*/int v)
{
   SELF(Point, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline Point::y_Prop & Point::y_Prop::operator= (Point::y_Prop & prop)
{
   SELF(Point, y);
   /*0H*/int v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline Point::y_Prop::operator /*0I*/int () const
{
   SELF(Point, y);
   return self ? ((C(Point) *)&self->impl)->y : 0;
}

inline Pointd::Pointd(double x, double y = 0)
{
   impl.x = x;
   impl.y = y;
}



// member accessors: Pointd::x
// (struct::double)

/*nstSet*/inline /*0H*/double Pointd::x_Prop::operator= (/*0H*/double v)
{
   SELF(Pointd, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline Pointd::x_Prop & Pointd::x_Prop::operator= (Pointd::x_Prop & prop)
{
   SELF(Pointd, x);
   /*0H*/double v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline Pointd::x_Prop::operator /*0I*/double () const
{
   SELF(Pointd, x);
   return self ? ((C(Pointd) *)&self->impl)->x : 0;
}

// member accessors: Pointd::y
// (struct::double)

/*nstSet*/inline /*0H*/double Pointd::y_Prop::operator= (/*0H*/double v)
{
   SELF(Pointd, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline Pointd::y_Prop & Pointd::y_Prop::operator= (Pointd::y_Prop & prop)
{
   SELF(Pointd, y);
   /*0H*/double v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline Pointd::y_Prop::operator /*0I*/double () const
{
   SELF(Pointd, y);
   return self ? ((C(Pointd) *)&self->impl)->y : 0;
}

inline Pointf::Pointf(float x, float y = 0)
{
   impl.x = x;
   impl.y = y;
}



// member accessors: Pointf::x
// (struct::float)

/*nstSet*/inline /*0H*/float Pointf::x_Prop::operator= (/*0H*/float v)
{
   SELF(Pointf, x);
   self->impl.x = v;
   return v;
}

/*regSet*/inline Pointf::x_Prop & Pointf::x_Prop::operator= (Pointf::x_Prop & prop)
{
   SELF(Pointf, x);
   /*0H*/float v = prop;
   self->impl.x = v;
   return prop;
}
/*regGet*/inline Pointf::x_Prop::operator /*0I*/float () const
{
   SELF(Pointf, x);
   return self ? ((C(Pointf) *)&self->impl)->x : 0;
}

// member accessors: Pointf::y
// (struct::float)

/*nstSet*/inline /*0H*/float Pointf::y_Prop::operator= (/*0H*/float v)
{
   SELF(Pointf, y);
   self->impl.y = v;
   return v;
}

/*regSet*/inline Pointf::y_Prop & Pointf::y_Prop::operator= (Pointf::y_Prop & prop)
{
   SELF(Pointf, y);
   /*0H*/float v = prop;
   self->impl.y = v;
   return prop;
}
/*regGet*/inline Pointf::y_Prop::operator /*0I*/float () const
{
   SELF(Pointf, y);
   return self ? ((C(Pointf) *)&self->impl)->y : 0;
}
// B (unit:unit)
inline Radians Radians::operator= (Degrees value) { return Degrees_to_Radians(value.impl); }
inline Radians::Radians(Degrees value) { Degrees_to_Radians(value.impl); }
inline Radians::operator Degrees() const { return Degrees_from_Radians(impl); }

inline RepButton::RepButton(bool pressing, Seconds delay = 0, Seconds delay0 = 0) : RepButton()
{
   this->pressing = pressing;
   this->delay = delay.impl;
   this->delay0 = delay0.impl;
}



// property callers: RepButton::delay   // set only
// (normal::unit|double)

/*nstSet*/inline /*0G*/Seconds RepButton::delay_Prop::operator= (/*0G*/Seconds v)
{
   SELF(RepButton, delay);
   RepButton_set_delay(self->impl, v.impl);
   return v;
}


// property callers: RepButton::delay0   // set only
// (normal::unit|double)

/*nstSet*/inline /*0G*/Seconds RepButton::delay0_Prop::operator= (/*0G*/Seconds v)
{
   SELF(RepButton, delay0);
   RepButton_set_delay0(self->impl, v.impl);
   return v;
}



// member accessors: RepButton::pressing
// (normal::enum|uint)

/*nstSet*/inline /*0H*/bool RepButton::pressing_Prop::operator= (/*0H*/bool v)
{
   SELF(RepButton, pressing);
   IPTR(self->impl, RepButton)->pressing = (C(bool))v;
   return v;
}

/*regSet*/inline RepButton::pressing_Prop & RepButton::pressing_Prop::operator= (RepButton::pressing_Prop & prop)
{
   SELF(RepButton, pressing);
   /*0H*/bool v = prop;
   IPTR(self->impl, RepButton)->pressing = (C(bool))v;
   return prop;
}
/*regGet*/inline RepButton::pressing_Prop::operator /*0I*/bool () const
{
   SELF(RepButton, pressing);
   return self ? (bool)IPTR(self->impl, RepButton)->pressing : (bool)0;
}

// member accessors: RepButton::timer
// (normal::normal)

/*nstSet*/inline /*0H*/Timer RepButton::timer_Prop::operator= (/*0H*/Timer v)
{
   SELF(RepButton, timer);
   IPTR(self->impl, RepButton)->timer = v.impl;
   return v;
}

/*regSet*/inline RepButton::timer_Prop & RepButton::timer_Prop::operator= (RepButton::timer_Prop & prop)
{
   SELF(RepButton, timer);
   /*0H*/Timer v = prop;
   IPTR(self->impl, RepButton)->timer = v.impl;
   return prop;
}
/*regGet*/inline RepButton::timer_Prop::operator /*0I*/Timer () const
{
   SELF(RepButton, timer);
   Timer value(IPTR(self->impl, RepButton)->timer, RepButton::_cpp_class);
   return value;
}

// member accessors: RepButton::timer2
// (normal::normal)

/*nstSet*/inline /*0H*/Timer RepButton::timer2_Prop::operator= (/*0H*/Timer v)
{
   SELF(RepButton, timer2);
   IPTR(self->impl, RepButton)->timer2 = v.impl;
   return v;
}

/*regSet*/inline RepButton::timer2_Prop & RepButton::timer2_Prop::operator= (RepButton::timer2_Prop & prop)
{
   SELF(RepButton, timer2);
   /*0H*/Timer v = prop;
   IPTR(self->impl, RepButton)->timer2 = v.impl;
   return prop;
}
/*regGet*/inline RepButton::timer2_Prop::operator /*0I*/Timer () const
{
   SELF(RepButton, timer2);
   Timer value(IPTR(self->impl, RepButton)->timer2, RepButton::_cpp_class);
   return value;
}
// B (unit:unit)


template <class TC, C(Class) ** TCO> inline void TSemaphore<TC, TCO>::release()
{
   Semaphore_release((C(Semaphore)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline C(bool) TSemaphore<TC, TCO>::tryWait()
{
   return Semaphore_tryWait((C(Semaphore)*)this->impl);
}
template <class TC, C(Class) ** TCO> inline void TSemaphore<TC, TCO>::wait()
{
   Semaphore_wait((C(Semaphore)*)this->impl);
}


// property callers: Semaphore::initCount
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TSemaphore<TC, TCO>::initCount_Prop::operator= (/*0H*/int v)
{
   SELF(Semaphore, initCount);
   Semaphore_set_initCount(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TSemaphore<TC, TCO>::initCount_Prop & TSemaphore<TC, TCO>::initCount_Prop::operator= (typename TSemaphore<TC, TCO>::initCount_Prop & prop)
{
   SELF(Semaphore, initCount);
   /*0H*/int v = prop;
   Semaphore_set_initCount(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TSemaphore<TC, TCO>::initCount_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TSemaphore TCTCO * self = CONTAINER_OF(this, TSemaphore TCTCO, initCount);
   return Semaphore_get_initCount(self ? self->impl : null);
}

// property callers: Semaphore::maxCount
// (nohead::int)

/*nstSet*/template <class TC, C(Class) ** TCO> inline /*0H*/int TSemaphore<TC, TCO>::maxCount_Prop::operator= (/*0H*/int v)
{
   SELF(Semaphore, maxCount);
   Semaphore_set_maxCount(self ? self->impl : null, v);
   return v;
}

/*regSet*/template <class TC, C(Class) ** TCO> inline typename TSemaphore<TC, TCO>::maxCount_Prop & TSemaphore<TC, TCO>::maxCount_Prop::operator= (typename TSemaphore<TC, TCO>::maxCount_Prop & prop)
{
   SELF(Semaphore, maxCount);
   /*0H*/int v = prop;
   Semaphore_set_maxCount(self ? self->impl : null, v);
   return prop;
}
/*regGet*/template <class TC, C(Class) ** TCO> inline TSemaphore<TC, TCO>::maxCount_Prop::operator /*0I*/int () const
{
   __attribute__((unused)) TSemaphore TCTCO * self = CONTAINER_OF(this, TSemaphore TCTCO, maxCount);
   return Semaphore_get_maxCount(self ? self->impl : null);
}

inline Size::Size(MinMaxValue w, MinMaxValue h = 0)
{
   impl.w = w.impl;
   impl.h = h.impl;
}



// member accessors: Size::w
// (struct::unit|int)

/*nstSet*/inline /*0H*/MinMaxValue Size::w_Prop::operator= (/*0H*/MinMaxValue v)
{
   SELF(Size, w);
   self->impl.w = (int)v.impl;
   return v;
}

/*regSet*/inline Size::w_Prop & Size::w_Prop::operator= (Size::w_Prop & prop)
{
   SELF(Size, w);
   /*0H*/MinMaxValue v = prop;
   self->impl.w = (int)v.impl;
   return prop;
}
/*regGet*/inline Size::w_Prop::operator /*0I*/MinMaxValue () const
{
   SELF(Size, w);
   return MinMaxValue(self->impl.w);
}
/*regGet*/inline Size::w_Prop::operator /*0J*/C(MinMaxValue) () const
{
   SELF(Size, w);
   return MinMaxValue(self->w);
}

// member accessors: Size::h
// (struct::unit|int)

/*nstSet*/inline /*0H*/MinMaxValue Size::h_Prop::operator= (/*0H*/MinMaxValue v)
{
   SELF(Size, h);
   self->impl.h = (int)v.impl;
   return v;
}

/*regSet*/inline Size::h_Prop & Size::h_Prop::operator= (Size::h_Prop & prop)
{
   SELF(Size, h);
   /*0H*/MinMaxValue v = prop;
   self->impl.h = (int)v.impl;
   return prop;
}
/*regGet*/inline Size::h_Prop::operator /*0I*/MinMaxValue () const
{
   SELF(Size, h);
   return MinMaxValue(self->impl.h);
}
/*regGet*/inline Size::h_Prop::operator /*0J*/C(MinMaxValue) () const
{
   SELF(Size, h);
   return MinMaxValue(self->h);
}

inline TempFile::TempFile(FileOpenMode openMode, unsigned char * buffer = null, uintsize size = 0, uintsize allocated = 0) : TempFile()
{
   this->openMode = openMode;
   this->buffer = buffer;
   this->size = size;
   this->allocated = allocated;
}


inline byte * TempFile::stealBuffer()
{
   return TempFile_stealBuffer(impl);
}


// property callers: TempFile::openMode
// (normal::enum|int)

/*nstSet*/inline /*0H*/FileOpenMode TempFile::openMode_Prop::operator= (/*0H*/FileOpenMode v)
{
   SELF(TempFile, openMode);
   TempFile_set_openMode(self ? self->impl : null, (C(FileOpenMode))v);
   return v;
}

/*regSet*/inline TempFile::openMode_Prop & TempFile::openMode_Prop::operator= (TempFile::openMode_Prop & prop)
{
   SELF(TempFile, openMode);
   /*0H*/FileOpenMode v = prop;
   TempFile_set_openMode(self ? self->impl : null, (C(FileOpenMode))v);
   return prop;
}
/*regGet*/inline TempFile::openMode_Prop::operator /*0I*/FileOpenMode () const
{
   SELF(TempFile, openMode);
   return (FileOpenMode)TempFile_get_openMode(self ? self->impl : null);
}

// property callers: TempFile::buffer
// (normal::byte *)

/*nstSet*/inline /*0H*/unsigned char * TempFile::buffer_Prop::operator= (/*0H*/unsigned char * v)
{
   SELF(TempFile, buffer);
   TempFile_set_buffer(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline TempFile::buffer_Prop & TempFile::buffer_Prop::operator= (TempFile::buffer_Prop & prop)
{
   SELF(TempFile, buffer);
   /*0H*/unsigned char * v = prop;
   TempFile_set_buffer(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline TempFile::buffer_Prop::operator /*0I*/unsigned char * () const
{
   SELF(TempFile, buffer);
   return TempFile_get_buffer(self ? self->impl : null);
}

// property callers: TempFile::size
// (normal::uintsize)

/*nstSet*/inline /*0H*/uintsize TempFile::size_Prop::operator= (/*0H*/uintsize v)
{
   SELF(TempFile, size);
   TempFile_set_size(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline TempFile::size_Prop & TempFile::size_Prop::operator= (TempFile::size_Prop & prop)
{
   SELF(TempFile, size);
   /*0H*/uintsize v = prop;
   TempFile_set_size(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline TempFile::size_Prop::operator /*0I*/uintsize () const
{
   SELF(TempFile, size);
   return TempFile_get_size(self ? self->impl : null);
}

// property callers: TempFile::allocated
// (normal::uintsize)

/*nstSet*/inline /*0H*/uintsize TempFile::allocated_Prop::operator= (/*0H*/uintsize v)
{
   SELF(TempFile, allocated);
   TempFile_set_allocated(self ? self->impl : null, v);
   return v;
}

/*regSet*/inline TempFile::allocated_Prop & TempFile::allocated_Prop::operator= (TempFile::allocated_Prop & prop)
{
   SELF(TempFile, allocated);
   /*0H*/uintsize v = prop;
   TempFile_set_allocated(self ? self->impl : null, v);
   return prop;
}
/*regGet*/inline TempFile::allocated_Prop::operator /*0I*/uintsize () const
{
   SELF(TempFile, allocated);
   return TempFile_get_allocated(self ? self->impl : null);
}

inline Thread::Thread_main_Functor::FunctionType Thread::Thread_main_Functor::operator= (FunctionType func)
{
   SELF(Thread, main);
   if(self->vTbl == Thread::_cpp_class.vTbl)
   {
      uint size = Thread::_cpp_class.impl->vTblSize;
      self->vTbl = (void (**)())newt(Thread::Thread_main_Functor::FunctionType, size);
      memcpy(self->vTbl, Thread::_cpp_class.vTbl, sizeof(Thread::Thread_main_Functor::FunctionType) * size);
   }
   ((Thread::Thread_main_Functor::FunctionType *)self->vTbl)[M_VTBLID(Thread, main)] = func;
   return func;
}
inline uint Thread::Thread_main_Functor::operator()( )
{
   SELF(Thread, main);
   return Thread_main(self ? self->impl : (C(Thread))null);
}
// inline void Thread::register_main(CPPClass & cl, Thread::Thread_main_Functor::FunctionType func)
// {
//    ((Thread::Thread_main_Functor::FunctionType *)cl.vTbl)[M_VTBLID(Thread, main)] = func;
// }


inline void Thread::create()
{
   Thread_create(impl);
}
inline void Thread::kill()
{
   Thread_kill(impl);
}
inline void Thread::setPriority(/*1Ab*/ThreadPriority priority)
{
   Thread_setPriority(impl, /*5Ee*/(C(ThreadPriority))priority);
}
inline void Thread::wait()
{
   Thread_wait(impl);
}


// property callers: Thread::created   // get only
// (normal::enum|uint)

/*regGet*/inline Thread::created_Prop::operator /*0I*/bool () const
{
   SELF(Thread, created);
   return (bool)Thread_get_created(self ? self->impl : null);
}
// B (unit:unit)



// member accessors: UnicodeDecomposition::canonical
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::canonical_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, canonical);
   UNICODEDECOMPOSITION_SET_canonical(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::canonical_Prop & UnicodeDecomposition::canonical_Prop::operator= (UnicodeDecomposition::canonical_Prop & prop)
{
   SELF(UnicodeDecomposition, canonical);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_canonical(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::canonical_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, canonical);
   return (bool)UNICODEDECOMPOSITION_canonical(self->impl);
}

// member accessors: UnicodeDecomposition::compat
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::compat_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, compat);
   UNICODEDECOMPOSITION_SET_compat(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::compat_Prop & UnicodeDecomposition::compat_Prop::operator= (UnicodeDecomposition::compat_Prop & prop)
{
   SELF(UnicodeDecomposition, compat);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_compat(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::compat_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, compat);
   return (bool)UNICODEDECOMPOSITION_compat(self->impl);
}

// member accessors: UnicodeDecomposition::fraction
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::fraction_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, fraction);
   UNICODEDECOMPOSITION_SET_fraction(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::fraction_Prop & UnicodeDecomposition::fraction_Prop::operator= (UnicodeDecomposition::fraction_Prop & prop)
{
   SELF(UnicodeDecomposition, fraction);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_fraction(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::fraction_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, fraction);
   return (bool)UNICODEDECOMPOSITION_fraction(self->impl);
}

// member accessors: UnicodeDecomposition::font
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::font_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, font);
   UNICODEDECOMPOSITION_SET_font(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::font_Prop & UnicodeDecomposition::font_Prop::operator= (UnicodeDecomposition::font_Prop & prop)
{
   SELF(UnicodeDecomposition, font);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_font(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::font_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, font);
   return (bool)UNICODEDECOMPOSITION_font(self->impl);
}

// member accessors: UnicodeDecomposition::noBreak
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::noBreak_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, noBreak);
   UNICODEDECOMPOSITION_SET_noBreak(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::noBreak_Prop & UnicodeDecomposition::noBreak_Prop::operator= (UnicodeDecomposition::noBreak_Prop & prop)
{
   SELF(UnicodeDecomposition, noBreak);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_noBreak(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::noBreak_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, noBreak);
   return (bool)UNICODEDECOMPOSITION_noBreak(self->impl);
}

// member accessors: UnicodeDecomposition::initial
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::initial_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, initial);
   UNICODEDECOMPOSITION_SET_initial(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::initial_Prop & UnicodeDecomposition::initial_Prop::operator= (UnicodeDecomposition::initial_Prop & prop)
{
   SELF(UnicodeDecomposition, initial);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_initial(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::initial_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, initial);
   return (bool)UNICODEDECOMPOSITION_initial(self->impl);
}

// member accessors: UnicodeDecomposition::final
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::final_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, final);
   UNICODEDECOMPOSITION_SET_final(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::final_Prop & UnicodeDecomposition::final_Prop::operator= (UnicodeDecomposition::final_Prop & prop)
{
   SELF(UnicodeDecomposition, final);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_final(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::final_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, final);
   return (bool)UNICODEDECOMPOSITION_final(self->impl);
}

// member accessors: UnicodeDecomposition::medial
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::medial_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, medial);
   UNICODEDECOMPOSITION_SET_medial(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::medial_Prop & UnicodeDecomposition::medial_Prop::operator= (UnicodeDecomposition::medial_Prop & prop)
{
   SELF(UnicodeDecomposition, medial);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_medial(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::medial_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, medial);
   return (bool)UNICODEDECOMPOSITION_medial(self->impl);
}

// member accessors: UnicodeDecomposition::isolated
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::isolated_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, isolated);
   UNICODEDECOMPOSITION_SET_isolated(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::isolated_Prop & UnicodeDecomposition::isolated_Prop::operator= (UnicodeDecomposition::isolated_Prop & prop)
{
   SELF(UnicodeDecomposition, isolated);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_isolated(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::isolated_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, isolated);
   return (bool)UNICODEDECOMPOSITION_isolated(self->impl);
}

// member accessors: UnicodeDecomposition::circle
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::circle_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, circle);
   UNICODEDECOMPOSITION_SET_circle(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::circle_Prop & UnicodeDecomposition::circle_Prop::operator= (UnicodeDecomposition::circle_Prop & prop)
{
   SELF(UnicodeDecomposition, circle);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_circle(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::circle_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, circle);
   return (bool)UNICODEDECOMPOSITION_circle(self->impl);
}

// member accessors: UnicodeDecomposition::square
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::square_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, square);
   UNICODEDECOMPOSITION_SET_square(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::square_Prop & UnicodeDecomposition::square_Prop::operator= (UnicodeDecomposition::square_Prop & prop)
{
   SELF(UnicodeDecomposition, square);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_square(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::square_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, square);
   return (bool)UNICODEDECOMPOSITION_square(self->impl);
}

// member accessors: UnicodeDecomposition::sub
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::sub_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, sub);
   UNICODEDECOMPOSITION_SET_sub(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::sub_Prop & UnicodeDecomposition::sub_Prop::operator= (UnicodeDecomposition::sub_Prop & prop)
{
   SELF(UnicodeDecomposition, sub);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_sub(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::sub_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, sub);
   return (bool)UNICODEDECOMPOSITION_sub(self->impl);
}

// member accessors: UnicodeDecomposition::super
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::super_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, super);
   UNICODEDECOMPOSITION_SET_super(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::super_Prop & UnicodeDecomposition::super_Prop::operator= (UnicodeDecomposition::super_Prop & prop)
{
   SELF(UnicodeDecomposition, super);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_super(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::super_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, super);
   return (bool)UNICODEDECOMPOSITION_super(self->impl);
}

// member accessors: UnicodeDecomposition::small
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::small_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, small);
   UNICODEDECOMPOSITION_SET_small(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::small_Prop & UnicodeDecomposition::small_Prop::operator= (UnicodeDecomposition::small_Prop & prop)
{
   SELF(UnicodeDecomposition, small);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_small(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::small_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, small);
   return (bool)UNICODEDECOMPOSITION_small(self->impl);
}

// member accessors: UnicodeDecomposition::vertical
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::vertical_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, vertical);
   UNICODEDECOMPOSITION_SET_vertical(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::vertical_Prop & UnicodeDecomposition::vertical_Prop::operator= (UnicodeDecomposition::vertical_Prop & prop)
{
   SELF(UnicodeDecomposition, vertical);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_vertical(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::vertical_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, vertical);
   return (bool)UNICODEDECOMPOSITION_vertical(self->impl);
}

// member accessors: UnicodeDecomposition::wide
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::wide_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, wide);
   UNICODEDECOMPOSITION_SET_wide(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::wide_Prop & UnicodeDecomposition::wide_Prop::operator= (UnicodeDecomposition::wide_Prop & prop)
{
   SELF(UnicodeDecomposition, wide);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_wide(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::wide_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, wide);
   return (bool)UNICODEDECOMPOSITION_wide(self->impl);
}

// member accessors: UnicodeDecomposition::narrow
// (bits::enum|uint)

/*nstSet*/inline /*0H*/bool UnicodeDecomposition::narrow_Prop::operator= (/*0H*/bool v)
{
   SELF(UnicodeDecomposition, narrow);
   UNICODEDECOMPOSITION_SET_narrow(self->impl, v);
   return v;
}

/*regSet*/inline UnicodeDecomposition::narrow_Prop & UnicodeDecomposition::narrow_Prop::operator= (UnicodeDecomposition::narrow_Prop & prop)
{
   SELF(UnicodeDecomposition, narrow);
   /*0H*/bool v = prop;
   UNICODEDECOMPOSITION_SET_narrow(self->impl, v);
   return prop;
}
/*regGet*/inline UnicodeDecomposition::narrow_Prop::operator /*0I*/bool () const
{
   SELF(UnicodeDecomposition, narrow);
   return (bool)UNICODEDECOMPOSITION_narrow(self->impl);
}
// function: gLMultisampling
inline void gLMultisampling(/*1Ab*/bool value)
{
   F(gLMultisampling)(/*5Ee*/(C(bool))value);
}
// function: bestColorMatch
inline int bestColorMatch(/*1Ab*/ColorAlpha * palette, /*1Ab*/int start, /*1Ab*/int end, /*1Ab*/Color rgb)
{
   return F(bestColorMatch)(/*5Ee*/(C(ColorAlpha) *)palette, /*5Ge*/start, /*5Ge*/end, /*5Ee*/(C(Color))rgb.impl);
}
// function: getColorDepthShifts
inline byte getColorDepthShifts(/*1Ab*/PixelFormat format)
{
   return F(getColorDepthShifts)(/*5Ee*/(C(PixelFormat))format);
}
// function: getDefaultMaterial
inline C(Material) * getDefaultMaterial()
{
   return F(getDefaultMaterial)();
}
// function: getDefaultPalette
inline C(ColorAlpha) * getDefaultPalette()
{
   return F(getDefaultPalette)();
}
// function: getDepthBits
inline int getDepthBits(/*1Ab*/PixelFormat colorDepth)
{
   return F(getDepthBits)(/*5Ee*/(C(PixelFormat))colorDepth);
}
// function: getResolutionHeight
inline int getResolutionHeight(/*1Ab*/Resolution resolution)
{
   return F(getResolutionHeight)(/*5Ee*/(C(Resolution))resolution);
}
// function: getResolutionWidth
inline int getResolutionWidth(/*1Ab*/Resolution resolution)
{
   return F(getResolutionWidth)(/*5Ee*/(C(Resolution))resolution);
}
// function: listAvailableFonts
inline TMap<C(String) _ARG FontInfo> listAvailableFonts()
{
   return TMap<C(String) _ARG FontInfo>(F(listAvailableFonts)());
}
// function: loadPalette
inline C(ColorAlpha) * loadPalette(/*1Ab*/const char * fileName, /*1Ab*/const char * type)
{
   return F(loadPalette)(/*5Ge*/fileName, /*5Ge*/type);
}
// function: paletteGradient
inline void paletteGradient(/*1Ab*/ColorAlpha * palette, /*1Ab*/int numColors, /*1Ab*/ColorKey * keys, /*1Ab*/int numKeys, /*1Ab*/float smoothness)
{
   F(paletteGradient)(/*5Ee*/(C(ColorAlpha) *)palette, /*5Ge*/numColors, /*5Ee*/(C(ColorKey) *)keys, /*5Ge*/numKeys, /*5Ge*/smoothness);
}
// function: resolveCharFont
inline C(FaceInfo) * resolveCharFont(constString faceName, /*1Ab*/float size, /*1Ab*/FontFlags flags, constString lang, /*1Ab*/unichar testChar)
{
   return F(resolveCharFont)(/*5Ge*/faceName, /*5Ge*/size, /*5Ee*/(C(FontFlags))flags.impl, /*5Ge*/lang, /*5Ge*/testChar);
}
// function: resolveFont
inline TArray<C(FaceInfo) _ARG int _ARG C(FaceInfo)> resolveFont(constString faceName, /*1Ab*/float size, /*1Ab*/FontFlags flags)
{
   return TArray<C(FaceInfo) _ARG int _ARG C(FaceInfo)>(F(resolveFont)(/*5Ge*/faceName, /*5Ge*/size, /*5Ee*/(C(FontFlags))flags.impl));
}
// function: setPrintingDocumentName
inline void setPrintingDocumentName(constString name)
{
   F(setPrintingDocumentName)(/*5Ge*/name);
}
// function: gLABBindBuffer
inline void gLABBindBuffer(/*1Ab*/int target, /*1Ab*/uint buffer)
{
   F(gLABBindBuffer)(/*5Ge*/target, /*5Ge*/buffer);
}
// function: gLABBindVertexArray
inline void gLABBindVertexArray(/*1Ab*/uint vao)
{
   F(gLABBindVertexArray)(/*5Ge*/vao);
}
// function: gLSetupFog
inline void gLSetupFog(/*1Ab*/bool enable)
{
   F(gLSetupFog)(/*5Ee*/(C(bool))enable);
}
// function: gLSetupLighting
inline void gLSetupLighting(/*1Ab*/bool enable)
{
   F(gLSetupLighting)(/*5Ee*/(C(bool))enable);
}
// function: gLSetupTexturing
inline void gLSetupTexturing(/*1Ab*/bool enable)
{
   F(gLSetupTexturing)(/*5Ee*/(C(bool))enable);
}
// function: useSingleGLContext
inline void useSingleGLContext(/*1Ab*/bool useSingle)
{
   F(useSingleGLContext)(/*5Ee*/(C(bool))useSingle);
}
// function: glimtkBegin
inline void glimtkBegin(/*1Ab*/GLIMTKMode mode)
{
   F(glimtkBegin)(/*5Ee*/(C(GLIMTKMode))mode);
}
// function: glimtkColor3f
inline void glimtkColor3f(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b)
{
   F(glimtkColor3f)(/*5Ge*/r, /*5Ge*/g, /*5Ge*/b);
}
// function: glimtkColor4f
inline void glimtkColor4f(/*1Ab*/float r, /*1Ab*/float g, /*1Ab*/float b, /*1Ab*/float a)
{
   F(glimtkColor4f)(/*5Ge*/r, /*5Ge*/g, /*5Ge*/b, /*5Ge*/a);
}
// function: glimtkColor4fv
inline void glimtkColor4fv(/*1Ab*/float * a)
{
   F(glimtkColor4fv)(/*5Ge*/a);
}
// function: glimtkColor4ub
inline void glimtkColor4ub(/*1Ab*/byte r, /*1Ab*/byte g, /*1Ab*/byte b, /*1Ab*/byte a)
{
   F(glimtkColor4ub)(/*5Ge*/r, /*5Ge*/g, /*5Ge*/b, /*5Ge*/a);
}
// function: glimtkEnd
inline void glimtkEnd()
{
   F(glimtkEnd)();
}
// function: glimtkNormal3d
inline void glimtkNormal3d(/*1Ab*/double x, /*1Ab*/double y, /*1Ab*/double z)
{
   F(glimtkNormal3d)(/*5Ge*/x, /*5Ge*/y, /*5Ge*/z);
}
// function: glimtkNormal3f
inline void glimtkNormal3f(/*1Ab*/float x, /*1Ab*/float y, /*1Ab*/float z)
{
   F(glimtkNormal3f)(/*5Ge*/x, /*5Ge*/y, /*5Ge*/z);
}
// function: glimtkNormal3fd
inline void glimtkNormal3fd(/*1Ab*/double * coords)
{
   F(glimtkNormal3fd)(/*5Ge*/coords);
}
// function: glimtkNormal3fv
inline void glimtkNormal3fv(/*1Ab*/float * coords)
{
   F(glimtkNormal3fv)(/*5Ge*/coords);
}
// function: glimtkRecti
inline void glimtkRecti(/*1Ab*/int a, /*1Ab*/int b, /*1Ab*/int c, /*1Ab*/int d)
{
   F(glimtkRecti)(/*5Ge*/a, /*5Ge*/b, /*5Ge*/c, /*5Ge*/d);
}
// function: glimtkTexCoord2d
inline void glimtkTexCoord2d(/*1Ab*/double x, /*1Ab*/double y)
{
   F(glimtkTexCoord2d)(/*5Ge*/x, /*5Ge*/y);
}
// function: glimtkTexCoord2f
inline void glimtkTexCoord2f(/*1Ab*/float x, /*1Ab*/float y)
{
   F(glimtkTexCoord2f)(/*5Ge*/x, /*5Ge*/y);
}
// function: glimtkTexCoord2fv
inline void glimtkTexCoord2fv(/*1Ab*/float * a)
{
   F(glimtkTexCoord2fv)(/*5Ge*/a);
}
// function: glimtkTexCoord2i
inline void glimtkTexCoord2i(/*1Ab*/int x, /*1Ab*/int y)
{
   F(glimtkTexCoord2i)(/*5Ge*/x, /*5Ge*/y);
}
// function: glimtkVertex2d
inline void glimtkVertex2d(/*1Ab*/double x, /*1Ab*/double y)
{
   F(glimtkVertex2d)(/*5Ge*/x, /*5Ge*/y);
}
// function: glimtkVertex2f
inline void glimtkVertex2f(/*1Ab*/float x, /*1Ab*/float y)
{
   F(glimtkVertex2f)(/*5Ge*/x, /*5Ge*/y);
}
// function: glimtkVertex2i
inline void glimtkVertex2i(/*1Ab*/int x, /*1Ab*/int y)
{
   F(glimtkVertex2i)(/*5Ge*/x, /*5Ge*/y);
}
// function: glimtkVertex3d
inline void glimtkVertex3d(/*1Ab*/double x, /*1Ab*/double y, /*1Ab*/double z)
{
   F(glimtkVertex3d)(/*5Ge*/x, /*5Ge*/y, /*5Ge*/z);
}
// function: glimtkVertex3dv
inline void glimtkVertex3dv(/*1Ab*/double * coords)
{
   F(glimtkVertex3dv)(/*5Ge*/coords);
}
// function: glimtkVertex3f
inline void glimtkVertex3f(/*1Ab*/float x, /*1Ab*/float y, /*1Ab*/float z)
{
   F(glimtkVertex3f)(/*5Ge*/x, /*5Ge*/y, /*5Ge*/z);
}
// function: glimtkVertex3fv
inline void glimtkVertex3fv(/*1Ab*/float * coords)
{
   F(glimtkVertex3fv)(/*5Ge*/coords);
}
// function: glmsFlushMatrices
inline void glmsFlushMatrices()
{
   F(glmsFlushMatrices)();
}
// function: glmsFrustum
inline void glmsFrustum(/*1Ab*/double l, /*1Ab*/double r, /*1Ab*/double b, /*1Ab*/double t, /*1Ab*/double n, /*1Ab*/double f)
{
   F(glmsFrustum)(/*5Ge*/l, /*5Ge*/r, /*5Ge*/b, /*5Ge*/t, /*5Ge*/n, /*5Ge*/f);
}
// function: glmsGetDoublev
inline void glmsGetDoublev(/*1Ab*/GLMSWhatToGet what, /*1Ab*/double * i)
{
   F(glmsGetDoublev)(/*5Ee*/(C(GLMSWhatToGet))what, /*5Ge*/i);
}
// function: glmsGetNearPlane
inline double glmsGetNearPlane()
{
   return F(glmsGetNearPlane)();
}
// function: glmsLoadIdentity
inline void glmsLoadIdentity()
{
   F(glmsLoadIdentity)();
}
// function: glmsLoadMatrix
inline void glmsLoadMatrix(/*1Ab*/Matrix & matrix)
{
   F(glmsLoadMatrix)(/*5De*/&matrix.impl);
}
inline void glmsLoadMatrix(/*1Ac*/Matrix * matrix)
{
   F(glmsLoadMatrix)(/*5Cf*/(C(Matrix) *)matrix);
}
// function: glmsLoadMatrixd
inline void glmsLoadMatrixd(/*1Ab*/double * i)
{
   F(glmsLoadMatrixd)(/*5Ge*/i);
}
// function: glmsLoadMatrixf
inline void glmsLoadMatrixf(/*1Ab*/float * i)
{
   F(glmsLoadMatrixf)(/*5Ge*/i);
}
// function: glmsMatrixMode
inline void glmsMatrixMode(/*1Ab*/MatrixMode mode)
{
   F(glmsMatrixMode)(/*5Ee*/(C(MatrixMode))mode);
}
// function: glmsMultMatrixd
inline void glmsMultMatrixd(/*1Ab*/double * i)
{
   F(glmsMultMatrixd)(/*5Ge*/i);
}
// function: glmsMultMatrixf
inline void glmsMultMatrixf(/*1Ab*/float * i)
{
   F(glmsMultMatrixf)(/*5Ge*/i);
}
// function: glmsOrtho
inline void glmsOrtho(/*1Ab*/double l, /*1Ab*/double r, /*1Ab*/double b, /*1Ab*/double t, /*1Ab*/double n, /*1Ab*/double f)
{
   F(glmsOrtho)(/*5Ge*/l, /*5Ge*/r, /*5Ge*/b, /*5Ge*/t, /*5Ge*/n, /*5Ge*/f);
}
// function: glmsPopMatrix
inline void glmsPopMatrix()
{
   F(glmsPopMatrix)();
}
// function: glmsPushMatrix
inline void glmsPushMatrix()
{
   F(glmsPushMatrix)();
}
// function: glmsRotated
inline void glmsRotated(/*1Ab*/double angle, /*1Ab*/double x, /*1Ab*/double y, /*1Ab*/double z)
{
   F(glmsRotated)(/*5Ge*/angle, /*5Ge*/x, /*5Ge*/y, /*5Ge*/z);
}
// function: glmsScaled
inline void glmsScaled(/*1Ab*/double a, /*1Ab*/double b, /*1Ab*/double c)
{
   F(glmsScaled)(/*5Ge*/a, /*5Ge*/b, /*5Ge*/c);
}
// function: glmsSetNearPlane
inline void glmsSetNearPlane(/*1Ab*/double value)
{
   F(glmsSetNearPlane)(/*5Ge*/value);
}
// function: glmsTranslated
inline void glmsTranslated(/*1Ab*/double a, /*1Ab*/double b, /*1Ab*/double c)
{
   F(glmsTranslated)(/*5Ge*/a, /*5Ge*/b, /*5Ge*/c);
}
// function: glsupLightModeli
inline void glsupLightModeli(/*1Ab*/uint pname, /*1Ab*/int param)
{
   F(glsupLightModeli)(/*5Ge*/pname, /*5Ge*/param);
}
// function: glsupLineStipple
inline void glsupLineStipple(/*1Ab*/int i, /*1Ab*/uint16 j)
{
   F(glsupLineStipple)(/*5Ge*/i, /*5Ge*/j);
}
// function: fastInvSqrt
inline float fastInvSqrt(/*1Ab*/float x)
{
   return F(fastInvSqrt)(/*5Ge*/x);
}
// function: fastInvSqrtDouble
inline double fastInvSqrtDouble(/*1Ab*/double x)
{
   return F(fastInvSqrtDouble)(/*5Ge*/x);
}
// function: applySkin
inline void applySkin(/*1Ab*/Class c, /*1Ab*/const char * name, /*1Ab*/void ** vTbl)
{
   F(applySkin)(/*5De*/c.impl, /*5Ge*/name, /*5Ge*/vTbl);
}
// function: desktop3DFullScreen
inline C(bool) desktop3DFullScreen(/*1Ab*/Window & window)
{
   return F(desktop3DFullScreen)(/*5De*/window.impl);
}
// function: desktop3DGetClipBox
inline void desktop3DGetClipBox(/*1Ab*/Box & box)
{
   F(desktop3DGetClipBox)(/*5De*/&box.impl);
}
inline void desktop3DGetClipBox(/*1Ac*/Box * box)
{
   F(desktop3DGetClipBox)(/*5Cf*/(C(Box) *)box);
}
// function: desktop3DGetClippedWindow
inline Window desktop3DGetClippedWindow()
{
   return Window(F(desktop3DGetClippedWindow)());
}
// function: desktop3DGetWindowHandle
inline void * desktop3DGetWindowHandle(/*1Ab*/Window & window)
{
   return F(desktop3DGetWindowHandle)(/*5De*/window.impl);
}
// function: desktop3DInitialize
inline void desktop3DInitialize(/*1Ab*/Window & window, void (* setup)(C(Window) window, int w, int h), void (* update)(C(Window) window, C(Box) * box))
{
   F(desktop3DInitialize)(/*5De*/window.impl, /*5Ge*/setup, /*5Ge*/update);
}
// function: desktop3DMouseMessage
inline C(bool) desktop3DMouseMessage(/*1Ab*/Window & window, /*1Ab*/uint method, /*1Ab*/int x, /*1Ab*/int y, /*1Ab*/Modifiers * mods, /*1Ab*/bool consequential, /*1Ab*/bool activate)
{
   return F(desktop3DMouseMessage)(/*5De*/window.impl, /*5Ge*/method, /*5Ge*/x, /*5Ge*/y, /*5Ee*/(C(Modifiers) *)mods, /*5Ee*/(C(bool))consequential, /*5Ee*/(C(bool))activate);
}
// function: desktop3DSetDesktopDirty
inline void desktop3DSetDesktopDirty()
{
   F(desktop3DSetDesktopDirty)();
}
// function: desktop3DTitleBarClicked
inline C(bool) desktop3DTitleBarClicked(/*1Ab*/Window & clickedWindow, /*1Ab*/int x, /*1Ab*/int y)
{
   return F(desktop3DTitleBarClicked)(/*5De*/clickedWindow.impl, /*5Ge*/x, /*5Ge*/y);
}
// function: desktop3DUpdateDisplay
inline C(bool) desktop3DUpdateDisplay()
{
   return F(desktop3DUpdateDisplay)();
}
// function: queryCompass
inline void queryCompass(/*1Ab*/Euler & value)
{
   F(queryCompass)(/*5De*/&value.impl);
}
inline void queryCompass(/*1Ac*/Euler * value)
{
   F(queryCompass)(/*5Cf*/(C(Euler) *)value);
}
// function: unapplySkin
inline void unapplySkin(/*1Ab*/Class c)
{
   F(unapplySkin)(/*5De*/c.impl);
}
// function: connectToFileServer
inline FileServerConnection connectToFileServer(/*1Ab*/const char * hostName, /*1Ab*/int port)
{
   return FileServerConnection(F(connectToFileServer)(/*5Ge*/hostName, /*5Ge*/port));
}
// function: fileOpenURL
inline HTTPFile fileOpenURL(/*1Ab*/const char * name)
{
   return HTTPFile(F(fileOpenURL)(/*5Ge*/name));
}
// function: getAddressFromName
inline C(bool) getAddressFromName(/*1Ab*/const char * hostName, /*1Ab*/char * inetAddress)
{
   return F(getAddressFromName)(/*5Ge*/hostName, /*5Ge*/inetAddress);
}
// function: getHostName
inline C(bool) getHostName(/*1Ab*/char * hostName, /*1Ab*/int size)
{
   return F(getHostName)(/*5Ge*/hostName, /*5Ge*/size);
}
// function: getNameFromAddress
inline C(bool) getNameFromAddress(/*1Ab*/const char * inetAddress, /*1Ab*/char * hostName)
{
   return F(getNameFromAddress)(/*5Ge*/inetAddress, /*5Ge*/hostName);
}
// function: setCurlEmbeddedCA
inline C(bool) setCurlEmbeddedCA(/*1Ab*/void * curlHandle)
{
   return F(setCurlEmbeddedCA)(/*5Ge*/curlHandle);
}
// function: archiveOpen
inline Archive archiveOpen(/*1Ab*/const char * fileName, /*1Ab*/ArchiveOpenFlags flags)
{
   return Archive(F(archiveOpen)(/*5Ge*/fileName, /*5Ee*/(C(ArchiveOpenFlags))flags.impl));
}
// function: archiveQuerySize
inline C(bool) archiveQuerySize(/*1Ab*/const char * fileName, /*1Ab*/FileSize * size)
{
   return F(archiveQuerySize)(/*5Ge*/fileName, /*5Ee*/(C(FileSize) *)size);
}
// function: changeWorkingDir
inline C(bool) changeWorkingDir(/*1Ab*/const char * buf)
{
   return F(changeWorkingDir)(/*5Ge*/buf);
}
// function: charMatchCategories
inline C(bool) charMatchCategories(/*1Ab*/unichar ch, /*1Ab*/CharCategories categories)
{
   return F(charMatchCategories)(/*5Ge*/ch, /*5Ee*/(C(CharCategories))categories.impl);
}
// function: copyBytes
inline void copyBytes(/*1Ab*/void * dest, /*1Ab*/const void * source, /*1Ab*/uint64 count)
{
   F(copyBytes)(/*5Ge*/dest, /*5Ge*/source, /*5Ge*/count);
}
// function: copyBytesBy2
inline void copyBytesBy2(/*1Ab*/void * dest, /*1Ab*/const void * source, /*1Ab*/uint count)
{
   F(copyBytesBy2)(/*5Ge*/dest, /*5Ge*/source, /*5Ge*/count);
}
// function: copyBytesBy4
inline void copyBytesBy4(/*1Ab*/void * dest, /*1Ab*/const void * source, /*1Ab*/uint count)
{
   F(copyBytesBy4)(/*5Ge*/dest, /*5Ge*/source, /*5Ge*/count);
}
// function: copySystemPath
inline char * copySystemPath(/*1Ab*/const char * p)
{
   return F(copySystemPath)(/*5Ge*/p);
}
// function: copyUnixPath
inline char * copyUnixPath(/*1Ab*/const char * p)
{
   return F(copyUnixPath)(/*5Ge*/p);
}
// function: createTemporaryDir
inline void createTemporaryDir(/*1Ab*/char * tempFileName, /*1Ab*/const char * ap1)
{
   F(createTemporaryDir)(/*5Ge*/tempFileName, /*5Ge*/ap1);
}
// function: createTemporaryFile
inline File createTemporaryFile(/*1Ab*/char * tempFileName, /*1Ab*/const char * ap1)
{
   return File(F(createTemporaryFile)(/*5Ge*/tempFileName, /*5Ge*/ap1));
}
// function: deleteFile
inline C(bool) deleteFile(/*1Ab*/const char * fileName)
{
   return F(deleteFile)(/*5Ge*/fileName);
}
// function: dualPipeOpen
inline DualPipe dualPipeOpen(/*1Ab*/PipeOpenMode mode, /*1Ab*/const char * commandLine)
{
   return DualPipe(F(dualPipeOpen)(/*5Ee*/(C(PipeOpenMode))mode.impl, /*5Ge*/commandLine));
}
// function: dualPipeOpenEnv
inline DualPipe dualPipeOpenEnv(/*1Ab*/PipeOpenMode mode, /*1Ab*/const char * env, /*1Ab*/const char * commandLine)
{
   return DualPipe(F(dualPipeOpenEnv)(/*5Ee*/(C(PipeOpenMode))mode.impl, /*5Ge*/env, /*5Ge*/commandLine));
}
// function: dualPipeOpenEnvf
template<typename... Args> inline DualPipe dualPipeOpenEnvf(/*1Ab*/PipeOpenMode mode, /*1Ab*/const char * env, /*1Ab*/const char * command, /*1Ab*/Args... args)
{
   return DualPipe(F(dualPipeOpenEnvf)(/*5Ee*/(C(PipeOpenMode))mode.impl, /*5Ge*/env, /*5Ge*/command, /*5Ae*/args...));
}
// function: dualPipeOpenf
template<typename... Args> inline DualPipe dualPipeOpenf(/*1Ab*/PipeOpenMode mode, /*1Ab*/const char * command, /*1Ab*/Args... args)
{
   return DualPipe(F(dualPipeOpenf)(/*5Ee*/(C(PipeOpenMode))mode.impl, /*5Ge*/command, /*5Ae*/args...));
}
// function: dumpErrors
inline void dumpErrors(/*1Ab*/bool display)
{
   F(dumpErrors)(/*5Ee*/(C(bool))display);
}
// function: execute
template<typename... Args> inline C(bool) execute(/*1Ab*/const char * command, /*1Ab*/Args... args)
{
   return F(execute)(/*5Ge*/command, /*5Ae*/args...);
}
// function: executeEnv
template<typename... Args> inline C(bool) executeEnv(/*1Ab*/const char * env, /*1Ab*/const char * command, /*1Ab*/Args... args)
{
   return F(executeEnv)(/*5Ge*/env, /*5Ge*/command, /*5Ae*/args...);
}
// function: executeWait
template<typename... Args> inline C(bool) executeWait(/*1Ab*/const char * command, /*1Ab*/Args... args)
{
   return F(executeWait)(/*5Ge*/command, /*5Ae*/args...);
}
// function: fileExists
inline C(FileAttribs) fileExists(/*1Ab*/const char * fileName)
{
   return F(fileExists)(/*5Ge*/fileName);
}
// function: fileFixCase
inline void fileFixCase(/*1Ab*/char * file)
{
   F(fileFixCase)(/*5Ge*/file);
}
// function: fileGetSize
inline C(bool) fileGetSize(/*1Ab*/const char * fileName, /*1Ab*/FileSize * size)
{
   return F(fileGetSize)(/*5Ge*/fileName, /*5Ee*/(C(FileSize) *)size);
}
// function: fileGetStats
inline C(bool) fileGetStats(/*1Ab*/const char * fileName, /*1Ab*/FileStats & stats)
{
   return F(fileGetStats)(/*5Ge*/fileName, /*5De*/&stats.impl);
}
inline C(bool) fileGetStats(/*1Ac*/const char * fileName, /*1Ac*/FileStats * stats)
{
   return F(fileGetStats)(/*5Gf*/fileName, /*5Cf*/(C(FileStats) *)stats);
}
// function: fileOpen
inline File fileOpen(/*1Ab*/const char * fileName, /*1Ab*/FileOpenMode mode)
{
   return File(F(fileOpen)(/*5Ge*/fileName, /*5Ee*/(C(FileOpenMode))mode));
}
// function: fileOpenBuffered
inline BufferedFile fileOpenBuffered(/*1Ab*/const char * fileName, /*1Ab*/FileOpenMode mode)
{
   return BufferedFile(F(fileOpenBuffered)(/*5Ge*/fileName, /*5Ee*/(C(FileOpenMode))mode));
}
// function: fileSetAttribs
inline C(bool) fileSetAttribs(/*1Ab*/const char * fileName, /*1Ab*/FileAttribs attribs)
{
   return F(fileSetAttribs)(/*5Ge*/fileName, /*5Ee*/(C(FileAttribs))attribs.impl);
}
// function: fileSetTime
inline C(bool) fileSetTime(/*1Ab*/const char * fileName, /*1Ab*/SecSince1970 created, /*1Ab*/SecSince1970 accessed, /*1Ab*/SecSince1970 modified)
{
   return F(fileSetTime)(/*5Ge*/fileName, /*5Ee*/(C(SecSince1970))created.impl, /*5Ee*/(C(SecSince1970))accessed.impl, /*5Ee*/(C(SecSince1970))modified.impl);
}
// function: fileTruncate
inline C(bool) fileTruncate(/*1Ab*/const char * fileName, /*1Ab*/uint64 size)
{
   return F(fileTruncate)(/*5Ge*/fileName, /*5Ge*/size);
}
// function: fillBytes
inline void fillBytes(/*1Ab*/void * area, /*1Ab*/byte value, /*1Ab*/uint count)
{
   F(fillBytes)(/*5Ge*/area, /*5Ge*/value, /*5Ge*/count);
}
// function: fillBytesBy2
inline void fillBytesBy2(/*1Ab*/void * area, /*1Ab*/uint16 value, /*1Ab*/uint count)
{
   F(fillBytesBy2)(/*5Ge*/area, /*5Ge*/value, /*5Ge*/count);
}
// function: fillBytesBy4
inline void fillBytesBy4(/*1Ab*/void * area, /*1Ab*/uint value, /*1Ab*/uint count)
{
   F(fillBytesBy4)(/*5Ge*/area, /*5Ge*/value, /*5Ge*/count);
}
// function: getAlNum
inline C(bool) getAlNum(/*1Ab*/const char ** input, /*1Ab*/char * string, /*1Ab*/int max)
{
   return F(getAlNum)(/*5Ge*/input, /*5Ge*/string, /*5Ge*/max);
}
// function: getCharCategory
inline C(CharCategory) getCharCategory(/*1Ab*/unichar ch)
{
   return F(getCharCategory)(/*5Ge*/ch);
}
// function: getCombiningClass
inline uint getCombiningClass(/*1Ab*/unichar ch)
{
   return F(getCombiningClass)(/*5Ge*/ch);
}
// function: getEnvironment
inline char * getEnvironment(/*1Ab*/const char * envName, /*1Ab*/char * envValue, /*1Ab*/int max)
{
   return F(getEnvironment)(/*5Ge*/envName, /*5Ge*/envValue, /*5Ge*/max);
}
// function: getFreeSpace
inline void getFreeSpace(/*1Ab*/const char * path, /*1Ab*/FileSize64 * size)
{
   F(getFreeSpace)(/*5Ge*/path, /*5Ee*/(C(FileSize64) *)size);
}
// function: getLastErrorCode
inline uint getLastErrorCode()
{
   return F(getLastErrorCode)();
}
// function: getRandom
inline int getRandom(/*1Ab*/int lo, /*1Ab*/int hi)
{
   return F(getRandom)(/*5Ge*/lo, /*5Ge*/hi);
}
// function: getSlashPathBuffer
inline char * getSlashPathBuffer(/*1Ab*/char * d, /*1Ab*/const char * p)
{
   return F(getSlashPathBuffer)(/*5Ge*/d, /*5Ge*/p);
}
// function: getSystemPathBuffer
inline char * getSystemPathBuffer(/*1Ab*/char * d, /*1Ab*/const char * p)
{
   return F(getSystemPathBuffer)(/*5Ge*/d, /*5Ge*/p);
}
// function: getTime
inline C(Time) getTime()
{
   return F(getTime)();
}
// function: getWorkingDir
inline char * getWorkingDir(/*1Ab*/char * buf, /*1Ab*/int size)
{
   return F(getWorkingDir)(/*5Ge*/buf, /*5Ge*/size);
}
// function: __e_log
inline void __e_log(/*1Ab*/const char * text)
{
   F(__e_log)(/*5Ge*/text);
}
// function: logErrorCode
inline void logErrorCode(/*1Ab*/ErrorCode errorCode, /*1Ab*/const char * details)
{
   F(logErrorCode)(/*5Ee*/(C(ErrorCode))errorCode.impl, /*5Ge*/details);
}
// function: __e_logf
template<typename... Args> inline void __e_logf(/*1Ab*/const char * format, /*1Ab*/Args... args)
{
   F(__e_logf)(/*5Ge*/format, /*5Ae*/args...);
}
// function: makeDir
inline C(bool) makeDir(/*1Ab*/const char * path)
{
   return F(makeDir)(/*5Ge*/path);
}
// function: makeSlashPath
inline void makeSlashPath(/*1Ab*/char * p)
{
   F(makeSlashPath)(/*5Ge*/p);
}
// function: makeSystemPath
inline void makeSystemPath(/*1Ab*/char * p)
{
   F(makeSystemPath)(/*5Ge*/p);
}
// function: moveBytes
inline void moveBytes(/*1Ab*/void * dest, /*1Ab*/const void * source, /*1Ab*/uint count)
{
   F(moveBytes)(/*5Ge*/dest, /*5Ge*/source, /*5Ge*/count);
}
// function: moveFile
inline C(bool) moveFile(/*1Ab*/const char * source, /*1Ab*/const char * dest)
{
   return F(moveFile)(/*5Ge*/source, /*5Ge*/dest);
}
// function: moveFileEx
inline C(bool) moveFileEx(/*1Ab*/const char * source, /*1Ab*/const char * dest, /*1Ab*/MoveFileOptions options)
{
   return F(moveFileEx)(/*5Ge*/source, /*5Ge*/dest, /*5Ee*/(C(MoveFileOptions))options.impl);
}
// function: printECONObject
inline C(String) printECONObject(/*1Ab*/Class objectType, /*1Ab*/void * object, /*1Ab*/int indent)
{
   return F(printECONObject)(/*5De*/objectType.impl, /*5Ge*/object, /*5Ge*/indent);
}
// function: printObjectNotationString
inline C(String) printObjectNotationString(/*1Ab*/Class objectType, /*1Ab*/void * object, /*1Ab*/ObjectNotationType onType, /*1Ab*/int indent, /*1Ab*/bool indentFirst, /*1Ab*/JSONFirstLetterCapitalization capitalize)
{
   return F(printObjectNotationString)(/*5De*/objectType.impl, /*5Ge*/object, /*5Ee*/(C(ObjectNotationType))onType, /*5Ge*/indent, /*5Ee*/(C(bool))indentFirst, /*5Ee*/(C(JSONFirstLetterCapitalization))capitalize);
}
// function: randomSeed
inline void randomSeed(/*1Ab*/uint seed)
{
   F(randomSeed)(/*5Ge*/seed);
}
// function: removeDir
inline C(bool) removeDir(/*1Ab*/const char * path)
{
   return F(removeDir)(/*5Ge*/path);
}
// function: renameFile
inline C(bool) renameFile(/*1Ab*/const char * oldName, /*1Ab*/const char * newName)
{
   return F(renameFile)(/*5Ge*/oldName, /*5Ge*/newName);
}
// function: resetError
inline void resetError()
{
   F(resetError)();
}
// function: setEnvironment
inline void setEnvironment(/*1Ab*/const char * envName, /*1Ab*/const char * envValue)
{
   F(setEnvironment)(/*5Ge*/envName, /*5Ge*/envValue);
}
// function: setErrorLevel
inline void setErrorLevel(/*1Ab*/ErrorLevel level)
{
   F(setErrorLevel)(/*5Ee*/(C(ErrorLevel))level);
}
// function: setLoggingMode
inline void setLoggingMode(/*1Ab*/LoggingMode mode, /*1Ab*/void * where)
{
   F(setLoggingMode)(/*5Ee*/(C(LoggingMode))mode, /*5Ge*/where);
}
// function: shellOpen
template<typename... Args> inline C(bool) shellOpen(/*1Ab*/const char * fileName, /*1Ab*/Args... args)
{
   return F(shellOpen)(/*5Ge*/fileName, /*5Ae*/args...);
}
// function: __sleep
inline void __sleep(/*1Ab*/Time seconds)
{
   F(__sleep)(/*5Ee*/(C(Time))seconds.impl);
}
// function: stringIndent
inline C(String) stringIndent(constString base, /*1Ab*/int nSpaces, /*1Ab*/bool indentFirst)
{
   return F(stringIndent)(/*5Ge*/base, /*5Ge*/nSpaces, /*5Ee*/(C(bool))indentFirst);
}
// function: uTF16BEtoUTF8Buffer
inline int uTF16BEtoUTF8Buffer(/*1Ab*/const uint16 * source, /*1Ab*/byte * dest, /*1Ab*/int max)
{
   return F(uTF16BEtoUTF8Buffer)(/*5Ge*/source, /*5Ge*/dest, /*5Ge*/max);
}
// function: uTF8toISO8859_1
inline int uTF8toISO8859_1(/*1Ab*/const char * source, /*1Ab*/char * dest, /*1Ab*/int max)
{
   return F(uTF8toISO8859_1)(/*5Ge*/source, /*5Ge*/dest, /*5Ge*/max);
}
// function: uTF8toUTF16BufferLen
inline int uTF8toUTF16BufferLen(/*1Ab*/const char * source, /*1Ab*/uint16 * dest, /*1Ab*/int max, /*1Ab*/int len)
{
   return F(uTF8toUTF16BufferLen)(/*5Ge*/source, /*5Ge*/dest, /*5Ge*/max, /*5Ge*/len);
}
// function: uTF8toUTF16Len
inline uint16 * uTF8toUTF16Len(/*1Ab*/const char * source, /*1Ab*/int byteCount, /*1Ab*/int * wordCount)
{
   return F(uTF8toUTF16Len)(/*5Ge*/source, /*5Ge*/byteCount, /*5Ge*/wordCount);
}
// function: unsetEnvironment
inline void unsetEnvironment(/*1Ab*/const char * envName)
{
   F(unsetEnvironment)(/*5Ge*/envName);
}
// function: writeECONObject
inline C(bool) writeECONObject(/*1Ab*/File & f, /*1Ab*/Class objectType, /*1Ab*/void * object, /*1Ab*/int indent)
{
   return F(writeECONObject)(/*5De*/f.impl, /*5De*/objectType.impl, /*5Ge*/object, /*5Ge*/indent);
}
// function: writeJSONObject
inline C(bool) writeJSONObject(/*1Ab*/File & f, /*1Ab*/Class objectType, /*1Ab*/void * object, /*1Ab*/int indent)
{
   return F(writeJSONObject)(/*5De*/f.impl, /*5De*/objectType.impl, /*5Ge*/object, /*5Ge*/indent);
}
// function: writeJSONObject2
inline C(bool) writeJSONObject2(/*1Ab*/File & f, /*1Ab*/Class objectType, /*1Ab*/void * object, /*1Ab*/int indent, /*1Ab*/JSONFirstLetterCapitalization capitalize)
{
   return F(writeJSONObject2)(/*5De*/f.impl, /*5De*/objectType.impl, /*5Ge*/object, /*5Ge*/indent, /*5Ee*/(C(JSONFirstLetterCapitalization))capitalize);
}
// function: writeJSONObjectMapped
inline C(bool) writeJSONObjectMapped(/*1Ab*/File & f, /*1Ab*/Class objectType, /*1Ab*/void * object, /*1Ab*/int indent, /*1Ab*/TMap<C(String) _ARG C(String)> & stringMap)
{
   return F(writeJSONObjectMapped)(/*5De*/f.impl, /*5De*/objectType.impl, /*5Ge*/object, /*5Ge*/indent, /*5De*/((Instance&&)stringMap).impl);
}
// function: writeONString
inline C(bool) writeONString(/*1Ab*/File & f, constString s, /*1Ab*/bool eCON, /*1Ab*/int indent)
{
   return F(writeONString)(/*5De*/f.impl, /*5Ge*/s, /*5Ee*/(C(bool))eCON, /*5Ge*/indent);
}
// function: accenti
inline C(String) accenti(constString string)
{
   return F(accenti)(/*5Ge*/string);
}
// function: casei
inline C(String) casei(constString string)
{
   return F(casei)(/*5Ge*/string);
}
// function: debugBreakpoint
inline void debugBreakpoint()
{
   F(debugBreakpoint)();
}
// function: encodeArrayToString
inline C(String) encodeArrayToString(/*1Ab*/TArray<unichar _ARG int _ARG unichar> & array)
{
   return F(encodeArrayToString)(/*5De*/((Instance&&)array).impl);
}
// function: normalizeNFC
inline C(String) normalizeNFC(constString string)
{
   return F(normalizeNFC)(/*5Ge*/string);
}
// function: normalizeNFD
inline C(String) normalizeNFD(constString string)
{
   return F(normalizeNFD)(/*5Ge*/string);
}
// function: normalizeNFKC
inline C(String) normalizeNFKC(constString string)
{
   return F(normalizeNFKC)(/*5Ge*/string);
}
// function: normalizeNFKD
inline C(String) normalizeNFKD(constString string)
{
   return F(normalizeNFKD)(/*5Ge*/string);
}
// function: normalizeNFKDArray
inline TArray<unichar _ARG int _ARG unichar> normalizeNFKDArray(constString string)
{
   return TArray<unichar _ARG int _ARG unichar>(F(normalizeNFKDArray)(/*5Ge*/string));
}
// function: normalizeUnicode
inline C(String) normalizeUnicode(constString string, /*1Ab*/UnicodeDecomposition type, /*1Ab*/bool compose)
{
   return F(normalizeUnicode)(/*5Ge*/string, /*5Ee*/(C(UnicodeDecomposition))type.impl, /*5Ee*/(C(bool))compose);
}
// function: normalizeUnicodeArray
inline TArray<unichar _ARG int _ARG unichar> normalizeUnicodeArray(constString string, /*1Ab*/UnicodeDecomposition type, /*1Ab*/bool compose)
{
   return TArray<unichar _ARG int _ARG unichar>(F(normalizeUnicodeArray)(/*5Ge*/string, /*5Ee*/(C(UnicodeDecomposition))type.impl, /*5Ee*/(C(bool))compose));
}
// function: stripUnicodeCategory
inline C(String) stripUnicodeCategory(constString string, /*1Ab*/CharCategory c)
{
   return F(stripUnicodeCategory)(/*5Ge*/string, /*5Ee*/(C(CharCategory))c);
}


#endif // !defined(__ECERE_HPP__)
